; ModuleID = 'out_reg2mem.ll'
source_filename = "llvm-link"

@yqxyt_Warning_Remove_returned_Nil_for_key_ = internal unnamed_addr constant [37 x i8] c"Warning: Remove returned Nil for key "
@gjykt_Warning_Remove_returned_wrong_value_for_key_ = internal unnamed_addr constant [45 x i8] c"Warning: Remove returned wrong value for key "
@umtrl_Error_Nil_returned_during_random_hit_test_for_key_ = internal unnamed_addr constant [51 x i8] c"Error: Nil returned during random hit test for key "
@uyexo__unique_keys_for_random_hit_test = internal unnamed_addr constant [33 x i8] c" unique keys for random hit test."
@mbvap_Error_Nil_returned_during_sequential_hit_test_for_key_ = internal unnamed_addr constant [55 x i8] c"Error: Nil returned during sequential hit test for key "
@_parameterization_PairPtri32._Ptri1 = linkonce_odr constant [4 x ptr] [ptr @Pair, ptr @_parameterization_Ptri32, ptr @_parameterization_Ptri1, ptr null]
@_parameterization_PairPtri32._Ptri32 = linkonce_odr constant [4 x ptr] [ptr @Pair, ptr @_parameterization_Ptri32, ptr @_parameterization_Ptri32, ptr null]
@PRNG_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @PRNG, ptr null]
@PRNG_offset_tbl = constant [4 x i32] [i32 15, i32 10, i32 10, i32 0]
@PRNG = constant { [3 x i64], [7 x ptr], [5 x ptr] } { [3 x i64] [i64 -4401938362882229211, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @PRNG_hashtbl, ptr @PRNG_offset_tbl, ptr @_data_size_PRNG, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [5 x ptr] [ptr @PRNG_field_seed, ptr @PRNG_B_init_initial_seedPtri32, ptr @PRNG_B_next_, ptr @PRNG_init_initial_seedPtri32, ptr @PRNG_next_] }
@PRNG_field_seed = internal constant { ptr, ptr } { ptr @PRNG_getter_seed, ptr @PRNG_setter_seed }
@bool_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @bool_typ]
@bool_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@i8_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @i8_typ]
@i8_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@i32_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @i32_typ, ptr null]
@i32_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@i64_typ_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @Object, ptr @i64_typ, ptr null]
@i64_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@i128_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @i128_typ, ptr @any_typ, ptr null]
@i128_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@f64_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @f64_typ]
@f64_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@nil_typ_hashtbl = constant [2 x ptr] [ptr @nil_typ, ptr @any_typ]
@nil_typ_offset_tbl = constant [2 x i32] [i32 10, i32 10]
@any_typ_hashtbl = constant [1 x ptr] [ptr @any_typ]
@any_typ_offset_tbl = constant [1 x i32] [i32 10]
@nothing_typ_hashtbl = constant [4 x ptr] [ptr null, ptr @Object, ptr @any_typ, ptr @nothing_typ]
@nothing_typ_offset_tbl = constant [4 x i32] [i32 0, i32 10, i32 10, i32 10]
@coroutine_typ_hashtbl = constant [4 x ptr] [ptr null, ptr @Object, ptr @any_typ, ptr @coroutine_typ]
@coroutine_typ_offset_tbl = constant [4 x i32] [i32 0, i32 10, i32 10, i32 10]
@function_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @function_typ, ptr null]
@function_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@buffer_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @buffer_typ, ptr @any_typ, ptr null]
@buffer_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@tuple_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @tuple_typ]
@tuple_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@union_typ_hashtbl = constant [4 x ptr] [ptr @union_typ, ptr null, ptr @any_typ, ptr @Object]
@union_typ_offset_tbl = constant [4 x i32] [i32 10, i32 0, i32 10, i32 10]
@Object_hashtbl = constant [2 x ptr] [ptr @Object, ptr @any_typ]
@Object_offset_tbl = constant [2 x i32] [i32 10, i32 10]
@Tombstone_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @Tombstone]
@Tombstone_offset_tbl = constant [4 x i32] [i32 12, i32 0, i32 10, i32 10]
@Tombstone = constant { [3 x i64], [7 x ptr], [2 x ptr] } { [3 x i64] [i64 -8477883990763853851, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Tombstone_hashtbl, ptr @Tombstone_offset_tbl, ptr @_data_size_Tombstone, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [2 x ptr] [ptr @Tombstone_B_init_, ptr @Tombstone_init_] }
@Entry_hashtbl = constant [4 x ptr] [ptr @Entry, ptr @Object, ptr @any_typ, ptr null]
@Entry_offset_tbl = constant [4 x i32] [i32 10, i32 24, i32 10, i32 0]
@Entry = constant { [3 x i64], [7 x ptr], [14 x ptr] } { [3 x i64] [i64 4015701072841558310, i64 4611686018427388181, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Entry_hashtbl, ptr @Entry_offset_tbl, ptr @_data_size_Entry, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [14 x ptr] [ptr @Entry_field_Entry_0, ptr @Entry_field_Entry_1, ptr @Entry_field_hash, ptr @Entry_field_key, ptr @Entry_field_value, ptr @Entry_B_init_keyK_valueTombstone_hashPtri32_init_keyK_valueV_hashPtri32, ptr @Entry_B_key_, ptr @Entry_B_value_, ptr @Entry_B_hash_, ptr @Entry_init_keyK_valueTombstone_hashPtri32, ptr @Entry_init_keyK_valueV_hashPtri32, ptr @Entry_key_, ptr @Entry_value_, ptr @Entry_hash_] }
@HashMap_hashtbl = constant [8 x ptr] [ptr null, ptr @HashMap, ptr @Container, ptr null, ptr @Object, ptr null, ptr @any_typ, ptr @Iterable2]
@HashMap_offset_tbl = constant [8 x i32] [i32 0, i32 10, i32 84, i32 0, i32 84, i32 0, i32 10, i32 61]
@HashMap = constant { [3 x i64], [7 x ptr], [74 x ptr] } { [3 x i64] [i64 -2849643283898152329, i64 4611686018427388091, i64 7], [7 x ptr] [ptr @subtype_test, ptr @HashMap_hashtbl, ptr @HashMap_offset_tbl, ptr @_data_size_HashMap, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [74 x ptr] [ptr @HashMap_field_HashMap_0, ptr @HashMap_field_HashMap_1, ptr @HashMap_field_HashMap_2, ptr @HashMap_field_entries, ptr @HashMap_field_entries_len, ptr @HashMap_field_size, ptr @HashMap_field_load, ptr @HashMap_field_hasher, ptr @HashMap_field_eq, ptr @HashMap_B_init_hasherFunctionK_to_Ptri32_eqFunctionK._K_to_Ptri1, ptr @HashMap_B_find_slot_keyK_hashPtri32, ptr @HashMap_B_ensure_capacity_required_loadPtri32, ptr @HashMap_B_resize_new_capacityPtri32, ptr @HashMap_B_insert_internal_keyK_valueV_hashPtri32, ptr @HashMap_B_insert_keyK_valueV, ptr @HashMap_B_get_keyK, ptr @HashMap_B_remove_keyK, ptr @HashMap_B_clear_, ptr @HashMap_B_size_, ptr @HashMap_B_iterator_, ptr @HashMap_B_each_fFunctionT_to_Nothing, ptr @HashMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @HashMap_B_all_fFunctionT_to_Ptri1, ptr @HashMap_B_any_fFunctionT_to_Ptri1, ptr @HashMap_B_map_fFunctionT_to_U, ptr @HashMap_B_filter_fFunctionT_to_Ptri1, ptr @HashMap_B_chain_otherIterable2T, ptr @HashMap_B_interleave_otherIterable2T, ptr @HashMap_B_zip_otherIterable2U, ptr @HashMap_B_product_otherIterable2U, ptr @HashMap_init_hasherFunctionK_to_Ptri32_eqFunctionK._K_to_Ptri1, ptr @HashMap_find_slot_keyK_hashPtri32, ptr @HashMap_ensure_capacity_required_loadPtri32, ptr @HashMap_resize_new_capacityPtri32, ptr @HashMap_insert_internal_keyK_valueV_hashPtri32, ptr @HashMap_insert_keyK_valueV, ptr @HashMap_get_keyK, ptr @HashMap_remove_keyK, ptr @HashMap_clear_, ptr @HashMap_size_, ptr @HashMap_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U, ptr @HashMap_field_HashMap_2, ptr @HashMap_B_iterator_, ptr @HashMap_B_each_fFunctionT_to_Nothing, ptr @HashMap_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @HashMap_B_all_fFunctionT_to_Ptri1, ptr @HashMap_B_any_fFunctionT_to_Ptri1, ptr @HashMap_B_map_fFunctionT_to_U, ptr @HashMap_B_filter_fFunctionT_to_Ptri1, ptr @HashMap_B_chain_otherIterable2T, ptr @HashMap_B_interleave_otherIterable2T, ptr @HashMap_B_zip_otherIterable2U, ptr @HashMap_B_product_otherIterable2U, ptr @HashMap_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U] }
@HashMapIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr @HashMapIterator, ptr null, ptr @Iterator2, ptr null]
@HashMapIterator_offset_tbl = constant [8 x i32] [i32 23, i32 10, i32 0, i32 23, i32 10, i32 0, i32 20, i32 0]
@HashMapIterator = constant { [3 x i64], [7 x ptr], [13 x ptr] } { [3 x i64] [i64 -704669437586349537, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @HashMapIterator_hashtbl, ptr @HashMapIterator_offset_tbl, ptr @_data_size_HashMapIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [13 x ptr] [ptr @HashMapIterator_field_HashMapIterator_0, ptr @HashMapIterator_field_HashMapIterator_1, ptr @HashMapIterator_field_HashMapIterator_2, ptr @HashMapIterator_field_map_entries, ptr @HashMapIterator_field_index, ptr @HashMapIterator_field_length, ptr @HashMapIterator_B_init_map_entriesBufferEntryK._V_or_Nil_lengthPtri32, ptr @HashMapIterator_B_next_, ptr @HashMapIterator_init_map_entriesBufferEntryK._V_or_Nil_lengthPtri32, ptr @HashMapIterator_next_, ptr @HashMapIterator_field_HashMapIterator_2, ptr @HashMapIterator_B_next_, ptr @HashMapIterator_next_] }
@Entry_field_hash = internal constant { ptr, ptr } { ptr @Entry_getter_hash, ptr @Entry_setter_hash }
@Entry_field_key = internal constant { ptr, ptr } { ptr @Entry_getter_key, ptr @Entry_setter_key }
@Entry_field_value = internal constant { ptr, ptr } { ptr @Entry_getter_value, ptr @Entry_setter_value }
@HashMap_field_entries = internal constant { ptr, ptr } { ptr @HashMap_getter_entries, ptr @HashMap_setter_entries }
@HashMap_field_entries_len = internal constant { ptr, ptr } { ptr @HashMap_getter_entries_len, ptr @HashMap_setter_entries_len }
@HashMap_field_size = internal constant { ptr, ptr } { ptr @HashMap_getter_size, ptr @HashMap_setter_size }
@HashMap_field_load = internal constant { ptr, ptr } { ptr @HashMap_getter_load, ptr @HashMap_setter_load }
@HashMap_field_hasher = internal constant { ptr, ptr } { ptr @HashMap_getter_hasher, ptr @HashMap_setter_hasher }
@HashMap_field_eq = internal constant { ptr, ptr } { ptr @HashMap_getter_eq, ptr @HashMap_setter_eq }
@HashMapIterator_field_map_entries = internal constant { ptr, ptr } { ptr @HashMapIterator_getter_map_entries, ptr @HashMapIterator_setter_map_entries }
@HashMapIterator_field_index = internal constant { ptr, ptr } { ptr @HashMapIterator_getter_index, ptr @HashMapIterator_setter_index }
@HashMapIterator_field_length = internal constant { ptr, ptr } { ptr @HashMapIterator_getter_length, ptr @HashMapIterator_setter_length }
@_parameterization_Ptri1 = linkonce_odr constant [2 x ptr] [ptr @bool_typ, ptr null]
@Pair_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @Pair, ptr null]
@Pair_offset_tbl = constant [4 x i32] [i32 20, i32 10, i32 10, i32 0]
@Pair = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 9197944775169318296, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Pair_hashtbl, ptr @Pair_offset_tbl, ptr @_data_size_Pair, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @Pair_field_Pair_0, ptr @Pair_field_Pair_1, ptr @Pair_field_first, ptr @Pair_field_second, ptr @Pair_B_init_firstT_secondU, ptr @Pair_B_first_, ptr @Pair_B_second_, ptr @Pair_init_firstT_secondU, ptr @Pair_first_, ptr @Pair_second_] }
@Container_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container]
@Container_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@Container = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 9056556090793359372, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Container_hashtbl, ptr @Container_offset_tbl, ptr @_data_size_Container, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Iterator2_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @Iterator2, ptr @Container]
@Iterator2_offset_tbl = constant [4 x i32] [i32 13, i32 10, i32 10, i32 13]
@Iterator2 = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 4189192806087951739, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Iterator2_hashtbl, ptr @Iterator2_offset_tbl, ptr @_data_size_Iterator2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Iterable2_hashtbl = constant [4 x ptr] [ptr @Iterable2, ptr @any_typ, ptr @Container, ptr @Object]
@Iterable2_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 33, i32 33]
@Iterable2 = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 5693646204635713916, i64 4611686018427388349, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Iterable2_hashtbl, ptr @Iterable2_offset_tbl, ptr @_data_size_Iterable2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Array_hashtbl = constant [8 x ptr] [ptr @Container, ptr null, ptr @Iterable2, ptr @Object, ptr @any_typ, ptr null, ptr null, ptr @Array]
@Array_offset_tbl = constant [8 x i32] [i32 85, i32 0, i32 62, i32 85, i32 10, i32 0, i32 0, i32 10]
@Array = constant { [3 x i64], [7 x ptr], [75 x ptr] } { [3 x i64] [i64 -5261542750394134544, i64 4611686018427388289, i64 7], [7 x ptr] [ptr @subtype_test, ptr @Array_hashtbl, ptr @Array_offset_tbl, ptr @_data_size_Array, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [75 x ptr] [ptr @Array_field_Array_0, ptr @Array_field_buffer, ptr @Array_field_length, ptr @Array_field_capacity, ptr @Array_B__Self_from_iterable_iterableIterable2T, ptr @Array_B_init_, ptr @Array_B_init_capacityPtri32, ptr @Array_B_init_lengthPtri32_capacityPtri32, ptr @Array_B_length_, ptr @Array_B_capacity_, ptr @Array_B_append_xT, ptr @Array_B_reserve_new_capacityPtri32, ptr @Array_B__index_xPtri32, ptr @Array_B__set_index_xPtri32_valueT, ptr @Array_B_throw_oob_xPtri32, ptr @Array_B_unchecked_index_xPtri32, ptr @Array_B_unchecked_insert_xPtri32_valueT, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Ptri1, ptr @Array_B_any_fFunctionT_to_Ptri1, ptr @Array_B_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Ptri1, ptr @Array_B_chain_otherIterable2T, ptr @Array_B_interleave_otherIterable2T, ptr @Array_B_zip_otherIterable2U, ptr @Array_B_product_otherIterable2U, ptr @Array__Self_from_iterable_iterableIterable2T, ptr @Array_init_, ptr @Array_init_capacityPtri32, ptr @Array_init_lengthPtri32_capacityPtri32, ptr @Array_length_, ptr @Array_capacity_, ptr @Array_append_xT, ptr @Array_reserve_new_capacityPtri32, ptr @Array__index_xPtri32, ptr @Array__set_index_xPtri32_valueT, ptr @Array_throw_oob_xPtri32, ptr @Array_unchecked_index_xPtri32, ptr @Array_unchecked_insert_xPtri32_valueT, ptr @Array_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U, ptr @Array_field_Array_0, ptr @Array_B_iterator_, ptr @Array_B_each_fFunctionT_to_Nothing, ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Array_B_all_fFunctionT_to_Ptri1, ptr @Array_B_any_fFunctionT_to_Ptri1, ptr @Array_B_map_fFunctionT_to_U, ptr @Array_B_filter_fFunctionT_to_Ptri1, ptr @Array_B_chain_otherIterable2T, ptr @Array_B_interleave_otherIterable2T, ptr @Array_B_zip_otherIterable2U, ptr @Array_B_product_otherIterable2U, ptr @Array_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U] }
@ArrayIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr @ArrayIterator, ptr null, ptr @Iterator2, ptr null]
@ArrayIterator_offset_tbl = constant [8 x i32] [i32 20, i32 10, i32 0, i32 20, i32 10, i32 0, i32 17, i32 0]
@ArrayIterator = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 3447345754186651411, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ArrayIterator_hashtbl, ptr @ArrayIterator_offset_tbl, ptr @_data_size_ArrayIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @ArrayIterator_field_ArrayIterator_0, ptr @ArrayIterator_field_array, ptr @ArrayIterator_field_index, ptr @ArrayIterator_B_init_arrayArrayT, ptr @ArrayIterator_B_next_, ptr @ArrayIterator_init_arrayArrayT, ptr @ArrayIterator_next_, ptr @ArrayIterator_field_ArrayIterator_0, ptr @ArrayIterator_B_next_, ptr @ArrayIterator_next_] }
@MapIterable2_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr @MapIterable2, ptr @Container, ptr null, ptr @Iterable2, ptr null, ptr null]
@MapIterable2_offset_tbl = constant [8 x i32] [i32 61, i32 10, i32 10, i32 61, i32 0, i32 38, i32 0, i32 0]
@MapIterable2 = constant { [3 x i64], [7 x ptr], [51 x ptr] } { [3 x i64] [i64 -1724859134596891929, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MapIterable2_hashtbl, ptr @MapIterable2_offset_tbl, ptr @_data_size_MapIterable2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [51 x ptr] [ptr @MapIterable2_field_MapIterable2_0, ptr @MapIterable2_field_MapIterable2_1, ptr @MapIterable2_field_iterable, ptr @MapIterable2_field_f, ptr @MapIterable2_B_init_iterableIterable2T_fFunctionT_to_U, ptr @MapIterable2_B_iterator_, ptr @MapIterable2_B_each_fFunctionT_to_Nothing, ptr @MapIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapIterable2_B_all_fFunctionT_to_Ptri1, ptr @MapIterable2_B_any_fFunctionT_to_Ptri1, ptr @MapIterable2_B_map_fFunctionT_to_U, ptr @MapIterable2_B_filter_fFunctionT_to_Ptri1, ptr @MapIterable2_B_chain_otherIterable2T, ptr @MapIterable2_B_interleave_otherIterable2T, ptr @MapIterable2_B_zip_otherIterable2U, ptr @MapIterable2_B_product_otherIterable2U, ptr @MapIterable2_init_iterableIterable2T_fFunctionT_to_U, ptr @MapIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U, ptr @MapIterable2_field_MapIterable2_1, ptr @MapIterable2_B_iterator_, ptr @MapIterable2_B_each_fFunctionT_to_Nothing, ptr @MapIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MapIterable2_B_all_fFunctionT_to_Ptri1, ptr @MapIterable2_B_any_fFunctionT_to_Ptri1, ptr @MapIterable2_B_map_fFunctionT_to_U, ptr @MapIterable2_B_filter_fFunctionT_to_Ptri1, ptr @MapIterable2_B_chain_otherIterable2T, ptr @MapIterable2_B_interleave_otherIterable2T, ptr @MapIterable2_B_zip_otherIterable2U, ptr @MapIterable2_B_product_otherIterable2U, ptr @MapIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U] }
@MapIterator2_hashtbl = constant [8 x ptr] [ptr null, ptr @Container, ptr @MapIterator2, ptr null, ptr @Object, ptr @Iterator2, ptr null, ptr @any_typ]
@MapIterator2_offset_tbl = constant [8 x i32] [i32 0, i32 21, i32 10, i32 0, i32 21, i32 18, i32 0, i32 10]
@MapIterator2 = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -10255947709272500, i64 4611686018427388279, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MapIterator2_hashtbl, ptr @MapIterator2_offset_tbl, ptr @_data_size_MapIterator2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @MapIterator2_field_MapIterator2_0, ptr @MapIterator2_field_MapIterator2_1, ptr @MapIterator2_field_iterator, ptr @MapIterator2_field_f, ptr @MapIterator2_B_init_iteratorIterator2T_fFunctionT_to_U, ptr @MapIterator2_B_next_, ptr @MapIterator2_init_iteratorIterator2T_fFunctionT_to_U, ptr @MapIterator2_next_, ptr @MapIterator2_field_MapIterator2_1, ptr @MapIterator2_B_next_, ptr @MapIterator2_next_] }
@FilterIterable2_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @Iterable2, ptr @FilterIterable2, ptr null]
@FilterIterable2_offset_tbl = constant [8 x i32] [i32 60, i32 10, i32 0, i32 60, i32 0, i32 37, i32 10, i32 0]
@FilterIterable2 = constant { [3 x i64], [7 x ptr], [50 x ptr] } { [3 x i64] [i64 1178467452958968374, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @FilterIterable2_hashtbl, ptr @FilterIterable2_offset_tbl, ptr @_data_size_FilterIterable2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [50 x ptr] [ptr @FilterIterable2_field_FilterIterable2_0, ptr @FilterIterable2_field_iterable, ptr @FilterIterable2_field_f, ptr @FilterIterable2_B_init_iterableIterable2T_fFunctionT_to_Ptri1, ptr @FilterIterable2_B_iterator_, ptr @FilterIterable2_B_each_fFunctionT_to_Nothing, ptr @FilterIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @FilterIterable2_B_all_fFunctionT_to_Ptri1, ptr @FilterIterable2_B_any_fFunctionT_to_Ptri1, ptr @FilterIterable2_B_map_fFunctionT_to_U, ptr @FilterIterable2_B_filter_fFunctionT_to_Ptri1, ptr @FilterIterable2_B_chain_otherIterable2T, ptr @FilterIterable2_B_interleave_otherIterable2T, ptr @FilterIterable2_B_zip_otherIterable2U, ptr @FilterIterable2_B_product_otherIterable2U, ptr @FilterIterable2_init_iterableIterable2T_fFunctionT_to_Ptri1, ptr @FilterIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U, ptr @FilterIterable2_field_FilterIterable2_0, ptr @FilterIterable2_B_iterator_, ptr @FilterIterable2_B_each_fFunctionT_to_Nothing, ptr @FilterIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @FilterIterable2_B_all_fFunctionT_to_Ptri1, ptr @FilterIterable2_B_any_fFunctionT_to_Ptri1, ptr @FilterIterable2_B_map_fFunctionT_to_U, ptr @FilterIterable2_B_filter_fFunctionT_to_Ptri1, ptr @FilterIterable2_B_chain_otherIterable2T, ptr @FilterIterable2_B_interleave_otherIterable2T, ptr @FilterIterable2_B_zip_otherIterable2U, ptr @FilterIterable2_B_product_otherIterable2U, ptr @FilterIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U] }
@FilterIterator2_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr @FilterIterator2, ptr @Container, ptr null, ptr null, ptr @Iterator2, ptr null]
@FilterIterator2_offset_tbl = constant [8 x i32] [i32 20, i32 10, i32 10, i32 20, i32 0, i32 0, i32 17, i32 0]
@FilterIterator2 = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 8213847504843366470, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @FilterIterator2_hashtbl, ptr @FilterIterator2_offset_tbl, ptr @_data_size_FilterIterator2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @FilterIterator2_field_FilterIterator2_0, ptr @FilterIterator2_field_iterator, ptr @FilterIterator2_field_f, ptr @FilterIterator2_B_init_iteratorIterator2T_fFunctionT_to_Ptri1, ptr @FilterIterator2_B_next_, ptr @FilterIterator2_init_iteratorIterator2T_fFunctionT_to_Ptri1, ptr @FilterIterator2_next_, ptr @FilterIterator2_field_FilterIterator2_0, ptr @FilterIterator2_B_next_, ptr @FilterIterator2_next_] }
@ChainIterable2_hashtbl = constant [8 x ptr] [ptr @ChainIterable2, ptr @Object, ptr @any_typ, ptr null, ptr null, ptr @Container, ptr null, ptr @Iterable2]
@ChainIterable2_offset_tbl = constant [8 x i32] [i32 10, i32 60, i32 10, i32 0, i32 0, i32 60, i32 0, i32 37]
@ChainIterable2 = constant { [3 x i64], [7 x ptr], [50 x ptr] } { [3 x i64] [i64 -5233298072945030060, i64 4611686018427388319, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ChainIterable2_hashtbl, ptr @ChainIterable2_offset_tbl, ptr @_data_size_ChainIterable2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [50 x ptr] [ptr @ChainIterable2_field_ChainIterable2_0, ptr @ChainIterable2_field_first, ptr @ChainIterable2_field_second, ptr @ChainIterable2_B_init_firstIterable2T_secondIterable2T, ptr @ChainIterable2_B_iterator_, ptr @ChainIterable2_B_each_fFunctionT_to_Nothing, ptr @ChainIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainIterable2_B_all_fFunctionT_to_Ptri1, ptr @ChainIterable2_B_any_fFunctionT_to_Ptri1, ptr @ChainIterable2_B_map_fFunctionT_to_U, ptr @ChainIterable2_B_filter_fFunctionT_to_Ptri1, ptr @ChainIterable2_B_chain_otherIterable2T, ptr @ChainIterable2_B_interleave_otherIterable2T, ptr @ChainIterable2_B_zip_otherIterable2U, ptr @ChainIterable2_B_product_otherIterable2U, ptr @ChainIterable2_init_firstIterable2T_secondIterable2T, ptr @ChainIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U, ptr @ChainIterable2_field_ChainIterable2_0, ptr @ChainIterable2_B_iterator_, ptr @ChainIterable2_B_each_fFunctionT_to_Nothing, ptr @ChainIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainIterable2_B_all_fFunctionT_to_Ptri1, ptr @ChainIterable2_B_any_fFunctionT_to_Ptri1, ptr @ChainIterable2_B_map_fFunctionT_to_U, ptr @ChainIterable2_B_filter_fFunctionT_to_Ptri1, ptr @ChainIterable2_B_chain_otherIterable2T, ptr @ChainIterable2_B_interleave_otherIterable2T, ptr @ChainIterable2_B_zip_otherIterable2U, ptr @ChainIterable2_B_product_otherIterable2U, ptr @ChainIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U] }
@ChainIterator2_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr null, ptr @Iterator2, ptr @ChainIterator2]
@ChainIterator2_offset_tbl = constant [8 x i32] [i32 21, i32 10, i32 0, i32 21, i32 0, i32 0, i32 18, i32 10]
@ChainIterator2 = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -228267985060461774, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ChainIterator2_hashtbl, ptr @ChainIterator2_offset_tbl, ptr @_data_size_ChainIterator2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @ChainIterator2_field_ChainIterator2_0, ptr @ChainIterator2_field_first, ptr @ChainIterator2_field_second, ptr @ChainIterator2_field_on_first, ptr @ChainIterator2_B_init_firstIterator2T_secondIterator2T, ptr @ChainIterator2_B_next_, ptr @ChainIterator2_init_firstIterator2T_secondIterator2T, ptr @ChainIterator2_next_, ptr @ChainIterator2_field_ChainIterator2_0, ptr @ChainIterator2_B_next_, ptr @ChainIterator2_next_] }
@InterleaveIterable2_hashtbl = constant [8 x ptr] [ptr @Iterable2, ptr null, ptr null, ptr @InterleaveIterable2, ptr @any_typ, ptr @Object, ptr null, ptr @Container]
@InterleaveIterable2_offset_tbl = constant [8 x i32] [i32 37, i32 0, i32 0, i32 10, i32 10, i32 60, i32 0, i32 60]
@InterleaveIterable2 = constant { [3 x i64], [7 x ptr], [50 x ptr] } { [3 x i64] [i64 -6258231685215461775, i64 4611686018427388207, i64 7], [7 x ptr] [ptr @subtype_test, ptr @InterleaveIterable2_hashtbl, ptr @InterleaveIterable2_offset_tbl, ptr @_data_size_InterleaveIterable2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [50 x ptr] [ptr @InterleaveIterable2_field_InterleaveIterable2_0, ptr @InterleaveIterable2_field_first, ptr @InterleaveIterable2_field_second, ptr @InterleaveIterable2_B_init_firstIterable2T_secondIterable2T, ptr @InterleaveIterable2_B_iterator_, ptr @InterleaveIterable2_B_each_fFunctionT_to_Nothing, ptr @InterleaveIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleaveIterable2_B_all_fFunctionT_to_Ptri1, ptr @InterleaveIterable2_B_any_fFunctionT_to_Ptri1, ptr @InterleaveIterable2_B_map_fFunctionT_to_U, ptr @InterleaveIterable2_B_filter_fFunctionT_to_Ptri1, ptr @InterleaveIterable2_B_chain_otherIterable2T, ptr @InterleaveIterable2_B_interleave_otherIterable2T, ptr @InterleaveIterable2_B_zip_otherIterable2U, ptr @InterleaveIterable2_B_product_otherIterable2U, ptr @InterleaveIterable2_init_firstIterable2T_secondIterable2T, ptr @InterleaveIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U, ptr @InterleaveIterable2_field_InterleaveIterable2_0, ptr @InterleaveIterable2_B_iterator_, ptr @InterleaveIterable2_B_each_fFunctionT_to_Nothing, ptr @InterleaveIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleaveIterable2_B_all_fFunctionT_to_Ptri1, ptr @InterleaveIterable2_B_any_fFunctionT_to_Ptri1, ptr @InterleaveIterable2_B_map_fFunctionT_to_U, ptr @InterleaveIterable2_B_filter_fFunctionT_to_Ptri1, ptr @InterleaveIterable2_B_chain_otherIterable2T, ptr @InterleaveIterable2_B_interleave_otherIterable2T, ptr @InterleaveIterable2_B_zip_otherIterable2U, ptr @InterleaveIterable2_B_product_otherIterable2U, ptr @InterleaveIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U] }
@InterleaveIterator2_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr null, ptr null, ptr @InterleaveIterator2, ptr @Container, ptr null, ptr @Iterator2, ptr @Object]
@InterleaveIterator2_offset_tbl = constant [8 x i32] [i32 10, i32 0, i32 0, i32 10, i32 21, i32 0, i32 18, i32 21]
@InterleaveIterator2 = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 6709847746581360093, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @InterleaveIterator2_hashtbl, ptr @InterleaveIterator2_offset_tbl, ptr @_data_size_InterleaveIterator2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @InterleaveIterator2_field_InterleaveIterator2_0, ptr @InterleaveIterator2_field_first, ptr @InterleaveIterator2_field_second, ptr @InterleaveIterator2_field_on_first, ptr @InterleaveIterator2_B_init_firstIterator2T_secondIterator2T, ptr @InterleaveIterator2_B_next_, ptr @InterleaveIterator2_init_firstIterator2T_secondIterator2T, ptr @InterleaveIterator2_next_, ptr @InterleaveIterator2_field_InterleaveIterator2_0, ptr @InterleaveIterator2_B_next_, ptr @InterleaveIterator2_next_] }
@ZipIterable2_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr @ZipIterable2, ptr @Container, ptr null, ptr @Iterable2, ptr null, ptr null]
@ZipIterable2_offset_tbl = constant [8 x i32] [i32 62, i32 10, i32 10, i32 62, i32 0, i32 39, i32 0, i32 0]
@ZipIterable2 = constant { [3 x i64], [7 x ptr], [52 x ptr] } { [3 x i64] [i64 -3218950579047519815, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ZipIterable2_hashtbl, ptr @ZipIterable2_offset_tbl, ptr @_data_size_ZipIterable2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [52 x ptr] [ptr @ZipIterable2_field_ZipIterable2_0, ptr @ZipIterable2_field_ZipIterable2_1, ptr @ZipIterable2_field_ZipIterable2_2, ptr @ZipIterable2_field_first, ptr @ZipIterable2_field_second, ptr @ZipIterable2_B_init_firstIterable2T_secondIterable2U, ptr @ZipIterable2_B_iterator_, ptr @ZipIterable2_B_each_fFunctionT_to_Nothing, ptr @ZipIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZipIterable2_B_all_fFunctionT_to_Ptri1, ptr @ZipIterable2_B_any_fFunctionT_to_Ptri1, ptr @ZipIterable2_B_map_fFunctionT_to_U, ptr @ZipIterable2_B_filter_fFunctionT_to_Ptri1, ptr @ZipIterable2_B_chain_otherIterable2T, ptr @ZipIterable2_B_interleave_otherIterable2T, ptr @ZipIterable2_B_zip_otherIterable2U, ptr @ZipIterable2_B_product_otherIterable2U, ptr @ZipIterable2_init_firstIterable2T_secondIterable2U, ptr @ZipIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U, ptr @ZipIterable2_field_ZipIterable2_2, ptr @ZipIterable2_B_iterator_, ptr @ZipIterable2_B_each_fFunctionT_to_Nothing, ptr @ZipIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZipIterable2_B_all_fFunctionT_to_Ptri1, ptr @ZipIterable2_B_any_fFunctionT_to_Ptri1, ptr @ZipIterable2_B_map_fFunctionT_to_U, ptr @ZipIterable2_B_filter_fFunctionT_to_Ptri1, ptr @ZipIterable2_B_chain_otherIterable2T, ptr @ZipIterable2_B_interleave_otherIterable2T, ptr @ZipIterable2_B_zip_otherIterable2U, ptr @ZipIterable2_B_product_otherIterable2U, ptr @ZipIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U] }
@ZipIterator2_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr null, ptr null, ptr @ZipIterator2, ptr @Container, ptr null, ptr @Iterator2, ptr @Object]
@ZipIterator2_offset_tbl = constant [8 x i32] [i32 10, i32 0, i32 0, i32 10, i32 22, i32 0, i32 19, i32 22]
@ZipIterator2 = constant { [3 x i64], [7 x ptr], [12 x ptr] } { [3 x i64] [i64 5502728639611621286, i64 4611686018427388247, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ZipIterator2_hashtbl, ptr @ZipIterator2_offset_tbl, ptr @_data_size_ZipIterator2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [12 x ptr] [ptr @ZipIterator2_field_ZipIterator2_0, ptr @ZipIterator2_field_ZipIterator2_1, ptr @ZipIterator2_field_ZipIterator2_2, ptr @ZipIterator2_field_first, ptr @ZipIterator2_field_second, ptr @ZipIterator2_B_init_firstIterator2T_secondIterator2U, ptr @ZipIterator2_B_next_, ptr @ZipIterator2_init_firstIterator2T_secondIterator2U, ptr @ZipIterator2_next_, ptr @ZipIterator2_field_ZipIterator2_2, ptr @ZipIterator2_B_next_, ptr @ZipIterator2_next_] }
@ProductIterable2_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @Iterable2, ptr @ProductIterable2, ptr null]
@ProductIterable2_offset_tbl = constant [8 x i32] [i32 62, i32 10, i32 0, i32 62, i32 0, i32 39, i32 10, i32 0]
@ProductIterable2 = constant { [3 x i64], [7 x ptr], [52 x ptr] } { [3 x i64] [i64 7827074759551300494, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ProductIterable2_hashtbl, ptr @ProductIterable2_offset_tbl, ptr @_data_size_ProductIterable2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [52 x ptr] [ptr @ProductIterable2_field_ProductIterable2_0, ptr @ProductIterable2_field_ProductIterable2_1, ptr @ProductIterable2_field_ProductIterable2_2, ptr @ProductIterable2_field_first, ptr @ProductIterable2_field_second, ptr @ProductIterable2_B_init_firstIterable2T_secondIterable2U, ptr @ProductIterable2_B_iterator_, ptr @ProductIterable2_B_each_fFunctionT_to_Nothing, ptr @ProductIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductIterable2_B_all_fFunctionT_to_Ptri1, ptr @ProductIterable2_B_any_fFunctionT_to_Ptri1, ptr @ProductIterable2_B_map_fFunctionT_to_U, ptr @ProductIterable2_B_filter_fFunctionT_to_Ptri1, ptr @ProductIterable2_B_chain_otherIterable2T, ptr @ProductIterable2_B_interleave_otherIterable2T, ptr @ProductIterable2_B_zip_otherIterable2U, ptr @ProductIterable2_B_product_otherIterable2U, ptr @ProductIterable2_init_firstIterable2T_secondIterable2U, ptr @ProductIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U, ptr @ProductIterable2_field_ProductIterable2_2, ptr @ProductIterable2_B_iterator_, ptr @ProductIterable2_B_each_fFunctionT_to_Nothing, ptr @ProductIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductIterable2_B_all_fFunctionT_to_Ptri1, ptr @ProductIterable2_B_any_fFunctionT_to_Ptri1, ptr @ProductIterable2_B_map_fFunctionT_to_U, ptr @ProductIterable2_B_filter_fFunctionT_to_Ptri1, ptr @ProductIterable2_B_chain_otherIterable2T, ptr @ProductIterable2_B_interleave_otherIterable2T, ptr @ProductIterable2_B_zip_otherIterable2U, ptr @ProductIterable2_B_product_otherIterable2U, ptr @ProductIterable2_iterator_, ptr @Iterable2_each_fFunctionT_to_Nothing, ptr @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable2_all_fFunctionT_to_Ptri1, ptr @Iterable2_any_fFunctionT_to_Ptri1, ptr @Iterable2_map_fFunctionT_to_U, ptr @Iterable2_filter_fFunctionT_to_Ptri1, ptr @Iterable2_chain_otherIterable2T, ptr @Iterable2_interleave_otherIterable2T, ptr @Iterable2_zip_otherIterable2U, ptr @Iterable2_product_otherIterable2U] }
@ProductIterator2_hashtbl = constant [8 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Container, ptr null, ptr @ProductIterator2, ptr @Iterator2, ptr null]
@ProductIterator2_offset_tbl = constant [8 x i32] [i32 24, i32 10, i32 0, i32 24, i32 0, i32 10, i32 21, i32 0]
@ProductIterator2 = constant { [3 x i64], [7 x ptr], [14 x ptr] } { [3 x i64] [i64 4440657219728359865, i64 4611686018427388081, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ProductIterator2_hashtbl, ptr @ProductIterator2_offset_tbl, ptr @_data_size_ProductIterator2, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [14 x ptr] [ptr @ProductIterator2_field_ProductIterator2_0, ptr @ProductIterator2_field_ProductIterator2_1, ptr @ProductIterator2_field_ProductIterator2_2, ptr @ProductIterator2_field_first_iterator, ptr @ProductIterator2_field_second_iterator, ptr @ProductIterator2_field_second_iterable, ptr @ProductIterator2_field_current_first, ptr @ProductIterator2_B_init_first_iteratorIterator2T_second_iterableIterable2U, ptr @ProductIterator2_B_next_, ptr @ProductIterator2_init_first_iteratorIterator2T_second_iterableIterable2U, ptr @ProductIterator2_next_, ptr @ProductIterator2_field_ProductIterator2_2, ptr @ProductIterator2_B_next_, ptr @ProductIterator2_next_] }
@Pair_field_first = internal constant { ptr, ptr } { ptr @Pair_getter_first, ptr @Pair_setter_first }
@Pair_field_second = internal constant { ptr, ptr } { ptr @Pair_getter_second, ptr @Pair_setter_second }
@Array_field_buffer = internal constant { ptr, ptr } { ptr @Array_getter_buffer, ptr @Array_setter_buffer }
@Array_field_length = internal constant { ptr, ptr } { ptr @Array_getter_length, ptr @Array_setter_length }
@Array_field_capacity = internal constant { ptr, ptr } { ptr @Array_getter_capacity, ptr @Array_setter_capacity }
@ArrayIterator_field_array = internal constant { ptr, ptr } { ptr @ArrayIterator_getter_array, ptr @ArrayIterator_setter_array }
@ArrayIterator_field_index = internal constant { ptr, ptr } { ptr @ArrayIterator_getter_index, ptr @ArrayIterator_setter_index }
@MapIterable2_field_iterable = internal constant { ptr, ptr } { ptr @MapIterable2_getter_iterable, ptr @MapIterable2_setter_iterable }
@MapIterable2_field_f = internal constant { ptr, ptr } { ptr @MapIterable2_getter_f, ptr @MapIterable2_setter_f }
@MapIterator2_field_iterator = internal constant { ptr, ptr } { ptr @MapIterator2_getter_iterator, ptr @MapIterator2_setter_iterator }
@MapIterator2_field_f = internal constant { ptr, ptr } { ptr @MapIterator2_getter_f, ptr @MapIterator2_setter_f }
@FilterIterable2_field_iterable = internal constant { ptr, ptr } { ptr @FilterIterable2_getter_iterable, ptr @FilterIterable2_setter_iterable }
@FilterIterable2_field_f = internal constant { ptr, ptr } { ptr @FilterIterable2_getter_f, ptr @FilterIterable2_setter_f }
@FilterIterator2_field_iterator = internal constant { ptr, ptr } { ptr @FilterIterator2_getter_iterator, ptr @FilterIterator2_setter_iterator }
@FilterIterator2_field_f = internal constant { ptr, ptr } { ptr @FilterIterator2_getter_f, ptr @FilterIterator2_setter_f }
@ChainIterable2_field_first = internal constant { ptr, ptr } { ptr @ChainIterable2_getter_first, ptr @ChainIterable2_setter_first }
@ChainIterable2_field_second = internal constant { ptr, ptr } { ptr @ChainIterable2_getter_second, ptr @ChainIterable2_setter_second }
@ChainIterator2_field_first = internal constant { ptr, ptr } { ptr @ChainIterator2_getter_first, ptr @ChainIterator2_setter_first }
@ChainIterator2_field_second = internal constant { ptr, ptr } { ptr @ChainIterator2_getter_second, ptr @ChainIterator2_setter_second }
@ChainIterator2_field_on_first = internal constant { ptr, ptr } { ptr @ChainIterator2_getter_on_first, ptr @ChainIterator2_setter_on_first }
@InterleaveIterable2_field_first = internal constant { ptr, ptr } { ptr @InterleaveIterable2_getter_first, ptr @InterleaveIterable2_setter_first }
@InterleaveIterable2_field_second = internal constant { ptr, ptr } { ptr @InterleaveIterable2_getter_second, ptr @InterleaveIterable2_setter_second }
@InterleaveIterator2_field_first = internal constant { ptr, ptr } { ptr @InterleaveIterator2_getter_first, ptr @InterleaveIterator2_setter_first }
@InterleaveIterator2_field_second = internal constant { ptr, ptr } { ptr @InterleaveIterator2_getter_second, ptr @InterleaveIterator2_setter_second }
@InterleaveIterator2_field_on_first = internal constant { ptr, ptr } { ptr @InterleaveIterator2_getter_on_first, ptr @InterleaveIterator2_setter_on_first }
@ZipIterable2_field_first = internal constant { ptr, ptr } { ptr @ZipIterable2_getter_first, ptr @ZipIterable2_setter_first }
@ZipIterable2_field_second = internal constant { ptr, ptr } { ptr @ZipIterable2_getter_second, ptr @ZipIterable2_setter_second }
@ZipIterator2_field_first = internal constant { ptr, ptr } { ptr @ZipIterator2_getter_first, ptr @ZipIterator2_setter_first }
@ZipIterator2_field_second = internal constant { ptr, ptr } { ptr @ZipIterator2_getter_second, ptr @ZipIterator2_setter_second }
@ProductIterable2_field_first = internal constant { ptr, ptr } { ptr @ProductIterable2_getter_first, ptr @ProductIterable2_setter_first }
@ProductIterable2_field_second = internal constant { ptr, ptr } { ptr @ProductIterable2_getter_second, ptr @ProductIterable2_setter_second }
@ProductIterator2_field_first_iterator = internal constant { ptr, ptr } { ptr @ProductIterator2_getter_first_iterator, ptr @ProductIterator2_setter_first_iterator }
@ProductIterator2_field_second_iterator = internal constant { ptr, ptr } { ptr @ProductIterator2_getter_second_iterator, ptr @ProductIterator2_setter_second_iterator }
@ProductIterator2_field_second_iterable = internal constant { ptr, ptr } { ptr @ProductIterator2_getter_second_iterable, ptr @ProductIterator2_setter_second_iterable }
@ProductIterator2_field_current_first = internal constant { ptr, ptr } { ptr @ProductIterator2_getter_current_first, ptr @ProductIterator2_setter_current_first }
@_parameterization_String = linkonce_odr constant [2 x ptr] [ptr @String, ptr null]
@Iterator_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @Iterator]
@Iterator_offset_tbl = constant [4 x i32] [i32 10, i32 0, i32 10, i32 10]
@Iterable_hashtbl = constant [4 x ptr] [ptr null, ptr @Iterable, ptr @any_typ, ptr @Object]
@Iterable_offset_tbl = constant [4 x i32] [i32 0, i32 10, i32 10, i32 12]
@Representable_hashtbl = constant [4 x ptr] [ptr @Representable, ptr null, ptr @any_typ, ptr @Object]
@Representable_offset_tbl = constant [4 x i32] [i32 10, i32 0, i32 10, i32 12]
@String_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr null, ptr @String, ptr @Representable, ptr @Object, ptr null, ptr null, ptr @Iterable]
@String_offset_tbl = constant [8 x i32] [i32 10, i32 0, i32 10, i32 43, i32 43, i32 0, i32 0, i32 41]
@Character_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @Character]
@Character_offset_tbl = constant [4 x i32] [i32 15, i32 0, i32 10, i32 10]
@StringIterator_hashtbl = constant [4 x ptr] [ptr @StringIterator, ptr @Object, ptr @any_typ, ptr @Iterator]
@StringIterator_offset_tbl = constant [4 x i32] [i32 10, i32 16, i32 10, i32 16]
@Exception_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @Exception]
@Exception_offset_tbl = constant [4 x i32] [i32 23, i32 0, i32 10, i32 10]
@String_field_bytes = internal constant { ptr, ptr } { ptr @String_getter_bytes, ptr @String_setter_bytes }
@String_field_length = internal constant { ptr, ptr } { ptr @String_getter_length, ptr @String_setter_length }
@String_field_capacity = internal constant { ptr, ptr } { ptr @String_getter_capacity, ptr @String_setter_capacity }
@Character_field_byte = internal constant { ptr, ptr } { ptr @Character_getter_byte, ptr @Character_setter_byte }
@StringIterator_field_str = internal constant { ptr, ptr } { ptr @StringIterator_getter_str, ptr @StringIterator_setter_str }
@StringIterator_field_index = internal constant { ptr, ptr } { ptr @StringIterator_getter_index, ptr @StringIterator_setter_index }
@Exception_field_line_number = internal constant { ptr, ptr } { ptr @Exception_getter_line_number, ptr @Exception_setter_line_number }
@Exception_field_file_name = internal constant { ptr, ptr } { ptr @Exception_getter_file_name, ptr @Exception_setter_file_name }
@Exception_field_message = internal constant { ptr, ptr } { ptr @Exception_getter_message, ptr @Exception_setter_message }
@_parameterization_Ptri32 = linkonce_odr constant [2 x ptr] [ptr @i32_typ, ptr null]
@i32_string = linkonce_odr constant [4 x i8] c"%d\0A\00"
@i64_string = linkonce_odr constant [6 x i8] c"%lld\0A\00"
@bool_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 5801531371504802705, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @bool_typ_hashtbl, ptr @bool_typ_offset_tbl, ptr @_data_size_bool_typ, ptr @_box_bool_typ, ptr @_unbox_bool_typ, ptr @_data_size_bool_typ], [0 x ptr] undef }
@i8_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 2582149688529881115, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i8_typ_hashtbl, ptr @i8_typ_offset_tbl, ptr @_data_size_i8_typ, ptr @_box_i8_typ, ptr @_unbox_i8_typ, ptr @_data_size_i8_typ], [0 x ptr] undef }
@i32_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -2253724949814257982, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i32_typ_hashtbl, ptr @i32_typ_offset_tbl, ptr @_data_size_i32_typ, ptr @_box_i32_typ, ptr @_unbox_i32_typ, ptr @_data_size_i32_typ], [0 x ptr] undef }
@i64_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -7469797244461771922, i64 4611686018427388157, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i64_typ_hashtbl, ptr @i64_typ_offset_tbl, ptr @_data_size_i64_typ, ptr @_box_i64_typ, ptr @_unbox_i64_typ, ptr @_data_size_i64_typ], [0 x ptr] undef }
@i128_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -8755878215469463641, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i128_typ_hashtbl, ptr @i128_typ_offset_tbl, ptr @_data_size_i128_typ, ptr @_box_i128_typ, ptr @_unbox_i128_typ, ptr @_data_size_i128_typ], [0 x ptr] undef }
@f64_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -757315540097298781, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @f64_typ_hashtbl, ptr @f64_typ_offset_tbl, ptr @_data_size_f64_typ, ptr @_box_f64_typ, ptr @_unbox_f64_typ, ptr @_data_size_f64_typ], [0 x ptr] undef }
@nil_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -5126806859456325683, i64 4611686018427388081, i64 1], [7 x ptr] [ptr @subtype_test, ptr @nil_typ_hashtbl, ptr @nil_typ_offset_tbl, ptr @_data_size_nil_typ, ptr @_box_nil_typ, ptr @_unbox_nil_typ, ptr @_data_size_nil_typ], [0 x ptr] undef }
@any_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3084208142191802847, i64 4611686018427388073, i64 0], [7 x ptr] [ptr @subtype_test, ptr @any_typ_hashtbl, ptr @any_typ_offset_tbl, ptr @_data_size_any_typ, ptr @_box_Default, ptr @_unbox_Default, ptr @_data_size_any_typ], [0 x ptr] undef }
@nothing_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -3334456163433371378, i64 4611686018427388097, i64 3], [7 x ptr] [ptr @subtype_test, ptr @nothing_typ_hashtbl, ptr @nothing_typ_offset_tbl, ptr @_data_size_nothing_typ, ptr @_box_nothing_typ, ptr @_unbox_nothing_typ, ptr @_data_size_nothing_typ], [0 x ptr] undef }
@coroutine_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 7194361020959218064, i64 4611686018427388097, i64 3], [7 x ptr] [ptr @subtype_test, ptr @coroutine_typ_hashtbl, ptr @coroutine_typ_offset_tbl, ptr @_data_size_coroutine_typ, ptr @_box_coroutine_typ, ptr @_unbox_coroutine_typ, ptr @_data_size_coroutine_typ], [0 x ptr] undef }
@function_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 7927147055246173914, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @function_typ_hashtbl, ptr @function_typ_offset_tbl, ptr @_data_size_function_typ, ptr @_box_function_typ, ptr @_unbox_function_typ, ptr @_data_size_function_typ], [0 x ptr] undef }
@buffer_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -318192747195410237, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @buffer_typ_hashtbl, ptr @buffer_typ_offset_tbl, ptr @_data_size_buffer_typ, ptr @_box_buffer_typ, ptr @_unbox_buffer_typ, ptr @_data_size_buffer_typ], [0 x ptr] undef }
@tuple_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3422634369532007740, i64 4611686018427388081, i64 3], [7 x ptr] [ptr @subtype_test, ptr @tuple_typ_hashtbl, ptr @tuple_typ_offset_tbl, ptr @_data_size_tuple_typ, ptr @_box_tuple_typ, ptr @_unbox_tuple_typ, ptr @_data_size_tuple_typ], [0 x ptr] undef }
@union_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -7543233778997666740, i64 4611686018427388093, i64 3], [7 x ptr] [ptr @subtype_test, ptr @union_typ_hashtbl, ptr @union_typ_offset_tbl, ptr @_data_size_union_typ, ptr @_box_union_typ, ptr @_unbox_union_typ, ptr @_data_size_union_typ], [0 x ptr] undef }
@Object = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3282773614056351330, i64 4611686018427388081, i64 1], [7 x ptr] [ptr @subtype_test, ptr @Object_hashtbl, ptr @Object_offset_tbl, ptr @_data_size_Object, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Iterator = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 8673632051301757104, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Iterator_hashtbl, ptr @Iterator_offset_tbl, ptr @_data_size_Iterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Iterable = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3037712219555723519, i64 4611686018427388093, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Iterable_hashtbl, ptr @Iterable_offset_tbl, ptr @_data_size_Iterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Representable = constant { [3 x i64], [7 x ptr], [2 x ptr] } { [3 x i64] [i64 -7260840641129990118, i64 4611686018427388093, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Representable_hashtbl, ptr @Representable_offset_tbl, ptr @_data_size_Representable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [2 x ptr] [ptr @Representable_B_repr_, ptr @Representable_repr_] }
@String = constant { [3 x i64], [7 x ptr], [35 x ptr] } { [3 x i64] [i64 6499063144389013426, i64 4611686018427388073, i64 7], [7 x ptr] [ptr @subtype_test, ptr @String_hashtbl, ptr @String_offset_tbl, ptr @_data_size_String, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [35 x ptr] [ptr @String_field_bytes, ptr @String_field_length, ptr @String_field_capacity, ptr @String_B_init_, ptr @String_B_init_bytesBufferPtri8_lengthPtri32_capacityPtri32, ptr @String_B_length_, ptr @String_B_capacity_, ptr @String_B_bytes_, ptr @String_B_append_xPtri8, ptr @String_B_extend_strString, ptr @String_B__index_xPtri32, ptr @String_B__EQ_otherString, ptr @String_B_pop_, ptr @String_B_copy_, ptr @String_B_c_string_, ptr @String_B_iterator_, ptr @String_B_repr_, ptr @String_init_, ptr @String_init_bytesBufferPtri8_lengthPtri32_capacityPtri32, ptr @String_length_, ptr @String_capacity_, ptr @String_bytes_, ptr @String_append_xPtri8, ptr @String_extend_strString, ptr @String__index_xPtri32, ptr @String__EQ_otherString, ptr @String_pop_, ptr @String_copy_, ptr @String_c_string_, ptr @String_iterator_, ptr @String_repr_, ptr @String_B_iterator_, ptr @String_iterator_, ptr @String_B_repr_, ptr @String_repr_] }
@Character = constant { [3 x i64], [7 x ptr], [5 x ptr] } { [3 x i64] [i64 6681222582356018452, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Character_hashtbl, ptr @Character_offset_tbl, ptr @_data_size_Character, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [5 x ptr] [ptr @Character_field_byte, ptr @Character_B_byte_, ptr @Character_B_init_bytePtri8, ptr @Character_byte_, ptr @Character_init_bytePtri8] }
@StringIterator = constant { [3 x i64], [7 x ptr], [6 x ptr] } { [3 x i64] [i64 -7260570988945952630, i64 4611686018427388097, i64 3], [7 x ptr] [ptr @subtype_test, ptr @StringIterator_hashtbl, ptr @StringIterator_offset_tbl, ptr @_data_size_StringIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [6 x ptr] [ptr @StringIterator_field_str, ptr @StringIterator_field_index, ptr @StringIterator_B_init_strString, ptr @StringIterator_B_next_, ptr @StringIterator_init_strString, ptr @StringIterator_next_] }
@Exception = constant { [3 x i64], [7 x ptr], [13 x ptr] } { [3 x i64] [i64 9027164862567808692, i64 4611686018427388091, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Exception_hashtbl, ptr @Exception_offset_tbl, ptr @_data_size_Exception, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [13 x ptr] [ptr @Exception_field_line_number, ptr @Exception_field_file_name, ptr @Exception_field_message, ptr @Exception_B_init_messageString, ptr @Exception_B_init_, ptr @Exception_B_set_info_line_numberPtri32_file_nameString, ptr @Exception_B_report_, ptr @Exception_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberPtri32_file_nameString, ptr @Exception_report_, ptr @Exception_print_message_] }
@IO_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @IO, ptr null, ptr @Object]
@IO_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 20]
@IO = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 5359822646784595218, i64 4611686018427388247, i64 3], [7 x ptr] [ptr @subtype_test, ptr @IO_hashtbl, ptr @IO_offset_tbl, ptr @_data_size_IO, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @IO_B__Self_print_xCharacter__Self_print_xPtri1__Self_print_xPtri32__Self_print_xNil__Self_print_xString__Self_print_xPtri64__Self_print_xRepresentable__Self_print_xPtrf64__Self_print_xPtri8, ptr @IO__Self_print_xCharacter, ptr @IO__Self_print_xPtri1, ptr @IO__Self_print_xPtri32, ptr @IO__Self_print_xNil, ptr @IO__Self_print_xString, ptr @IO__Self_print_xPtri64, ptr @IO__Self_print_xRepresentable, ptr @IO__Self_print_xPtrf64, ptr @IO__Self_print_xPtri8] }
@string_string.95 = internal constant [4 x i8] c"%s\0A\00"
@float_string = linkonce_odr constant [4 x i8] c"%f\0A\00"
@exception_message = internal constant [45 x i8] c"Error: uncaught exception. Program aborted.\0A\00"
@into_caller_buf = linkonce_odr thread_local global [3 x ptr] zeroinitializer
@current_coroutine = linkonce_odr thread_local local_unnamed_addr global ptr null
@always_one = linkonce thread_local local_unnamed_addr global i1 true
@current_ptr = internal thread_local global ptr null

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_PRNG(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 4, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @PRNG_B_init_initial_seedPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 104
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @PRNG_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @PRNG_init_initial_seedPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #2 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !1
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !1
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !1
  %product.i.i.i = mul i64 %hash_coef.i.i, -4401938362882229211
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !1
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull %.fca.0.extract) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %. = tail call i32 @llvm.smax.i32(i32 %3, i32 1)
  tail call void %10(ptr %.fca.1.extract, i32 %.) #35
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @PRNG_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !4
  %product.i.i.i = mul i64 %hash_coef.i.i, -4401938362882229211
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !4
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %.fca.0.extract) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = tail call i32 %8(ptr %.fca.1.extract) #36
  %10 = mul i32 %9, 1103515245
  %11 = add i32 %10, 12345
  %12 = and i32 %11, 2147483647
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %.fca.0.extract) #34
  %14 = getelementptr i8, ptr %7, i64 8
  %15 = load ptr, ptr %14, align 8
  tail call void %15(ptr %.fca.1.extract, i32 %12) #35
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %.fca.0.extract) #34
  %17 = load ptr, ptr %6, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = tail call i32 %18(ptr %.fca.1.extract) #36
  ret i32 %19
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare ptr @llvm.invariant.start.p0(i64 immarg, ptr nocapture) #4

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @PRNG_getter_seed(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #5 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @PRNG_setter_seed(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #6 {
  store i32 %1, ptr %0, align 4
  ret void
}

define i1 @obvzesuyhl(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @fwguoiyozn(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @jxklgmxkzf(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @wnqcnuwksw(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @pcqqahzzfu(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @eptcgwbewk(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @uapuynspes(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @aezirnfvtu(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @egzihtnwnj(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @njmyxpctxz(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @ehsipluukj(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @gfgpcwhvzl(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @qqpnfjadrc(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @ogzjpsiwda(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @rqipwqtmqq(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @appmrwvncp(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @xnsyrjqygq(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @zqowobcfpb(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

define i1 @bljcadvgpu(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1, { ptr, i160 } %2) {
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.15.8.extract.trunc = trunc i160 %.fca.1.extract3 to i32
  %.fca.1.extract = extractvalue { ptr, i160 } %2, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %4 = tail call i1 %0(i32 %.sroa.15.8.extract.trunc, i32 %.sroa.1.8.extract.trunc)
  ret i1 %4
}

define i32 @kgxtsntexh(ptr nest nocapture nofree noundef nonnull readonly %0, { ptr, i160 } %1) {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 %0(i32 %.sroa.1.8.extract.trunc)
  ret i32 %3
}

; Function Attrs: nounwind
define void @print_benchmark_result({ ptr, ptr, ptr, i32 } %0, i32 %1, i64 %2) local_unnamed_addr #7 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !7
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !7
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !7
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !7
  %4 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract, 0
  %5 = ptrtoint ptr %.fca.1.extract to i64
  %6 = ptrtoint ptr %.fca.2.extract to i64
  %.sroa.6.8.insert.ext = zext i32 %offset.i.i to i160
  %.sroa.6.8.insert.shift = shl nuw i160 %.sroa.6.8.insert.ext, 128
  %.sroa.5.8.insert.ext = zext i64 %6 to i160
  %.sroa.5.8.insert.shift = shl nuw nsw i160 %.sroa.5.8.insert.ext, 64
  %.sroa.5.8.insert.insert = or disjoint i160 %.sroa.6.8.insert.shift, %.sroa.5.8.insert.shift
  %.sroa.3.8.insert.ext237 = zext i64 %5 to i160
  %.sroa.3.8.insert.insert238 = or disjoint i160 %.sroa.5.8.insert.insert, %.sroa.3.8.insert.ext237
  %7 = insertvalue { ptr, i160 } %4, i160 %.sroa.3.8.insert.insert238, 1
  %8 = alloca [1 x ptr], align 8
  store ptr @_parameterization_String, ptr %8, align 8
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %8) #34
  %10 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #34
  %11 = getelementptr i8, ptr %.fca.0.extract, i64 24
  %12 = getelementptr i8, ptr %.fca.0.extract, i64 32
  %13 = load i64, ptr %hash_coef_ptr.i.i, align 4
  %14 = load i64, ptr %tbl_size_ptr.i.i, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %result.i.i = tail call i1 %15(i64 %14, i64 %13, i64 -7260840641129990118, i64 ptrtoint (ptr @Representable to i64), ptr readonly %16) #5
  br i1 %result.i.i, label %17, label %.critedge.i

17:                                               ; preds = %3
  %result.i14.i = tail call i1 %15(i64 %14, i64 %13, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %16) #5
  %result.i15.i = tail call i1 %15(i64 %14, i64 %13, i64 6681222582356018452, i64 ptrtoint (ptr @Character to i64), ptr readonly %16) #5
  %.reg2mem47.0.i = select i1 %result.i14.i, i1 true, i1 %result.i15.i
  br i1 %.reg2mem47.0.i, label %.critedge.i, label %._crit_edge.lr.ph.i

.critedge.i:                                      ; preds = %17, %3
  %18 = icmp eq ptr %.fca.0.extract, @bool_typ
  br i1 %18, label %._crit_edge.lr.ph.i, label %19

19:                                               ; preds = %.critedge.i
  %20 = icmp eq ptr %.fca.0.extract, @f64_typ
  br i1 %20, label %._crit_edge.lr.ph.i, label %21

21:                                               ; preds = %19
  %22 = icmp eq ptr %.fca.0.extract, @i32_typ
  br i1 %22, label %._crit_edge.lr.ph.i, label %23

23:                                               ; preds = %21
  %24 = icmp eq ptr %.fca.0.extract, @i8_typ
  br i1 %24, label %._crit_edge.lr.ph.i, label %25

25:                                               ; preds = %23
  %result.i16.i = tail call i1 %15(i64 %14, i64 %13, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %16) #5
  %result.i17.i = tail call i1 %15(i64 %14, i64 %13, i64 6681222582356018452, i64 ptrtoint (ptr @Character to i64), ptr readonly %16) #5
  %not.result.i16.i = xor i1 %result.i16.i, true
  %.reg2mem43.0.i = select i1 %not.result.i16.i, i1 true, i1 %result.i17.i
  br i1 %.reg2mem43.0.i, label %26, label %._crit_edge.lr.ph.i

26:                                               ; preds = %25
  %not.result.i17.i = xor i1 %result.i17.i, true
  %.reg2mem41.0.i = or i1 %result.i16.i, %not.result.i17.i
  %27 = icmp eq ptr %.fca.0.extract, @nil_typ
  %28 = icmp eq ptr %.fca.0.extract, null
  %29 = or i1 %27, %28
  %30 = select i1 %29, i32 4, i32 6
  %.reg2mem39.0.i = select i1 %.reg2mem41.0.i, i32 %30, i32 1
  br label %._crit_edge.lr.ph.i

._crit_edge.lr.ph.i:                              ; preds = %26, %25, %23, %21, %19, %.critedge.i, %17
  %.reg2mem27.0.i = phi i32 [ 2, %.critedge.i ], [ 8, %19 ], [ 3, %21 ], [ 9, %23 ], [ %.reg2mem39.0.i, %26 ], [ 5, %25 ], [ 7, %17 ]
  %31 = zext nneg i32 %.reg2mem27.0.i to i64
  %32 = getelementptr [10 x ptr], ptr @IO, i64 0, i64 %31
  %33 = getelementptr i8, ptr %32, i64 80
  %34 = load ptr, ptr %33, align 8
  call void %34(ptr nonnull align 8 dereferenceable(8) %8, { ptr, i160 } %7) #7
  %result.i97 = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i97, align 16
  %result.i.i375 = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i375, ptr noundef nonnull align 16 dereferenceable(14) %result.i97, i64 14, i1 false)
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i375)
  %35 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %1) #17
  %result.i103 = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i103, align 16
  %result.i.i389 = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i389, ptr noundef nonnull align 16 dereferenceable(14) %result.i103, i64 14, i1 false)
  %puts.i313 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i389)
  %36 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %2) #17
  %result.i109 = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i109, align 4
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %result.i.i408 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i408, ptr noundef nonnull align 4 dereferenceable(3) %result.i109, i64 3, i1 false)
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %puts.i333 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i408)
  %39 = icmp sgt i32 %1, 0
  br i1 %39, label %._crit_edge1, label %._crit_edge

._crit_edge1:                                     ; preds = %._crit_edge.lr.ph.i
  %40 = icmp sgt i64 %2, 0
  br i1 %40, label %41, label %._crit_edge.lr.ph.i428

41:                                               ; preds = %._crit_edge1
  %42 = zext nneg i32 %1 to i64
  %43 = mul i64 %2, 1000000
  %44 = sdiv i64 %43, %42
  br label %._crit_edge.lr.ph.i428

._crit_edge.lr.ph.i428:                           ; preds = %._crit_edge1, %41
  %.0 = phi i64 [ %44, %41 ], [ 0, %._crit_edge1 ]
  %result.i114 = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i114, align 16
  %result.i.i427 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i427, ptr noundef nonnull align 16 dereferenceable(15) %result.i114, i64 15, i1 false)
  %puts.i353 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i427)
  %45 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0) #17
  %result.i120 = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i120, align 4
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %result.i.i446 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i446, ptr noundef nonnull align 4 dereferenceable(3) %result.i120, i64 3, i1 false)
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %puts.i373 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i446)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph.i, %._crit_edge.lr.ph.i428
  ret void
}

define void @benchmark_insert_sequential(i32 %0) local_unnamed_addr {
  %2 = alloca [0 x ptr], align 8
  %3 = alloca [3 x ptr], align 8
  %oldProtect.i154 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %result.i150 = tail call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i150, align 8
  %4 = getelementptr inbounds i8, ptr %result.i150, i64 8
  store ptr @_parameterization_Ptri32, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %result.i150, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %5, align 8
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i150) #38
  %result.i151 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i)
  %result.i152 = call i32 @VirtualProtect(ptr nofree %result.i151, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i151, ptr noalias nofree noundef nonnull readnone @kgxtsntexh, ptr noalias nofree noundef nonnull readnone @i32_hasher) #38
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i151) #39
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i151) #38
  %result.i153 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i154)
  %result.i155 = call i32 @VirtualProtect(ptr nofree %result.i153, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i154) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i154)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i153, ptr noalias nofree noundef nonnull readnone @bljcadvgpu, ptr noalias nofree noundef nonnull readnone @i32_eq) #38
  %ret.i156 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i153) #39
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i153) #38
  %9 = getelementptr inbounds i8, ptr %result.i150, i64 48
  store ptr %ret.i, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %result.i150, i64 56
  store ptr %ret.i156, ptr %10, align 8
  %result.i.i = call noalias dereferenceable_or_null(512) ptr @bump_malloc_inner(i64 noundef 512, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %11 = getelementptr inbounds i8, ptr %result.i150, i64 24
  store ptr %result.i.i, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %result.i150, i64 32
  store i32 16, ptr %12, align 8
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #34
  %14 = call i64 @clock()
  %15 = icmp sgt i32 %0, 0
  br i1 %15, label %._crit_edge.preheader, label %546

._crit_edge.preheader:                            ; preds = %1
  %16 = getelementptr inbounds i8, ptr %result.i150, i64 40
  %17 = getelementptr inbounds i8, ptr %result.i150, i64 36
  %18 = getelementptr inbounds i8, ptr %3, i64 8
  %19 = getelementptr inbounds i8, ptr %3, i64 16
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.preheader, %HashMap_insert_internal_keyK_valueV_hashPtri32.exit
  %.0216 = phi i32 [ %20, %HashMap_insert_internal_keyK_valueV_hashPtri32.exit ], [ 0, %._crit_edge.preheader ]
  %20 = add nuw nsw i32 %.0216, 1
  %.sroa.0131.0.insert.ext = zext nneg i32 %.0216 to i160
  %21 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0131.0.insert.ext, 1
  %.sroa.0128.0.insert.ext = zext nneg i32 %20 to i160
  %22 = load i32, ptr %16, align 8
  %23 = load i32, ptr %12, align 8
  %24 = icmp eq i32 %23, 0
  %25 = mul i32 %22, 10
  %26 = add i32 %25, 10
  %27 = mul i32 %23, 6
  %28 = icmp sge i32 %26, %27
  %.0.i375 = select i1 %24, i1 true, i1 %28
  br i1 %.0.i375, label %._crit_edge1.i377, label %HashMap_ensure_capacity_required_loadPtri32.exit

._crit_edge1.i377:                                ; preds = %._crit_edge
  %29 = shl i32 %23, 1
  %spec.select.i378 = call i32 @llvm.smax.i32(i32 %29, i32 16)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %30 = load ptr, ptr %11, align 8
  %31 = zext nneg i32 %spec.select.i378 to i64
  %32 = shl nuw nsw i64 %31, 5
  %result.i.i490 = call noalias ptr @bump_malloc_inner(i64 noundef %32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i490, ptr %11, align 8
  store i32 %spec.select.i378, ptr %12, align 8
  store i32 0, ptr %17, align 4
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #38
  store i32 0, ptr %16, align 8
  %34 = icmp sgt i32 %23, 0
  br i1 %34, label %.lr.ph.i491, label %HashMap_resize_new_capacityPtri32.exit

.lr.ph.i491:                                      ; preds = %._crit_edge1.i377, %._crit_edge.i492
  %.096.i = phi i32 [ %237, %._crit_edge.i492 ], [ 0, %._crit_edge1.i377 ]
  %35 = zext nneg i32 %.096.i to i64
  %36 = shl nuw nsw i64 %35, 5
  %37 = getelementptr i8, ptr %30, i64 %36
  %38 = load ptr, ptr %37, align 8
  %39 = icmp ne ptr %38, @nil_typ
  %40 = icmp ne ptr %38, null
  %.not40.i = and i1 %39, %40
  br i1 %.not40.i, label %41, label %._crit_edge.i492

41:                                               ; preds = %.lr.ph.i491
  %42 = getelementptr i8, ptr %37, i64 8
  %43 = load i64, ptr %42, align 4
  %.sroa_idx.i493 = getelementptr i8, ptr %37, i64 16
  %44 = load i64, ptr %.sroa_idx.i493, align 4
  %45 = inttoptr i64 %43 to ptr
  %46 = inttoptr i64 %44 to ptr
  %hash_coef_ptr.i.i42.i = getelementptr i8, ptr %38, i64 8
  %tbl_size_ptr.i.i43.i = getelementptr i8, ptr %38, i64 16
  %offset_tbl_ptr.i.i44.i = getelementptr i8, ptr %38, i64 40
  %hash_coef.i.i45.i = load i64, ptr %hash_coef_ptr.i.i42.i, align 4, !noalias !10
  %tbl_size.i.i46.i = load i64, ptr %tbl_size_ptr.i.i43.i, align 4, !noalias !10
  %offset_tbl.i.i47.i = load ptr, ptr %offset_tbl_ptr.i.i44.i, align 8, !noalias !10
  %product.i.i.i48.i = mul i64 %hash_coef.i.i45.i, 4015701072841558310
  %shifted.i.i.i49.i = lshr i64 %product.i.i.i48.i, 32
  %xored.i.i.i50.i = xor i64 %shifted.i.i.i49.i, %product.i.i.i48.i
  %hash.i.i.i51.i = and i64 %xored.i.i.i50.i, %tbl_size.i.i46.i
  %offset_ptr.i.i52.i = getelementptr i32, ptr %offset_tbl.i.i47.i, i64 %hash.i.i.i51.i
  %offset.i.i53.i = load i32, ptr %offset_ptr.i.i52.i, align 4, !noalias !10
  %47 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %38, 0
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %45, 1
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %46, 2
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, i32 %offset.i.i53.i, 3
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %38)
  %53 = sext i32 %offset.i.i53.i to i64
  %54 = getelementptr ptr, ptr %38, i64 %53
  %55 = getelementptr i8, ptr %54, i64 56
  %56 = load ptr, ptr %55, align 8
  %result.i55.i = call ptr %56({ ptr, ptr, ptr, i32 } %50, ptr nocapture nofree noundef nonnull readonly %2) #16
  %57 = call { ptr, i160 } %result.i55.i({ ptr, ptr, ptr, i32 } %50, { ptr, ptr, ptr, i32 } %50, ptr nonnull align 8 %2) #7
  %.fca.0.extract29.i = extractvalue { ptr, i160 } %57, 0
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %59 = load ptr, ptr %4, align 8
  %60 = load ptr, ptr %59, align 8
  %61 = ptrtoint ptr %60 to i64
  %62 = getelementptr i8, ptr %.fca.0.extract29.i, i64 8
  %63 = getelementptr i8, ptr %.fca.0.extract29.i, i64 16
  %64 = getelementptr i8, ptr %.fca.0.extract29.i, i64 24
  %65 = getelementptr i8, ptr %.fca.0.extract29.i, i64 32
  %66 = load i64, ptr %62, align 4
  %67 = load i64, ptr %63, align 4
  %68 = load ptr, ptr %64, align 8
  %69 = load ptr, ptr %65, align 8
  %70 = load i64, ptr %60, align 4
  %result.i57.i = call i1 %68(i64 %67, i64 %66, i64 %70, i64 %61, ptr readonly %69) #5
  br i1 %result.i57.i, label %71, label %._crit_edge.i492

71:                                               ; preds = %41
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %38)
  %74 = getelementptr i8, ptr %54, i64 48
  %75 = load ptr, ptr %74, align 8
  %result.i58.i = call ptr %75({ ptr, ptr, ptr, i32 } %50, ptr nocapture nofree noundef nonnull readonly %2) #16
  %76 = call { ptr, i160 } %result.i58.i({ ptr, ptr, ptr, i32 } %50, { ptr, ptr, ptr, i32 } %50, ptr nonnull align 8 %2) #7
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %38)
  %79 = getelementptr i8, ptr %54, i64 64
  %80 = load ptr, ptr %79, align 8
  %result.i59.i = call ptr %80({ ptr, ptr, ptr, i32 } %50, ptr nocapture nofree noundef nonnull readonly %2) #16
  %81 = call i32 %result.i59.i({ ptr, ptr, ptr, i32 } %50, { ptr, ptr, ptr, i32 } %50, ptr nonnull align 8 %2) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %3)
  %82 = load ptr, ptr %result.i150, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %83 = load i32, ptr %12, align 8
  %84 = add i32 %83, -1
  %85 = and i32 %84, %81
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %87 = load ptr, ptr %11, align 8
  %88 = sext i32 %85 to i64
  %89 = shl nsw i64 %88, 5
  %90 = getelementptr i8, ptr %87, i64 %89
  %91 = load ptr, ptr %90, align 8
  %92 = icmp eq ptr %91, @nil_typ
  %93 = icmp eq ptr %91, null
  %94 = or i1 %92, %93
  br i1 %94, label %HashMap_find_slot_keyK_hashPtri32.exit687, label %.lr.ph.i663

.lr.ph.i663:                                      ; preds = %71
  %95 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %96

96:                                               ; preds = %._crit_edge.thread.i678, %.lr.ph.i663
  %97 = phi i32 [ %85, %.lr.ph.i663 ], [ %139, %._crit_edge.thread.i678 ]
  %spec.store.select.i683697 = phi i32 [ -1, %.lr.ph.i663 ], [ %spec.store.select.i683, %._crit_edge.thread.i678 ]
  %98 = phi ptr [ %91, %.lr.ph.i663 ], [ %144, %._crit_edge.thread.i678 ]
  %99 = phi ptr [ %90, %.lr.ph.i663 ], [ %143, %._crit_edge.thread.i678 ]
  %.sroa_idx.i664 = getelementptr i8, ptr %99, i64 16
  %100 = load i64, ptr %.sroa_idx.i664, align 4
  %101 = getelementptr i8, ptr %99, i64 8
  %102 = load i64, ptr %101, align 4
  %103 = inttoptr i64 %102 to ptr
  %104 = inttoptr i64 %100 to ptr
  %hash_coef_ptr.i.i56.i665 = getelementptr i8, ptr %98, i64 8
  %tbl_size_ptr.i.i57.i666 = getelementptr i8, ptr %98, i64 16
  %offset_tbl_ptr.i.i58.i667 = getelementptr i8, ptr %98, i64 40
  %hash_coef.i.i59.i668 = load i64, ptr %hash_coef_ptr.i.i56.i665, align 4
  %tbl_size.i.i60.i669 = load i64, ptr %tbl_size_ptr.i.i57.i666, align 4
  %offset_tbl.i.i61.i670 = load ptr, ptr %offset_tbl_ptr.i.i58.i667, align 8
  %product.i.i.i62.i671 = mul i64 %hash_coef.i.i59.i668, 4015701072841558310
  %shifted.i.i.i63.i672 = lshr i64 %product.i.i.i62.i671, 32
  %xored.i.i.i64.i673 = xor i64 %shifted.i.i.i63.i672, %product.i.i.i62.i671
  %hash.i.i.i65.i674 = and i64 %xored.i.i.i64.i673, %tbl_size.i.i60.i669
  %offset_ptr.i.i66.i675 = getelementptr i32, ptr %offset_tbl.i.i61.i670, i64 %hash.i.i.i65.i674
  %offset.i.i67.i676 = load i32, ptr %offset_ptr.i.i66.i675, align 4
  %105 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %98, 0
  %106 = insertvalue { ptr, ptr, ptr, i32 } %105, ptr %103, 1
  %107 = insertvalue { ptr, ptr, ptr, i32 } %106, ptr %104, 2
  %108 = insertvalue { ptr, ptr, ptr, i32 } %107, i32 %offset.i.i67.i676, 3
  %109 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %98)
  %110 = sext i32 %offset.i.i67.i676 to i64
  %111 = getelementptr ptr, ptr %98, i64 %110
  %112 = getelementptr i8, ptr %111, i64 64
  %113 = load ptr, ptr %112, align 8
  %result.i.i677 = call ptr %113({ ptr, ptr, ptr, i32 } %108, ptr nocapture nofree noundef nonnull readonly %2) #16
  %114 = call i32 %result.i.i677({ ptr, ptr, ptr, i32 } %108, { ptr, ptr, ptr, i32 } %108, ptr nonnull align 8 %2) #7
  %115 = icmp eq i32 %114, %81
  br i1 %115, label %._crit_edge.i685, label %._crit_edge.thread.i678

._crit_edge.i685:                                 ; preds = %96
  %116 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %117 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %98)
  %118 = getelementptr i8, ptr %111, i64 48
  %119 = load ptr, ptr %118, align 8
  %result.i69.i686 = call ptr %119({ ptr, ptr, ptr, i32 } %108, ptr nocapture nofree noundef nonnull readonly %2) #16
  %120 = call { ptr, i160 } %result.i69.i686({ ptr, ptr, ptr, i32 } %108, { ptr, ptr, ptr, i32 } %108, ptr nonnull align 8 %2) #7
  %121 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %122 = load ptr, ptr %10, align 8
  %123 = call i1 %122({ ptr, i160 } %120, { ptr, i160 } %76) #7
  br i1 %123, label %HashMap_find_slot_keyK_hashPtri32.exit687.loopexit, label %._crit_edge.thread.i678

._crit_edge.thread.i678:                          ; preds = %._crit_edge.i685, %96
  %124 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %125 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %98)
  %126 = getelementptr i8, ptr %111, i64 56
  %127 = load ptr, ptr %126, align 8
  %result.i70.i679 = call ptr %127({ ptr, ptr, ptr, i32 } %108, ptr nocapture nofree noundef nonnull readonly %2) #16
  %128 = call { ptr, i160 } %result.i70.i679({ ptr, ptr, ptr, i32 } %108, { ptr, ptr, ptr, i32 } %108, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i680 = extractvalue { ptr, i160 } %128, 0
  %129 = getelementptr i8, ptr %.fca.0.extract19.i680, i64 8
  %130 = getelementptr i8, ptr %.fca.0.extract19.i680, i64 16
  %131 = getelementptr i8, ptr %.fca.0.extract19.i680, i64 24
  %132 = getelementptr i8, ptr %.fca.0.extract19.i680, i64 32
  %133 = load i64, ptr %129, align 4
  %134 = load i64, ptr %130, align 4
  %135 = load ptr, ptr %131, align 8
  %136 = load ptr, ptr %132, align 8
  %result.i71.i681 = call i1 %135(i64 %134, i64 %133, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %136) #5
  %137 = icmp eq i32 %spec.store.select.i683697, -1
  %or.cond.i682 = select i1 %result.i71.i681, i1 %137, i1 false
  %spec.store.select.i683 = select i1 %or.cond.i682, i32 %97, i32 %spec.store.select.i683697
  %138 = add i32 %97, 1
  %139 = and i32 %138, %84
  %140 = load ptr, ptr %11, align 8
  %141 = sext i32 %139 to i64
  %142 = shl nsw i64 %141, 5
  %143 = getelementptr i8, ptr %140, i64 %142
  %144 = load ptr, ptr %143, align 8
  %145 = icmp eq ptr %144, @nil_typ
  %146 = icmp eq ptr %144, null
  %147 = or i1 %145, %146
  br i1 %147, label %._crit_edge105.loopexit.i684, label %96

._crit_edge105.loopexit.i684:                     ; preds = %._crit_edge.thread.i678
  %148 = icmp eq i32 %spec.store.select.i683, -1
  %.pre.i.pre716 = select i1 %148, i32 %139, i32 %spec.store.select.i683
  br label %HashMap_find_slot_keyK_hashPtri32.exit687

HashMap_find_slot_keyK_hashPtri32.exit687.loopexit: ; preds = %._crit_edge.i685
  %.pre749 = load ptr, ptr %11, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit687

HashMap_find_slot_keyK_hashPtri32.exit687:        ; preds = %HashMap_find_slot_keyK_hashPtri32.exit687.loopexit, %71, %._crit_edge105.loopexit.i684
  %149 = phi ptr [ %140, %._crit_edge105.loopexit.i684 ], [ %87, %71 ], [ %.pre749, %HashMap_find_slot_keyK_hashPtri32.exit687.loopexit ]
  %150 = phi i32 [ %.pre.i.pre716, %._crit_edge105.loopexit.i684 ], [ %85, %71 ], [ %97, %HashMap_find_slot_keyK_hashPtri32.exit687.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %151 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %152 = sext i32 %150 to i64
  %153 = shl nsw i64 %152, 5
  %154 = getelementptr i8, ptr %149, i64 %153
  %155 = load ptr, ptr %154, align 8
  %156 = getelementptr i8, ptr %154, i64 8
  %157 = load i64, ptr %156, align 4
  %.sroa_idx.i596 = getelementptr i8, ptr %154, i64 16
  %158 = load i64, ptr %.sroa_idx.i596, align 4
  %159 = load ptr, ptr %4, align 8
  %160 = load ptr, ptr %82, align 8, !alias.scope !13
  %161 = getelementptr i8, ptr %160, i64 72
  %162 = load ptr, ptr %161, align 8, !alias.scope !13
  %result.i.i.i598 = call { i64, i64 } %162(ptr nocapture nofree nonnull readonly %82) #5, !alias.scope !13
  %163 = extractvalue { i64, i64 } %result.i.i.i598, 0
  %164 = extractvalue { i64, i64 } %result.i.i.i598, 1
  %165 = call i64 @llvm.umax.i64(i64 %164, i64 8)
  %166 = urem i64 20, %164
  %167 = icmp eq i64 %166, 0
  %168 = sub i64 %164, %166
  %169 = select i1 %167, i64 0, i64 %168
  %170 = add i64 %163, 20
  %171 = add i64 %170, %169
  %172 = and i64 %171, 7
  %173 = icmp eq i64 %172, 0
  %174 = sub nuw nsw i64 40, %172
  %175 = select i1 %173, i64 32, i64 %174
  %176 = add i64 %175, %171
  %177 = urem i64 %176, %165
  %178 = icmp eq i64 %177, 0
  %179 = sub i64 %165, %177
  %180 = select i1 %178, i64 0, i64 %179
  %181 = add i64 %176, %180
  %result.i71.i599 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %181, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %82, ptr %result.i71.i599, align 8
  %182 = getelementptr inbounds i8, ptr %result.i71.i599, i64 8
  store ptr %159, ptr %182, align 8
  %183 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i599)
  %184 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %result.i71.i599, 1
  %185 = insertvalue { ptr, ptr, ptr, i32 } %184, ptr undef, 2
  %186 = insertvalue { ptr, ptr, ptr, i32 } %185, i32 10, 3
  store ptr %82, ptr %3, align 8
  store ptr %159, ptr %18, align 8
  store ptr @_parameterization_Ptri32, ptr %19, align 8
  %187 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %3)
  %188 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Entry)
  %189 = load i64, ptr %62, align 4
  %190 = load i64, ptr %63, align 4
  %191 = load ptr, ptr %64, align 8
  %192 = load ptr, ptr %65, align 8
  %result.i.i117.i = call i1 %191(i64 %190, i64 %189, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %192) #5
  %193 = select i1 %result.i.i117.i, i64 9, i64 10
  %gep = getelementptr [14 x ptr], ptr getelementptr inbounds (i8, ptr @Entry, i64 80), i64 0, i64 %193
  %194 = load ptr, ptr %gep, align 8
  call void %194({ ptr, ptr, ptr, i32 } %186, { ptr, ptr, ptr, i32 } %186, ptr nonnull align 8 dereferenceable(24) %3, { ptr, i160 } %76, { ptr, i160 } %57, i32 %81) #7
  %195 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %196 = load ptr, ptr %11, align 8
  %197 = getelementptr i8, ptr %196, i64 %153
  store ptr @Entry, ptr %197, align 8
  %198 = getelementptr i8, ptr %197, i64 8
  %199 = ptrtoint ptr %result.i71.i599 to i64
  store i64 %199, ptr %198, align 4
  %.sroa_idx4.i600 = getelementptr i8, ptr %197, i64 24
  store i32 10, ptr %.sroa_idx4.i600, align 4
  %200 = icmp eq ptr %155, @nil_typ
  %201 = icmp eq ptr %155, null
  %202 = or i1 %200, %201
  br i1 %202, label %203, label %206

203:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit687
  %204 = load i32, ptr %17, align 4
  %205 = add i32 %204, 1
  store i32 %205, ptr %17, align 4
  br label %._crit_edge.sink.split.i617

206:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit687
  %207 = inttoptr i64 %157 to ptr
  %208 = inttoptr i64 %158 to ptr
  %hash_coef_ptr.i.i88.i601 = getelementptr i8, ptr %155, i64 8
  %tbl_size_ptr.i.i89.i602 = getelementptr i8, ptr %155, i64 16
  %offset_tbl_ptr.i.i90.i603 = getelementptr i8, ptr %155, i64 40
  %hash_coef.i.i91.i604 = load i64, ptr %hash_coef_ptr.i.i88.i601, align 4, !noalias !16
  %tbl_size.i.i92.i605 = load i64, ptr %tbl_size_ptr.i.i89.i602, align 4, !noalias !16
  %offset_tbl.i.i93.i606 = load ptr, ptr %offset_tbl_ptr.i.i90.i603, align 8, !noalias !16
  %product.i.i.i94.i607 = mul i64 %hash_coef.i.i91.i604, 4015701072841558310
  %shifted.i.i.i95.i608 = lshr i64 %product.i.i.i94.i607, 32
  %xored.i.i.i96.i609 = xor i64 %shifted.i.i.i95.i608, %product.i.i.i94.i607
  %hash.i.i.i97.i610 = and i64 %xored.i.i.i96.i609, %tbl_size.i.i92.i605
  %offset_ptr.i.i98.i611 = getelementptr i32, ptr %offset_tbl.i.i93.i606, i64 %hash.i.i.i97.i610
  %offset.i.i99.i612 = load i32, ptr %offset_ptr.i.i98.i611, align 4, !noalias !16
  %209 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %155, 0
  %210 = insertvalue { ptr, ptr, ptr, i32 } %209, ptr %207, 1
  %211 = insertvalue { ptr, ptr, ptr, i32 } %210, ptr %208, 2
  %212 = insertvalue { ptr, ptr, ptr, i32 } %211, i32 %offset.i.i99.i612, 3
  %213 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %214 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %155)
  %215 = sext i32 %offset.i.i99.i612 to i64
  %216 = getelementptr ptr, ptr %155, i64 %215
  %217 = getelementptr i8, ptr %216, i64 56
  %218 = load ptr, ptr %217, align 8
  %result.i101.i613 = call ptr %218({ ptr, ptr, ptr, i32 } %212, ptr nocapture nofree noundef nonnull readonly %2) #16
  %219 = call { ptr, i160 } %result.i101.i613({ ptr, ptr, ptr, i32 } %212, { ptr, ptr, ptr, i32 } %212, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i614 = extractvalue { ptr, i160 } %219, 0
  %220 = getelementptr i8, ptr %.fca.0.extract51.i614, i64 8
  %221 = getelementptr i8, ptr %.fca.0.extract51.i614, i64 16
  %222 = getelementptr i8, ptr %.fca.0.extract51.i614, i64 24
  %223 = getelementptr i8, ptr %.fca.0.extract51.i614, i64 32
  %224 = load i64, ptr %220, align 4
  %225 = load i64, ptr %221, align 4
  %226 = load ptr, ptr %222, align 8
  %227 = load ptr, ptr %223, align 8
  %result.i102.i615 = call i1 %226(i64 %225, i64 %224, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %227) #5
  br i1 %result.i102.i615, label %._crit_edge.sink.split.i617, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit619

._crit_edge.sink.split.i617:                      ; preds = %206, %203
  %.sink159.i618 = phi i64 [ 48, %203 ], [ 40, %206 ]
  %228 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %229 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i618
  %230 = load ptr, ptr %229, align 8
  %231 = load ptr, ptr %230, align 8
  %232 = call i32 %231(ptr nonnull %result.i150) #36
  %233 = add i32 %232, 1
  %234 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %235 = getelementptr i8, ptr %230, i64 8
  %236 = load ptr, ptr %235, align 8
  call void %236(ptr nonnull %result.i150, i32 %233) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit619

HashMap_insert_internal_keyK_valueV_hashPtri32.exit619: ; preds = %206, %._crit_edge.sink.split.i617
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %3)
  br label %._crit_edge.i492

._crit_edge.i492:                                 ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit619, %41, %.lr.ph.i491
  %237 = add nuw nsw i32 %.096.i, 1
  %238 = icmp slt i32 %237, %23
  br i1 %238, label %.lr.ph.i491, label %HashMap_resize_new_capacityPtri32.exit

HashMap_resize_new_capacityPtri32.exit:           ; preds = %._crit_edge.i492, %._crit_edge1.i377
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_ensure_capacity_required_loadPtri32.exit

HashMap_ensure_capacity_required_loadPtri32.exit: ; preds = %._crit_edge, %HashMap_resize_new_capacityPtri32.exit
  %239 = load ptr, ptr %9, align 8
  %240 = call i32 %239({ ptr, i160 } %21) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %241 = load ptr, ptr %result.i150, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %242 = load i32, ptr %12, align 8
  %243 = add i32 %242, -1
  %244 = and i32 %243, %240
  %245 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %246 = load ptr, ptr %11, align 8
  %247 = sext i32 %244 to i64
  %248 = shl nsw i64 %247, 5
  %249 = getelementptr i8, ptr %246, i64 %248
  %250 = load ptr, ptr %249, align 8
  %251 = icmp eq ptr %250, @nil_typ
  %252 = icmp eq ptr %250, null
  %253 = or i1 %251, %252
  br i1 %253, label %HashMap_find_slot_keyK_hashPtri32.exit529, label %.lr.ph.i506

.lr.ph.i506:                                      ; preds = %HashMap_ensure_capacity_required_loadPtri32.exit
  %254 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %255

255:                                              ; preds = %._crit_edge.thread.i521, %.lr.ph.i506
  %256 = phi i32 [ %244, %.lr.ph.i506 ], [ %298, %._crit_edge.thread.i521 ]
  %spec.store.select.i526548 = phi i32 [ -1, %.lr.ph.i506 ], [ %spec.store.select.i526, %._crit_edge.thread.i521 ]
  %257 = phi ptr [ %250, %.lr.ph.i506 ], [ %303, %._crit_edge.thread.i521 ]
  %258 = phi ptr [ %249, %.lr.ph.i506 ], [ %302, %._crit_edge.thread.i521 ]
  %.sroa_idx.i507 = getelementptr i8, ptr %258, i64 16
  %259 = load i64, ptr %.sroa_idx.i507, align 4
  %260 = getelementptr i8, ptr %258, i64 8
  %261 = load i64, ptr %260, align 4
  %262 = inttoptr i64 %261 to ptr
  %263 = inttoptr i64 %259 to ptr
  %hash_coef_ptr.i.i56.i508 = getelementptr i8, ptr %257, i64 8
  %tbl_size_ptr.i.i57.i509 = getelementptr i8, ptr %257, i64 16
  %offset_tbl_ptr.i.i58.i510 = getelementptr i8, ptr %257, i64 40
  %hash_coef.i.i59.i511 = load i64, ptr %hash_coef_ptr.i.i56.i508, align 4
  %tbl_size.i.i60.i512 = load i64, ptr %tbl_size_ptr.i.i57.i509, align 4
  %offset_tbl.i.i61.i513 = load ptr, ptr %offset_tbl_ptr.i.i58.i510, align 8
  %product.i.i.i62.i514 = mul i64 %hash_coef.i.i59.i511, 4015701072841558310
  %shifted.i.i.i63.i515 = lshr i64 %product.i.i.i62.i514, 32
  %xored.i.i.i64.i516 = xor i64 %shifted.i.i.i63.i515, %product.i.i.i62.i514
  %hash.i.i.i65.i517 = and i64 %xored.i.i.i64.i516, %tbl_size.i.i60.i512
  %offset_ptr.i.i66.i518 = getelementptr i32, ptr %offset_tbl.i.i61.i513, i64 %hash.i.i.i65.i517
  %offset.i.i67.i519 = load i32, ptr %offset_ptr.i.i66.i518, align 4
  %264 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %257, 0
  %265 = insertvalue { ptr, ptr, ptr, i32 } %264, ptr %262, 1
  %266 = insertvalue { ptr, ptr, ptr, i32 } %265, ptr %263, 2
  %267 = insertvalue { ptr, ptr, ptr, i32 } %266, i32 %offset.i.i67.i519, 3
  %268 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %257)
  %269 = sext i32 %offset.i.i67.i519 to i64
  %270 = getelementptr ptr, ptr %257, i64 %269
  %271 = getelementptr i8, ptr %270, i64 64
  %272 = load ptr, ptr %271, align 8
  %result.i.i520 = call ptr %272({ ptr, ptr, ptr, i32 } %267, ptr nocapture nofree noundef nonnull readonly %2) #16
  %273 = call i32 %result.i.i520({ ptr, ptr, ptr, i32 } %267, { ptr, ptr, ptr, i32 } %267, ptr nonnull align 8 %2) #7
  %274 = icmp eq i32 %273, %240
  br i1 %274, label %._crit_edge.i528, label %._crit_edge.thread.i521

._crit_edge.i528:                                 ; preds = %255
  %275 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %276 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %257)
  %277 = getelementptr i8, ptr %270, i64 48
  %278 = load ptr, ptr %277, align 8
  %result.i69.i = call ptr %278({ ptr, ptr, ptr, i32 } %267, ptr nocapture nofree noundef nonnull readonly %2) #16
  %279 = call { ptr, i160 } %result.i69.i({ ptr, ptr, ptr, i32 } %267, { ptr, ptr, ptr, i32 } %267, ptr nonnull align 8 %2) #7
  %280 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %281 = load ptr, ptr %10, align 8
  %282 = call i1 %281({ ptr, i160 } %279, { ptr, i160 } %21) #7
  br i1 %282, label %HashMap_find_slot_keyK_hashPtri32.exit529.loopexit, label %._crit_edge.thread.i521

._crit_edge.thread.i521:                          ; preds = %._crit_edge.i528, %255
  %283 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %284 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %257)
  %285 = getelementptr i8, ptr %270, i64 56
  %286 = load ptr, ptr %285, align 8
  %result.i70.i522 = call ptr %286({ ptr, ptr, ptr, i32 } %267, ptr nocapture nofree noundef nonnull readonly %2) #16
  %287 = call { ptr, i160 } %result.i70.i522({ ptr, ptr, ptr, i32 } %267, { ptr, ptr, ptr, i32 } %267, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i523 = extractvalue { ptr, i160 } %287, 0
  %288 = getelementptr i8, ptr %.fca.0.extract19.i523, i64 8
  %289 = getelementptr i8, ptr %.fca.0.extract19.i523, i64 16
  %290 = getelementptr i8, ptr %.fca.0.extract19.i523, i64 24
  %291 = getelementptr i8, ptr %.fca.0.extract19.i523, i64 32
  %292 = load i64, ptr %288, align 4
  %293 = load i64, ptr %289, align 4
  %294 = load ptr, ptr %290, align 8
  %295 = load ptr, ptr %291, align 8
  %result.i71.i524 = call i1 %294(i64 %293, i64 %292, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %295) #5
  %296 = icmp eq i32 %spec.store.select.i526548, -1
  %or.cond.i525 = select i1 %result.i71.i524, i1 %296, i1 false
  %spec.store.select.i526 = select i1 %or.cond.i525, i32 %256, i32 %spec.store.select.i526548
  %297 = add i32 %256, 1
  %298 = and i32 %297, %243
  %299 = load ptr, ptr %11, align 8
  %300 = sext i32 %298 to i64
  %301 = shl nsw i64 %300, 5
  %302 = getelementptr i8, ptr %299, i64 %301
  %303 = load ptr, ptr %302, align 8
  %304 = icmp eq ptr %303, @nil_typ
  %305 = icmp eq ptr %303, null
  %306 = or i1 %304, %305
  br i1 %306, label %._crit_edge105.loopexit.i527, label %255

._crit_edge105.loopexit.i527:                     ; preds = %._crit_edge.thread.i521
  %307 = icmp eq i32 %spec.store.select.i526, -1
  %.pre.i.pre562 = select i1 %307, i32 %298, i32 %spec.store.select.i526
  br label %HashMap_find_slot_keyK_hashPtri32.exit529

HashMap_find_slot_keyK_hashPtri32.exit529.loopexit: ; preds = %._crit_edge.i528
  %.pre587 = load ptr, ptr %11, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit529

HashMap_find_slot_keyK_hashPtri32.exit529:        ; preds = %HashMap_find_slot_keyK_hashPtri32.exit529.loopexit, %HashMap_ensure_capacity_required_loadPtri32.exit, %._crit_edge105.loopexit.i527
  %308 = phi ptr [ %299, %._crit_edge105.loopexit.i527 ], [ %246, %HashMap_ensure_capacity_required_loadPtri32.exit ], [ %.pre587, %HashMap_find_slot_keyK_hashPtri32.exit529.loopexit ]
  %309 = phi i32 [ %.pre.i.pre562, %._crit_edge105.loopexit.i527 ], [ %244, %HashMap_ensure_capacity_required_loadPtri32.exit ], [ %256, %HashMap_find_slot_keyK_hashPtri32.exit529.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %310 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %311 = sext i32 %309 to i64
  %312 = shl nsw i64 %311, 5
  %313 = getelementptr i8, ptr %308, i64 %312
  %314 = load ptr, ptr %313, align 8
  %315 = getelementptr i8, ptr %313, i64 8
  %316 = load i64, ptr %315, align 4
  %.sroa_idx.i394 = getelementptr i8, ptr %313, i64 16
  %317 = load i64, ptr %.sroa_idx.i394, align 4
  %318 = load ptr, ptr %4, align 8
  %319 = load ptr, ptr %241, align 8, !alias.scope !19
  %320 = getelementptr i8, ptr %319, i64 72
  %321 = load ptr, ptr %320, align 8, !alias.scope !19
  %result.i.i.i = call { i64, i64 } %321(ptr nocapture nofree nonnull readonly %241) #5, !alias.scope !19
  %322 = extractvalue { i64, i64 } %result.i.i.i, 0
  %323 = extractvalue { i64, i64 } %result.i.i.i, 1
  %324 = call i64 @llvm.umax.i64(i64 %323, i64 8)
  %325 = urem i64 20, %323
  %326 = icmp eq i64 %325, 0
  %327 = sub i64 %323, %325
  %328 = select i1 %326, i64 0, i64 %327
  %329 = add i64 %322, 20
  %330 = add i64 %329, %328
  %331 = and i64 %330, 7
  %332 = icmp eq i64 %331, 0
  %333 = sub nuw nsw i64 40, %331
  %334 = select i1 %332, i64 32, i64 %333
  %335 = add i64 %334, %330
  %336 = urem i64 %335, %324
  %337 = icmp eq i64 %336, 0
  %338 = sub i64 %324, %336
  %339 = select i1 %337, i64 0, i64 %338
  %340 = add i64 %335, %339
  %result.i71.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %340, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %241, ptr %result.i71.i, align 8
  %341 = getelementptr inbounds i8, ptr %result.i71.i, i64 8
  store ptr %318, ptr %341, align 8
  %342 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i)
  %343 = load ptr, ptr %241, align 8
  %344 = getelementptr i8, ptr %343, i64 72
  %345 = load ptr, ptr %344, align 8
  %result.i.i572 = call { i64, i64 } %345(ptr nocapture nofree nonnull readonly %241) #5
  %346 = extractvalue { i64, i64 } %result.i.i572, 1
  %347 = urem i64 20, %346
  %348 = icmp eq i64 %347, 0
  %reass.sub = sub i64 %346, %347
  %349 = add i64 %reass.sub, 20
  %350 = select i1 %348, i64 20, i64 %349
  %351 = getelementptr i8, ptr %result.i71.i, i64 %350
  %352 = getelementptr i8, ptr %343, i64 64
  %353 = load ptr, ptr %352, align 8
  call void %353({ ptr, i160 } %21, ptr nocapture nofree nonnull readonly %241, ptr nocapture nofree writeonly %351) #13
  %354 = load ptr, ptr %result.i71.i, align 8
  %355 = load ptr, ptr %354, align 8
  %356 = getelementptr i8, ptr %355, i64 72
  %357 = load ptr, ptr %356, align 8
  %result.i.i573 = call { i64, i64 } %357(ptr nocapture nofree nonnull readonly %354) #5
  %358 = extractvalue { i64, i64 } %result.i.i573, 0
  %359 = extractvalue { i64, i64 } %result.i.i573, 1
  %360 = urem i64 20, %359
  %361 = icmp eq i64 %360, 0
  %362 = sub i64 %359, %360
  %363 = select i1 %361, i64 0, i64 %362
  %364 = add i64 %358, 20
  %365 = add i64 %364, %363
  %366 = and i64 %365, 7
  %367 = icmp eq i64 %366, 0
  %368 = sub nuw nsw i64 8, %366
  %369 = select i1 %367, i64 0, i64 %368
  %370 = getelementptr i8, ptr %result.i71.i, i64 %365
  %371 = getelementptr i8, ptr %370, i64 %369
  store ptr @i32_typ, ptr %371, align 8
  %372 = getelementptr i8, ptr %371, i64 8
  store i160 %.sroa.0128.0.insert.ext, ptr %372, align 4
  %373 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @Entry) #34
  %374 = getelementptr inbounds i8, ptr %result.i71.i, i64 16
  store i32 %240, ptr %374, align 8
  %375 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  store ptr @Entry, ptr %313, align 8
  %376 = ptrtoint ptr %result.i71.i to i64
  store i64 %376, ptr %315, align 4
  %.sroa_idx4.i = getelementptr i8, ptr %313, i64 24
  store i32 10, ptr %.sroa_idx4.i, align 4
  %377 = icmp eq ptr %314, @nil_typ
  %378 = icmp eq ptr %314, null
  %379 = or i1 %377, %378
  br i1 %379, label %380, label %383

380:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit529
  %381 = load i32, ptr %17, align 4
  %382 = add i32 %381, 1
  store i32 %382, ptr %17, align 4
  br label %._crit_edge.sink.split.i

383:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit529
  %384 = inttoptr i64 %316 to ptr
  %385 = inttoptr i64 %317 to ptr
  %hash_coef_ptr.i.i88.i = getelementptr i8, ptr %314, i64 8
  %tbl_size_ptr.i.i89.i = getelementptr i8, ptr %314, i64 16
  %offset_tbl_ptr.i.i90.i = getelementptr i8, ptr %314, i64 40
  %hash_coef.i.i91.i = load i64, ptr %hash_coef_ptr.i.i88.i, align 4, !noalias !22
  %tbl_size.i.i92.i = load i64, ptr %tbl_size_ptr.i.i89.i, align 4, !noalias !22
  %offset_tbl.i.i93.i = load ptr, ptr %offset_tbl_ptr.i.i90.i, align 8, !noalias !22
  %product.i.i.i94.i = mul i64 %hash_coef.i.i91.i, 4015701072841558310
  %shifted.i.i.i95.i = lshr i64 %product.i.i.i94.i, 32
  %xored.i.i.i96.i = xor i64 %shifted.i.i.i95.i, %product.i.i.i94.i
  %hash.i.i.i97.i = and i64 %xored.i.i.i96.i, %tbl_size.i.i92.i
  %offset_ptr.i.i98.i = getelementptr i32, ptr %offset_tbl.i.i93.i, i64 %hash.i.i.i97.i
  %offset.i.i99.i = load i32, ptr %offset_ptr.i.i98.i, align 4, !noalias !22
  %386 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %314, 0
  %387 = insertvalue { ptr, ptr, ptr, i32 } %386, ptr %384, 1
  %388 = insertvalue { ptr, ptr, ptr, i32 } %387, ptr %385, 2
  %389 = insertvalue { ptr, ptr, ptr, i32 } %388, i32 %offset.i.i99.i, 3
  %390 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %391 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %314)
  %392 = sext i32 %offset.i.i99.i to i64
  %393 = getelementptr ptr, ptr %314, i64 %392
  %394 = getelementptr i8, ptr %393, i64 56
  %395 = load ptr, ptr %394, align 8
  %result.i101.i = call ptr %395({ ptr, ptr, ptr, i32 } %389, ptr nocapture nofree noundef nonnull readonly %2) #16
  %396 = call { ptr, i160 } %result.i101.i({ ptr, ptr, ptr, i32 } %389, { ptr, ptr, ptr, i32 } %389, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i396 = extractvalue { ptr, i160 } %396, 0
  %397 = getelementptr i8, ptr %.fca.0.extract51.i396, i64 8
  %398 = getelementptr i8, ptr %.fca.0.extract51.i396, i64 16
  %399 = getelementptr i8, ptr %.fca.0.extract51.i396, i64 24
  %400 = getelementptr i8, ptr %.fca.0.extract51.i396, i64 32
  %401 = load i64, ptr %397, align 4
  %402 = load i64, ptr %398, align 4
  %403 = load ptr, ptr %399, align 8
  %404 = load ptr, ptr %400, align 8
  %result.i102.i = call i1 %403(i64 %402, i64 %401, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %404) #5
  br i1 %result.i102.i, label %._crit_edge.sink.split.i, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit

._crit_edge.sink.split.i:                         ; preds = %383, %380
  %.sink159.i = phi i64 [ 48, %380 ], [ 40, %383 ]
  %405 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %406 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i
  %407 = load ptr, ptr %406, align 8
  %408 = load ptr, ptr %407, align 8
  %409 = call i32 %408(ptr nonnull %result.i150) #36
  %410 = add i32 %409, 1
  %411 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %412 = getelementptr i8, ptr %407, i64 8
  %413 = load ptr, ptr %412, align 8
  call void %413(ptr nonnull %result.i150, i32 %410) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit

HashMap_insert_internal_keyK_valueV_hashPtri32.exit: ; preds = %383, %._crit_edge.sink.split.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %414 = icmp slt i32 %20, %0
  br i1 %414, label %._crit_edge, label %._crit_edge2

._crit_edge2:                                     ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit
  %415 = call i64 @clock()
  %416 = add nsw i32 %0, -1
  %.sroa.0117.0.insert.ext = zext nneg i32 %416 to i160
  %417 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0117.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %418 = load ptr, ptr %9, align 8
  %419 = call i32 %418({ ptr, i160 } %417) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %420 = load i32, ptr %12, align 8
  %421 = add i32 %420, -1
  %422 = and i32 %421, %419
  %423 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %424 = load ptr, ptr %11, align 8
  %425 = sext i32 %422 to i64
  %426 = shl nsw i64 %425, 5
  %427 = getelementptr i8, ptr %424, i64 %426
  %428 = load ptr, ptr %427, align 8
  %429 = icmp eq ptr %428, @nil_typ
  %430 = icmp eq ptr %428, null
  %431 = or i1 %429, %430
  br i1 %431, label %HashMap_find_slot_keyK_hashPtri32.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %._crit_edge2
  %432 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %433

433:                                              ; preds = %._crit_edge.thread.i, %.lr.ph.i
  %434 = phi i32 [ %422, %.lr.ph.i ], [ %476, %._crit_edge.thread.i ]
  %spec.store.select.i469 = phi i32 [ -1, %.lr.ph.i ], [ %spec.store.select.i, %._crit_edge.thread.i ]
  %435 = phi ptr [ %428, %.lr.ph.i ], [ %481, %._crit_edge.thread.i ]
  %436 = phi ptr [ %427, %.lr.ph.i ], [ %480, %._crit_edge.thread.i ]
  %.sroa_idx.i410 = getelementptr i8, ptr %436, i64 16
  %437 = load i64, ptr %.sroa_idx.i410, align 4
  %438 = getelementptr i8, ptr %436, i64 8
  %439 = load i64, ptr %438, align 4
  %440 = inttoptr i64 %439 to ptr
  %441 = inttoptr i64 %437 to ptr
  %hash_coef_ptr.i.i56.i = getelementptr i8, ptr %435, i64 8
  %tbl_size_ptr.i.i57.i = getelementptr i8, ptr %435, i64 16
  %offset_tbl_ptr.i.i58.i = getelementptr i8, ptr %435, i64 40
  %hash_coef.i.i59.i = load i64, ptr %hash_coef_ptr.i.i56.i, align 4
  %tbl_size.i.i60.i = load i64, ptr %tbl_size_ptr.i.i57.i, align 4
  %offset_tbl.i.i61.i = load ptr, ptr %offset_tbl_ptr.i.i58.i, align 8
  %product.i.i.i62.i = mul i64 %hash_coef.i.i59.i, 4015701072841558310
  %shifted.i.i.i63.i = lshr i64 %product.i.i.i62.i, 32
  %xored.i.i.i64.i = xor i64 %shifted.i.i.i63.i, %product.i.i.i62.i
  %hash.i.i.i65.i = and i64 %xored.i.i.i64.i, %tbl_size.i.i60.i
  %offset_ptr.i.i66.i = getelementptr i32, ptr %offset_tbl.i.i61.i, i64 %hash.i.i.i65.i
  %offset.i.i67.i = load i32, ptr %offset_ptr.i.i66.i, align 4
  %442 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %435, 0
  %443 = insertvalue { ptr, ptr, ptr, i32 } %442, ptr %440, 1
  %444 = insertvalue { ptr, ptr, ptr, i32 } %443, ptr %441, 2
  %445 = insertvalue { ptr, ptr, ptr, i32 } %444, i32 %offset.i.i67.i, 3
  %446 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %435)
  %447 = sext i32 %offset.i.i67.i to i64
  %448 = getelementptr ptr, ptr %435, i64 %447
  %449 = getelementptr i8, ptr %448, i64 64
  %450 = load ptr, ptr %449, align 8
  %result.i.i411 = call ptr %450({ ptr, ptr, ptr, i32 } %445, ptr nocapture nofree noundef nonnull readonly %2) #16
  %451 = call i32 %result.i.i411({ ptr, ptr, ptr, i32 } %445, { ptr, ptr, ptr, i32 } %445, ptr nonnull align 8 %2) #7
  %452 = icmp eq i32 %451, %419
  br i1 %452, label %._crit_edge.i413, label %._crit_edge.thread.i

._crit_edge.i413:                                 ; preds = %433
  %453 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %454 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %435)
  %455 = getelementptr i8, ptr %448, i64 48
  %456 = load ptr, ptr %455, align 8
  %result.i69.i414 = call ptr %456({ ptr, ptr, ptr, i32 } %445, ptr nocapture nofree noundef nonnull readonly %2) #16
  %457 = call { ptr, i160 } %result.i69.i414({ ptr, ptr, ptr, i32 } %445, { ptr, ptr, ptr, i32 } %445, ptr nonnull align 8 %2) #7
  %458 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %459 = load ptr, ptr %10, align 8
  %460 = call i1 %459({ ptr, i160 } %457, { ptr, i160 } %417) #7
  br i1 %460, label %HashMap_find_slot_keyK_hashPtri32.exit.loopexit, label %._crit_edge.thread.i

._crit_edge.thread.i:                             ; preds = %._crit_edge.i413, %433
  %461 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %462 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %435)
  %463 = getelementptr i8, ptr %448, i64 56
  %464 = load ptr, ptr %463, align 8
  %result.i70.i = call ptr %464({ ptr, ptr, ptr, i32 } %445, ptr nocapture nofree noundef nonnull readonly %2) #16
  %465 = call { ptr, i160 } %result.i70.i({ ptr, ptr, ptr, i32 } %445, { ptr, ptr, ptr, i32 } %445, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i = extractvalue { ptr, i160 } %465, 0
  %466 = getelementptr i8, ptr %.fca.0.extract19.i, i64 8
  %467 = getelementptr i8, ptr %.fca.0.extract19.i, i64 16
  %468 = getelementptr i8, ptr %.fca.0.extract19.i, i64 24
  %469 = getelementptr i8, ptr %.fca.0.extract19.i, i64 32
  %470 = load i64, ptr %466, align 4
  %471 = load i64, ptr %467, align 4
  %472 = load ptr, ptr %468, align 8
  %473 = load ptr, ptr %469, align 8
  %result.i71.i412 = call i1 %472(i64 %471, i64 %470, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %473) #5
  %474 = icmp eq i32 %spec.store.select.i469, -1
  %or.cond.i = select i1 %result.i71.i412, i1 %474, i1 false
  %spec.store.select.i = select i1 %or.cond.i, i32 %434, i32 %spec.store.select.i469
  %475 = add i32 %434, 1
  %476 = and i32 %475, %421
  %477 = load ptr, ptr %11, align 8
  %478 = sext i32 %476 to i64
  %479 = shl nsw i64 %478, 5
  %480 = getelementptr i8, ptr %477, i64 %479
  %481 = load ptr, ptr %480, align 8
  %482 = icmp eq ptr %481, @nil_typ
  %483 = icmp eq ptr %481, null
  %484 = or i1 %482, %483
  br i1 %484, label %._crit_edge105.loopexit.i, label %433

._crit_edge105.loopexit.i:                        ; preds = %._crit_edge.thread.i
  %485 = icmp eq i32 %spec.store.select.i, -1
  %.pre.i.pre = select i1 %485, i32 %476, i32 %spec.store.select.i
  br label %HashMap_find_slot_keyK_hashPtri32.exit

HashMap_find_slot_keyK_hashPtri32.exit.loopexit:  ; preds = %._crit_edge.i413
  %.pre = load ptr, ptr %11, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit

HashMap_find_slot_keyK_hashPtri32.exit:           ; preds = %HashMap_find_slot_keyK_hashPtri32.exit.loopexit, %._crit_edge2, %._crit_edge105.loopexit.i
  %486 = phi ptr [ %477, %._crit_edge105.loopexit.i ], [ %424, %._crit_edge2 ], [ %.pre, %HashMap_find_slot_keyK_hashPtri32.exit.loopexit ]
  %487 = phi i32 [ %.pre.i.pre, %._crit_edge105.loopexit.i ], [ %422, %._crit_edge2 ], [ %434, %HashMap_find_slot_keyK_hashPtri32.exit.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %488 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %489 = sext i32 %487 to i64
  %490 = shl nsw i64 %489, 5
  %491 = getelementptr i8, ptr %486, i64 %490
  %492 = load ptr, ptr %491, align 8
  %493 = icmp ne ptr %492, @nil_typ
  %494 = icmp ne ptr %492, null
  %.not57.i = and i1 %493, %494
  br i1 %.not57.i, label %495, label %HashMap_get_keyK.exit.thread

495:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit
  %496 = getelementptr i8, ptr %491, i64 8
  %497 = load i64, ptr %496, align 4
  %.sroa_idx.i = getelementptr i8, ptr %491, i64 16
  %498 = load i64, ptr %.sroa_idx.i, align 4
  %499 = inttoptr i64 %497 to ptr
  %500 = inttoptr i64 %498 to ptr
  %hash_coef_ptr.i.i60.i = getelementptr i8, ptr %492, i64 8
  %tbl_size_ptr.i.i61.i = getelementptr i8, ptr %492, i64 16
  %offset_tbl_ptr.i.i62.i = getelementptr i8, ptr %492, i64 40
  %hash_coef.i.i63.i = load i64, ptr %hash_coef_ptr.i.i60.i, align 4, !noalias !25
  %tbl_size.i.i64.i = load i64, ptr %tbl_size_ptr.i.i61.i, align 4, !noalias !25
  %offset_tbl.i.i65.i = load ptr, ptr %offset_tbl_ptr.i.i62.i, align 8, !noalias !25
  %product.i.i.i66.i = mul i64 %hash_coef.i.i63.i, 4015701072841558310
  %shifted.i.i.i67.i = lshr i64 %product.i.i.i66.i, 32
  %xored.i.i.i68.i = xor i64 %shifted.i.i.i67.i, %product.i.i.i66.i
  %hash.i.i.i69.i = and i64 %xored.i.i.i68.i, %tbl_size.i.i64.i
  %offset_ptr.i.i70.i = getelementptr i32, ptr %offset_tbl.i.i65.i, i64 %hash.i.i.i69.i
  %offset.i.i71.i = load i32, ptr %offset_ptr.i.i70.i, align 4, !noalias !25
  %501 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %492, 0
  %502 = insertvalue { ptr, ptr, ptr, i32 } %501, ptr %499, 1
  %503 = insertvalue { ptr, ptr, ptr, i32 } %502, ptr %500, 2
  %504 = insertvalue { ptr, ptr, ptr, i32 } %503, i32 %offset.i.i71.i, 3
  %505 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %506 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %492)
  %507 = sext i32 %offset.i.i71.i to i64
  %508 = getelementptr ptr, ptr %492, i64 %507
  %509 = getelementptr i8, ptr %508, i64 56
  %510 = load ptr, ptr %509, align 8
  %result.i73.i = call ptr %510({ ptr, ptr, ptr, i32 } %504, ptr nocapture nofree noundef nonnull readonly %2) #16
  %511 = call { ptr, i160 } %result.i73.i({ ptr, ptr, ptr, i32 } %504, { ptr, ptr, ptr, i32 } %504, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i = extractvalue { ptr, i160 } %511, 0
  %.fca.1.extract52.i = extractvalue { ptr, i160 } %511, 1
  %512 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %513 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %492)
  %514 = getelementptr i8, ptr %508, i64 64
  %515 = load ptr, ptr %514, align 8
  %result.i74.i = call ptr %515({ ptr, ptr, ptr, i32 } %504, ptr nocapture nofree noundef nonnull readonly %2) #16
  %516 = call i32 %result.i74.i({ ptr, ptr, ptr, i32 } %504, { ptr, ptr, ptr, i32 } %504, ptr nonnull align 8 %2) #7
  %517 = icmp eq i32 %516, %419
  br i1 %517, label %._crit_edge.i, label %HashMap_get_keyK.exit.thread

._crit_edge.i:                                    ; preds = %495
  %518 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %519 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %492)
  %520 = getelementptr i8, ptr %508, i64 48
  %521 = load ptr, ptr %520, align 8
  %result.i75.i = call ptr %521({ ptr, ptr, ptr, i32 } %504, ptr nocapture nofree noundef nonnull readonly %2) #16
  %522 = call { ptr, i160 } %result.i75.i({ ptr, ptr, ptr, i32 } %504, { ptr, ptr, ptr, i32 } %504, ptr nonnull align 8 %2) #7
  %523 = load ptr, ptr %10, align 8
  %524 = call i1 %523({ ptr, i160 } %522, { ptr, i160 } %417) #7
  br i1 %524, label %HashMap_get_keyK.exit, label %HashMap_get_keyK.exit.thread

HashMap_get_keyK.exit.thread:                     ; preds = %HashMap_find_slot_keyK_hashPtri32.exit, %495, %._crit_edge.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %._crit_edge4

HashMap_get_keyK.exit:                            ; preds = %._crit_edge.i
  %525 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %526 = load ptr, ptr %4, align 8
  %527 = load ptr, ptr %526, align 8
  %528 = ptrtoint ptr %527 to i64
  %529 = getelementptr i8, ptr %.fca.0.extract51.i, i64 8
  %530 = getelementptr i8, ptr %.fca.0.extract51.i, i64 16
  %531 = getelementptr i8, ptr %.fca.0.extract51.i, i64 24
  %532 = getelementptr i8, ptr %.fca.0.extract51.i, i64 32
  %533 = load i64, ptr %529, align 4
  %534 = load i64, ptr %530, align 4
  %535 = load ptr, ptr %531, align 8
  %536 = load ptr, ptr %532, align 8
  %537 = load i64, ptr %527, align 4
  %result.i77.i = call i1 %535(i64 %534, i64 %533, i64 %537, i64 %528, ptr readonly %536) #5
  %cond.fr.i = freeze i1 %result.i77.i
  %spec.select.i = select i1 %cond.fr.i, ptr %.fca.0.extract51.i, ptr @nil_typ
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %538 = icmp ne ptr %spec.select.i, @nil_typ
  %539 = icmp ne ptr %spec.select.i, null
  %.not143 = and i1 %538, %539
  br i1 %.not143, label %._crit_edge3, label %._crit_edge4

._crit_edge3:                                     ; preds = %HashMap_get_keyK.exit
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract52.i to i32
  %.not147 = icmp eq i32 %0, %.sroa.2.8.extract.trunc
  br label %._crit_edge4

._crit_edge4:                                     ; preds = %HashMap_get_keyK.exit.thread, %HashMap_get_keyK.exit, %._crit_edge3
  %.2 = phi i1 [ %.not147, %._crit_edge3 ], [ false, %HashMap_get_keyK.exit ], [ false, %HashMap_get_keyK.exit.thread ]
  %540 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %541 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #34
  %542 = load i32, ptr %17, align 4
  %.not148 = icmp eq i32 %542, %0
  %543 = select i1 %.not148, i1 %.2, i1 false
  %544 = select i1 %543, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %545 = bitcast <4 x i8> %544 to i32
  br label %._crit_edge.lr.ph.i

546:                                              ; preds = %1
  %547 = call i64 @clock()
  %548 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %549 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #34
  br label %._crit_edge.lr.ph.i

._crit_edge.lr.ph.i:                              ; preds = %546, %._crit_edge4
  %550 = phi i64 [ %415, %._crit_edge4 ], [ %547, %546 ]
  %.reg2mem15.0.in = phi i32 [ %545, %._crit_edge4 ], [ 1397965136, %546 ]
  %result.i162 = call noalias align 32 dereferenceable_or_null(18) ptr @bump_malloc_inner(i64 noundef 18, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <17 x i8> <i8 73, i8 110, i8 115, i8 101, i8 114, i8 116, i8 32, i8 83, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108>, ptr %result.i162, align 32
  %551 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #34
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %552 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %553 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i428 = call noalias dereferenceable_or_null(18) ptr @bump_malloc_inner(i64 noundef 18, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(17) %result.i.i428, ptr noundef nonnull align 32 dereferenceable(17) %result.i162, i64 17, i1 false)
  %554 = sub i64 %550, %14
  %555 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %556 = getelementptr i8, ptr %result.i.i428, i64 17
  store i8 0, ptr %556, align 1
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i428)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i97.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i97.i, align 16
  %result.i.i375.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i375.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i97.i, i64 14, i1 false)
  %puts.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i375.i)
  %557 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %0) #17
  %result.i103.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i103.i, align 16
  %result.i.i389.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i389.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i103.i, i64 14, i1 false)
  %puts.i313.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i389.i)
  %558 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %554) #17
  %result.i109.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i109.i, align 4
  %result.i.i408.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i408.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i109.i, i64 3, i1 false)
  %puts.i333.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i408.i)
  br i1 %15, label %._crit_edge1.i, label %._crit_edge.lr.ph.i444

._crit_edge1.i:                                   ; preds = %._crit_edge.lr.ph.i
  %559 = icmp sgt i64 %554, 0
  br i1 %559, label %560, label %._crit_edge.lr.ph.i428.i

560:                                              ; preds = %._crit_edge1.i
  %561 = zext nneg i32 %0 to i64
  %562 = mul i64 %554, 1000000
  %563 = sdiv i64 %562, %561
  br label %._crit_edge.lr.ph.i428.i

._crit_edge.lr.ph.i428.i:                         ; preds = %560, %._crit_edge1.i
  %.0.i = phi i64 [ %563, %560 ], [ 0, %._crit_edge1.i ]
  %result.i114.i = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i114.i, align 16
  %result.i.i427.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i427.i, ptr noundef nonnull align 16 dereferenceable(15) %result.i114.i, i64 15, i1 false)
  %puts.i353.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i427.i)
  %564 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0.i) #17
  %result.i120.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i120.i, align 4
  %565 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %result.i.i446.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i446.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i120.i, i64 3, i1 false)
  %566 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %puts.i373.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i446.i)
  br label %._crit_edge.lr.ph.i444

._crit_edge.lr.ph.i444:                           ; preds = %._crit_edge.lr.ph.i, %._crit_edge.lr.ph.i428.i
  %result.i166 = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i166, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %567 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %568 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i443 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i443, ptr noundef nonnull align 32 dereferenceable(18) %result.i166, i64 18, i1 false)
  %569 = getelementptr i8, ptr %result.i.i443, i64 18
  store i8 0, ptr %569, align 1
  %puts.i350 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i443)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %570 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %571 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %572 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i462 = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store i32 %.reg2mem15.0.in, ptr %result.i.i462, align 1
  %573 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %574 = getelementptr i8, ptr %result.i.i462, i64 4
  store i8 0, ptr %574, align 1
  %puts.i370 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i462)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  ret void
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.init.trampoline(ptr nocapture writeonly, ptr readnone, ptr readnone) #4

declare i64 @clock() local_unnamed_addr

define void @benchmark_insert_random(i32 %0) local_unnamed_addr {
  %2 = alloca [0 x ptr], align 8
  %3 = alloca [3 x ptr], align 8
  %4 = alloca [3 x ptr], align 8
  %oldProtect.i317 = alloca i32, align 4
  %oldProtect.i313 = alloca i32, align 4
  %oldProtect.i272 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %.sroa.0231.sroa.0 = alloca i8, align 8
  %result.i268 = tail call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i268, align 8
  %5 = getelementptr inbounds i8, ptr %result.i268, i64 8
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %result.i268, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %6, align 8
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i268) #38
  %result.i269 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i)
  %result.i270 = call i32 @VirtualProtect(ptr nofree %result.i269, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i269, ptr noalias nofree noundef nonnull readnone @zqowobcfpb, ptr noalias nofree noundef nonnull readnone @i32_hasher) #38
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i269) #39
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i269) #38
  %result.i271 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i272)
  %result.i273 = call i32 @VirtualProtect(ptr nofree %result.i271, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i272) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i272)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i271, ptr noalias nofree noundef nonnull readnone @xnsyrjqygq, ptr noalias nofree noundef nonnull readnone @i32_eq) #38
  %ret.i274 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i271) #39
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i271) #38
  %10 = getelementptr inbounds i8, ptr %result.i268, i64 48
  store ptr %ret.i, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %result.i268, i64 56
  store ptr %ret.i274, ptr %11, align 8
  %result.i.i = call noalias dereferenceable_or_null(512) ptr @bump_malloc_inner(i64 noundef 512, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %12 = getelementptr inbounds i8, ptr %result.i268, i64 24
  store ptr %result.i.i, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %result.i268, i64 32
  store i32 16, ptr %13, align 8
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #34
  %15 = sext i32 %0 to i64
  %16 = shl nsw i64 %15, 2
  %result.i4.i = call noalias ptr @bump_malloc_inner(i64 noundef %16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #34
  %result.i311 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i311, align 8
  %18 = getelementptr inbounds i8, ptr %result.i311, i64 8
  store ptr @_parameterization_Ptri1, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %result.i311, i64 16
  store ptr @_parameterization_PairPtri32._Ptri1, ptr %19, align 8
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i311)
  %result.i312 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i313)
  %result.i314 = call i32 @VirtualProtect(ptr nofree %result.i312, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i313) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i313)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i312, ptr noalias nofree noundef nonnull readnone @appmrwvncp, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %ret.i315 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i312) #39
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i312)
  %result.i316 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i317)
  %result.i318 = call i32 @VirtualProtect(ptr nofree %result.i316, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i317) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i317)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i316, ptr noalias nofree noundef nonnull readnone @rqipwqtmqq, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %ret.i319 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i316) #39
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i316)
  %23 = getelementptr inbounds i8, ptr %result.i311, i64 48
  store ptr %ret.i315, ptr %23, align 8
  %24 = getelementptr inbounds i8, ptr %result.i311, i64 56
  store ptr %ret.i319, ptr %24, align 8
  %result.i.i514 = call noalias dereferenceable_or_null(512) ptr @bump_malloc_inner(i64 noundef 512, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %25 = getelementptr inbounds i8, ptr %result.i311, i64 24
  store ptr %result.i.i514, ptr %25, align 8
  %26 = getelementptr inbounds i8, ptr %result.i311, i64 32
  store i32 16, ptr %26, align 8
  %27 = icmp sgt i32 %0, 0
  br i1 %27, label %._crit_edge.lr.ph, label %._crit_edge2._crit_edge.thread

._crit_edge2._crit_edge.thread:                   ; preds = %1
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #34
  %30 = call i64 @clock()
  %31 = call i64 @clock()
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #34
  br label %._crit_edge.lr.ph.i

._crit_edge.lr.ph:                                ; preds = %1
  %34 = add nsw i32 %0, -1
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %36 = getelementptr inbounds i8, ptr %result.i311, i64 40
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #34
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  %39 = getelementptr inbounds i8, ptr %result.i311, i64 36
  %40 = getelementptr inbounds i8, ptr %4, i64 8
  %41 = getelementptr inbounds i8, ptr %4, i64 16
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph, %HashMap_insert_internal_keyK_valueV_hashPtri32.exit
  %42 = phi i32 [ 123, %._crit_edge.lr.ph ], [ %45, %HashMap_insert_internal_keyK_valueV_hashPtri32.exit ]
  %.0473 = phi i32 [ -1, %._crit_edge.lr.ph ], [ %spec.select, %HashMap_insert_internal_keyK_valueV_hashPtri32.exit ]
  %.0247472 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %443, %HashMap_insert_internal_keyK_valueV_hashPtri32.exit ]
  %43 = mul i32 %42, 1103515245
  %44 = add i32 %43, 12345
  %45 = and i32 %44, 2147483647
  %.sroa.0241.0.insert.ext = zext nneg i32 %45 to i160
  %46 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0241.0.insert.ext, 1
  %47 = zext nneg i32 %.0247472 to i64
  %48 = shl nuw nsw i64 %47, 2
  %49 = getelementptr i8, ptr %result.i4.i, i64 %48
  store i32 %45, ptr %49, align 1
  %50 = icmp eq i32 %.0247472, %34
  %spec.select = select i1 %50, i32 %45, i32 %.0473
  store i1 true, ptr %.sroa.0231.sroa.0, align 8
  %.sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.0. = load i8, ptr %.sroa.0231.sroa.0, align 8
  %.sroa.0231.0.insert.ext = zext i8 %.sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.0. to i160
  %51 = load i32, ptr %36, align 8
  %52 = load i32, ptr %26, align 8
  %53 = icmp eq i32 %52, 0
  %54 = mul i32 %51, 10
  %55 = add i32 %54, 10
  %56 = mul i32 %52, 6
  %57 = icmp sge i32 %55, %56
  %.0.i814 = select i1 %53, i1 true, i1 %57
  br i1 %.0.i814, label %._crit_edge1.i816, label %HashMap_ensure_capacity_required_loadPtri32.exit

._crit_edge1.i816:                                ; preds = %._crit_edge
  %58 = shl i32 %52, 1
  %spec.select.i817 = call i32 @llvm.smax.i32(i32 %58, i32 16)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %59 = load ptr, ptr %25, align 8
  %60 = zext nneg i32 %spec.select.i817 to i64
  %61 = shl nuw nsw i64 %60, 5
  %result.i.i1034 = call noalias ptr @bump_malloc_inner(i64 noundef %61, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1034, ptr %25, align 8
  store i32 %spec.select.i817, ptr %26, align 8
  store i32 0, ptr %39, align 4
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #38
  store i32 0, ptr %36, align 8
  %63 = icmp sgt i32 %52, 0
  br i1 %63, label %.lr.ph.i1035, label %HashMap_resize_new_capacityPtri32.exit

.lr.ph.i1035:                                     ; preds = %._crit_edge1.i816, %._crit_edge.i1036
  %.096.i = phi i32 [ %266, %._crit_edge.i1036 ], [ 0, %._crit_edge1.i816 ]
  %64 = zext nneg i32 %.096.i to i64
  %65 = shl nuw nsw i64 %64, 5
  %66 = getelementptr i8, ptr %59, i64 %65
  %67 = load ptr, ptr %66, align 8
  %68 = icmp ne ptr %67, @nil_typ
  %69 = icmp ne ptr %67, null
  %.not40.i = and i1 %68, %69
  br i1 %.not40.i, label %70, label %._crit_edge.i1036

70:                                               ; preds = %.lr.ph.i1035
  %71 = getelementptr i8, ptr %66, i64 8
  %72 = load i64, ptr %71, align 4
  %.sroa_idx.i1037 = getelementptr i8, ptr %66, i64 16
  %73 = load i64, ptr %.sroa_idx.i1037, align 4
  %74 = inttoptr i64 %72 to ptr
  %75 = inttoptr i64 %73 to ptr
  %hash_coef_ptr.i.i42.i = getelementptr i8, ptr %67, i64 8
  %tbl_size_ptr.i.i43.i = getelementptr i8, ptr %67, i64 16
  %offset_tbl_ptr.i.i44.i = getelementptr i8, ptr %67, i64 40
  %hash_coef.i.i45.i = load i64, ptr %hash_coef_ptr.i.i42.i, align 4, !noalias !28
  %tbl_size.i.i46.i = load i64, ptr %tbl_size_ptr.i.i43.i, align 4, !noalias !28
  %offset_tbl.i.i47.i = load ptr, ptr %offset_tbl_ptr.i.i44.i, align 8, !noalias !28
  %product.i.i.i48.i = mul i64 %hash_coef.i.i45.i, 4015701072841558310
  %shifted.i.i.i49.i = lshr i64 %product.i.i.i48.i, 32
  %xored.i.i.i50.i = xor i64 %shifted.i.i.i49.i, %product.i.i.i48.i
  %hash.i.i.i51.i = and i64 %xored.i.i.i50.i, %tbl_size.i.i46.i
  %offset_ptr.i.i52.i = getelementptr i32, ptr %offset_tbl.i.i47.i, i64 %hash.i.i.i51.i
  %offset.i.i53.i = load i32, ptr %offset_ptr.i.i52.i, align 4, !noalias !28
  %76 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %67, 0
  %77 = insertvalue { ptr, ptr, ptr, i32 } %76, ptr %74, 1
  %78 = insertvalue { ptr, ptr, ptr, i32 } %77, ptr %75, 2
  %79 = insertvalue { ptr, ptr, ptr, i32 } %78, i32 %offset.i.i53.i, 3
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %67)
  %82 = sext i32 %offset.i.i53.i to i64
  %83 = getelementptr ptr, ptr %67, i64 %82
  %84 = getelementptr i8, ptr %83, i64 56
  %85 = load ptr, ptr %84, align 8
  %result.i55.i = call ptr %85({ ptr, ptr, ptr, i32 } %79, ptr nocapture nofree noundef nonnull readonly %2) #16
  %86 = call { ptr, i160 } %result.i55.i({ ptr, ptr, ptr, i32 } %79, { ptr, ptr, ptr, i32 } %79, ptr nonnull align 8 %2) #7
  %.fca.0.extract29.i = extractvalue { ptr, i160 } %86, 0
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %88 = load ptr, ptr %18, align 8
  %89 = load ptr, ptr %88, align 8
  %90 = ptrtoint ptr %89 to i64
  %91 = getelementptr i8, ptr %.fca.0.extract29.i, i64 8
  %92 = getelementptr i8, ptr %.fca.0.extract29.i, i64 16
  %93 = getelementptr i8, ptr %.fca.0.extract29.i, i64 24
  %94 = getelementptr i8, ptr %.fca.0.extract29.i, i64 32
  %95 = load i64, ptr %91, align 4
  %96 = load i64, ptr %92, align 4
  %97 = load ptr, ptr %93, align 8
  %98 = load ptr, ptr %94, align 8
  %99 = load i64, ptr %89, align 4
  %result.i57.i = call i1 %97(i64 %96, i64 %95, i64 %99, i64 %90, ptr readonly %98) #5
  br i1 %result.i57.i, label %100, label %._crit_edge.i1036

100:                                              ; preds = %70
  %101 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %102 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %67)
  %103 = getelementptr i8, ptr %83, i64 48
  %104 = load ptr, ptr %103, align 8
  %result.i58.i = call ptr %104({ ptr, ptr, ptr, i32 } %79, ptr nocapture nofree noundef nonnull readonly %2) #16
  %105 = call { ptr, i160 } %result.i58.i({ ptr, ptr, ptr, i32 } %79, { ptr, ptr, ptr, i32 } %79, ptr nonnull align 8 %2) #7
  %106 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %107 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %67)
  %108 = getelementptr i8, ptr %83, i64 64
  %109 = load ptr, ptr %108, align 8
  %result.i59.i = call ptr %109({ ptr, ptr, ptr, i32 } %79, ptr nocapture nofree noundef nonnull readonly %2) #16
  %110 = call i32 %result.i59.i({ ptr, ptr, ptr, i32 } %79, { ptr, ptr, ptr, i32 } %79, ptr nonnull align 8 %2) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %4)
  %111 = load ptr, ptr %result.i311, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %112 = load i32, ptr %26, align 8
  %113 = add i32 %112, -1
  %114 = and i32 %113, %110
  %115 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %116 = load ptr, ptr %25, align 8
  %117 = sext i32 %114 to i64
  %118 = shl nsw i64 %117, 5
  %119 = getelementptr i8, ptr %116, i64 %118
  %120 = load ptr, ptr %119, align 8
  %121 = icmp eq ptr %120, @nil_typ
  %122 = icmp eq ptr %120, null
  %123 = or i1 %121, %122
  br i1 %123, label %HashMap_find_slot_keyK_hashPtri32.exit1443, label %.lr.ph.i1419

.lr.ph.i1419:                                     ; preds = %100
  %124 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %125

125:                                              ; preds = %._crit_edge.thread.i1434, %.lr.ph.i1419
  %126 = phi i32 [ %114, %.lr.ph.i1419 ], [ %168, %._crit_edge.thread.i1434 ]
  %spec.store.select.i14391505 = phi i32 [ -1, %.lr.ph.i1419 ], [ %spec.store.select.i1439, %._crit_edge.thread.i1434 ]
  %127 = phi ptr [ %120, %.lr.ph.i1419 ], [ %173, %._crit_edge.thread.i1434 ]
  %128 = phi ptr [ %119, %.lr.ph.i1419 ], [ %172, %._crit_edge.thread.i1434 ]
  %.sroa_idx.i1420 = getelementptr i8, ptr %128, i64 16
  %129 = load i64, ptr %.sroa_idx.i1420, align 4
  %130 = getelementptr i8, ptr %128, i64 8
  %131 = load i64, ptr %130, align 4
  %132 = inttoptr i64 %131 to ptr
  %133 = inttoptr i64 %129 to ptr
  %hash_coef_ptr.i.i56.i1421 = getelementptr i8, ptr %127, i64 8
  %tbl_size_ptr.i.i57.i1422 = getelementptr i8, ptr %127, i64 16
  %offset_tbl_ptr.i.i58.i1423 = getelementptr i8, ptr %127, i64 40
  %hash_coef.i.i59.i1424 = load i64, ptr %hash_coef_ptr.i.i56.i1421, align 4
  %tbl_size.i.i60.i1425 = load i64, ptr %tbl_size_ptr.i.i57.i1422, align 4
  %offset_tbl.i.i61.i1426 = load ptr, ptr %offset_tbl_ptr.i.i58.i1423, align 8
  %product.i.i.i62.i1427 = mul i64 %hash_coef.i.i59.i1424, 4015701072841558310
  %shifted.i.i.i63.i1428 = lshr i64 %product.i.i.i62.i1427, 32
  %xored.i.i.i64.i1429 = xor i64 %shifted.i.i.i63.i1428, %product.i.i.i62.i1427
  %hash.i.i.i65.i1430 = and i64 %xored.i.i.i64.i1429, %tbl_size.i.i60.i1425
  %offset_ptr.i.i66.i1431 = getelementptr i32, ptr %offset_tbl.i.i61.i1426, i64 %hash.i.i.i65.i1430
  %offset.i.i67.i1432 = load i32, ptr %offset_ptr.i.i66.i1431, align 4
  %134 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %127, 0
  %135 = insertvalue { ptr, ptr, ptr, i32 } %134, ptr %132, 1
  %136 = insertvalue { ptr, ptr, ptr, i32 } %135, ptr %133, 2
  %137 = insertvalue { ptr, ptr, ptr, i32 } %136, i32 %offset.i.i67.i1432, 3
  %138 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %127)
  %139 = sext i32 %offset.i.i67.i1432 to i64
  %140 = getelementptr ptr, ptr %127, i64 %139
  %141 = getelementptr i8, ptr %140, i64 64
  %142 = load ptr, ptr %141, align 8
  %result.i.i1433 = call ptr %142({ ptr, ptr, ptr, i32 } %137, ptr nocapture nofree noundef nonnull readonly %2) #16
  %143 = call i32 %result.i.i1433({ ptr, ptr, ptr, i32 } %137, { ptr, ptr, ptr, i32 } %137, ptr nonnull align 8 %2) #7
  %144 = icmp eq i32 %143, %110
  br i1 %144, label %._crit_edge.i1441, label %._crit_edge.thread.i1434

._crit_edge.i1441:                                ; preds = %125
  %145 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %146 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %127)
  %147 = getelementptr i8, ptr %140, i64 48
  %148 = load ptr, ptr %147, align 8
  %result.i69.i1442 = call ptr %148({ ptr, ptr, ptr, i32 } %137, ptr nocapture nofree noundef nonnull readonly %2) #16
  %149 = call { ptr, i160 } %result.i69.i1442({ ptr, ptr, ptr, i32 } %137, { ptr, ptr, ptr, i32 } %137, ptr nonnull align 8 %2) #7
  %150 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %151 = load ptr, ptr %24, align 8
  %152 = call i1 %151({ ptr, i160 } %149, { ptr, i160 } %105) #7
  br i1 %152, label %HashMap_find_slot_keyK_hashPtri32.exit1443.loopexit, label %._crit_edge.thread.i1434

._crit_edge.thread.i1434:                         ; preds = %._crit_edge.i1441, %125
  %153 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %154 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %127)
  %155 = getelementptr i8, ptr %140, i64 56
  %156 = load ptr, ptr %155, align 8
  %result.i70.i1435 = call ptr %156({ ptr, ptr, ptr, i32 } %137, ptr nocapture nofree noundef nonnull readonly %2) #16
  %157 = call { ptr, i160 } %result.i70.i1435({ ptr, ptr, ptr, i32 } %137, { ptr, ptr, ptr, i32 } %137, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i1436 = extractvalue { ptr, i160 } %157, 0
  %158 = getelementptr i8, ptr %.fca.0.extract19.i1436, i64 8
  %159 = getelementptr i8, ptr %.fca.0.extract19.i1436, i64 16
  %160 = getelementptr i8, ptr %.fca.0.extract19.i1436, i64 24
  %161 = getelementptr i8, ptr %.fca.0.extract19.i1436, i64 32
  %162 = load i64, ptr %158, align 4
  %163 = load i64, ptr %159, align 4
  %164 = load ptr, ptr %160, align 8
  %165 = load ptr, ptr %161, align 8
  %result.i71.i1437 = call i1 %164(i64 %163, i64 %162, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %165) #5
  %166 = icmp eq i32 %spec.store.select.i14391505, -1
  %or.cond.i1438 = select i1 %result.i71.i1437, i1 %166, i1 false
  %spec.store.select.i1439 = select i1 %or.cond.i1438, i32 %126, i32 %spec.store.select.i14391505
  %167 = add i32 %126, 1
  %168 = and i32 %167, %113
  %169 = load ptr, ptr %25, align 8
  %170 = sext i32 %168 to i64
  %171 = shl nsw i64 %170, 5
  %172 = getelementptr i8, ptr %169, i64 %171
  %173 = load ptr, ptr %172, align 8
  %174 = icmp eq ptr %173, @nil_typ
  %175 = icmp eq ptr %173, null
  %176 = or i1 %174, %175
  br i1 %176, label %._crit_edge105.loopexit.i1440, label %125

._crit_edge105.loopexit.i1440:                    ; preds = %._crit_edge.thread.i1434
  %177 = icmp eq i32 %spec.store.select.i1439, -1
  %.pre.i.pre1540 = select i1 %177, i32 %168, i32 %spec.store.select.i1439
  br label %HashMap_find_slot_keyK_hashPtri32.exit1443

HashMap_find_slot_keyK_hashPtri32.exit1443.loopexit: ; preds = %._crit_edge.i1441
  %.pre1598 = load ptr, ptr %25, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit1443

HashMap_find_slot_keyK_hashPtri32.exit1443:       ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1443.loopexit, %100, %._crit_edge105.loopexit.i1440
  %178 = phi ptr [ %169, %._crit_edge105.loopexit.i1440 ], [ %116, %100 ], [ %.pre1598, %HashMap_find_slot_keyK_hashPtri32.exit1443.loopexit ]
  %179 = phi i32 [ %.pre.i.pre1540, %._crit_edge105.loopexit.i1440 ], [ %114, %100 ], [ %126, %HashMap_find_slot_keyK_hashPtri32.exit1443.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %180 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %181 = sext i32 %179 to i64
  %182 = shl nsw i64 %181, 5
  %183 = getelementptr i8, ptr %178, i64 %182
  %184 = load ptr, ptr %183, align 8
  %185 = getelementptr i8, ptr %183, i64 8
  %186 = load i64, ptr %185, align 4
  %.sroa_idx.i1278 = getelementptr i8, ptr %183, i64 16
  %187 = load i64, ptr %.sroa_idx.i1278, align 4
  %188 = load ptr, ptr %18, align 8
  %189 = load ptr, ptr %111, align 8, !alias.scope !31
  %190 = getelementptr i8, ptr %189, i64 72
  %191 = load ptr, ptr %190, align 8, !alias.scope !31
  %result.i.i.i1280 = call { i64, i64 } %191(ptr nocapture nofree nonnull readonly %111) #5, !alias.scope !31
  %192 = extractvalue { i64, i64 } %result.i.i.i1280, 0
  %193 = extractvalue { i64, i64 } %result.i.i.i1280, 1
  %194 = call i64 @llvm.umax.i64(i64 %193, i64 8)
  %195 = urem i64 20, %193
  %196 = icmp eq i64 %195, 0
  %197 = sub i64 %193, %195
  %198 = select i1 %196, i64 0, i64 %197
  %199 = add i64 %192, 20
  %200 = add i64 %199, %198
  %201 = and i64 %200, 7
  %202 = icmp eq i64 %201, 0
  %203 = sub nuw nsw i64 40, %201
  %204 = select i1 %202, i64 32, i64 %203
  %205 = add i64 %204, %200
  %206 = urem i64 %205, %194
  %207 = icmp eq i64 %206, 0
  %208 = sub i64 %194, %206
  %209 = select i1 %207, i64 0, i64 %208
  %210 = add i64 %205, %209
  %result.i71.i1281 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %210, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %111, ptr %result.i71.i1281, align 8
  %211 = getelementptr inbounds i8, ptr %result.i71.i1281, i64 8
  store ptr %188, ptr %211, align 8
  %212 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i1281)
  %213 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %result.i71.i1281, 1
  %214 = insertvalue { ptr, ptr, ptr, i32 } %213, ptr undef, 2
  %215 = insertvalue { ptr, ptr, ptr, i32 } %214, i32 10, 3
  store ptr %111, ptr %4, align 8
  store ptr %188, ptr %40, align 8
  store ptr @_parameterization_Ptri32, ptr %41, align 8
  %216 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %4)
  %217 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Entry)
  %218 = load i64, ptr %91, align 4
  %219 = load i64, ptr %92, align 4
  %220 = load ptr, ptr %93, align 8
  %221 = load ptr, ptr %94, align 8
  %result.i.i117.i = call i1 %220(i64 %219, i64 %218, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %221) #5
  %222 = select i1 %result.i.i117.i, i64 9, i64 10
  %gep = getelementptr [14 x ptr], ptr getelementptr inbounds (i8, ptr @Entry, i64 80), i64 0, i64 %222
  %223 = load ptr, ptr %gep, align 8
  call void %223({ ptr, ptr, ptr, i32 } %215, { ptr, ptr, ptr, i32 } %215, ptr nonnull align 8 dereferenceable(24) %4, { ptr, i160 } %105, { ptr, i160 } %86, i32 %110) #7
  %224 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %225 = load ptr, ptr %25, align 8
  %226 = getelementptr i8, ptr %225, i64 %182
  store ptr @Entry, ptr %226, align 8
  %227 = getelementptr i8, ptr %226, i64 8
  %228 = ptrtoint ptr %result.i71.i1281 to i64
  store i64 %228, ptr %227, align 4
  %.sroa_idx4.i1282 = getelementptr i8, ptr %226, i64 24
  store i32 10, ptr %.sroa_idx4.i1282, align 4
  %229 = icmp eq ptr %184, @nil_typ
  %230 = icmp eq ptr %184, null
  %231 = or i1 %229, %230
  br i1 %231, label %232, label %235

232:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1443
  %233 = load i32, ptr %39, align 4
  %234 = add i32 %233, 1
  store i32 %234, ptr %39, align 4
  br label %._crit_edge.sink.split.i1299

235:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1443
  %236 = inttoptr i64 %186 to ptr
  %237 = inttoptr i64 %187 to ptr
  %hash_coef_ptr.i.i88.i1283 = getelementptr i8, ptr %184, i64 8
  %tbl_size_ptr.i.i89.i1284 = getelementptr i8, ptr %184, i64 16
  %offset_tbl_ptr.i.i90.i1285 = getelementptr i8, ptr %184, i64 40
  %hash_coef.i.i91.i1286 = load i64, ptr %hash_coef_ptr.i.i88.i1283, align 4, !noalias !34
  %tbl_size.i.i92.i1287 = load i64, ptr %tbl_size_ptr.i.i89.i1284, align 4, !noalias !34
  %offset_tbl.i.i93.i1288 = load ptr, ptr %offset_tbl_ptr.i.i90.i1285, align 8, !noalias !34
  %product.i.i.i94.i1289 = mul i64 %hash_coef.i.i91.i1286, 4015701072841558310
  %shifted.i.i.i95.i1290 = lshr i64 %product.i.i.i94.i1289, 32
  %xored.i.i.i96.i1291 = xor i64 %shifted.i.i.i95.i1290, %product.i.i.i94.i1289
  %hash.i.i.i97.i1292 = and i64 %xored.i.i.i96.i1291, %tbl_size.i.i92.i1287
  %offset_ptr.i.i98.i1293 = getelementptr i32, ptr %offset_tbl.i.i93.i1288, i64 %hash.i.i.i97.i1292
  %offset.i.i99.i1294 = load i32, ptr %offset_ptr.i.i98.i1293, align 4, !noalias !34
  %238 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %184, 0
  %239 = insertvalue { ptr, ptr, ptr, i32 } %238, ptr %236, 1
  %240 = insertvalue { ptr, ptr, ptr, i32 } %239, ptr %237, 2
  %241 = insertvalue { ptr, ptr, ptr, i32 } %240, i32 %offset.i.i99.i1294, 3
  %242 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %243 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %184)
  %244 = sext i32 %offset.i.i99.i1294 to i64
  %245 = getelementptr ptr, ptr %184, i64 %244
  %246 = getelementptr i8, ptr %245, i64 56
  %247 = load ptr, ptr %246, align 8
  %result.i101.i1295 = call ptr %247({ ptr, ptr, ptr, i32 } %241, ptr nocapture nofree noundef nonnull readonly %2) #16
  %248 = call { ptr, i160 } %result.i101.i1295({ ptr, ptr, ptr, i32 } %241, { ptr, ptr, ptr, i32 } %241, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i1296 = extractvalue { ptr, i160 } %248, 0
  %249 = getelementptr i8, ptr %.fca.0.extract51.i1296, i64 8
  %250 = getelementptr i8, ptr %.fca.0.extract51.i1296, i64 16
  %251 = getelementptr i8, ptr %.fca.0.extract51.i1296, i64 24
  %252 = getelementptr i8, ptr %.fca.0.extract51.i1296, i64 32
  %253 = load i64, ptr %249, align 4
  %254 = load i64, ptr %250, align 4
  %255 = load ptr, ptr %251, align 8
  %256 = load ptr, ptr %252, align 8
  %result.i102.i1297 = call i1 %255(i64 %254, i64 %253, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %256) #5
  br i1 %result.i102.i1297, label %._crit_edge.sink.split.i1299, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1301

._crit_edge.sink.split.i1299:                     ; preds = %235, %232
  %.sink159.i1300 = phi i64 [ 48, %232 ], [ 40, %235 ]
  %257 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %258 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i1300
  %259 = load ptr, ptr %258, align 8
  %260 = load ptr, ptr %259, align 8
  %261 = call i32 %260(ptr nonnull %result.i311) #36
  %262 = add i32 %261, 1
  %263 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %264 = getelementptr i8, ptr %259, i64 8
  %265 = load ptr, ptr %264, align 8
  call void %265(ptr nonnull %result.i311, i32 %262) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1301

HashMap_insert_internal_keyK_valueV_hashPtri32.exit1301: ; preds = %235, %._crit_edge.sink.split.i1299
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %4)
  br label %._crit_edge.i1036

._crit_edge.i1036:                                ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1301, %70, %.lr.ph.i1035
  %266 = add nuw nsw i32 %.096.i, 1
  %267 = icmp slt i32 %266, %52
  br i1 %267, label %.lr.ph.i1035, label %HashMap_resize_new_capacityPtri32.exit

HashMap_resize_new_capacityPtri32.exit:           ; preds = %._crit_edge.i1036, %._crit_edge1.i816
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_ensure_capacity_required_loadPtri32.exit

HashMap_ensure_capacity_required_loadPtri32.exit: ; preds = %._crit_edge, %HashMap_resize_new_capacityPtri32.exit
  %268 = load ptr, ptr %23, align 8
  %269 = call i32 %268({ ptr, i160 } %46) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %270 = load ptr, ptr %result.i311, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %271 = load i32, ptr %26, align 8
  %272 = add i32 %271, -1
  %273 = and i32 %272, %269
  %274 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %275 = load ptr, ptr %25, align 8
  %276 = sext i32 %273 to i64
  %277 = shl nsw i64 %276, 5
  %278 = getelementptr i8, ptr %275, i64 %277
  %279 = load ptr, ptr %278, align 8
  %280 = icmp eq ptr %279, @nil_typ
  %281 = icmp eq ptr %279, null
  %282 = or i1 %280, %281
  br i1 %282, label %HashMap_find_slot_keyK_hashPtri32.exit1073, label %.lr.ph.i1050

.lr.ph.i1050:                                     ; preds = %HashMap_ensure_capacity_required_loadPtri32.exit
  %283 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %284

284:                                              ; preds = %._crit_edge.thread.i1065, %.lr.ph.i1050
  %285 = phi i32 [ %273, %.lr.ph.i1050 ], [ %327, %._crit_edge.thread.i1065 ]
  %spec.store.select.i10701195 = phi i32 [ -1, %.lr.ph.i1050 ], [ %spec.store.select.i1070, %._crit_edge.thread.i1065 ]
  %286 = phi ptr [ %279, %.lr.ph.i1050 ], [ %332, %._crit_edge.thread.i1065 ]
  %287 = phi ptr [ %278, %.lr.ph.i1050 ], [ %331, %._crit_edge.thread.i1065 ]
  %.sroa_idx.i1051 = getelementptr i8, ptr %287, i64 16
  %288 = load i64, ptr %.sroa_idx.i1051, align 4
  %289 = getelementptr i8, ptr %287, i64 8
  %290 = load i64, ptr %289, align 4
  %291 = inttoptr i64 %290 to ptr
  %292 = inttoptr i64 %288 to ptr
  %hash_coef_ptr.i.i56.i1052 = getelementptr i8, ptr %286, i64 8
  %tbl_size_ptr.i.i57.i1053 = getelementptr i8, ptr %286, i64 16
  %offset_tbl_ptr.i.i58.i1054 = getelementptr i8, ptr %286, i64 40
  %hash_coef.i.i59.i1055 = load i64, ptr %hash_coef_ptr.i.i56.i1052, align 4
  %tbl_size.i.i60.i1056 = load i64, ptr %tbl_size_ptr.i.i57.i1053, align 4
  %offset_tbl.i.i61.i1057 = load ptr, ptr %offset_tbl_ptr.i.i58.i1054, align 8
  %product.i.i.i62.i1058 = mul i64 %hash_coef.i.i59.i1055, 4015701072841558310
  %shifted.i.i.i63.i1059 = lshr i64 %product.i.i.i62.i1058, 32
  %xored.i.i.i64.i1060 = xor i64 %shifted.i.i.i63.i1059, %product.i.i.i62.i1058
  %hash.i.i.i65.i1061 = and i64 %xored.i.i.i64.i1060, %tbl_size.i.i60.i1056
  %offset_ptr.i.i66.i1062 = getelementptr i32, ptr %offset_tbl.i.i61.i1057, i64 %hash.i.i.i65.i1061
  %offset.i.i67.i1063 = load i32, ptr %offset_ptr.i.i66.i1062, align 4
  %293 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %286, 0
  %294 = insertvalue { ptr, ptr, ptr, i32 } %293, ptr %291, 1
  %295 = insertvalue { ptr, ptr, ptr, i32 } %294, ptr %292, 2
  %296 = insertvalue { ptr, ptr, ptr, i32 } %295, i32 %offset.i.i67.i1063, 3
  %297 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %286)
  %298 = sext i32 %offset.i.i67.i1063 to i64
  %299 = getelementptr ptr, ptr %286, i64 %298
  %300 = getelementptr i8, ptr %299, i64 64
  %301 = load ptr, ptr %300, align 8
  %result.i.i1064 = call ptr %301({ ptr, ptr, ptr, i32 } %296, ptr nocapture nofree noundef nonnull readonly %2) #16
  %302 = call i32 %result.i.i1064({ ptr, ptr, ptr, i32 } %296, { ptr, ptr, ptr, i32 } %296, ptr nonnull align 8 %2) #7
  %303 = icmp eq i32 %302, %269
  br i1 %303, label %._crit_edge.i1072, label %._crit_edge.thread.i1065

._crit_edge.i1072:                                ; preds = %284
  %304 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %305 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %286)
  %306 = getelementptr i8, ptr %299, i64 48
  %307 = load ptr, ptr %306, align 8
  %result.i69.i = call ptr %307({ ptr, ptr, ptr, i32 } %296, ptr nocapture nofree noundef nonnull readonly %2) #16
  %308 = call { ptr, i160 } %result.i69.i({ ptr, ptr, ptr, i32 } %296, { ptr, ptr, ptr, i32 } %296, ptr nonnull align 8 %2) #7
  %309 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %310 = load ptr, ptr %24, align 8
  %311 = call i1 %310({ ptr, i160 } %308, { ptr, i160 } %46) #7
  br i1 %311, label %HashMap_find_slot_keyK_hashPtri32.exit1073.loopexit, label %._crit_edge.thread.i1065

._crit_edge.thread.i1065:                         ; preds = %._crit_edge.i1072, %284
  %312 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %313 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %286)
  %314 = getelementptr i8, ptr %299, i64 56
  %315 = load ptr, ptr %314, align 8
  %result.i70.i1066 = call ptr %315({ ptr, ptr, ptr, i32 } %296, ptr nocapture nofree noundef nonnull readonly %2) #16
  %316 = call { ptr, i160 } %result.i70.i1066({ ptr, ptr, ptr, i32 } %296, { ptr, ptr, ptr, i32 } %296, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i1067 = extractvalue { ptr, i160 } %316, 0
  %317 = getelementptr i8, ptr %.fca.0.extract19.i1067, i64 8
  %318 = getelementptr i8, ptr %.fca.0.extract19.i1067, i64 16
  %319 = getelementptr i8, ptr %.fca.0.extract19.i1067, i64 24
  %320 = getelementptr i8, ptr %.fca.0.extract19.i1067, i64 32
  %321 = load i64, ptr %317, align 4
  %322 = load i64, ptr %318, align 4
  %323 = load ptr, ptr %319, align 8
  %324 = load ptr, ptr %320, align 8
  %result.i71.i1068 = call i1 %323(i64 %322, i64 %321, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %324) #5
  %325 = icmp eq i32 %spec.store.select.i10701195, -1
  %or.cond.i1069 = select i1 %result.i71.i1068, i1 %325, i1 false
  %spec.store.select.i1070 = select i1 %or.cond.i1069, i32 %285, i32 %spec.store.select.i10701195
  %326 = add i32 %285, 1
  %327 = and i32 %326, %272
  %328 = load ptr, ptr %25, align 8
  %329 = sext i32 %327 to i64
  %330 = shl nsw i64 %329, 5
  %331 = getelementptr i8, ptr %328, i64 %330
  %332 = load ptr, ptr %331, align 8
  %333 = icmp eq ptr %332, @nil_typ
  %334 = icmp eq ptr %332, null
  %335 = or i1 %333, %334
  br i1 %335, label %._crit_edge105.loopexit.i1071, label %284

._crit_edge105.loopexit.i1071:                    ; preds = %._crit_edge.thread.i1065
  %336 = icmp eq i32 %spec.store.select.i1070, -1
  %.pre.i.pre1221 = select i1 %336, i32 %327, i32 %spec.store.select.i1070
  br label %HashMap_find_slot_keyK_hashPtri32.exit1073

HashMap_find_slot_keyK_hashPtri32.exit1073.loopexit: ; preds = %._crit_edge.i1072
  %.pre1264 = load ptr, ptr %25, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit1073

HashMap_find_slot_keyK_hashPtri32.exit1073:       ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1073.loopexit, %HashMap_ensure_capacity_required_loadPtri32.exit, %._crit_edge105.loopexit.i1071
  %337 = phi ptr [ %328, %._crit_edge105.loopexit.i1071 ], [ %275, %HashMap_ensure_capacity_required_loadPtri32.exit ], [ %.pre1264, %HashMap_find_slot_keyK_hashPtri32.exit1073.loopexit ]
  %338 = phi i32 [ %.pre.i.pre1221, %._crit_edge105.loopexit.i1071 ], [ %273, %HashMap_ensure_capacity_required_loadPtri32.exit ], [ %285, %HashMap_find_slot_keyK_hashPtri32.exit1073.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %339 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %340 = sext i32 %338 to i64
  %341 = shl nsw i64 %340, 5
  %342 = getelementptr i8, ptr %337, i64 %341
  %343 = load ptr, ptr %342, align 8
  %344 = getelementptr i8, ptr %342, i64 8
  %345 = load i64, ptr %344, align 4
  %.sroa_idx.i833 = getelementptr i8, ptr %342, i64 16
  %346 = load i64, ptr %.sroa_idx.i833, align 4
  %347 = load ptr, ptr %18, align 8
  %348 = load ptr, ptr %270, align 8, !alias.scope !37
  %349 = getelementptr i8, ptr %348, i64 72
  %350 = load ptr, ptr %349, align 8, !alias.scope !37
  %result.i.i.i = call { i64, i64 } %350(ptr nocapture nofree nonnull readonly %270) #5, !alias.scope !37
  %351 = extractvalue { i64, i64 } %result.i.i.i, 0
  %352 = extractvalue { i64, i64 } %result.i.i.i, 1
  %353 = call i64 @llvm.umax.i64(i64 %352, i64 8)
  %354 = urem i64 20, %352
  %355 = icmp eq i64 %354, 0
  %356 = sub i64 %352, %354
  %357 = select i1 %355, i64 0, i64 %356
  %358 = add i64 %351, 20
  %359 = add i64 %358, %357
  %360 = and i64 %359, 7
  %361 = icmp eq i64 %360, 0
  %362 = sub nuw nsw i64 40, %360
  %363 = select i1 %361, i64 32, i64 %362
  %364 = add i64 %363, %359
  %365 = urem i64 %364, %353
  %366 = icmp eq i64 %365, 0
  %367 = sub i64 %353, %365
  %368 = select i1 %366, i64 0, i64 %367
  %369 = add i64 %364, %368
  %result.i71.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %369, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %270, ptr %result.i71.i, align 8
  %370 = getelementptr inbounds i8, ptr %result.i71.i, i64 8
  store ptr %347, ptr %370, align 8
  %371 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i)
  %372 = load ptr, ptr %270, align 8
  %373 = getelementptr i8, ptr %372, i64 72
  %374 = load ptr, ptr %373, align 8
  %result.i.i1236 = call { i64, i64 } %374(ptr nocapture nofree nonnull readonly %270) #5
  %375 = extractvalue { i64, i64 } %result.i.i1236, 1
  %376 = urem i64 20, %375
  %377 = icmp eq i64 %376, 0
  %reass.sub1580 = sub i64 %375, %376
  %378 = add i64 %reass.sub1580, 20
  %379 = select i1 %377, i64 20, i64 %378
  %380 = getelementptr i8, ptr %result.i71.i, i64 %379
  %381 = getelementptr i8, ptr %372, i64 64
  %382 = load ptr, ptr %381, align 8
  call void %382({ ptr, i160 } %46, ptr nocapture nofree nonnull readonly %270, ptr nocapture nofree writeonly %380) #13
  %383 = load ptr, ptr %result.i71.i, align 8
  %384 = load ptr, ptr %383, align 8
  %385 = getelementptr i8, ptr %384, i64 72
  %386 = load ptr, ptr %385, align 8
  %result.i.i1237 = call { i64, i64 } %386(ptr nocapture nofree nonnull readonly %383) #5
  %387 = extractvalue { i64, i64 } %result.i.i1237, 0
  %388 = extractvalue { i64, i64 } %result.i.i1237, 1
  %389 = urem i64 20, %388
  %390 = icmp eq i64 %389, 0
  %391 = sub i64 %388, %389
  %392 = select i1 %390, i64 0, i64 %391
  %393 = add i64 %387, 20
  %394 = add i64 %393, %392
  %395 = and i64 %394, 7
  %396 = icmp eq i64 %395, 0
  %397 = sub nuw nsw i64 8, %395
  %398 = select i1 %396, i64 0, i64 %397
  %399 = getelementptr i8, ptr %result.i71.i, i64 %394
  %400 = getelementptr i8, ptr %399, i64 %398
  store ptr @bool_typ, ptr %400, align 8
  %401 = getelementptr i8, ptr %400, i64 8
  store i160 %.sroa.0231.0.insert.ext, ptr %401, align 4
  %402 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @Entry) #34
  %403 = getelementptr inbounds i8, ptr %result.i71.i, i64 16
  store i32 %269, ptr %403, align 8
  %404 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  store ptr @Entry, ptr %342, align 8
  %405 = ptrtoint ptr %result.i71.i to i64
  store i64 %405, ptr %344, align 4
  %.sroa_idx4.i = getelementptr i8, ptr %342, i64 24
  store i32 10, ptr %.sroa_idx4.i, align 4
  %406 = icmp eq ptr %343, @nil_typ
  %407 = icmp eq ptr %343, null
  %408 = or i1 %406, %407
  br i1 %408, label %409, label %412

409:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1073
  %410 = load i32, ptr %39, align 4
  %411 = add i32 %410, 1
  store i32 %411, ptr %39, align 4
  br label %._crit_edge.sink.split.i

412:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1073
  %413 = inttoptr i64 %345 to ptr
  %414 = inttoptr i64 %346 to ptr
  %hash_coef_ptr.i.i88.i = getelementptr i8, ptr %343, i64 8
  %tbl_size_ptr.i.i89.i = getelementptr i8, ptr %343, i64 16
  %offset_tbl_ptr.i.i90.i = getelementptr i8, ptr %343, i64 40
  %hash_coef.i.i91.i = load i64, ptr %hash_coef_ptr.i.i88.i, align 4, !noalias !40
  %tbl_size.i.i92.i = load i64, ptr %tbl_size_ptr.i.i89.i, align 4, !noalias !40
  %offset_tbl.i.i93.i = load ptr, ptr %offset_tbl_ptr.i.i90.i, align 8, !noalias !40
  %product.i.i.i94.i = mul i64 %hash_coef.i.i91.i, 4015701072841558310
  %shifted.i.i.i95.i = lshr i64 %product.i.i.i94.i, 32
  %xored.i.i.i96.i = xor i64 %shifted.i.i.i95.i, %product.i.i.i94.i
  %hash.i.i.i97.i = and i64 %xored.i.i.i96.i, %tbl_size.i.i92.i
  %offset_ptr.i.i98.i = getelementptr i32, ptr %offset_tbl.i.i93.i, i64 %hash.i.i.i97.i
  %offset.i.i99.i = load i32, ptr %offset_ptr.i.i98.i, align 4, !noalias !40
  %415 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %343, 0
  %416 = insertvalue { ptr, ptr, ptr, i32 } %415, ptr %413, 1
  %417 = insertvalue { ptr, ptr, ptr, i32 } %416, ptr %414, 2
  %418 = insertvalue { ptr, ptr, ptr, i32 } %417, i32 %offset.i.i99.i, 3
  %419 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %420 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %343)
  %421 = sext i32 %offset.i.i99.i to i64
  %422 = getelementptr ptr, ptr %343, i64 %421
  %423 = getelementptr i8, ptr %422, i64 56
  %424 = load ptr, ptr %423, align 8
  %result.i101.i = call ptr %424({ ptr, ptr, ptr, i32 } %418, ptr nocapture nofree noundef nonnull readonly %2) #16
  %425 = call { ptr, i160 } %result.i101.i({ ptr, ptr, ptr, i32 } %418, { ptr, ptr, ptr, i32 } %418, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i835 = extractvalue { ptr, i160 } %425, 0
  %426 = getelementptr i8, ptr %.fca.0.extract51.i835, i64 8
  %427 = getelementptr i8, ptr %.fca.0.extract51.i835, i64 16
  %428 = getelementptr i8, ptr %.fca.0.extract51.i835, i64 24
  %429 = getelementptr i8, ptr %.fca.0.extract51.i835, i64 32
  %430 = load i64, ptr %426, align 4
  %431 = load i64, ptr %427, align 4
  %432 = load ptr, ptr %428, align 8
  %433 = load ptr, ptr %429, align 8
  %result.i102.i = call i1 %432(i64 %431, i64 %430, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %433) #5
  br i1 %result.i102.i, label %._crit_edge.sink.split.i, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit

._crit_edge.sink.split.i:                         ; preds = %412, %409
  %.sink159.i = phi i64 [ 48, %409 ], [ 40, %412 ]
  %434 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %435 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i
  %436 = load ptr, ptr %435, align 8
  %437 = load ptr, ptr %436, align 8
  %438 = call i32 %437(ptr nonnull %result.i311) #36
  %439 = add i32 %438, 1
  %440 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %441 = getelementptr i8, ptr %436, i64 8
  %442 = load ptr, ptr %441, align 8
  call void %442(ptr nonnull %result.i311, i32 %439) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit

HashMap_insert_internal_keyK_valueV_hashPtri32.exit: ; preds = %412, %._crit_edge.sink.split.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %443 = add nuw nsw i32 %.0247472, 1
  %444 = icmp slt i32 %443, %0
  br i1 %444, label %._crit_edge, label %._crit_edge2._crit_edge

._crit_edge2._crit_edge:                          ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit
  %445 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %446 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #34
  %447 = load i32, ptr %39, align 4
  %448 = call i64 @clock()
  %449 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  %450 = getelementptr inbounds i8, ptr %result.i268, i64 40
  %451 = getelementptr inbounds i8, ptr %result.i268, i64 36
  %452 = getelementptr inbounds i8, ptr %3, i64 8
  %453 = getelementptr inbounds i8, ptr %3, i64 16
  br label %._crit_edge3

._crit_edge3:                                     ; preds = %._crit_edge2._crit_edge, %HashMap_insert_internal_keyK_valueV_hashPtri32.exit901
  %.2249474 = phi i32 [ %852, %HashMap_insert_internal_keyK_valueV_hashPtri32.exit901 ], [ 0, %._crit_edge2._crit_edge ]
  %454 = zext nneg i32 %.2249474 to i64
  %455 = shl nuw nsw i64 %454, 2
  %456 = getelementptr i8, ptr %result.i4.i, i64 %455
  %457 = load i32, ptr %456, align 1
  %.sroa.2.sroa.0.0.insert.ext.i = zext i32 %457 to i160
  %458 = add i32 %457, 1
  %459 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i, 1
  %.sroa.0211.0.insert.ext = zext i32 %458 to i160
  %460 = load i32, ptr %450, align 8
  %461 = load i32, ptr %13, align 8
  %462 = icmp eq i32 %461, 0
  %463 = mul i32 %460, 10
  %464 = add i32 %463, 10
  %465 = mul i32 %461, 6
  %466 = icmp sge i32 %464, %465
  %.0.i850 = select i1 %462, i1 true, i1 %466
  br i1 %.0.i850, label %._crit_edge1.i852, label %HashMap_ensure_capacity_required_loadPtri32.exit856

._crit_edge1.i852:                                ; preds = %._crit_edge3
  %467 = shl i32 %461, 1
  %spec.select.i854 = call i32 @llvm.smax.i32(i32 %467, i32 16)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %468 = load ptr, ptr %12, align 8
  %469 = zext nneg i32 %spec.select.i854 to i64
  %470 = shl nuw nsw i64 %469, 5
  %result.i.i1101 = call noalias ptr @bump_malloc_inner(i64 noundef %470, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1101, ptr %12, align 8
  store i32 %spec.select.i854, ptr %13, align 8
  store i32 0, ptr %451, align 4
  %471 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #38
  store i32 0, ptr %450, align 8
  %472 = icmp sgt i32 %461, 0
  br i1 %472, label %.lr.ph.i1102, label %HashMap_resize_new_capacityPtri32.exit1128

.lr.ph.i1102:                                     ; preds = %._crit_edge1.i852, %._crit_edge.i1105
  %.096.i1103 = phi i32 [ %675, %._crit_edge.i1105 ], [ 0, %._crit_edge1.i852 ]
  %473 = zext nneg i32 %.096.i1103 to i64
  %474 = shl nuw nsw i64 %473, 5
  %475 = getelementptr i8, ptr %468, i64 %474
  %476 = load ptr, ptr %475, align 8
  %477 = icmp ne ptr %476, @nil_typ
  %478 = icmp ne ptr %476, null
  %.not40.i1104 = and i1 %477, %478
  br i1 %.not40.i1104, label %479, label %._crit_edge.i1105

479:                                              ; preds = %.lr.ph.i1102
  %480 = getelementptr i8, ptr %475, i64 8
  %481 = load i64, ptr %480, align 4
  %.sroa_idx.i1106 = getelementptr i8, ptr %475, i64 16
  %482 = load i64, ptr %.sroa_idx.i1106, align 4
  %483 = inttoptr i64 %481 to ptr
  %484 = inttoptr i64 %482 to ptr
  %hash_coef_ptr.i.i42.i1107 = getelementptr i8, ptr %476, i64 8
  %tbl_size_ptr.i.i43.i1108 = getelementptr i8, ptr %476, i64 16
  %offset_tbl_ptr.i.i44.i1109 = getelementptr i8, ptr %476, i64 40
  %hash_coef.i.i45.i1110 = load i64, ptr %hash_coef_ptr.i.i42.i1107, align 4, !noalias !43
  %tbl_size.i.i46.i1111 = load i64, ptr %tbl_size_ptr.i.i43.i1108, align 4, !noalias !43
  %offset_tbl.i.i47.i1112 = load ptr, ptr %offset_tbl_ptr.i.i44.i1109, align 8, !noalias !43
  %product.i.i.i48.i1113 = mul i64 %hash_coef.i.i45.i1110, 4015701072841558310
  %shifted.i.i.i49.i1114 = lshr i64 %product.i.i.i48.i1113, 32
  %xored.i.i.i50.i1115 = xor i64 %shifted.i.i.i49.i1114, %product.i.i.i48.i1113
  %hash.i.i.i51.i1116 = and i64 %xored.i.i.i50.i1115, %tbl_size.i.i46.i1111
  %offset_ptr.i.i52.i1117 = getelementptr i32, ptr %offset_tbl.i.i47.i1112, i64 %hash.i.i.i51.i1116
  %offset.i.i53.i1118 = load i32, ptr %offset_ptr.i.i52.i1117, align 4, !noalias !43
  %485 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %476, 0
  %486 = insertvalue { ptr, ptr, ptr, i32 } %485, ptr %483, 1
  %487 = insertvalue { ptr, ptr, ptr, i32 } %486, ptr %484, 2
  %488 = insertvalue { ptr, ptr, ptr, i32 } %487, i32 %offset.i.i53.i1118, 3
  %489 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %490 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %476)
  %491 = sext i32 %offset.i.i53.i1118 to i64
  %492 = getelementptr ptr, ptr %476, i64 %491
  %493 = getelementptr i8, ptr %492, i64 56
  %494 = load ptr, ptr %493, align 8
  %result.i55.i1119 = call ptr %494({ ptr, ptr, ptr, i32 } %488, ptr nocapture nofree noundef nonnull readonly %2) #16
  %495 = call { ptr, i160 } %result.i55.i1119({ ptr, ptr, ptr, i32 } %488, { ptr, ptr, ptr, i32 } %488, ptr nonnull align 8 %2) #7
  %.fca.0.extract29.i1120 = extractvalue { ptr, i160 } %495, 0
  %496 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %497 = load ptr, ptr %5, align 8
  %498 = load ptr, ptr %497, align 8
  %499 = ptrtoint ptr %498 to i64
  %500 = getelementptr i8, ptr %.fca.0.extract29.i1120, i64 8
  %501 = getelementptr i8, ptr %.fca.0.extract29.i1120, i64 16
  %502 = getelementptr i8, ptr %.fca.0.extract29.i1120, i64 24
  %503 = getelementptr i8, ptr %.fca.0.extract29.i1120, i64 32
  %504 = load i64, ptr %500, align 4
  %505 = load i64, ptr %501, align 4
  %506 = load ptr, ptr %502, align 8
  %507 = load ptr, ptr %503, align 8
  %508 = load i64, ptr %498, align 4
  %result.i57.i1122 = call i1 %506(i64 %505, i64 %504, i64 %508, i64 %499, ptr readonly %507) #5
  br i1 %result.i57.i1122, label %509, label %._crit_edge.i1105

509:                                              ; preds = %479
  %510 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %511 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %476)
  %512 = getelementptr i8, ptr %492, i64 48
  %513 = load ptr, ptr %512, align 8
  %result.i58.i1123 = call ptr %513({ ptr, ptr, ptr, i32 } %488, ptr nocapture nofree noundef nonnull readonly %2) #16
  %514 = call { ptr, i160 } %result.i58.i1123({ ptr, ptr, ptr, i32 } %488, { ptr, ptr, ptr, i32 } %488, ptr nonnull align 8 %2) #7
  %515 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %516 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %476)
  %517 = getelementptr i8, ptr %492, i64 64
  %518 = load ptr, ptr %517, align 8
  %result.i59.i1125 = call ptr %518({ ptr, ptr, ptr, i32 } %488, ptr nocapture nofree noundef nonnull readonly %2) #16
  %519 = call i32 %result.i59.i1125({ ptr, ptr, ptr, i32 } %488, { ptr, ptr, ptr, i32 } %488, ptr nonnull align 8 %2) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %3)
  %520 = load ptr, ptr %result.i268, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %521 = load i32, ptr %13, align 8
  %522 = add i32 %521, -1
  %523 = and i32 %522, %519
  %524 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %525 = load ptr, ptr %12, align 8
  %526 = sext i32 %523 to i64
  %527 = shl nsw i64 %526, 5
  %528 = getelementptr i8, ptr %525, i64 %527
  %529 = load ptr, ptr %528, align 8
  %530 = icmp eq ptr %529, @nil_typ
  %531 = icmp eq ptr %529, null
  %532 = or i1 %530, %531
  br i1 %532, label %HashMap_find_slot_keyK_hashPtri32.exit1488, label %.lr.ph.i1458

.lr.ph.i1458:                                     ; preds = %509
  %533 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %534

534:                                              ; preds = %._crit_edge.thread.i1474, %.lr.ph.i1458
  %535 = phi i32 [ %523, %.lr.ph.i1458 ], [ %577, %._crit_edge.thread.i1474 ]
  %spec.store.select.i14791511 = phi i32 [ -1, %.lr.ph.i1458 ], [ %spec.store.select.i1479, %._crit_edge.thread.i1474 ]
  %536 = phi ptr [ %529, %.lr.ph.i1458 ], [ %582, %._crit_edge.thread.i1474 ]
  %537 = phi ptr [ %528, %.lr.ph.i1458 ], [ %581, %._crit_edge.thread.i1474 ]
  %.sroa_idx.i1460 = getelementptr i8, ptr %537, i64 16
  %538 = load i64, ptr %.sroa_idx.i1460, align 4
  %539 = getelementptr i8, ptr %537, i64 8
  %540 = load i64, ptr %539, align 4
  %541 = inttoptr i64 %540 to ptr
  %542 = inttoptr i64 %538 to ptr
  %hash_coef_ptr.i.i56.i1461 = getelementptr i8, ptr %536, i64 8
  %tbl_size_ptr.i.i57.i1462 = getelementptr i8, ptr %536, i64 16
  %offset_tbl_ptr.i.i58.i1463 = getelementptr i8, ptr %536, i64 40
  %hash_coef.i.i59.i1464 = load i64, ptr %hash_coef_ptr.i.i56.i1461, align 4
  %tbl_size.i.i60.i1465 = load i64, ptr %tbl_size_ptr.i.i57.i1462, align 4
  %offset_tbl.i.i61.i1466 = load ptr, ptr %offset_tbl_ptr.i.i58.i1463, align 8
  %product.i.i.i62.i1467 = mul i64 %hash_coef.i.i59.i1464, 4015701072841558310
  %shifted.i.i.i63.i1468 = lshr i64 %product.i.i.i62.i1467, 32
  %xored.i.i.i64.i1469 = xor i64 %shifted.i.i.i63.i1468, %product.i.i.i62.i1467
  %hash.i.i.i65.i1470 = and i64 %xored.i.i.i64.i1469, %tbl_size.i.i60.i1465
  %offset_ptr.i.i66.i1471 = getelementptr i32, ptr %offset_tbl.i.i61.i1466, i64 %hash.i.i.i65.i1470
  %offset.i.i67.i1472 = load i32, ptr %offset_ptr.i.i66.i1471, align 4
  %543 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %536, 0
  %544 = insertvalue { ptr, ptr, ptr, i32 } %543, ptr %541, 1
  %545 = insertvalue { ptr, ptr, ptr, i32 } %544, ptr %542, 2
  %546 = insertvalue { ptr, ptr, ptr, i32 } %545, i32 %offset.i.i67.i1472, 3
  %547 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %536)
  %548 = sext i32 %offset.i.i67.i1472 to i64
  %549 = getelementptr ptr, ptr %536, i64 %548
  %550 = getelementptr i8, ptr %549, i64 64
  %551 = load ptr, ptr %550, align 8
  %result.i.i1473 = call ptr %551({ ptr, ptr, ptr, i32 } %546, ptr nocapture nofree noundef nonnull readonly %2) #16
  %552 = call i32 %result.i.i1473({ ptr, ptr, ptr, i32 } %546, { ptr, ptr, ptr, i32 } %546, ptr nonnull align 8 %2) #7
  %553 = icmp eq i32 %552, %519
  br i1 %553, label %._crit_edge.i1485, label %._crit_edge.thread.i1474

._crit_edge.i1485:                                ; preds = %534
  %554 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %555 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %536)
  %556 = getelementptr i8, ptr %549, i64 48
  %557 = load ptr, ptr %556, align 8
  %result.i69.i1486 = call ptr %557({ ptr, ptr, ptr, i32 } %546, ptr nocapture nofree noundef nonnull readonly %2) #16
  %558 = call { ptr, i160 } %result.i69.i1486({ ptr, ptr, ptr, i32 } %546, { ptr, ptr, ptr, i32 } %546, ptr nonnull align 8 %2) #7
  %559 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %560 = load ptr, ptr %11, align 8
  %561 = call i1 %560({ ptr, i160 } %558, { ptr, i160 } %514) #7
  br i1 %561, label %HashMap_find_slot_keyK_hashPtri32.exit1488.loopexit, label %._crit_edge.thread.i1474

._crit_edge.thread.i1474:                         ; preds = %._crit_edge.i1485, %534
  %562 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %563 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %536)
  %564 = getelementptr i8, ptr %549, i64 56
  %565 = load ptr, ptr %564, align 8
  %result.i70.i1475 = call ptr %565({ ptr, ptr, ptr, i32 } %546, ptr nocapture nofree noundef nonnull readonly %2) #16
  %566 = call { ptr, i160 } %result.i70.i1475({ ptr, ptr, ptr, i32 } %546, { ptr, ptr, ptr, i32 } %546, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i1476 = extractvalue { ptr, i160 } %566, 0
  %567 = getelementptr i8, ptr %.fca.0.extract19.i1476, i64 8
  %568 = getelementptr i8, ptr %.fca.0.extract19.i1476, i64 16
  %569 = getelementptr i8, ptr %.fca.0.extract19.i1476, i64 24
  %570 = getelementptr i8, ptr %.fca.0.extract19.i1476, i64 32
  %571 = load i64, ptr %567, align 4
  %572 = load i64, ptr %568, align 4
  %573 = load ptr, ptr %569, align 8
  %574 = load ptr, ptr %570, align 8
  %result.i71.i1477 = call i1 %573(i64 %572, i64 %571, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %574) #5
  %575 = icmp eq i32 %spec.store.select.i14791511, -1
  %or.cond.i1478 = select i1 %result.i71.i1477, i1 %575, i1 false
  %spec.store.select.i1479 = select i1 %or.cond.i1478, i32 %535, i32 %spec.store.select.i14791511
  %576 = add i32 %535, 1
  %577 = and i32 %576, %522
  %578 = load ptr, ptr %12, align 8
  %579 = sext i32 %577 to i64
  %580 = shl nsw i64 %579, 5
  %581 = getelementptr i8, ptr %578, i64 %580
  %582 = load ptr, ptr %581, align 8
  %583 = icmp eq ptr %582, @nil_typ
  %584 = icmp eq ptr %582, null
  %585 = or i1 %583, %584
  br i1 %585, label %._crit_edge105.loopexit.i1481, label %534

._crit_edge105.loopexit.i1481:                    ; preds = %._crit_edge.thread.i1474
  %586 = icmp eq i32 %spec.store.select.i1479, -1
  %.pre.i1484.pre = select i1 %586, i32 %577, i32 %spec.store.select.i1479
  br label %HashMap_find_slot_keyK_hashPtri32.exit1488

HashMap_find_slot_keyK_hashPtri32.exit1488.loopexit: ; preds = %._crit_edge.i1485
  %.pre1599 = load ptr, ptr %12, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit1488

HashMap_find_slot_keyK_hashPtri32.exit1488:       ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1488.loopexit, %509, %._crit_edge105.loopexit.i1481
  %587 = phi ptr [ %578, %._crit_edge105.loopexit.i1481 ], [ %525, %509 ], [ %.pre1599, %HashMap_find_slot_keyK_hashPtri32.exit1488.loopexit ]
  %588 = phi i32 [ %.pre.i1484.pre, %._crit_edge105.loopexit.i1481 ], [ %523, %509 ], [ %535, %HashMap_find_slot_keyK_hashPtri32.exit1488.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %589 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %590 = sext i32 %588 to i64
  %591 = shl nsw i64 %590, 5
  %592 = getelementptr i8, ptr %587, i64 %591
  %593 = load ptr, ptr %592, align 8
  %594 = getelementptr i8, ptr %592, i64 8
  %595 = load i64, ptr %594, align 4
  %.sroa_idx.i1321 = getelementptr i8, ptr %592, i64 16
  %596 = load i64, ptr %.sroa_idx.i1321, align 4
  %597 = load ptr, ptr %5, align 8
  %598 = load ptr, ptr %520, align 8, !alias.scope !46
  %599 = getelementptr i8, ptr %598, i64 72
  %600 = load ptr, ptr %599, align 8, !alias.scope !46
  %result.i.i.i1323 = call { i64, i64 } %600(ptr nocapture nofree nonnull readonly %520) #5, !alias.scope !46
  %601 = extractvalue { i64, i64 } %result.i.i.i1323, 0
  %602 = extractvalue { i64, i64 } %result.i.i.i1323, 1
  %603 = call i64 @llvm.umax.i64(i64 %602, i64 8)
  %604 = urem i64 20, %602
  %605 = icmp eq i64 %604, 0
  %606 = sub i64 %602, %604
  %607 = select i1 %605, i64 0, i64 %606
  %608 = add i64 %601, 20
  %609 = add i64 %608, %607
  %610 = and i64 %609, 7
  %611 = icmp eq i64 %610, 0
  %612 = sub nuw nsw i64 40, %610
  %613 = select i1 %611, i64 32, i64 %612
  %614 = add i64 %613, %609
  %615 = urem i64 %614, %603
  %616 = icmp eq i64 %615, 0
  %617 = sub i64 %603, %615
  %618 = select i1 %616, i64 0, i64 %617
  %619 = add i64 %614, %618
  %result.i71.i1324 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %619, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %520, ptr %result.i71.i1324, align 8
  %620 = getelementptr inbounds i8, ptr %result.i71.i1324, i64 8
  store ptr %597, ptr %620, align 8
  %621 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i1324)
  %622 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %result.i71.i1324, 1
  %623 = insertvalue { ptr, ptr, ptr, i32 } %622, ptr undef, 2
  %624 = insertvalue { ptr, ptr, ptr, i32 } %623, i32 10, 3
  store ptr %520, ptr %3, align 8
  store ptr %597, ptr %452, align 8
  store ptr @_parameterization_Ptri32, ptr %453, align 8
  %625 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %3)
  %626 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Entry)
  %627 = load i64, ptr %500, align 4
  %628 = load i64, ptr %501, align 4
  %629 = load ptr, ptr %502, align 8
  %630 = load ptr, ptr %503, align 8
  %result.i.i117.i1325 = call i1 %629(i64 %628, i64 %627, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %630) #5
  %631 = select i1 %result.i.i117.i1325, i64 9, i64 10
  %gep1359 = getelementptr [14 x ptr], ptr getelementptr inbounds (i8, ptr @Entry, i64 80), i64 0, i64 %631
  %632 = load ptr, ptr %gep1359, align 8
  call void %632({ ptr, ptr, ptr, i32 } %624, { ptr, ptr, ptr, i32 } %624, ptr nonnull align 8 dereferenceable(24) %3, { ptr, i160 } %514, { ptr, i160 } %495, i32 %519) #7
  %633 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %634 = load ptr, ptr %12, align 8
  %635 = getelementptr i8, ptr %634, i64 %591
  store ptr @Entry, ptr %635, align 8
  %636 = getelementptr i8, ptr %635, i64 8
  %637 = ptrtoint ptr %result.i71.i1324 to i64
  store i64 %637, ptr %636, align 4
  %.sroa_idx4.i1327 = getelementptr i8, ptr %635, i64 24
  store i32 10, ptr %.sroa_idx4.i1327, align 4
  %638 = icmp eq ptr %593, @nil_typ
  %639 = icmp eq ptr %593, null
  %640 = or i1 %638, %639
  br i1 %640, label %641, label %644

641:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1488
  %642 = load i32, ptr %451, align 4
  %643 = add i32 %642, 1
  store i32 %643, ptr %451, align 4
  br label %._crit_edge.sink.split.i1344

644:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1488
  %645 = inttoptr i64 %595 to ptr
  %646 = inttoptr i64 %596 to ptr
  %hash_coef_ptr.i.i88.i1328 = getelementptr i8, ptr %593, i64 8
  %tbl_size_ptr.i.i89.i1329 = getelementptr i8, ptr %593, i64 16
  %offset_tbl_ptr.i.i90.i1330 = getelementptr i8, ptr %593, i64 40
  %hash_coef.i.i91.i1331 = load i64, ptr %hash_coef_ptr.i.i88.i1328, align 4, !noalias !49
  %tbl_size.i.i92.i1332 = load i64, ptr %tbl_size_ptr.i.i89.i1329, align 4, !noalias !49
  %offset_tbl.i.i93.i1333 = load ptr, ptr %offset_tbl_ptr.i.i90.i1330, align 8, !noalias !49
  %product.i.i.i94.i1334 = mul i64 %hash_coef.i.i91.i1331, 4015701072841558310
  %shifted.i.i.i95.i1335 = lshr i64 %product.i.i.i94.i1334, 32
  %xored.i.i.i96.i1336 = xor i64 %shifted.i.i.i95.i1335, %product.i.i.i94.i1334
  %hash.i.i.i97.i1337 = and i64 %xored.i.i.i96.i1336, %tbl_size.i.i92.i1332
  %offset_ptr.i.i98.i1338 = getelementptr i32, ptr %offset_tbl.i.i93.i1333, i64 %hash.i.i.i97.i1337
  %offset.i.i99.i1339 = load i32, ptr %offset_ptr.i.i98.i1338, align 4, !noalias !49
  %647 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %593, 0
  %648 = insertvalue { ptr, ptr, ptr, i32 } %647, ptr %645, 1
  %649 = insertvalue { ptr, ptr, ptr, i32 } %648, ptr %646, 2
  %650 = insertvalue { ptr, ptr, ptr, i32 } %649, i32 %offset.i.i99.i1339, 3
  %651 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %652 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %593)
  %653 = sext i32 %offset.i.i99.i1339 to i64
  %654 = getelementptr ptr, ptr %593, i64 %653
  %655 = getelementptr i8, ptr %654, i64 56
  %656 = load ptr, ptr %655, align 8
  %result.i101.i1340 = call ptr %656({ ptr, ptr, ptr, i32 } %650, ptr nocapture nofree noundef nonnull readonly %2) #16
  %657 = call { ptr, i160 } %result.i101.i1340({ ptr, ptr, ptr, i32 } %650, { ptr, ptr, ptr, i32 } %650, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i1341 = extractvalue { ptr, i160 } %657, 0
  %658 = getelementptr i8, ptr %.fca.0.extract51.i1341, i64 8
  %659 = getelementptr i8, ptr %.fca.0.extract51.i1341, i64 16
  %660 = getelementptr i8, ptr %.fca.0.extract51.i1341, i64 24
  %661 = getelementptr i8, ptr %.fca.0.extract51.i1341, i64 32
  %662 = load i64, ptr %658, align 4
  %663 = load i64, ptr %659, align 4
  %664 = load ptr, ptr %660, align 8
  %665 = load ptr, ptr %661, align 8
  %result.i102.i1342 = call i1 %664(i64 %663, i64 %662, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %665) #5
  br i1 %result.i102.i1342, label %._crit_edge.sink.split.i1344, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1346

._crit_edge.sink.split.i1344:                     ; preds = %644, %641
  %.sink159.i1345 = phi i64 [ 48, %641 ], [ 40, %644 ]
  %666 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %667 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i1345
  %668 = load ptr, ptr %667, align 8
  %669 = load ptr, ptr %668, align 8
  %670 = call i32 %669(ptr nonnull %result.i268) #36
  %671 = add i32 %670, 1
  %672 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %673 = getelementptr i8, ptr %668, i64 8
  %674 = load ptr, ptr %673, align 8
  call void %674(ptr nonnull %result.i268, i32 %671) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1346

HashMap_insert_internal_keyK_valueV_hashPtri32.exit1346: ; preds = %644, %._crit_edge.sink.split.i1344
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %3)
  br label %._crit_edge.i1105

._crit_edge.i1105:                                ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1346, %479, %.lr.ph.i1102
  %675 = add nuw nsw i32 %.096.i1103, 1
  %676 = icmp slt i32 %675, %461
  br i1 %676, label %.lr.ph.i1102, label %HashMap_resize_new_capacityPtri32.exit1128

HashMap_resize_new_capacityPtri32.exit1128:       ; preds = %._crit_edge.i1105, %._crit_edge1.i852
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_ensure_capacity_required_loadPtri32.exit856

HashMap_ensure_capacity_required_loadPtri32.exit856: ; preds = %._crit_edge3, %HashMap_resize_new_capacityPtri32.exit1128
  %677 = load ptr, ptr %10, align 8
  %678 = call i32 %677({ ptr, i160 } %459) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %679 = load ptr, ptr %result.i268, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %680 = load i32, ptr %13, align 8
  %681 = add i32 %680, -1
  %682 = and i32 %681, %678
  %683 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %684 = load ptr, ptr %12, align 8
  %685 = sext i32 %682 to i64
  %686 = shl nsw i64 %685, 5
  %687 = getelementptr i8, ptr %684, i64 %686
  %688 = load ptr, ptr %687, align 8
  %689 = icmp eq ptr %688, @nil_typ
  %690 = icmp eq ptr %688, null
  %691 = or i1 %689, %690
  br i1 %691, label %HashMap_find_slot_keyK_hashPtri32.exit1173, label %.lr.ph.i1143

.lr.ph.i1143:                                     ; preds = %HashMap_ensure_capacity_required_loadPtri32.exit856
  %692 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %693

693:                                              ; preds = %._crit_edge.thread.i1159, %.lr.ph.i1143
  %694 = phi i32 [ %682, %.lr.ph.i1143 ], [ %736, %._crit_edge.thread.i1159 ]
  %spec.store.select.i11641201 = phi i32 [ -1, %.lr.ph.i1143 ], [ %spec.store.select.i1164, %._crit_edge.thread.i1159 ]
  %695 = phi ptr [ %688, %.lr.ph.i1143 ], [ %741, %._crit_edge.thread.i1159 ]
  %696 = phi ptr [ %687, %.lr.ph.i1143 ], [ %740, %._crit_edge.thread.i1159 ]
  %.sroa_idx.i1145 = getelementptr i8, ptr %696, i64 16
  %697 = load i64, ptr %.sroa_idx.i1145, align 4
  %698 = getelementptr i8, ptr %696, i64 8
  %699 = load i64, ptr %698, align 4
  %700 = inttoptr i64 %699 to ptr
  %701 = inttoptr i64 %697 to ptr
  %hash_coef_ptr.i.i56.i1146 = getelementptr i8, ptr %695, i64 8
  %tbl_size_ptr.i.i57.i1147 = getelementptr i8, ptr %695, i64 16
  %offset_tbl_ptr.i.i58.i1148 = getelementptr i8, ptr %695, i64 40
  %hash_coef.i.i59.i1149 = load i64, ptr %hash_coef_ptr.i.i56.i1146, align 4
  %tbl_size.i.i60.i1150 = load i64, ptr %tbl_size_ptr.i.i57.i1147, align 4
  %offset_tbl.i.i61.i1151 = load ptr, ptr %offset_tbl_ptr.i.i58.i1148, align 8
  %product.i.i.i62.i1152 = mul i64 %hash_coef.i.i59.i1149, 4015701072841558310
  %shifted.i.i.i63.i1153 = lshr i64 %product.i.i.i62.i1152, 32
  %xored.i.i.i64.i1154 = xor i64 %shifted.i.i.i63.i1153, %product.i.i.i62.i1152
  %hash.i.i.i65.i1155 = and i64 %xored.i.i.i64.i1154, %tbl_size.i.i60.i1150
  %offset_ptr.i.i66.i1156 = getelementptr i32, ptr %offset_tbl.i.i61.i1151, i64 %hash.i.i.i65.i1155
  %offset.i.i67.i1157 = load i32, ptr %offset_ptr.i.i66.i1156, align 4
  %702 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %695, 0
  %703 = insertvalue { ptr, ptr, ptr, i32 } %702, ptr %700, 1
  %704 = insertvalue { ptr, ptr, ptr, i32 } %703, ptr %701, 2
  %705 = insertvalue { ptr, ptr, ptr, i32 } %704, i32 %offset.i.i67.i1157, 3
  %706 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %695)
  %707 = sext i32 %offset.i.i67.i1157 to i64
  %708 = getelementptr ptr, ptr %695, i64 %707
  %709 = getelementptr i8, ptr %708, i64 64
  %710 = load ptr, ptr %709, align 8
  %result.i.i1158 = call ptr %710({ ptr, ptr, ptr, i32 } %705, ptr nocapture nofree noundef nonnull readonly %2) #16
  %711 = call i32 %result.i.i1158({ ptr, ptr, ptr, i32 } %705, { ptr, ptr, ptr, i32 } %705, ptr nonnull align 8 %2) #7
  %712 = icmp eq i32 %711, %678
  br i1 %712, label %._crit_edge.i1170, label %._crit_edge.thread.i1159

._crit_edge.i1170:                                ; preds = %693
  %713 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %714 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %695)
  %715 = getelementptr i8, ptr %708, i64 48
  %716 = load ptr, ptr %715, align 8
  %result.i69.i1171 = call ptr %716({ ptr, ptr, ptr, i32 } %705, ptr nocapture nofree noundef nonnull readonly %2) #16
  %717 = call { ptr, i160 } %result.i69.i1171({ ptr, ptr, ptr, i32 } %705, { ptr, ptr, ptr, i32 } %705, ptr nonnull align 8 %2) #7
  %718 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %719 = load ptr, ptr %11, align 8
  %720 = call i1 %719({ ptr, i160 } %717, { ptr, i160 } %459) #7
  br i1 %720, label %HashMap_find_slot_keyK_hashPtri32.exit1173.loopexit, label %._crit_edge.thread.i1159

._crit_edge.thread.i1159:                         ; preds = %._crit_edge.i1170, %693
  %721 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %722 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %695)
  %723 = getelementptr i8, ptr %708, i64 56
  %724 = load ptr, ptr %723, align 8
  %result.i70.i1160 = call ptr %724({ ptr, ptr, ptr, i32 } %705, ptr nocapture nofree noundef nonnull readonly %2) #16
  %725 = call { ptr, i160 } %result.i70.i1160({ ptr, ptr, ptr, i32 } %705, { ptr, ptr, ptr, i32 } %705, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i1161 = extractvalue { ptr, i160 } %725, 0
  %726 = getelementptr i8, ptr %.fca.0.extract19.i1161, i64 8
  %727 = getelementptr i8, ptr %.fca.0.extract19.i1161, i64 16
  %728 = getelementptr i8, ptr %.fca.0.extract19.i1161, i64 24
  %729 = getelementptr i8, ptr %.fca.0.extract19.i1161, i64 32
  %730 = load i64, ptr %726, align 4
  %731 = load i64, ptr %727, align 4
  %732 = load ptr, ptr %728, align 8
  %733 = load ptr, ptr %729, align 8
  %result.i71.i1162 = call i1 %732(i64 %731, i64 %730, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %733) #5
  %734 = icmp eq i32 %spec.store.select.i11641201, -1
  %or.cond.i1163 = select i1 %result.i71.i1162, i1 %734, i1 false
  %spec.store.select.i1164 = select i1 %or.cond.i1163, i32 %694, i32 %spec.store.select.i11641201
  %735 = add i32 %694, 1
  %736 = and i32 %735, %681
  %737 = load ptr, ptr %12, align 8
  %738 = sext i32 %736 to i64
  %739 = shl nsw i64 %738, 5
  %740 = getelementptr i8, ptr %737, i64 %739
  %741 = load ptr, ptr %740, align 8
  %742 = icmp eq ptr %741, @nil_typ
  %743 = icmp eq ptr %741, null
  %744 = or i1 %742, %743
  br i1 %744, label %._crit_edge105.loopexit.i1166, label %693

._crit_edge105.loopexit.i1166:                    ; preds = %._crit_edge.thread.i1159
  %745 = icmp eq i32 %spec.store.select.i1164, -1
  %.pre.i1169.pre = select i1 %745, i32 %736, i32 %spec.store.select.i1164
  br label %HashMap_find_slot_keyK_hashPtri32.exit1173

HashMap_find_slot_keyK_hashPtri32.exit1173.loopexit: ; preds = %._crit_edge.i1170
  %.pre1265 = load ptr, ptr %12, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit1173

HashMap_find_slot_keyK_hashPtri32.exit1173:       ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1173.loopexit, %HashMap_ensure_capacity_required_loadPtri32.exit856, %._crit_edge105.loopexit.i1166
  %746 = phi ptr [ %737, %._crit_edge105.loopexit.i1166 ], [ %684, %HashMap_ensure_capacity_required_loadPtri32.exit856 ], [ %.pre1265, %HashMap_find_slot_keyK_hashPtri32.exit1173.loopexit ]
  %747 = phi i32 [ %.pre.i1169.pre, %._crit_edge105.loopexit.i1166 ], [ %682, %HashMap_ensure_capacity_required_loadPtri32.exit856 ], [ %694, %HashMap_find_slot_keyK_hashPtri32.exit1173.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %748 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %749 = sext i32 %747 to i64
  %750 = shl nsw i64 %749, 5
  %751 = getelementptr i8, ptr %746, i64 %750
  %752 = load ptr, ptr %751, align 8
  %753 = getelementptr i8, ptr %751, i64 8
  %754 = load i64, ptr %753, align 4
  %.sroa_idx.i876 = getelementptr i8, ptr %751, i64 16
  %755 = load i64, ptr %.sroa_idx.i876, align 4
  %756 = load ptr, ptr %5, align 8
  %757 = load ptr, ptr %679, align 8, !alias.scope !52
  %758 = getelementptr i8, ptr %757, i64 72
  %759 = load ptr, ptr %758, align 8, !alias.scope !52
  %result.i.i.i878 = call { i64, i64 } %759(ptr nocapture nofree nonnull readonly %679) #5, !alias.scope !52
  %760 = extractvalue { i64, i64 } %result.i.i.i878, 0
  %761 = extractvalue { i64, i64 } %result.i.i.i878, 1
  %762 = call i64 @llvm.umax.i64(i64 %761, i64 8)
  %763 = urem i64 20, %761
  %764 = icmp eq i64 %763, 0
  %765 = sub i64 %761, %763
  %766 = select i1 %764, i64 0, i64 %765
  %767 = add i64 %760, 20
  %768 = add i64 %767, %766
  %769 = and i64 %768, 7
  %770 = icmp eq i64 %769, 0
  %771 = sub nuw nsw i64 40, %769
  %772 = select i1 %770, i64 32, i64 %771
  %773 = add i64 %772, %768
  %774 = urem i64 %773, %762
  %775 = icmp eq i64 %774, 0
  %776 = sub i64 %762, %774
  %777 = select i1 %775, i64 0, i64 %776
  %778 = add i64 %773, %777
  %result.i71.i879 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %778, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %679, ptr %result.i71.i879, align 8
  %779 = getelementptr inbounds i8, ptr %result.i71.i879, i64 8
  store ptr %756, ptr %779, align 8
  %780 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i879)
  %781 = load ptr, ptr %679, align 8
  %782 = getelementptr i8, ptr %781, i64 72
  %783 = load ptr, ptr %782, align 8
  %result.i.i1240 = call { i64, i64 } %783(ptr nocapture nofree nonnull readonly %679) #5
  %784 = extractvalue { i64, i64 } %result.i.i1240, 1
  %785 = urem i64 20, %784
  %786 = icmp eq i64 %785, 0
  %reass.sub = sub i64 %784, %785
  %787 = add i64 %reass.sub, 20
  %788 = select i1 %786, i64 20, i64 %787
  %789 = getelementptr i8, ptr %result.i71.i879, i64 %788
  %790 = getelementptr i8, ptr %781, i64 64
  %791 = load ptr, ptr %790, align 8
  call void %791({ ptr, i160 } %459, ptr nocapture nofree nonnull readonly %679, ptr nocapture nofree writeonly %789) #13
  %792 = load ptr, ptr %result.i71.i879, align 8
  %793 = load ptr, ptr %792, align 8
  %794 = getelementptr i8, ptr %793, i64 72
  %795 = load ptr, ptr %794, align 8
  %result.i.i1242 = call { i64, i64 } %795(ptr nocapture nofree nonnull readonly %792) #5
  %796 = extractvalue { i64, i64 } %result.i.i1242, 0
  %797 = extractvalue { i64, i64 } %result.i.i1242, 1
  %798 = urem i64 20, %797
  %799 = icmp eq i64 %798, 0
  %800 = sub i64 %797, %798
  %801 = select i1 %799, i64 0, i64 %800
  %802 = add i64 %796, 20
  %803 = add i64 %802, %801
  %804 = and i64 %803, 7
  %805 = icmp eq i64 %804, 0
  %806 = sub nuw nsw i64 8, %804
  %807 = select i1 %805, i64 0, i64 %806
  %808 = getelementptr i8, ptr %result.i71.i879, i64 %803
  %809 = getelementptr i8, ptr %808, i64 %807
  store ptr @i32_typ, ptr %809, align 8
  %810 = getelementptr i8, ptr %809, i64 8
  store i160 %.sroa.0211.0.insert.ext, ptr %810, align 4
  %811 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @Entry) #34
  %812 = getelementptr inbounds i8, ptr %result.i71.i879, i64 16
  store i32 %678, ptr %812, align 8
  %813 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  store ptr @Entry, ptr %751, align 8
  %814 = ptrtoint ptr %result.i71.i879 to i64
  store i64 %814, ptr %753, align 4
  %.sroa_idx4.i882 = getelementptr i8, ptr %751, i64 24
  store i32 10, ptr %.sroa_idx4.i882, align 4
  %815 = icmp eq ptr %752, @nil_typ
  %816 = icmp eq ptr %752, null
  %817 = or i1 %815, %816
  br i1 %817, label %818, label %821

818:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1173
  %819 = load i32, ptr %451, align 4
  %820 = add i32 %819, 1
  store i32 %820, ptr %451, align 4
  br label %._crit_edge.sink.split.i899

821:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1173
  %822 = inttoptr i64 %754 to ptr
  %823 = inttoptr i64 %755 to ptr
  %hash_coef_ptr.i.i88.i883 = getelementptr i8, ptr %752, i64 8
  %tbl_size_ptr.i.i89.i884 = getelementptr i8, ptr %752, i64 16
  %offset_tbl_ptr.i.i90.i885 = getelementptr i8, ptr %752, i64 40
  %hash_coef.i.i91.i886 = load i64, ptr %hash_coef_ptr.i.i88.i883, align 4, !noalias !55
  %tbl_size.i.i92.i887 = load i64, ptr %tbl_size_ptr.i.i89.i884, align 4, !noalias !55
  %offset_tbl.i.i93.i888 = load ptr, ptr %offset_tbl_ptr.i.i90.i885, align 8, !noalias !55
  %product.i.i.i94.i889 = mul i64 %hash_coef.i.i91.i886, 4015701072841558310
  %shifted.i.i.i95.i890 = lshr i64 %product.i.i.i94.i889, 32
  %xored.i.i.i96.i891 = xor i64 %shifted.i.i.i95.i890, %product.i.i.i94.i889
  %hash.i.i.i97.i892 = and i64 %xored.i.i.i96.i891, %tbl_size.i.i92.i887
  %offset_ptr.i.i98.i893 = getelementptr i32, ptr %offset_tbl.i.i93.i888, i64 %hash.i.i.i97.i892
  %offset.i.i99.i894 = load i32, ptr %offset_ptr.i.i98.i893, align 4, !noalias !55
  %824 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %752, 0
  %825 = insertvalue { ptr, ptr, ptr, i32 } %824, ptr %822, 1
  %826 = insertvalue { ptr, ptr, ptr, i32 } %825, ptr %823, 2
  %827 = insertvalue { ptr, ptr, ptr, i32 } %826, i32 %offset.i.i99.i894, 3
  %828 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %829 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %752)
  %830 = sext i32 %offset.i.i99.i894 to i64
  %831 = getelementptr ptr, ptr %752, i64 %830
  %832 = getelementptr i8, ptr %831, i64 56
  %833 = load ptr, ptr %832, align 8
  %result.i101.i895 = call ptr %833({ ptr, ptr, ptr, i32 } %827, ptr nocapture nofree noundef nonnull readonly %2) #16
  %834 = call { ptr, i160 } %result.i101.i895({ ptr, ptr, ptr, i32 } %827, { ptr, ptr, ptr, i32 } %827, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i896 = extractvalue { ptr, i160 } %834, 0
  %835 = getelementptr i8, ptr %.fca.0.extract51.i896, i64 8
  %836 = getelementptr i8, ptr %.fca.0.extract51.i896, i64 16
  %837 = getelementptr i8, ptr %.fca.0.extract51.i896, i64 24
  %838 = getelementptr i8, ptr %.fca.0.extract51.i896, i64 32
  %839 = load i64, ptr %835, align 4
  %840 = load i64, ptr %836, align 4
  %841 = load ptr, ptr %837, align 8
  %842 = load ptr, ptr %838, align 8
  %result.i102.i897 = call i1 %841(i64 %840, i64 %839, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %842) #5
  br i1 %result.i102.i897, label %._crit_edge.sink.split.i899, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit901

._crit_edge.sink.split.i899:                      ; preds = %821, %818
  %.sink159.i900 = phi i64 [ 48, %818 ], [ 40, %821 ]
  %843 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %844 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i900
  %845 = load ptr, ptr %844, align 8
  %846 = load ptr, ptr %845, align 8
  %847 = call i32 %846(ptr nonnull %result.i268) #36
  %848 = add i32 %847, 1
  %849 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %850 = getelementptr i8, ptr %845, i64 8
  %851 = load ptr, ptr %850, align 8
  call void %851(ptr nonnull %result.i268, i32 %848) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit901

HashMap_insert_internal_keyK_valueV_hashPtri32.exit901: ; preds = %821, %._crit_edge.sink.split.i899
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %852 = add nuw nsw i32 %.2249474, 1
  %853 = icmp slt i32 %852, %0
  br i1 %853, label %._crit_edge3, label %._crit_edge5

._crit_edge5:                                     ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit901
  %854 = call i64 @clock()
  %.sroa.0202.0.insert.ext = zext i32 %spec.select to i160
  %855 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0202.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %856 = load ptr, ptr %10, align 8
  %857 = call i32 %856({ ptr, i160 } %855) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %858 = load i32, ptr %13, align 8
  %859 = add i32 %858, -1
  %860 = and i32 %859, %857
  %861 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %862 = load ptr, ptr %12, align 8
  %863 = sext i32 %860 to i64
  %864 = shl nsw i64 %863, 5
  %865 = getelementptr i8, ptr %862, i64 %864
  %866 = load ptr, ptr %865, align 8
  %867 = icmp eq ptr %866, @nil_typ
  %868 = icmp eq ptr %866, null
  %869 = or i1 %867, %868
  br i1 %869, label %HashMap_find_slot_keyK_hashPtri32.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %._crit_edge5
  %870 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %871

871:                                              ; preds = %._crit_edge.thread.i, %.lr.ph.i
  %872 = phi i32 [ %860, %.lr.ph.i ], [ %914, %._crit_edge.thread.i ]
  %spec.store.select.i1013 = phi i32 [ -1, %.lr.ph.i ], [ %spec.store.select.i, %._crit_edge.thread.i ]
  %873 = phi ptr [ %866, %.lr.ph.i ], [ %919, %._crit_edge.thread.i ]
  %874 = phi ptr [ %865, %.lr.ph.i ], [ %918, %._crit_edge.thread.i ]
  %.sroa_idx.i914 = getelementptr i8, ptr %874, i64 16
  %875 = load i64, ptr %.sroa_idx.i914, align 4
  %876 = getelementptr i8, ptr %874, i64 8
  %877 = load i64, ptr %876, align 4
  %878 = inttoptr i64 %877 to ptr
  %879 = inttoptr i64 %875 to ptr
  %hash_coef_ptr.i.i56.i = getelementptr i8, ptr %873, i64 8
  %tbl_size_ptr.i.i57.i = getelementptr i8, ptr %873, i64 16
  %offset_tbl_ptr.i.i58.i = getelementptr i8, ptr %873, i64 40
  %hash_coef.i.i59.i = load i64, ptr %hash_coef_ptr.i.i56.i, align 4
  %tbl_size.i.i60.i = load i64, ptr %tbl_size_ptr.i.i57.i, align 4
  %offset_tbl.i.i61.i = load ptr, ptr %offset_tbl_ptr.i.i58.i, align 8
  %product.i.i.i62.i = mul i64 %hash_coef.i.i59.i, 4015701072841558310
  %shifted.i.i.i63.i = lshr i64 %product.i.i.i62.i, 32
  %xored.i.i.i64.i = xor i64 %shifted.i.i.i63.i, %product.i.i.i62.i
  %hash.i.i.i65.i = and i64 %xored.i.i.i64.i, %tbl_size.i.i60.i
  %offset_ptr.i.i66.i = getelementptr i32, ptr %offset_tbl.i.i61.i, i64 %hash.i.i.i65.i
  %offset.i.i67.i = load i32, ptr %offset_ptr.i.i66.i, align 4
  %880 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %873, 0
  %881 = insertvalue { ptr, ptr, ptr, i32 } %880, ptr %878, 1
  %882 = insertvalue { ptr, ptr, ptr, i32 } %881, ptr %879, 2
  %883 = insertvalue { ptr, ptr, ptr, i32 } %882, i32 %offset.i.i67.i, 3
  %884 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %873)
  %885 = sext i32 %offset.i.i67.i to i64
  %886 = getelementptr ptr, ptr %873, i64 %885
  %887 = getelementptr i8, ptr %886, i64 64
  %888 = load ptr, ptr %887, align 8
  %result.i.i915 = call ptr %888({ ptr, ptr, ptr, i32 } %883, ptr nocapture nofree noundef nonnull readonly %2) #16
  %889 = call i32 %result.i.i915({ ptr, ptr, ptr, i32 } %883, { ptr, ptr, ptr, i32 } %883, ptr nonnull align 8 %2) #7
  %890 = icmp eq i32 %889, %857
  br i1 %890, label %._crit_edge.i917, label %._crit_edge.thread.i

._crit_edge.i917:                                 ; preds = %871
  %891 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %892 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %873)
  %893 = getelementptr i8, ptr %886, i64 48
  %894 = load ptr, ptr %893, align 8
  %result.i69.i918 = call ptr %894({ ptr, ptr, ptr, i32 } %883, ptr nocapture nofree noundef nonnull readonly %2) #16
  %895 = call { ptr, i160 } %result.i69.i918({ ptr, ptr, ptr, i32 } %883, { ptr, ptr, ptr, i32 } %883, ptr nonnull align 8 %2) #7
  %896 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %897 = load ptr, ptr %11, align 8
  %898 = call i1 %897({ ptr, i160 } %895, { ptr, i160 } %855) #7
  br i1 %898, label %HashMap_find_slot_keyK_hashPtri32.exit.loopexit, label %._crit_edge.thread.i

._crit_edge.thread.i:                             ; preds = %._crit_edge.i917, %871
  %899 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %900 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %873)
  %901 = getelementptr i8, ptr %886, i64 56
  %902 = load ptr, ptr %901, align 8
  %result.i70.i = call ptr %902({ ptr, ptr, ptr, i32 } %883, ptr nocapture nofree noundef nonnull readonly %2) #16
  %903 = call { ptr, i160 } %result.i70.i({ ptr, ptr, ptr, i32 } %883, { ptr, ptr, ptr, i32 } %883, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i = extractvalue { ptr, i160 } %903, 0
  %904 = getelementptr i8, ptr %.fca.0.extract19.i, i64 8
  %905 = getelementptr i8, ptr %.fca.0.extract19.i, i64 16
  %906 = getelementptr i8, ptr %.fca.0.extract19.i, i64 24
  %907 = getelementptr i8, ptr %.fca.0.extract19.i, i64 32
  %908 = load i64, ptr %904, align 4
  %909 = load i64, ptr %905, align 4
  %910 = load ptr, ptr %906, align 8
  %911 = load ptr, ptr %907, align 8
  %result.i71.i916 = call i1 %910(i64 %909, i64 %908, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %911) #5
  %912 = icmp eq i32 %spec.store.select.i1013, -1
  %or.cond.i = select i1 %result.i71.i916, i1 %912, i1 false
  %spec.store.select.i = select i1 %or.cond.i, i32 %872, i32 %spec.store.select.i1013
  %913 = add i32 %872, 1
  %914 = and i32 %913, %859
  %915 = load ptr, ptr %12, align 8
  %916 = sext i32 %914 to i64
  %917 = shl nsw i64 %916, 5
  %918 = getelementptr i8, ptr %915, i64 %917
  %919 = load ptr, ptr %918, align 8
  %920 = icmp eq ptr %919, @nil_typ
  %921 = icmp eq ptr %919, null
  %922 = or i1 %920, %921
  br i1 %922, label %._crit_edge105.loopexit.i, label %871

._crit_edge105.loopexit.i:                        ; preds = %._crit_edge.thread.i
  %923 = icmp eq i32 %spec.store.select.i, -1
  %.pre.i.pre = select i1 %923, i32 %914, i32 %spec.store.select.i
  br label %HashMap_find_slot_keyK_hashPtri32.exit

HashMap_find_slot_keyK_hashPtri32.exit.loopexit:  ; preds = %._crit_edge.i917
  %.pre = load ptr, ptr %12, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit

HashMap_find_slot_keyK_hashPtri32.exit:           ; preds = %HashMap_find_slot_keyK_hashPtri32.exit.loopexit, %._crit_edge5, %._crit_edge105.loopexit.i
  %924 = phi ptr [ %915, %._crit_edge105.loopexit.i ], [ %862, %._crit_edge5 ], [ %.pre, %HashMap_find_slot_keyK_hashPtri32.exit.loopexit ]
  %925 = phi i32 [ %.pre.i.pre, %._crit_edge105.loopexit.i ], [ %860, %._crit_edge5 ], [ %872, %HashMap_find_slot_keyK_hashPtri32.exit.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %926 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %927 = sext i32 %925 to i64
  %928 = shl nsw i64 %927, 5
  %929 = getelementptr i8, ptr %924, i64 %928
  %930 = load ptr, ptr %929, align 8
  %931 = icmp ne ptr %930, @nil_typ
  %932 = icmp ne ptr %930, null
  %.not57.i = and i1 %931, %932
  br i1 %.not57.i, label %933, label %HashMap_get_keyK.exit.thread

933:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit
  %934 = getelementptr i8, ptr %929, i64 8
  %935 = load i64, ptr %934, align 4
  %.sroa_idx.i = getelementptr i8, ptr %929, i64 16
  %936 = load i64, ptr %.sroa_idx.i, align 4
  %937 = inttoptr i64 %935 to ptr
  %938 = inttoptr i64 %936 to ptr
  %hash_coef_ptr.i.i60.i = getelementptr i8, ptr %930, i64 8
  %tbl_size_ptr.i.i61.i = getelementptr i8, ptr %930, i64 16
  %offset_tbl_ptr.i.i62.i = getelementptr i8, ptr %930, i64 40
  %hash_coef.i.i63.i = load i64, ptr %hash_coef_ptr.i.i60.i, align 4, !noalias !58
  %tbl_size.i.i64.i = load i64, ptr %tbl_size_ptr.i.i61.i, align 4, !noalias !58
  %offset_tbl.i.i65.i = load ptr, ptr %offset_tbl_ptr.i.i62.i, align 8, !noalias !58
  %product.i.i.i66.i = mul i64 %hash_coef.i.i63.i, 4015701072841558310
  %shifted.i.i.i67.i = lshr i64 %product.i.i.i66.i, 32
  %xored.i.i.i68.i = xor i64 %shifted.i.i.i67.i, %product.i.i.i66.i
  %hash.i.i.i69.i = and i64 %xored.i.i.i68.i, %tbl_size.i.i64.i
  %offset_ptr.i.i70.i = getelementptr i32, ptr %offset_tbl.i.i65.i, i64 %hash.i.i.i69.i
  %offset.i.i71.i = load i32, ptr %offset_ptr.i.i70.i, align 4, !noalias !58
  %939 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %930, 0
  %940 = insertvalue { ptr, ptr, ptr, i32 } %939, ptr %937, 1
  %941 = insertvalue { ptr, ptr, ptr, i32 } %940, ptr %938, 2
  %942 = insertvalue { ptr, ptr, ptr, i32 } %941, i32 %offset.i.i71.i, 3
  %943 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %944 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %930)
  %945 = sext i32 %offset.i.i71.i to i64
  %946 = getelementptr ptr, ptr %930, i64 %945
  %947 = getelementptr i8, ptr %946, i64 56
  %948 = load ptr, ptr %947, align 8
  %result.i73.i = call ptr %948({ ptr, ptr, ptr, i32 } %942, ptr nocapture nofree noundef nonnull readonly %2) #16
  %949 = call { ptr, i160 } %result.i73.i({ ptr, ptr, ptr, i32 } %942, { ptr, ptr, ptr, i32 } %942, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i = extractvalue { ptr, i160 } %949, 0
  %.fca.1.extract52.i = extractvalue { ptr, i160 } %949, 1
  %950 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %951 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %930)
  %952 = getelementptr i8, ptr %946, i64 64
  %953 = load ptr, ptr %952, align 8
  %result.i74.i = call ptr %953({ ptr, ptr, ptr, i32 } %942, ptr nocapture nofree noundef nonnull readonly %2) #16
  %954 = call i32 %result.i74.i({ ptr, ptr, ptr, i32 } %942, { ptr, ptr, ptr, i32 } %942, ptr nonnull align 8 %2) #7
  %955 = icmp eq i32 %954, %857
  br i1 %955, label %._crit_edge.i, label %HashMap_get_keyK.exit.thread

._crit_edge.i:                                    ; preds = %933
  %956 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %957 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %930)
  %958 = getelementptr i8, ptr %946, i64 48
  %959 = load ptr, ptr %958, align 8
  %result.i75.i = call ptr %959({ ptr, ptr, ptr, i32 } %942, ptr nocapture nofree noundef nonnull readonly %2) #16
  %960 = call { ptr, i160 } %result.i75.i({ ptr, ptr, ptr, i32 } %942, { ptr, ptr, ptr, i32 } %942, ptr nonnull align 8 %2) #7
  %961 = load ptr, ptr %11, align 8
  %962 = call i1 %961({ ptr, i160 } %960, { ptr, i160 } %855) #7
  br i1 %962, label %HashMap_get_keyK.exit, label %HashMap_get_keyK.exit.thread

HashMap_get_keyK.exit.thread:                     ; preds = %HashMap_find_slot_keyK_hashPtri32.exit, %933, %._crit_edge.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %._crit_edge7

HashMap_get_keyK.exit:                            ; preds = %._crit_edge.i
  %963 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %964 = load ptr, ptr %5, align 8
  %965 = load ptr, ptr %964, align 8
  %966 = ptrtoint ptr %965 to i64
  %967 = getelementptr i8, ptr %.fca.0.extract51.i, i64 8
  %968 = getelementptr i8, ptr %.fca.0.extract51.i, i64 16
  %969 = getelementptr i8, ptr %.fca.0.extract51.i, i64 24
  %970 = getelementptr i8, ptr %.fca.0.extract51.i, i64 32
  %971 = load i64, ptr %967, align 4
  %972 = load i64, ptr %968, align 4
  %973 = load ptr, ptr %969, align 8
  %974 = load ptr, ptr %970, align 8
  %975 = load i64, ptr %965, align 4
  %result.i77.i = call i1 %973(i64 %972, i64 %971, i64 %975, i64 %966, ptr readonly %974) #5
  %cond.fr.i = freeze i1 %result.i77.i
  %spec.select.i = select i1 %cond.fr.i, ptr %.fca.0.extract51.i, ptr @nil_typ
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %976 = icmp ne ptr %spec.select.i, @nil_typ
  %977 = icmp ne ptr %spec.select.i, null
  %.not260 = and i1 %976, %977
  br i1 %.not260, label %._crit_edge6, label %._crit_edge7

._crit_edge6:                                     ; preds = %HashMap_get_keyK.exit
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract52.i to i32
  %978 = add i32 %spec.select, 1
  %.not264 = icmp eq i32 %978, %.sroa.2.8.extract.trunc
  br label %._crit_edge7

._crit_edge7:                                     ; preds = %HashMap_get_keyK.exit.thread, %HashMap_get_keyK.exit, %._crit_edge6
  %.2252 = phi i1 [ %.not264, %._crit_edge6 ], [ false, %HashMap_get_keyK.exit ], [ false, %HashMap_get_keyK.exit.thread ]
  %979 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %980 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #34
  %981 = load i32, ptr %451, align 4
  %.not265 = icmp eq i32 %981, %447
  %982 = select i1 %.not265, i1 %.2252, i1 false
  %983 = select i1 %982, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  br label %._crit_edge.lr.ph.i

._crit_edge.lr.ph.i:                              ; preds = %._crit_edge2._crit_edge.thread, %._crit_edge7
  %984 = phi i64 [ %448, %._crit_edge7 ], [ %30, %._crit_edge2._crit_edge.thread ]
  %985 = phi i32 [ %447, %._crit_edge7 ], [ 0, %._crit_edge2._crit_edge.thread ]
  %986 = phi i64 [ %854, %._crit_edge7 ], [ %31, %._crit_edge2._crit_edge.thread ]
  %.reg2mem21.0.in = phi <4 x i8> [ %983, %._crit_edge7 ], [ <i8 80, i8 65, i8 83, i8 83>, %._crit_edge2._crit_edge.thread ]
  %result.i344 = call noalias align 16 dereferenceable_or_null(14) ptr @bump_malloc_inner(i64 noundef 14, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <13 x i8> <i8 73, i8 110, i8 115, i8 101, i8 114, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109>, ptr %result.i344, align 16
  %987 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #34
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %988 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %989 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i932 = call noalias dereferenceable_or_null(14) ptr @bump_malloc_inner(i64 noundef 14, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(13) %result.i.i932, ptr noundef nonnull align 16 dereferenceable(13) %result.i344, i64 13, i1 false)
  %990 = sub i64 %986, %984
  %991 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %992 = getelementptr i8, ptr %result.i.i932, i64 13
  store i8 0, ptr %992, align 1
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i932)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i97.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i97.i, align 16
  %result.i.i375.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i375.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i97.i, i64 14, i1 false)
  %puts.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i375.i)
  %993 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %0) #17
  %result.i103.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i103.i, align 16
  %result.i.i389.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i389.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i103.i, i64 14, i1 false)
  %puts.i313.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i389.i)
  %994 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %990) #17
  %result.i109.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i109.i, align 4
  %result.i.i408.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i408.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i109.i, i64 3, i1 false)
  %puts.i333.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i408.i)
  br i1 %27, label %._crit_edge1.i, label %._crit_edge.lr.ph.i948

._crit_edge1.i:                                   ; preds = %._crit_edge.lr.ph.i
  %995 = icmp sgt i64 %990, 0
  br i1 %995, label %996, label %._crit_edge.lr.ph.i428.i

996:                                              ; preds = %._crit_edge1.i
  %997 = zext nneg i32 %0 to i64
  %998 = mul i64 %990, 1000000
  %999 = sdiv i64 %998, %997
  br label %._crit_edge.lr.ph.i428.i

._crit_edge.lr.ph.i428.i:                         ; preds = %996, %._crit_edge1.i
  %.0.i = phi i64 [ %999, %996 ], [ 0, %._crit_edge1.i ]
  %result.i114.i = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i114.i, align 16
  %result.i.i427.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i427.i, ptr noundef nonnull align 16 dereferenceable(15) %result.i114.i, i64 15, i1 false)
  %puts.i353.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i427.i)
  %1000 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0.i) #17
  %result.i120.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i120.i, align 4
  %1001 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %result.i.i446.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i446.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i120.i, i64 3, i1 false)
  %1002 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %puts.i373.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i446.i)
  br label %._crit_edge.lr.ph.i948

._crit_edge.lr.ph.i948:                           ; preds = %._crit_edge.lr.ph.i, %._crit_edge.lr.ph.i428.i
  %result.i348 = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i348, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1003 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1004 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i947 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i947, ptr noundef nonnull align 32 dereferenceable(18) %result.i348, i64 18, i1 false)
  %1005 = getelementptr i8, ptr %result.i.i947, i64 18
  store i8 0, ptr %1005, align 1
  %puts.i748 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i947)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1006 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1007 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i966 = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <4 x i8> %.reg2mem21.0.in, ptr %result.i.i966, align 1
  %1008 = getelementptr i8, ptr %result.i.i966, i64 4
  store i8 0, ptr %1008, align 1
  %puts.i768 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i966)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i363 = call noalias align 32 dereferenceable_or_null(28) ptr @bump_malloc_inner(i64 noundef 28, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <27 x i8> <i8 32, i8 32, i8 32, i8 32, i8 40, i8 69, i8 120, i8 112, i8 101, i8 99, i8 116, i8 101, i8 100, i8 32, i8 117, i8 110, i8 105, i8 113, i8 117, i8 101, i8 32, i8 115, i8 105, i8 122, i8 101, i8 58, i8 32>, ptr %result.i363, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1009 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1010 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i985 = call noalias dereferenceable_or_null(28) ptr @bump_malloc_inner(i64 noundef 28, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(27) %result.i.i985, ptr noundef nonnull align 32 dereferenceable(27) %result.i363, i64 27, i1 false)
  %1011 = getelementptr i8, ptr %result.i.i985, i64 27
  store i8 0, ptr %1011, align 1
  %puts.i788 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i985)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1012 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %985) #17
  %1013 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1014 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1015 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1004 = call noalias dereferenceable_or_null(2) ptr @bump_malloc_inner(i64 noundef 2, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store i8 41, ptr %result.i.i1004, align 1
  %1016 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %1017 = getelementptr i8, ptr %result.i.i1004, i64 1
  store i8 0, ptr %1017, align 1
  %puts.i808 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1004)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  ret void
}

define void @benchmark_get_sequential_hit(i32 %0) local_unnamed_addr {
  %2 = alloca [0 x ptr], align 8
  %3 = alloca [3 x ptr], align 8
  %oldProtect.i155 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %result.i151 = tail call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i151, align 8
  %4 = getelementptr inbounds i8, ptr %result.i151, i64 8
  store ptr @_parameterization_Ptri32, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %result.i151, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %5, align 8
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i151) #38
  %result.i152 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i)
  %result.i153 = call i32 @VirtualProtect(ptr nofree %result.i152, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i152, ptr noalias nofree noundef nonnull readnone @ogzjpsiwda, ptr noalias nofree noundef nonnull readnone @i32_hasher) #38
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i152) #39
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i152) #38
  %result.i154 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i155)
  %result.i156 = call i32 @VirtualProtect(ptr nofree %result.i154, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i155) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i155)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i154, ptr noalias nofree noundef nonnull readnone @qqpnfjadrc, ptr noalias nofree noundef nonnull readnone @i32_eq) #38
  %ret.i157 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i154) #39
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i154) #38
  %9 = getelementptr inbounds i8, ptr %result.i151, i64 48
  store ptr %ret.i, ptr %9, align 8
  %10 = getelementptr inbounds i8, ptr %result.i151, i64 56
  store ptr %ret.i157, ptr %10, align 8
  %result.i.i271 = call noalias dereferenceable_or_null(512) ptr @bump_malloc_inner(i64 noundef 512, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %11 = getelementptr inbounds i8, ptr %result.i151, i64 24
  store ptr %result.i.i271, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %result.i151, i64 32
  store i32 16, ptr %12, align 8
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #34
  %14 = icmp sgt i32 %0, 0
  br i1 %14, label %._crit_edge.preheader, label %._crit_edge1._crit_edge.thread

._crit_edge.preheader:                            ; preds = %1
  %15 = getelementptr inbounds i8, ptr %result.i151, i64 40
  %16 = getelementptr inbounds i8, ptr %result.i151, i64 36
  %17 = getelementptr inbounds i8, ptr %3, i64 8
  %18 = getelementptr inbounds i8, ptr %3, i64 16
  br label %._crit_edge

._crit_edge1._crit_edge.thread:                   ; preds = %1
  %19 = call i64 @clock()
  br label %._crit_edge.lr.ph.i505

._crit_edge:                                      ; preds = %._crit_edge.preheader, %HashMap_insert_internal_keyK_valueV_hashPtri32.exit
  %.0258 = phi i32 [ %20, %HashMap_insert_internal_keyK_valueV_hashPtri32.exit ], [ 0, %._crit_edge.preheader ]
  %.0139257 = phi i64 [ %415, %HashMap_insert_internal_keyK_valueV_hashPtri32.exit ], [ 0, %._crit_edge.preheader ]
  %20 = add nuw nsw i32 %.0258, 1
  %21 = zext nneg i32 %20 to i64
  %.sroa.0132.0.insert.ext = zext nneg i32 %.0258 to i160
  %22 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0132.0.insert.ext, 1
  %.sroa.0129.0.insert.ext = zext nneg i32 %20 to i160
  %23 = load i32, ptr %15, align 8
  %24 = load i32, ptr %12, align 8
  %25 = icmp eq i32 %24, 0
  %26 = mul i32 %23, 10
  %27 = add i32 %26, 10
  %28 = mul i32 %24, 6
  %29 = icmp sge i32 %27, %28
  %.0.i437 = select i1 %25, i1 true, i1 %29
  br i1 %.0.i437, label %._crit_edge1.i439, label %HashMap_ensure_capacity_required_loadPtri32.exit

._crit_edge1.i439:                                ; preds = %._crit_edge
  %30 = shl i32 %24, 1
  %spec.select.i440 = call i32 @llvm.smax.i32(i32 %30, i32 16)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %31 = load ptr, ptr %11, align 8
  %32 = zext nneg i32 %spec.select.i440 to i64
  %33 = shl nuw nsw i64 %32, 5
  %result.i.i = call noalias ptr @bump_malloc_inner(i64 noundef %33, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i, ptr %11, align 8
  store i32 %spec.select.i440, ptr %12, align 8
  store i32 0, ptr %16, align 4
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #38
  store i32 0, ptr %15, align 8
  %35 = icmp sgt i32 %24, 0
  br i1 %35, label %.lr.ph.i576, label %HashMap_resize_new_capacityPtri32.exit

.lr.ph.i576:                                      ; preds = %._crit_edge1.i439, %._crit_edge.i577
  %.096.i = phi i32 [ %238, %._crit_edge.i577 ], [ 0, %._crit_edge1.i439 ]
  %36 = zext nneg i32 %.096.i to i64
  %37 = shl nuw nsw i64 %36, 5
  %38 = getelementptr i8, ptr %31, i64 %37
  %39 = load ptr, ptr %38, align 8
  %40 = icmp ne ptr %39, @nil_typ
  %41 = icmp ne ptr %39, null
  %.not40.i = and i1 %40, %41
  br i1 %.not40.i, label %42, label %._crit_edge.i577

42:                                               ; preds = %.lr.ph.i576
  %43 = getelementptr i8, ptr %38, i64 8
  %44 = load i64, ptr %43, align 4
  %.sroa_idx.i578 = getelementptr i8, ptr %38, i64 16
  %45 = load i64, ptr %.sroa_idx.i578, align 4
  %46 = inttoptr i64 %44 to ptr
  %47 = inttoptr i64 %45 to ptr
  %hash_coef_ptr.i.i42.i = getelementptr i8, ptr %39, i64 8
  %tbl_size_ptr.i.i43.i = getelementptr i8, ptr %39, i64 16
  %offset_tbl_ptr.i.i44.i = getelementptr i8, ptr %39, i64 40
  %hash_coef.i.i45.i = load i64, ptr %hash_coef_ptr.i.i42.i, align 4, !noalias !61
  %tbl_size.i.i46.i = load i64, ptr %tbl_size_ptr.i.i43.i, align 4, !noalias !61
  %offset_tbl.i.i47.i = load ptr, ptr %offset_tbl_ptr.i.i44.i, align 8, !noalias !61
  %product.i.i.i48.i = mul i64 %hash_coef.i.i45.i, 4015701072841558310
  %shifted.i.i.i49.i = lshr i64 %product.i.i.i48.i, 32
  %xored.i.i.i50.i = xor i64 %shifted.i.i.i49.i, %product.i.i.i48.i
  %hash.i.i.i51.i = and i64 %xored.i.i.i50.i, %tbl_size.i.i46.i
  %offset_ptr.i.i52.i = getelementptr i32, ptr %offset_tbl.i.i47.i, i64 %hash.i.i.i51.i
  %offset.i.i53.i = load i32, ptr %offset_ptr.i.i52.i, align 4, !noalias !61
  %48 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %39, 0
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %46, 1
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, ptr %47, 2
  %51 = insertvalue { ptr, ptr, ptr, i32 } %50, i32 %offset.i.i53.i, 3
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %39)
  %54 = sext i32 %offset.i.i53.i to i64
  %55 = getelementptr ptr, ptr %39, i64 %54
  %56 = getelementptr i8, ptr %55, i64 56
  %57 = load ptr, ptr %56, align 8
  %result.i55.i = call ptr %57({ ptr, ptr, ptr, i32 } %51, ptr nocapture nofree noundef nonnull readonly %2) #16
  %58 = call { ptr, i160 } %result.i55.i({ ptr, ptr, ptr, i32 } %51, { ptr, ptr, ptr, i32 } %51, ptr nonnull align 8 %2) #7
  %.fca.0.extract29.i = extractvalue { ptr, i160 } %58, 0
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %60 = load ptr, ptr %4, align 8
  %61 = load ptr, ptr %60, align 8
  %62 = ptrtoint ptr %61 to i64
  %63 = getelementptr i8, ptr %.fca.0.extract29.i, i64 8
  %64 = getelementptr i8, ptr %.fca.0.extract29.i, i64 16
  %65 = getelementptr i8, ptr %.fca.0.extract29.i, i64 24
  %66 = getelementptr i8, ptr %.fca.0.extract29.i, i64 32
  %67 = load i64, ptr %63, align 4
  %68 = load i64, ptr %64, align 4
  %69 = load ptr, ptr %65, align 8
  %70 = load ptr, ptr %66, align 8
  %71 = load i64, ptr %61, align 4
  %result.i57.i = call i1 %69(i64 %68, i64 %67, i64 %71, i64 %62, ptr readonly %70) #5
  br i1 %result.i57.i, label %72, label %._crit_edge.i577

72:                                               ; preds = %42
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %39)
  %75 = getelementptr i8, ptr %55, i64 48
  %76 = load ptr, ptr %75, align 8
  %result.i58.i = call ptr %76({ ptr, ptr, ptr, i32 } %51, ptr nocapture nofree noundef nonnull readonly %2) #16
  %77 = call { ptr, i160 } %result.i58.i({ ptr, ptr, ptr, i32 } %51, { ptr, ptr, ptr, i32 } %51, ptr nonnull align 8 %2) #7
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %39)
  %80 = getelementptr i8, ptr %55, i64 64
  %81 = load ptr, ptr %80, align 8
  %result.i59.i = call ptr %81({ ptr, ptr, ptr, i32 } %51, ptr nocapture nofree noundef nonnull readonly %2) #16
  %82 = call i32 %result.i59.i({ ptr, ptr, ptr, i32 } %51, { ptr, ptr, ptr, i32 } %51, ptr nonnull align 8 %2) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %3)
  %83 = load ptr, ptr %result.i151, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %84 = load i32, ptr %12, align 8
  %85 = add i32 %84, -1
  %86 = and i32 %85, %82
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %88 = load ptr, ptr %11, align 8
  %89 = sext i32 %86 to i64
  %90 = shl nsw i64 %89, 5
  %91 = getelementptr i8, ptr %88, i64 %90
  %92 = load ptr, ptr %91, align 8
  %93 = icmp eq ptr %92, @nil_typ
  %94 = icmp eq ptr %92, null
  %95 = or i1 %93, %94
  br i1 %95, label %HashMap_find_slot_keyK_hashPtri32.exit784, label %.lr.ph.i760

.lr.ph.i760:                                      ; preds = %72
  %96 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %97

97:                                               ; preds = %._crit_edge.thread.i775, %.lr.ph.i760
  %98 = phi i32 [ %86, %.lr.ph.i760 ], [ %140, %._crit_edge.thread.i775 ]
  %spec.store.select.i780795 = phi i32 [ -1, %.lr.ph.i760 ], [ %spec.store.select.i780, %._crit_edge.thread.i775 ]
  %99 = phi ptr [ %92, %.lr.ph.i760 ], [ %145, %._crit_edge.thread.i775 ]
  %100 = phi ptr [ %91, %.lr.ph.i760 ], [ %144, %._crit_edge.thread.i775 ]
  %.sroa_idx.i761 = getelementptr i8, ptr %100, i64 16
  %101 = load i64, ptr %.sroa_idx.i761, align 4
  %102 = getelementptr i8, ptr %100, i64 8
  %103 = load i64, ptr %102, align 4
  %104 = inttoptr i64 %103 to ptr
  %105 = inttoptr i64 %101 to ptr
  %hash_coef_ptr.i.i56.i762 = getelementptr i8, ptr %99, i64 8
  %tbl_size_ptr.i.i57.i763 = getelementptr i8, ptr %99, i64 16
  %offset_tbl_ptr.i.i58.i764 = getelementptr i8, ptr %99, i64 40
  %hash_coef.i.i59.i765 = load i64, ptr %hash_coef_ptr.i.i56.i762, align 4
  %tbl_size.i.i60.i766 = load i64, ptr %tbl_size_ptr.i.i57.i763, align 4
  %offset_tbl.i.i61.i767 = load ptr, ptr %offset_tbl_ptr.i.i58.i764, align 8
  %product.i.i.i62.i768 = mul i64 %hash_coef.i.i59.i765, 4015701072841558310
  %shifted.i.i.i63.i769 = lshr i64 %product.i.i.i62.i768, 32
  %xored.i.i.i64.i770 = xor i64 %shifted.i.i.i63.i769, %product.i.i.i62.i768
  %hash.i.i.i65.i771 = and i64 %xored.i.i.i64.i770, %tbl_size.i.i60.i766
  %offset_ptr.i.i66.i772 = getelementptr i32, ptr %offset_tbl.i.i61.i767, i64 %hash.i.i.i65.i771
  %offset.i.i67.i773 = load i32, ptr %offset_ptr.i.i66.i772, align 4
  %106 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %99, 0
  %107 = insertvalue { ptr, ptr, ptr, i32 } %106, ptr %104, 1
  %108 = insertvalue { ptr, ptr, ptr, i32 } %107, ptr %105, 2
  %109 = insertvalue { ptr, ptr, ptr, i32 } %108, i32 %offset.i.i67.i773, 3
  %110 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %99)
  %111 = sext i32 %offset.i.i67.i773 to i64
  %112 = getelementptr ptr, ptr %99, i64 %111
  %113 = getelementptr i8, ptr %112, i64 64
  %114 = load ptr, ptr %113, align 8
  %result.i.i774 = call ptr %114({ ptr, ptr, ptr, i32 } %109, ptr nocapture nofree noundef nonnull readonly %2) #16
  %115 = call i32 %result.i.i774({ ptr, ptr, ptr, i32 } %109, { ptr, ptr, ptr, i32 } %109, ptr nonnull align 8 %2) #7
  %116 = icmp eq i32 %115, %82
  br i1 %116, label %._crit_edge.i782, label %._crit_edge.thread.i775

._crit_edge.i782:                                 ; preds = %97
  %117 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %118 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %99)
  %119 = getelementptr i8, ptr %112, i64 48
  %120 = load ptr, ptr %119, align 8
  %result.i69.i783 = call ptr %120({ ptr, ptr, ptr, i32 } %109, ptr nocapture nofree noundef nonnull readonly %2) #16
  %121 = call { ptr, i160 } %result.i69.i783({ ptr, ptr, ptr, i32 } %109, { ptr, ptr, ptr, i32 } %109, ptr nonnull align 8 %2) #7
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %123 = load ptr, ptr %10, align 8
  %124 = call i1 %123({ ptr, i160 } %121, { ptr, i160 } %77) #7
  br i1 %124, label %HashMap_find_slot_keyK_hashPtri32.exit784.loopexit, label %._crit_edge.thread.i775

._crit_edge.thread.i775:                          ; preds = %._crit_edge.i782, %97
  %125 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %126 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %99)
  %127 = getelementptr i8, ptr %112, i64 56
  %128 = load ptr, ptr %127, align 8
  %result.i70.i776 = call ptr %128({ ptr, ptr, ptr, i32 } %109, ptr nocapture nofree noundef nonnull readonly %2) #16
  %129 = call { ptr, i160 } %result.i70.i776({ ptr, ptr, ptr, i32 } %109, { ptr, ptr, ptr, i32 } %109, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i777 = extractvalue { ptr, i160 } %129, 0
  %130 = getelementptr i8, ptr %.fca.0.extract19.i777, i64 8
  %131 = getelementptr i8, ptr %.fca.0.extract19.i777, i64 16
  %132 = getelementptr i8, ptr %.fca.0.extract19.i777, i64 24
  %133 = getelementptr i8, ptr %.fca.0.extract19.i777, i64 32
  %134 = load i64, ptr %130, align 4
  %135 = load i64, ptr %131, align 4
  %136 = load ptr, ptr %132, align 8
  %137 = load ptr, ptr %133, align 8
  %result.i71.i778 = call i1 %136(i64 %135, i64 %134, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %137) #5
  %138 = icmp eq i32 %spec.store.select.i780795, -1
  %or.cond.i779 = select i1 %result.i71.i778, i1 %138, i1 false
  %spec.store.select.i780 = select i1 %or.cond.i779, i32 %98, i32 %spec.store.select.i780795
  %139 = add i32 %98, 1
  %140 = and i32 %139, %85
  %141 = load ptr, ptr %11, align 8
  %142 = sext i32 %140 to i64
  %143 = shl nsw i64 %142, 5
  %144 = getelementptr i8, ptr %141, i64 %143
  %145 = load ptr, ptr %144, align 8
  %146 = icmp eq ptr %145, @nil_typ
  %147 = icmp eq ptr %145, null
  %148 = or i1 %146, %147
  br i1 %148, label %._crit_edge105.loopexit.i781, label %97

._crit_edge105.loopexit.i781:                     ; preds = %._crit_edge.thread.i775
  %149 = icmp eq i32 %spec.store.select.i780, -1
  %.pre.i.pre815 = select i1 %149, i32 %140, i32 %spec.store.select.i780
  br label %HashMap_find_slot_keyK_hashPtri32.exit784

HashMap_find_slot_keyK_hashPtri32.exit784.loopexit: ; preds = %._crit_edge.i782
  %.pre851 = load ptr, ptr %11, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit784

HashMap_find_slot_keyK_hashPtri32.exit784:        ; preds = %HashMap_find_slot_keyK_hashPtri32.exit784.loopexit, %72, %._crit_edge105.loopexit.i781
  %150 = phi ptr [ %141, %._crit_edge105.loopexit.i781 ], [ %88, %72 ], [ %.pre851, %HashMap_find_slot_keyK_hashPtri32.exit784.loopexit ]
  %151 = phi i32 [ %.pre.i.pre815, %._crit_edge105.loopexit.i781 ], [ %86, %72 ], [ %98, %HashMap_find_slot_keyK_hashPtri32.exit784.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %152 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %153 = sext i32 %151 to i64
  %154 = shl nsw i64 %153, 5
  %155 = getelementptr i8, ptr %150, i64 %154
  %156 = load ptr, ptr %155, align 8
  %157 = getelementptr i8, ptr %155, i64 8
  %158 = load i64, ptr %157, align 4
  %.sroa_idx.i687 = getelementptr i8, ptr %155, i64 16
  %159 = load i64, ptr %.sroa_idx.i687, align 4
  %160 = load ptr, ptr %4, align 8
  %161 = load ptr, ptr %83, align 8, !alias.scope !64
  %162 = getelementptr i8, ptr %161, i64 72
  %163 = load ptr, ptr %162, align 8, !alias.scope !64
  %result.i.i.i689 = call { i64, i64 } %163(ptr nocapture nofree nonnull readonly %83) #5, !alias.scope !64
  %164 = extractvalue { i64, i64 } %result.i.i.i689, 0
  %165 = extractvalue { i64, i64 } %result.i.i.i689, 1
  %166 = call i64 @llvm.umax.i64(i64 %165, i64 8)
  %167 = urem i64 20, %165
  %168 = icmp eq i64 %167, 0
  %169 = sub i64 %165, %167
  %170 = select i1 %168, i64 0, i64 %169
  %171 = add i64 %164, 20
  %172 = add i64 %171, %170
  %173 = and i64 %172, 7
  %174 = icmp eq i64 %173, 0
  %175 = sub nuw nsw i64 40, %173
  %176 = select i1 %174, i64 32, i64 %175
  %177 = add i64 %176, %172
  %178 = urem i64 %177, %166
  %179 = icmp eq i64 %178, 0
  %180 = sub i64 %166, %178
  %181 = select i1 %179, i64 0, i64 %180
  %182 = add i64 %177, %181
  %result.i71.i690 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %182, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %83, ptr %result.i71.i690, align 8
  %183 = getelementptr inbounds i8, ptr %result.i71.i690, i64 8
  store ptr %160, ptr %183, align 8
  %184 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i690)
  %185 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %result.i71.i690, 1
  %186 = insertvalue { ptr, ptr, ptr, i32 } %185, ptr undef, 2
  %187 = insertvalue { ptr, ptr, ptr, i32 } %186, i32 10, 3
  store ptr %83, ptr %3, align 8
  store ptr %160, ptr %17, align 8
  store ptr @_parameterization_Ptri32, ptr %18, align 8
  %188 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %3)
  %189 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Entry)
  %190 = load i64, ptr %63, align 4
  %191 = load i64, ptr %64, align 4
  %192 = load ptr, ptr %65, align 8
  %193 = load ptr, ptr %66, align 8
  %result.i.i117.i = call i1 %192(i64 %191, i64 %190, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %193) #5
  %194 = select i1 %result.i.i117.i, i64 9, i64 10
  %gep = getelementptr [14 x ptr], ptr getelementptr inbounds (i8, ptr @Entry, i64 80), i64 0, i64 %194
  %195 = load ptr, ptr %gep, align 8
  call void %195({ ptr, ptr, ptr, i32 } %187, { ptr, ptr, ptr, i32 } %187, ptr nonnull align 8 dereferenceable(24) %3, { ptr, i160 } %77, { ptr, i160 } %58, i32 %82) #7
  %196 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %197 = load ptr, ptr %11, align 8
  %198 = getelementptr i8, ptr %197, i64 %154
  store ptr @Entry, ptr %198, align 8
  %199 = getelementptr i8, ptr %198, i64 8
  %200 = ptrtoint ptr %result.i71.i690 to i64
  store i64 %200, ptr %199, align 4
  %.sroa_idx4.i691 = getelementptr i8, ptr %198, i64 24
  store i32 10, ptr %.sroa_idx4.i691, align 4
  %201 = icmp eq ptr %156, @nil_typ
  %202 = icmp eq ptr %156, null
  %203 = or i1 %201, %202
  br i1 %203, label %204, label %207

204:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit784
  %205 = load i32, ptr %16, align 4
  %206 = add i32 %205, 1
  store i32 %206, ptr %16, align 4
  br label %._crit_edge.sink.split.i708

207:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit784
  %208 = inttoptr i64 %158 to ptr
  %209 = inttoptr i64 %159 to ptr
  %hash_coef_ptr.i.i88.i692 = getelementptr i8, ptr %156, i64 8
  %tbl_size_ptr.i.i89.i693 = getelementptr i8, ptr %156, i64 16
  %offset_tbl_ptr.i.i90.i694 = getelementptr i8, ptr %156, i64 40
  %hash_coef.i.i91.i695 = load i64, ptr %hash_coef_ptr.i.i88.i692, align 4, !noalias !67
  %tbl_size.i.i92.i696 = load i64, ptr %tbl_size_ptr.i.i89.i693, align 4, !noalias !67
  %offset_tbl.i.i93.i697 = load ptr, ptr %offset_tbl_ptr.i.i90.i694, align 8, !noalias !67
  %product.i.i.i94.i698 = mul i64 %hash_coef.i.i91.i695, 4015701072841558310
  %shifted.i.i.i95.i699 = lshr i64 %product.i.i.i94.i698, 32
  %xored.i.i.i96.i700 = xor i64 %shifted.i.i.i95.i699, %product.i.i.i94.i698
  %hash.i.i.i97.i701 = and i64 %xored.i.i.i96.i700, %tbl_size.i.i92.i696
  %offset_ptr.i.i98.i702 = getelementptr i32, ptr %offset_tbl.i.i93.i697, i64 %hash.i.i.i97.i701
  %offset.i.i99.i703 = load i32, ptr %offset_ptr.i.i98.i702, align 4, !noalias !67
  %210 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %156, 0
  %211 = insertvalue { ptr, ptr, ptr, i32 } %210, ptr %208, 1
  %212 = insertvalue { ptr, ptr, ptr, i32 } %211, ptr %209, 2
  %213 = insertvalue { ptr, ptr, ptr, i32 } %212, i32 %offset.i.i99.i703, 3
  %214 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %215 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %156)
  %216 = sext i32 %offset.i.i99.i703 to i64
  %217 = getelementptr ptr, ptr %156, i64 %216
  %218 = getelementptr i8, ptr %217, i64 56
  %219 = load ptr, ptr %218, align 8
  %result.i101.i704 = call ptr %219({ ptr, ptr, ptr, i32 } %213, ptr nocapture nofree noundef nonnull readonly %2) #16
  %220 = call { ptr, i160 } %result.i101.i704({ ptr, ptr, ptr, i32 } %213, { ptr, ptr, ptr, i32 } %213, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i705 = extractvalue { ptr, i160 } %220, 0
  %221 = getelementptr i8, ptr %.fca.0.extract51.i705, i64 8
  %222 = getelementptr i8, ptr %.fca.0.extract51.i705, i64 16
  %223 = getelementptr i8, ptr %.fca.0.extract51.i705, i64 24
  %224 = getelementptr i8, ptr %.fca.0.extract51.i705, i64 32
  %225 = load i64, ptr %221, align 4
  %226 = load i64, ptr %222, align 4
  %227 = load ptr, ptr %223, align 8
  %228 = load ptr, ptr %224, align 8
  %result.i102.i706 = call i1 %227(i64 %226, i64 %225, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %228) #5
  br i1 %result.i102.i706, label %._crit_edge.sink.split.i708, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit710

._crit_edge.sink.split.i708:                      ; preds = %207, %204
  %.sink159.i709 = phi i64 [ 48, %204 ], [ 40, %207 ]
  %229 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %230 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i709
  %231 = load ptr, ptr %230, align 8
  %232 = load ptr, ptr %231, align 8
  %233 = call i32 %232(ptr nonnull %result.i151) #36
  %234 = add i32 %233, 1
  %235 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %236 = getelementptr i8, ptr %231, i64 8
  %237 = load ptr, ptr %236, align 8
  call void %237(ptr nonnull %result.i151, i32 %234) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit710

HashMap_insert_internal_keyK_valueV_hashPtri32.exit710: ; preds = %207, %._crit_edge.sink.split.i708
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %3)
  br label %._crit_edge.i577

._crit_edge.i577:                                 ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit710, %42, %.lr.ph.i576
  %238 = add nuw nsw i32 %.096.i, 1
  %239 = icmp slt i32 %238, %24
  br i1 %239, label %.lr.ph.i576, label %HashMap_resize_new_capacityPtri32.exit

HashMap_resize_new_capacityPtri32.exit:           ; preds = %._crit_edge.i577, %._crit_edge1.i439
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_ensure_capacity_required_loadPtri32.exit

HashMap_ensure_capacity_required_loadPtri32.exit: ; preds = %._crit_edge, %HashMap_resize_new_capacityPtri32.exit
  %240 = load ptr, ptr %9, align 8
  %241 = call i32 %240({ ptr, i160 } %22) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %242 = load ptr, ptr %result.i151, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %243 = load i32, ptr %12, align 8
  %244 = add i32 %243, -1
  %245 = and i32 %244, %241
  %246 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %247 = load ptr, ptr %11, align 8
  %248 = sext i32 %245 to i64
  %249 = shl nsw i64 %248, 5
  %250 = getelementptr i8, ptr %247, i64 %249
  %251 = load ptr, ptr %250, align 8
  %252 = icmp eq ptr %251, @nil_typ
  %253 = icmp eq ptr %251, null
  %254 = or i1 %252, %253
  br i1 %254, label %HashMap_find_slot_keyK_hashPtri32.exit614, label %.lr.ph.i591

.lr.ph.i591:                                      ; preds = %HashMap_ensure_capacity_required_loadPtri32.exit
  %255 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %256

256:                                              ; preds = %._crit_edge.thread.i606, %.lr.ph.i591
  %257 = phi i32 [ %245, %.lr.ph.i591 ], [ %299, %._crit_edge.thread.i606 ]
  %spec.store.select.i611634 = phi i32 [ -1, %.lr.ph.i591 ], [ %spec.store.select.i611, %._crit_edge.thread.i606 ]
  %258 = phi ptr [ %251, %.lr.ph.i591 ], [ %304, %._crit_edge.thread.i606 ]
  %259 = phi ptr [ %250, %.lr.ph.i591 ], [ %303, %._crit_edge.thread.i606 ]
  %.sroa_idx.i592 = getelementptr i8, ptr %259, i64 16
  %260 = load i64, ptr %.sroa_idx.i592, align 4
  %261 = getelementptr i8, ptr %259, i64 8
  %262 = load i64, ptr %261, align 4
  %263 = inttoptr i64 %262 to ptr
  %264 = inttoptr i64 %260 to ptr
  %hash_coef_ptr.i.i56.i593 = getelementptr i8, ptr %258, i64 8
  %tbl_size_ptr.i.i57.i594 = getelementptr i8, ptr %258, i64 16
  %offset_tbl_ptr.i.i58.i595 = getelementptr i8, ptr %258, i64 40
  %hash_coef.i.i59.i596 = load i64, ptr %hash_coef_ptr.i.i56.i593, align 4
  %tbl_size.i.i60.i597 = load i64, ptr %tbl_size_ptr.i.i57.i594, align 4
  %offset_tbl.i.i61.i598 = load ptr, ptr %offset_tbl_ptr.i.i58.i595, align 8
  %product.i.i.i62.i599 = mul i64 %hash_coef.i.i59.i596, 4015701072841558310
  %shifted.i.i.i63.i600 = lshr i64 %product.i.i.i62.i599, 32
  %xored.i.i.i64.i601 = xor i64 %shifted.i.i.i63.i600, %product.i.i.i62.i599
  %hash.i.i.i65.i602 = and i64 %xored.i.i.i64.i601, %tbl_size.i.i60.i597
  %offset_ptr.i.i66.i603 = getelementptr i32, ptr %offset_tbl.i.i61.i598, i64 %hash.i.i.i65.i602
  %offset.i.i67.i604 = load i32, ptr %offset_ptr.i.i66.i603, align 4
  %265 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %258, 0
  %266 = insertvalue { ptr, ptr, ptr, i32 } %265, ptr %263, 1
  %267 = insertvalue { ptr, ptr, ptr, i32 } %266, ptr %264, 2
  %268 = insertvalue { ptr, ptr, ptr, i32 } %267, i32 %offset.i.i67.i604, 3
  %269 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %258)
  %270 = sext i32 %offset.i.i67.i604 to i64
  %271 = getelementptr ptr, ptr %258, i64 %270
  %272 = getelementptr i8, ptr %271, i64 64
  %273 = load ptr, ptr %272, align 8
  %result.i.i605 = call ptr %273({ ptr, ptr, ptr, i32 } %268, ptr nocapture nofree noundef nonnull readonly %2) #16
  %274 = call i32 %result.i.i605({ ptr, ptr, ptr, i32 } %268, { ptr, ptr, ptr, i32 } %268, ptr nonnull align 8 %2) #7
  %275 = icmp eq i32 %274, %241
  br i1 %275, label %._crit_edge.i613, label %._crit_edge.thread.i606

._crit_edge.i613:                                 ; preds = %256
  %276 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %277 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %258)
  %278 = getelementptr i8, ptr %271, i64 48
  %279 = load ptr, ptr %278, align 8
  %result.i69.i = call ptr %279({ ptr, ptr, ptr, i32 } %268, ptr nocapture nofree noundef nonnull readonly %2) #16
  %280 = call { ptr, i160 } %result.i69.i({ ptr, ptr, ptr, i32 } %268, { ptr, ptr, ptr, i32 } %268, ptr nonnull align 8 %2) #7
  %281 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %282 = load ptr, ptr %10, align 8
  %283 = call i1 %282({ ptr, i160 } %280, { ptr, i160 } %22) #7
  br i1 %283, label %HashMap_find_slot_keyK_hashPtri32.exit614.loopexit, label %._crit_edge.thread.i606

._crit_edge.thread.i606:                          ; preds = %._crit_edge.i613, %256
  %284 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %285 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %258)
  %286 = getelementptr i8, ptr %271, i64 56
  %287 = load ptr, ptr %286, align 8
  %result.i70.i607 = call ptr %287({ ptr, ptr, ptr, i32 } %268, ptr nocapture nofree noundef nonnull readonly %2) #16
  %288 = call { ptr, i160 } %result.i70.i607({ ptr, ptr, ptr, i32 } %268, { ptr, ptr, ptr, i32 } %268, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i608 = extractvalue { ptr, i160 } %288, 0
  %289 = getelementptr i8, ptr %.fca.0.extract19.i608, i64 8
  %290 = getelementptr i8, ptr %.fca.0.extract19.i608, i64 16
  %291 = getelementptr i8, ptr %.fca.0.extract19.i608, i64 24
  %292 = getelementptr i8, ptr %.fca.0.extract19.i608, i64 32
  %293 = load i64, ptr %289, align 4
  %294 = load i64, ptr %290, align 4
  %295 = load ptr, ptr %291, align 8
  %296 = load ptr, ptr %292, align 8
  %result.i71.i609 = call i1 %295(i64 %294, i64 %293, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %296) #5
  %297 = icmp eq i32 %spec.store.select.i611634, -1
  %or.cond.i610 = select i1 %result.i71.i609, i1 %297, i1 false
  %spec.store.select.i611 = select i1 %or.cond.i610, i32 %257, i32 %spec.store.select.i611634
  %298 = add i32 %257, 1
  %299 = and i32 %298, %244
  %300 = load ptr, ptr %11, align 8
  %301 = sext i32 %299 to i64
  %302 = shl nsw i64 %301, 5
  %303 = getelementptr i8, ptr %300, i64 %302
  %304 = load ptr, ptr %303, align 8
  %305 = icmp eq ptr %304, @nil_typ
  %306 = icmp eq ptr %304, null
  %307 = or i1 %305, %306
  br i1 %307, label %._crit_edge105.loopexit.i612, label %256

._crit_edge105.loopexit.i612:                     ; preds = %._crit_edge.thread.i606
  %308 = icmp eq i32 %spec.store.select.i611, -1
  %.pre.i.pre649 = select i1 %308, i32 %299, i32 %spec.store.select.i611
  br label %HashMap_find_slot_keyK_hashPtri32.exit614

HashMap_find_slot_keyK_hashPtri32.exit614.loopexit: ; preds = %._crit_edge.i613
  %.pre677 = load ptr, ptr %11, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit614

HashMap_find_slot_keyK_hashPtri32.exit614:        ; preds = %HashMap_find_slot_keyK_hashPtri32.exit614.loopexit, %HashMap_ensure_capacity_required_loadPtri32.exit, %._crit_edge105.loopexit.i612
  %309 = phi ptr [ %300, %._crit_edge105.loopexit.i612 ], [ %247, %HashMap_ensure_capacity_required_loadPtri32.exit ], [ %.pre677, %HashMap_find_slot_keyK_hashPtri32.exit614.loopexit ]
  %310 = phi i32 [ %.pre.i.pre649, %._crit_edge105.loopexit.i612 ], [ %245, %HashMap_ensure_capacity_required_loadPtri32.exit ], [ %257, %HashMap_find_slot_keyK_hashPtri32.exit614.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %311 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %312 = sext i32 %310 to i64
  %313 = shl nsw i64 %312, 5
  %314 = getelementptr i8, ptr %309, i64 %313
  %315 = load ptr, ptr %314, align 8
  %316 = getelementptr i8, ptr %314, i64 8
  %317 = load i64, ptr %316, align 4
  %.sroa_idx.i455 = getelementptr i8, ptr %314, i64 16
  %318 = load i64, ptr %.sroa_idx.i455, align 4
  %319 = load ptr, ptr %4, align 8
  %320 = load ptr, ptr %242, align 8, !alias.scope !70
  %321 = getelementptr i8, ptr %320, i64 72
  %322 = load ptr, ptr %321, align 8, !alias.scope !70
  %result.i.i.i = call { i64, i64 } %322(ptr nocapture nofree nonnull readonly %242) #5, !alias.scope !70
  %323 = extractvalue { i64, i64 } %result.i.i.i, 0
  %324 = extractvalue { i64, i64 } %result.i.i.i, 1
  %325 = call i64 @llvm.umax.i64(i64 %324, i64 8)
  %326 = urem i64 20, %324
  %327 = icmp eq i64 %326, 0
  %328 = sub i64 %324, %326
  %329 = select i1 %327, i64 0, i64 %328
  %330 = add i64 %323, 20
  %331 = add i64 %330, %329
  %332 = and i64 %331, 7
  %333 = icmp eq i64 %332, 0
  %334 = sub nuw nsw i64 40, %332
  %335 = select i1 %333, i64 32, i64 %334
  %336 = add i64 %335, %331
  %337 = urem i64 %336, %325
  %338 = icmp eq i64 %337, 0
  %339 = sub i64 %325, %337
  %340 = select i1 %338, i64 0, i64 %339
  %341 = add i64 %336, %340
  %result.i71.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %341, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %242, ptr %result.i71.i, align 8
  %342 = getelementptr inbounds i8, ptr %result.i71.i, i64 8
  store ptr %319, ptr %342, align 8
  %343 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i)
  %344 = load ptr, ptr %242, align 8
  %345 = getelementptr i8, ptr %344, i64 72
  %346 = load ptr, ptr %345, align 8
  %result.i.i660 = call { i64, i64 } %346(ptr nocapture nofree nonnull readonly %242) #5
  %347 = extractvalue { i64, i64 } %result.i.i660, 1
  %348 = urem i64 20, %347
  %349 = icmp eq i64 %348, 0
  %reass.sub = sub i64 %347, %348
  %350 = add i64 %reass.sub, 20
  %351 = select i1 %349, i64 20, i64 %350
  %352 = getelementptr i8, ptr %result.i71.i, i64 %351
  %353 = getelementptr i8, ptr %344, i64 64
  %354 = load ptr, ptr %353, align 8
  call void %354({ ptr, i160 } %22, ptr nocapture nofree nonnull readonly %242, ptr nocapture nofree writeonly %352) #13
  %355 = load ptr, ptr %result.i71.i, align 8
  %356 = load ptr, ptr %355, align 8
  %357 = getelementptr i8, ptr %356, i64 72
  %358 = load ptr, ptr %357, align 8
  %result.i.i661 = call { i64, i64 } %358(ptr nocapture nofree nonnull readonly %355) #5
  %359 = extractvalue { i64, i64 } %result.i.i661, 0
  %360 = extractvalue { i64, i64 } %result.i.i661, 1
  %361 = urem i64 20, %360
  %362 = icmp eq i64 %361, 0
  %363 = sub i64 %360, %361
  %364 = select i1 %362, i64 0, i64 %363
  %365 = add i64 %359, 20
  %366 = add i64 %365, %364
  %367 = and i64 %366, 7
  %368 = icmp eq i64 %367, 0
  %369 = sub nuw nsw i64 8, %367
  %370 = select i1 %368, i64 0, i64 %369
  %371 = getelementptr i8, ptr %result.i71.i, i64 %366
  %372 = getelementptr i8, ptr %371, i64 %370
  store ptr @i32_typ, ptr %372, align 8
  %373 = getelementptr i8, ptr %372, i64 8
  store i160 %.sroa.0129.0.insert.ext, ptr %373, align 4
  %374 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @Entry) #34
  %375 = getelementptr inbounds i8, ptr %result.i71.i, i64 16
  store i32 %241, ptr %375, align 8
  %376 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  store ptr @Entry, ptr %314, align 8
  %377 = ptrtoint ptr %result.i71.i to i64
  store i64 %377, ptr %316, align 4
  %.sroa_idx4.i = getelementptr i8, ptr %314, i64 24
  store i32 10, ptr %.sroa_idx4.i, align 4
  %378 = icmp eq ptr %315, @nil_typ
  %379 = icmp eq ptr %315, null
  %380 = or i1 %378, %379
  br i1 %380, label %381, label %384

381:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit614
  %382 = load i32, ptr %16, align 4
  %383 = add i32 %382, 1
  store i32 %383, ptr %16, align 4
  br label %._crit_edge.sink.split.i

384:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit614
  %385 = inttoptr i64 %317 to ptr
  %386 = inttoptr i64 %318 to ptr
  %hash_coef_ptr.i.i88.i = getelementptr i8, ptr %315, i64 8
  %tbl_size_ptr.i.i89.i = getelementptr i8, ptr %315, i64 16
  %offset_tbl_ptr.i.i90.i = getelementptr i8, ptr %315, i64 40
  %hash_coef.i.i91.i = load i64, ptr %hash_coef_ptr.i.i88.i, align 4, !noalias !73
  %tbl_size.i.i92.i = load i64, ptr %tbl_size_ptr.i.i89.i, align 4, !noalias !73
  %offset_tbl.i.i93.i = load ptr, ptr %offset_tbl_ptr.i.i90.i, align 8, !noalias !73
  %product.i.i.i94.i = mul i64 %hash_coef.i.i91.i, 4015701072841558310
  %shifted.i.i.i95.i = lshr i64 %product.i.i.i94.i, 32
  %xored.i.i.i96.i = xor i64 %shifted.i.i.i95.i, %product.i.i.i94.i
  %hash.i.i.i97.i = and i64 %xored.i.i.i96.i, %tbl_size.i.i92.i
  %offset_ptr.i.i98.i = getelementptr i32, ptr %offset_tbl.i.i93.i, i64 %hash.i.i.i97.i
  %offset.i.i99.i = load i32, ptr %offset_ptr.i.i98.i, align 4, !noalias !73
  %387 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %315, 0
  %388 = insertvalue { ptr, ptr, ptr, i32 } %387, ptr %385, 1
  %389 = insertvalue { ptr, ptr, ptr, i32 } %388, ptr %386, 2
  %390 = insertvalue { ptr, ptr, ptr, i32 } %389, i32 %offset.i.i99.i, 3
  %391 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %392 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %315)
  %393 = sext i32 %offset.i.i99.i to i64
  %394 = getelementptr ptr, ptr %315, i64 %393
  %395 = getelementptr i8, ptr %394, i64 56
  %396 = load ptr, ptr %395, align 8
  %result.i101.i = call ptr %396({ ptr, ptr, ptr, i32 } %390, ptr nocapture nofree noundef nonnull readonly %2) #16
  %397 = call { ptr, i160 } %result.i101.i({ ptr, ptr, ptr, i32 } %390, { ptr, ptr, ptr, i32 } %390, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i457 = extractvalue { ptr, i160 } %397, 0
  %398 = getelementptr i8, ptr %.fca.0.extract51.i457, i64 8
  %399 = getelementptr i8, ptr %.fca.0.extract51.i457, i64 16
  %400 = getelementptr i8, ptr %.fca.0.extract51.i457, i64 24
  %401 = getelementptr i8, ptr %.fca.0.extract51.i457, i64 32
  %402 = load i64, ptr %398, align 4
  %403 = load i64, ptr %399, align 4
  %404 = load ptr, ptr %400, align 8
  %405 = load ptr, ptr %401, align 8
  %result.i102.i = call i1 %404(i64 %403, i64 %402, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %405) #5
  br i1 %result.i102.i, label %._crit_edge.sink.split.i, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit

._crit_edge.sink.split.i:                         ; preds = %384, %381
  %.sink159.i = phi i64 [ 48, %381 ], [ 40, %384 ]
  %406 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %407 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i
  %408 = load ptr, ptr %407, align 8
  %409 = load ptr, ptr %408, align 8
  %410 = call i32 %409(ptr nonnull %result.i151) #36
  %411 = add i32 %410, 1
  %412 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %413 = getelementptr i8, ptr %408, i64 8
  %414 = load ptr, ptr %413, align 8
  call void %414(ptr nonnull %result.i151, i32 %411) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit

HashMap_insert_internal_keyK_valueV_hashPtri32.exit: ; preds = %384, %._crit_edge.sink.split.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %415 = add i64 %.0139257, %21
  %416 = icmp slt i32 %20, %0
  br i1 %416, label %._crit_edge, label %.lr.ph

.lr.ph:                                           ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit
  %417 = call i64 @clock()
  br label %418

418:                                              ; preds = %.lr.ph, %._crit_edge2
  %.2262 = phi i32 [ 0, %.lr.ph ], [ %553, %._crit_edge2 ]
  %.0141261 = phi i64 [ 0, %.lr.ph ], [ %.2143, %._crit_edge2 ]
  %.0144260 = phi i1 [ true, %.lr.ph ], [ %.2146, %._crit_edge2 ]
  %.sroa.0117.0.insert.ext = zext nneg i32 %.2262 to i160
  %419 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0117.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %420 = load ptr, ptr %9, align 8
  %421 = call i32 %420({ ptr, i160 } %419) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %422 = load i32, ptr %12, align 8
  %423 = add i32 %422, -1
  %424 = and i32 %423, %421
  %425 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %426 = load ptr, ptr %11, align 8
  %427 = sext i32 %424 to i64
  %428 = shl nsw i64 %427, 5
  %429 = getelementptr i8, ptr %426, i64 %428
  %430 = load ptr, ptr %429, align 8
  %431 = icmp eq ptr %430, @nil_typ
  %432 = icmp eq ptr %430, null
  %433 = or i1 %431, %432
  br i1 %433, label %HashMap_find_slot_keyK_hashPtri32.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %418
  %434 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %435

435:                                              ; preds = %._crit_edge.thread.i, %.lr.ph.i
  %436 = phi i32 [ %424, %.lr.ph.i ], [ %478, %._crit_edge.thread.i ]
  %spec.store.select.i550 = phi i32 [ -1, %.lr.ph.i ], [ %spec.store.select.i, %._crit_edge.thread.i ]
  %437 = phi ptr [ %430, %.lr.ph.i ], [ %483, %._crit_edge.thread.i ]
  %438 = phi ptr [ %429, %.lr.ph.i ], [ %482, %._crit_edge.thread.i ]
  %.sroa_idx.i471 = getelementptr i8, ptr %438, i64 16
  %439 = load i64, ptr %.sroa_idx.i471, align 4
  %440 = getelementptr i8, ptr %438, i64 8
  %441 = load i64, ptr %440, align 4
  %442 = inttoptr i64 %441 to ptr
  %443 = inttoptr i64 %439 to ptr
  %hash_coef_ptr.i.i56.i = getelementptr i8, ptr %437, i64 8
  %tbl_size_ptr.i.i57.i = getelementptr i8, ptr %437, i64 16
  %offset_tbl_ptr.i.i58.i = getelementptr i8, ptr %437, i64 40
  %hash_coef.i.i59.i = load i64, ptr %hash_coef_ptr.i.i56.i, align 4
  %tbl_size.i.i60.i = load i64, ptr %tbl_size_ptr.i.i57.i, align 4
  %offset_tbl.i.i61.i = load ptr, ptr %offset_tbl_ptr.i.i58.i, align 8
  %product.i.i.i62.i = mul i64 %hash_coef.i.i59.i, 4015701072841558310
  %shifted.i.i.i63.i = lshr i64 %product.i.i.i62.i, 32
  %xored.i.i.i64.i = xor i64 %shifted.i.i.i63.i, %product.i.i.i62.i
  %hash.i.i.i65.i = and i64 %xored.i.i.i64.i, %tbl_size.i.i60.i
  %offset_ptr.i.i66.i = getelementptr i32, ptr %offset_tbl.i.i61.i, i64 %hash.i.i.i65.i
  %offset.i.i67.i = load i32, ptr %offset_ptr.i.i66.i, align 4
  %444 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %437, 0
  %445 = insertvalue { ptr, ptr, ptr, i32 } %444, ptr %442, 1
  %446 = insertvalue { ptr, ptr, ptr, i32 } %445, ptr %443, 2
  %447 = insertvalue { ptr, ptr, ptr, i32 } %446, i32 %offset.i.i67.i, 3
  %448 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %437)
  %449 = sext i32 %offset.i.i67.i to i64
  %450 = getelementptr ptr, ptr %437, i64 %449
  %451 = getelementptr i8, ptr %450, i64 64
  %452 = load ptr, ptr %451, align 8
  %result.i.i472 = call ptr %452({ ptr, ptr, ptr, i32 } %447, ptr nocapture nofree noundef nonnull readonly %2) #16
  %453 = call i32 %result.i.i472({ ptr, ptr, ptr, i32 } %447, { ptr, ptr, ptr, i32 } %447, ptr nonnull align 8 %2) #7
  %454 = icmp eq i32 %453, %421
  br i1 %454, label %._crit_edge.i474, label %._crit_edge.thread.i

._crit_edge.i474:                                 ; preds = %435
  %455 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %456 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %437)
  %457 = getelementptr i8, ptr %450, i64 48
  %458 = load ptr, ptr %457, align 8
  %result.i69.i475 = call ptr %458({ ptr, ptr, ptr, i32 } %447, ptr nocapture nofree noundef nonnull readonly %2) #16
  %459 = call { ptr, i160 } %result.i69.i475({ ptr, ptr, ptr, i32 } %447, { ptr, ptr, ptr, i32 } %447, ptr nonnull align 8 %2) #7
  %460 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %461 = load ptr, ptr %10, align 8
  %462 = call i1 %461({ ptr, i160 } %459, { ptr, i160 } %419) #7
  br i1 %462, label %HashMap_find_slot_keyK_hashPtri32.exit.loopexit, label %._crit_edge.thread.i

._crit_edge.thread.i:                             ; preds = %._crit_edge.i474, %435
  %463 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %464 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %437)
  %465 = getelementptr i8, ptr %450, i64 56
  %466 = load ptr, ptr %465, align 8
  %result.i70.i = call ptr %466({ ptr, ptr, ptr, i32 } %447, ptr nocapture nofree noundef nonnull readonly %2) #16
  %467 = call { ptr, i160 } %result.i70.i({ ptr, ptr, ptr, i32 } %447, { ptr, ptr, ptr, i32 } %447, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i = extractvalue { ptr, i160 } %467, 0
  %468 = getelementptr i8, ptr %.fca.0.extract19.i, i64 8
  %469 = getelementptr i8, ptr %.fca.0.extract19.i, i64 16
  %470 = getelementptr i8, ptr %.fca.0.extract19.i, i64 24
  %471 = getelementptr i8, ptr %.fca.0.extract19.i, i64 32
  %472 = load i64, ptr %468, align 4
  %473 = load i64, ptr %469, align 4
  %474 = load ptr, ptr %470, align 8
  %475 = load ptr, ptr %471, align 8
  %result.i71.i473 = call i1 %474(i64 %473, i64 %472, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %475) #5
  %476 = icmp eq i32 %spec.store.select.i550, -1
  %or.cond.i = select i1 %result.i71.i473, i1 %476, i1 false
  %spec.store.select.i = select i1 %or.cond.i, i32 %436, i32 %spec.store.select.i550
  %477 = add i32 %436, 1
  %478 = and i32 %477, %423
  %479 = load ptr, ptr %11, align 8
  %480 = sext i32 %478 to i64
  %481 = shl nsw i64 %480, 5
  %482 = getelementptr i8, ptr %479, i64 %481
  %483 = load ptr, ptr %482, align 8
  %484 = icmp eq ptr %483, @nil_typ
  %485 = icmp eq ptr %483, null
  %486 = or i1 %484, %485
  br i1 %486, label %._crit_edge105.loopexit.i, label %435

._crit_edge105.loopexit.i:                        ; preds = %._crit_edge.thread.i
  %487 = icmp eq i32 %spec.store.select.i, -1
  %.pre.i.pre = select i1 %487, i32 %478, i32 %spec.store.select.i
  br label %HashMap_find_slot_keyK_hashPtri32.exit

HashMap_find_slot_keyK_hashPtri32.exit.loopexit:  ; preds = %._crit_edge.i474
  %.pre = load ptr, ptr %11, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit

HashMap_find_slot_keyK_hashPtri32.exit:           ; preds = %HashMap_find_slot_keyK_hashPtri32.exit.loopexit, %418, %._crit_edge105.loopexit.i
  %488 = phi ptr [ %479, %._crit_edge105.loopexit.i ], [ %426, %418 ], [ %.pre, %HashMap_find_slot_keyK_hashPtri32.exit.loopexit ]
  %489 = phi i32 [ %.pre.i.pre, %._crit_edge105.loopexit.i ], [ %424, %418 ], [ %436, %HashMap_find_slot_keyK_hashPtri32.exit.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %490 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %491 = sext i32 %489 to i64
  %492 = shl nsw i64 %491, 5
  %493 = getelementptr i8, ptr %488, i64 %492
  %494 = load ptr, ptr %493, align 8
  %495 = icmp ne ptr %494, @nil_typ
  %496 = icmp ne ptr %494, null
  %.not57.i = and i1 %495, %496
  br i1 %.not57.i, label %497, label %HashMap_get_keyK.exit.thread

497:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit
  %498 = getelementptr i8, ptr %493, i64 8
  %499 = load i64, ptr %498, align 4
  %.sroa_idx.i = getelementptr i8, ptr %493, i64 16
  %500 = load i64, ptr %.sroa_idx.i, align 4
  %501 = inttoptr i64 %499 to ptr
  %502 = inttoptr i64 %500 to ptr
  %hash_coef_ptr.i.i60.i = getelementptr i8, ptr %494, i64 8
  %tbl_size_ptr.i.i61.i = getelementptr i8, ptr %494, i64 16
  %offset_tbl_ptr.i.i62.i = getelementptr i8, ptr %494, i64 40
  %hash_coef.i.i63.i = load i64, ptr %hash_coef_ptr.i.i60.i, align 4, !noalias !76
  %tbl_size.i.i64.i = load i64, ptr %tbl_size_ptr.i.i61.i, align 4, !noalias !76
  %offset_tbl.i.i65.i = load ptr, ptr %offset_tbl_ptr.i.i62.i, align 8, !noalias !76
  %product.i.i.i66.i = mul i64 %hash_coef.i.i63.i, 4015701072841558310
  %shifted.i.i.i67.i = lshr i64 %product.i.i.i66.i, 32
  %xored.i.i.i68.i = xor i64 %shifted.i.i.i67.i, %product.i.i.i66.i
  %hash.i.i.i69.i = and i64 %xored.i.i.i68.i, %tbl_size.i.i64.i
  %offset_ptr.i.i70.i = getelementptr i32, ptr %offset_tbl.i.i65.i, i64 %hash.i.i.i69.i
  %offset.i.i71.i = load i32, ptr %offset_ptr.i.i70.i, align 4, !noalias !76
  %503 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %494, 0
  %504 = insertvalue { ptr, ptr, ptr, i32 } %503, ptr %501, 1
  %505 = insertvalue { ptr, ptr, ptr, i32 } %504, ptr %502, 2
  %506 = insertvalue { ptr, ptr, ptr, i32 } %505, i32 %offset.i.i71.i, 3
  %507 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %508 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %494)
  %509 = sext i32 %offset.i.i71.i to i64
  %510 = getelementptr ptr, ptr %494, i64 %509
  %511 = getelementptr i8, ptr %510, i64 56
  %512 = load ptr, ptr %511, align 8
  %result.i73.i = call ptr %512({ ptr, ptr, ptr, i32 } %506, ptr nocapture nofree noundef nonnull readonly %2) #16
  %513 = call { ptr, i160 } %result.i73.i({ ptr, ptr, ptr, i32 } %506, { ptr, ptr, ptr, i32 } %506, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i = extractvalue { ptr, i160 } %513, 0
  %.fca.1.extract52.i = extractvalue { ptr, i160 } %513, 1
  %514 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %515 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %494)
  %516 = getelementptr i8, ptr %510, i64 64
  %517 = load ptr, ptr %516, align 8
  %result.i74.i = call ptr %517({ ptr, ptr, ptr, i32 } %506, ptr nocapture nofree noundef nonnull readonly %2) #16
  %518 = call i32 %result.i74.i({ ptr, ptr, ptr, i32 } %506, { ptr, ptr, ptr, i32 } %506, ptr nonnull align 8 %2) #7
  %519 = icmp eq i32 %518, %421
  br i1 %519, label %._crit_edge.i, label %HashMap_get_keyK.exit.thread

._crit_edge.i:                                    ; preds = %497
  %520 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %521 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %494)
  %522 = getelementptr i8, ptr %510, i64 48
  %523 = load ptr, ptr %522, align 8
  %result.i75.i = call ptr %523({ ptr, ptr, ptr, i32 } %506, ptr nocapture nofree noundef nonnull readonly %2) #16
  %524 = call { ptr, i160 } %result.i75.i({ ptr, ptr, ptr, i32 } %506, { ptr, ptr, ptr, i32 } %506, ptr nonnull align 8 %2) #7
  %525 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %526 = load ptr, ptr %10, align 8
  %527 = call i1 %526({ ptr, i160 } %524, { ptr, i160 } %419) #7
  br i1 %527, label %HashMap_get_keyK.exit, label %HashMap_get_keyK.exit.thread

HashMap_get_keyK.exit.thread:                     ; preds = %HashMap_find_slot_keyK_hashPtri32.exit, %497, %._crit_edge.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %._crit_edge.lr.ph.i

HashMap_get_keyK.exit:                            ; preds = %._crit_edge.i
  %528 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %529 = load ptr, ptr %4, align 8
  %530 = load ptr, ptr %529, align 8
  %531 = ptrtoint ptr %530 to i64
  %532 = getelementptr i8, ptr %.fca.0.extract51.i, i64 8
  %533 = getelementptr i8, ptr %.fca.0.extract51.i, i64 16
  %534 = getelementptr i8, ptr %.fca.0.extract51.i, i64 24
  %535 = getelementptr i8, ptr %.fca.0.extract51.i, i64 32
  %536 = load i64, ptr %532, align 4
  %537 = load i64, ptr %533, align 4
  %538 = load ptr, ptr %534, align 8
  %539 = load ptr, ptr %535, align 8
  %540 = load i64, ptr %530, align 4
  %result.i77.i = call i1 %538(i64 %537, i64 %536, i64 %540, i64 %531, ptr readonly %539) #5
  %cond.fr.i = freeze i1 %result.i77.i
  %spec.select.i = select i1 %cond.fr.i, ptr %.fca.0.extract51.i, ptr @nil_typ
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %541 = icmp ne ptr %spec.select.i, @nil_typ
  %542 = icmp ne ptr %spec.select.i, null
  %.not150 = and i1 %541, %542
  br i1 %.not150, label %543, label %._crit_edge.lr.ph.i

543:                                              ; preds = %HashMap_get_keyK.exit
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract52.i to i32
  %544 = sext i32 %.sroa.2.8.extract.trunc to i64
  %545 = add i64 %.0141261, %544
  br label %._crit_edge2

._crit_edge.lr.ph.i:                              ; preds = %HashMap_get_keyK.exit, %HashMap_get_keyK.exit.thread
  %result.i161 = call noalias align 64 dereferenceable_or_null(56) ptr @bump_malloc_inner(i64 noundef 56, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %546 = load <55 x i8>, ptr @mbvap_Error_Nil_returned_during_sequential_hit_test_for_key_, align 64
  store <55 x i8> %546, ptr %result.i161, align 64
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %547 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %548 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i489 = call noalias dereferenceable_or_null(56) ptr @bump_malloc_inner(i64 noundef 56, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(55) %result.i.i489, ptr noundef nonnull align 64 dereferenceable(55) %result.i161, i64 55, i1 false)
  %549 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %550 = getelementptr i8, ptr %result.i.i489, i64 55
  store i8 0, ptr %550, align 1
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i489)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %551 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %552 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.2262) #17
  br label %._crit_edge2

._crit_edge2:                                     ; preds = %543, %._crit_edge.lr.ph.i
  %.2146 = phi i1 [ %.0144260, %543 ], [ false, %._crit_edge.lr.ph.i ]
  %.2143 = phi i64 [ %545, %543 ], [ %.0141261, %._crit_edge.lr.ph.i ]
  %553 = add nuw nsw i32 %.2262, 1
  %554 = icmp slt i32 %553, %0
  br i1 %554, label %418, label %._crit_edge.lr.ph.i505

._crit_edge.lr.ph.i505:                           ; preds = %._crit_edge2, %._crit_edge1._crit_edge.thread
  %555 = phi i64 [ %19, %._crit_edge1._crit_edge.thread ], [ %417, %._crit_edge2 ]
  %.0139.lcssa270 = phi i64 [ 0, %._crit_edge1._crit_edge.thread ], [ %415, %._crit_edge2 ]
  %.0144.lcssa = phi i1 [ true, %._crit_edge1._crit_edge.thread ], [ %.2146, %._crit_edge2 ]
  %.0141.lcssa = phi i64 [ 0, %._crit_edge1._crit_edge.thread ], [ %.2143, %._crit_edge2 ]
  %556 = call i64 @clock()
  %result.i167 = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <18 x i8> <i8 71, i8 101, i8 116, i8 32, i8 83, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108, i8 32, i8 72, i8 105, i8 116>, ptr %result.i167, align 32
  %557 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #34
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %558 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %559 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i504 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i504, ptr noundef nonnull align 32 dereferenceable(18) %result.i167, i64 18, i1 false)
  %560 = sub i64 %556, %555
  %561 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %562 = getelementptr i8, ptr %result.i.i504, i64 18
  store i8 0, ptr %562, align 1
  %puts.i391 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i504)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i97.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i97.i, align 16
  %result.i.i375.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i375.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i97.i, i64 14, i1 false)
  %puts.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i375.i)
  %563 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %0) #17
  %result.i103.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i103.i, align 16
  %result.i.i389.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i389.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i103.i, i64 14, i1 false)
  %puts.i313.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i389.i)
  %564 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %560) #17
  %result.i109.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i109.i, align 4
  %result.i.i408.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i408.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i109.i, i64 3, i1 false)
  %puts.i333.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i408.i)
  br i1 %14, label %._crit_edge1.i, label %._crit_edge.lr.ph.i524

._crit_edge1.i:                                   ; preds = %._crit_edge.lr.ph.i505
  %565 = icmp sgt i64 %560, 0
  br i1 %565, label %566, label %._crit_edge.lr.ph.i428.i

566:                                              ; preds = %._crit_edge1.i
  %567 = zext nneg i32 %0 to i64
  %568 = mul i64 %560, 1000000
  %569 = sdiv i64 %568, %567
  br label %._crit_edge.lr.ph.i428.i

._crit_edge.lr.ph.i428.i:                         ; preds = %566, %._crit_edge1.i
  %.0.i = phi i64 [ %569, %566 ], [ 0, %._crit_edge1.i ]
  %result.i114.i = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i114.i, align 16
  %result.i.i427.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i427.i, ptr noundef nonnull align 16 dereferenceable(15) %result.i114.i, i64 15, i1 false)
  %puts.i353.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i427.i)
  %570 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0.i) #17
  %result.i120.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i120.i, align 4
  %571 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %result.i.i446.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i446.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i120.i, i64 3, i1 false)
  %572 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %puts.i373.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i446.i)
  br label %._crit_edge.lr.ph.i524

._crit_edge.lr.ph.i524:                           ; preds = %._crit_edge.lr.ph.i505, %._crit_edge.lr.ph.i428.i
  %.not = icmp eq i64 %.0141.lcssa, %.0139.lcssa270
  %result.i171 = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i171, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %573 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %574 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i523 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i523, ptr noundef nonnull align 32 dereferenceable(18) %result.i171, i64 18, i1 false)
  %spec.select = select i1 %.not, i1 %.0144.lcssa, i1 false
  %575 = getelementptr i8, ptr %result.i.i523, i64 18
  store i8 0, ptr %575, align 1
  %puts.i411 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i523)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %. = select i1 %spec.select, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %576 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %577 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %578 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i542 = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <4 x i8> %., ptr %result.i.i542, align 1
  %579 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %580 = getelementptr i8, ptr %result.i.i542, i64 4
  store i8 0, ptr %580, align 1
  %puts.i431 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i542)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  ret void
}

define void @benchmark_get_random_hit(i32 %0) local_unnamed_addr {
  %2 = alloca [0 x ptr], align 8
  %3 = alloca [3 x ptr], align 8
  %4 = alloca [3 x ptr], align 8
  %oldProtect.i332 = alloca i32, align 4
  %oldProtect.i328 = alloca i32, align 4
  %oldProtect.i287 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %.sroa.0224.sroa.0 = alloca i8, align 8
  %result.i283 = tail call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i283, align 8
  %5 = getelementptr inbounds i8, ptr %result.i283, i64 8
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %result.i283, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %6, align 8
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i283) #38
  %result.i284 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i)
  %result.i285 = call i32 @VirtualProtect(ptr nofree %result.i284, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i284, ptr noalias nofree noundef nonnull readnone @gfgpcwhvzl, ptr noalias nofree noundef nonnull readnone @i32_hasher) #38
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i284) #39
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i284) #38
  %result.i286 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i287)
  %result.i288 = call i32 @VirtualProtect(ptr nofree %result.i286, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i287) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i287)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i286, ptr noalias nofree noundef nonnull readnone @ehsipluukj, ptr noalias nofree noundef nonnull readnone @i32_eq) #38
  %ret.i289 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i286) #39
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i286) #38
  %10 = getelementptr inbounds i8, ptr %result.i283, i64 48
  store ptr %ret.i, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %result.i283, i64 56
  store ptr %ret.i289, ptr %11, align 8
  %result.i.i541 = call noalias dereferenceable_or_null(512) ptr @bump_malloc_inner(i64 noundef 512, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %12 = getelementptr inbounds i8, ptr %result.i283, i64 24
  store ptr %result.i.i541, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %result.i283, i64 32
  store i32 16, ptr %13, align 8
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #34
  %15 = sext i32 %0 to i64
  %16 = shl nsw i64 %15, 2
  %result.i4.i = call noalias ptr @bump_malloc_inner(i64 noundef %16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #34
  %result.i326 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i326, align 8
  %18 = getelementptr inbounds i8, ptr %result.i326, i64 8
  store ptr @_parameterization_Ptri1, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %result.i326, i64 16
  store ptr @_parameterization_PairPtri32._Ptri1, ptr %19, align 8
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i326)
  %result.i327 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i328)
  %result.i329 = call i32 @VirtualProtect(ptr nofree %result.i327, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i328) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i328)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i327, ptr noalias nofree noundef nonnull readnone @njmyxpctxz, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %ret.i330 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i327) #39
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i327)
  %result.i331 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i332)
  %result.i333 = call i32 @VirtualProtect(ptr nofree %result.i331, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i332) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i332)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i331, ptr noalias nofree noundef nonnull readnone @egzihtnwnj, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %ret.i334 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i331) #39
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i331)
  %23 = getelementptr inbounds i8, ptr %result.i326, i64 48
  store ptr %ret.i330, ptr %23, align 8
  %24 = getelementptr inbounds i8, ptr %result.i326, i64 56
  store ptr %ret.i334, ptr %24, align 8
  %result.i.i581 = call noalias dereferenceable_or_null(512) ptr @bump_malloc_inner(i64 noundef 512, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %25 = getelementptr inbounds i8, ptr %result.i326, i64 24
  store ptr %result.i.i581, ptr %25, align 8
  %26 = getelementptr inbounds i8, ptr %result.i326, i64 32
  store i32 16, ptr %26, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #34
  %28 = mul i32 %0, 10
  %29 = icmp sgt i32 %0, 0
  %30 = icmp sgt i32 %28, 0
  %spec.select526 = and i1 %29, %30
  br i1 %spec.select526, label %.lr.ph, label %._crit_edge3._crit_edge

.lr.ph:                                           ; preds = %1
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #34
  %33 = getelementptr inbounds i8, ptr %result.i283, i64 40
  %34 = getelementptr inbounds i8, ptr %result.i326, i64 40
  %35 = getelementptr inbounds i8, ptr %result.i283, i64 36
  %36 = getelementptr inbounds i8, ptr %result.i326, i64 36
  %37 = getelementptr inbounds i8, ptr %4, i64 8
  %38 = getelementptr inbounds i8, ptr %4, i64 16
  %39 = getelementptr inbounds i8, ptr %3, i64 8
  %40 = getelementptr inbounds i8, ptr %3, i64 16
  br label %41

41:                                               ; preds = %.lr.ph, %._crit_edge1
  %42 = phi i32 [ 456, %.lr.ph ], [ %45, %._crit_edge1 ]
  %.0264529 = phi i32 [ 0, %.lr.ph ], [ %963, %._crit_edge1 ]
  %.0266528 = phi i32 [ 0, %.lr.ph ], [ %.2268, %._crit_edge1 ]
  %.0275527 = phi i64 [ 0, %.lr.ph ], [ %.2277, %._crit_edge1 ]
  %43 = mul i32 %42, 1103515245
  %44 = add i32 %43, 12345
  %45 = and i32 %44, 2147483647
  %.sroa.0252.0.insert.ext = zext nneg i32 %45 to i160
  %46 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0252.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %47 = load ptr, ptr %23, align 8
  %48 = call i32 %47({ ptr, i160 } %46) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %49 = load i32, ptr %26, align 8
  %50 = add i32 %49, -1
  %51 = and i32 %50, %48
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %53 = load ptr, ptr %25, align 8
  %54 = sext i32 %51 to i64
  %55 = shl nsw i64 %54, 5
  %56 = getelementptr i8, ptr %53, i64 %55
  %57 = load ptr, ptr %56, align 8
  %58 = icmp eq ptr %57, @nil_typ
  %59 = icmp eq ptr %57, null
  %60 = or i1 %58, %59
  br i1 %60, label %HashMap_find_slot_keyK_hashPtri32.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %41
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %62

62:                                               ; preds = %._crit_edge.thread.i, %.lr.ph.i
  %63 = phi i32 [ %51, %.lr.ph.i ], [ %105, %._crit_edge.thread.i ]
  %spec.store.select.i1193 = phi i32 [ -1, %.lr.ph.i ], [ %spec.store.select.i, %._crit_edge.thread.i ]
  %64 = phi ptr [ %57, %.lr.ph.i ], [ %110, %._crit_edge.thread.i ]
  %65 = phi ptr [ %56, %.lr.ph.i ], [ %109, %._crit_edge.thread.i ]
  %.sroa_idx.i929 = getelementptr i8, ptr %65, i64 16
  %66 = load i64, ptr %.sroa_idx.i929, align 4
  %67 = getelementptr i8, ptr %65, i64 8
  %68 = load i64, ptr %67, align 4
  %69 = inttoptr i64 %68 to ptr
  %70 = inttoptr i64 %66 to ptr
  %hash_coef_ptr.i.i56.i = getelementptr i8, ptr %64, i64 8
  %tbl_size_ptr.i.i57.i = getelementptr i8, ptr %64, i64 16
  %offset_tbl_ptr.i.i58.i = getelementptr i8, ptr %64, i64 40
  %hash_coef.i.i59.i = load i64, ptr %hash_coef_ptr.i.i56.i, align 4
  %tbl_size.i.i60.i = load i64, ptr %tbl_size_ptr.i.i57.i, align 4
  %offset_tbl.i.i61.i = load ptr, ptr %offset_tbl_ptr.i.i58.i, align 8
  %product.i.i.i62.i = mul i64 %hash_coef.i.i59.i, 4015701072841558310
  %shifted.i.i.i63.i = lshr i64 %product.i.i.i62.i, 32
  %xored.i.i.i64.i = xor i64 %shifted.i.i.i63.i, %product.i.i.i62.i
  %hash.i.i.i65.i = and i64 %xored.i.i.i64.i, %tbl_size.i.i60.i
  %offset_ptr.i.i66.i = getelementptr i32, ptr %offset_tbl.i.i61.i, i64 %hash.i.i.i65.i
  %offset.i.i67.i = load i32, ptr %offset_ptr.i.i66.i, align 4
  %71 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %64, 0
  %72 = insertvalue { ptr, ptr, ptr, i32 } %71, ptr %69, 1
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr %70, 2
  %74 = insertvalue { ptr, ptr, ptr, i32 } %73, i32 %offset.i.i67.i, 3
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %64)
  %76 = sext i32 %offset.i.i67.i to i64
  %77 = getelementptr ptr, ptr %64, i64 %76
  %78 = getelementptr i8, ptr %77, i64 64
  %79 = load ptr, ptr %78, align 8
  %result.i.i = call ptr %79({ ptr, ptr, ptr, i32 } %74, ptr nocapture nofree noundef nonnull readonly %2) #16
  %80 = call i32 %result.i.i({ ptr, ptr, ptr, i32 } %74, { ptr, ptr, ptr, i32 } %74, ptr nonnull align 8 %2) #7
  %81 = icmp eq i32 %80, %48
  br i1 %81, label %._crit_edge.i930, label %._crit_edge.thread.i

._crit_edge.i930:                                 ; preds = %62
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %64)
  %84 = getelementptr i8, ptr %77, i64 48
  %85 = load ptr, ptr %84, align 8
  %result.i69.i = call ptr %85({ ptr, ptr, ptr, i32 } %74, ptr nocapture nofree noundef nonnull readonly %2) #16
  %86 = call { ptr, i160 } %result.i69.i({ ptr, ptr, ptr, i32 } %74, { ptr, ptr, ptr, i32 } %74, ptr nonnull align 8 %2) #7
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %88 = load ptr, ptr %24, align 8
  %89 = call i1 %88({ ptr, i160 } %86, { ptr, i160 } %46) #7
  br i1 %89, label %HashMap_find_slot_keyK_hashPtri32.exit.loopexit, label %._crit_edge.thread.i

._crit_edge.thread.i:                             ; preds = %._crit_edge.i930, %62
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %64)
  %92 = getelementptr i8, ptr %77, i64 56
  %93 = load ptr, ptr %92, align 8
  %result.i70.i = call ptr %93({ ptr, ptr, ptr, i32 } %74, ptr nocapture nofree noundef nonnull readonly %2) #16
  %94 = call { ptr, i160 } %result.i70.i({ ptr, ptr, ptr, i32 } %74, { ptr, ptr, ptr, i32 } %74, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i = extractvalue { ptr, i160 } %94, 0
  %95 = getelementptr i8, ptr %.fca.0.extract19.i, i64 8
  %96 = getelementptr i8, ptr %.fca.0.extract19.i, i64 16
  %97 = getelementptr i8, ptr %.fca.0.extract19.i, i64 24
  %98 = getelementptr i8, ptr %.fca.0.extract19.i, i64 32
  %99 = load i64, ptr %95, align 4
  %100 = load i64, ptr %96, align 4
  %101 = load ptr, ptr %97, align 8
  %102 = load ptr, ptr %98, align 8
  %result.i71.i = call i1 %101(i64 %100, i64 %99, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %102) #5
  %103 = icmp eq i32 %spec.store.select.i1193, -1
  %or.cond.i = select i1 %result.i71.i, i1 %103, i1 false
  %spec.store.select.i = select i1 %or.cond.i, i32 %63, i32 %spec.store.select.i1193
  %104 = add i32 %63, 1
  %105 = and i32 %104, %50
  %106 = load ptr, ptr %25, align 8
  %107 = sext i32 %105 to i64
  %108 = shl nsw i64 %107, 5
  %109 = getelementptr i8, ptr %106, i64 %108
  %110 = load ptr, ptr %109, align 8
  %111 = icmp eq ptr %110, @nil_typ
  %112 = icmp eq ptr %110, null
  %113 = or i1 %111, %112
  br i1 %113, label %._crit_edge105.loopexit.i, label %62

._crit_edge105.loopexit.i:                        ; preds = %._crit_edge.thread.i
  %114 = icmp eq i32 %spec.store.select.i, -1
  %.pre.i.pre = select i1 %114, i32 %105, i32 %spec.store.select.i
  br label %HashMap_find_slot_keyK_hashPtri32.exit

HashMap_find_slot_keyK_hashPtri32.exit.loopexit:  ; preds = %._crit_edge.i930
  %.pre = load ptr, ptr %25, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit

HashMap_find_slot_keyK_hashPtri32.exit:           ; preds = %HashMap_find_slot_keyK_hashPtri32.exit.loopexit, %41, %._crit_edge105.loopexit.i
  %115 = phi ptr [ %106, %._crit_edge105.loopexit.i ], [ %53, %41 ], [ %.pre, %HashMap_find_slot_keyK_hashPtri32.exit.loopexit ]
  %116 = phi i32 [ %.pre.i.pre, %._crit_edge105.loopexit.i ], [ %51, %41 ], [ %63, %HashMap_find_slot_keyK_hashPtri32.exit.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %117 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %118 = sext i32 %116 to i64
  %119 = shl nsw i64 %118, 5
  %120 = getelementptr i8, ptr %115, i64 %119
  %121 = load ptr, ptr %120, align 8
  %122 = icmp ne ptr %121, @nil_typ
  %123 = icmp ne ptr %121, null
  %.not57.i = and i1 %122, %123
  br i1 %.not57.i, label %124, label %HashMap_get_keyK.exit.thread

124:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit
  %125 = getelementptr i8, ptr %120, i64 8
  %126 = load i64, ptr %125, align 4
  %.sroa_idx.i = getelementptr i8, ptr %120, i64 16
  %127 = load i64, ptr %.sroa_idx.i, align 4
  %128 = inttoptr i64 %126 to ptr
  %129 = inttoptr i64 %127 to ptr
  %hash_coef_ptr.i.i60.i = getelementptr i8, ptr %121, i64 8
  %tbl_size_ptr.i.i61.i = getelementptr i8, ptr %121, i64 16
  %offset_tbl_ptr.i.i62.i = getelementptr i8, ptr %121, i64 40
  %hash_coef.i.i63.i = load i64, ptr %hash_coef_ptr.i.i60.i, align 4, !noalias !79
  %tbl_size.i.i64.i = load i64, ptr %tbl_size_ptr.i.i61.i, align 4, !noalias !79
  %offset_tbl.i.i65.i = load ptr, ptr %offset_tbl_ptr.i.i62.i, align 8, !noalias !79
  %product.i.i.i66.i = mul i64 %hash_coef.i.i63.i, 4015701072841558310
  %shifted.i.i.i67.i = lshr i64 %product.i.i.i66.i, 32
  %xored.i.i.i68.i = xor i64 %shifted.i.i.i67.i, %product.i.i.i66.i
  %hash.i.i.i69.i = and i64 %xored.i.i.i68.i, %tbl_size.i.i64.i
  %offset_ptr.i.i70.i = getelementptr i32, ptr %offset_tbl.i.i65.i, i64 %hash.i.i.i69.i
  %offset.i.i71.i = load i32, ptr %offset_ptr.i.i70.i, align 4, !noalias !79
  %130 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %121, 0
  %131 = insertvalue { ptr, ptr, ptr, i32 } %130, ptr %128, 1
  %132 = insertvalue { ptr, ptr, ptr, i32 } %131, ptr %129, 2
  %133 = insertvalue { ptr, ptr, ptr, i32 } %132, i32 %offset.i.i71.i, 3
  %134 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %135 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %121)
  %136 = sext i32 %offset.i.i71.i to i64
  %137 = getelementptr ptr, ptr %121, i64 %136
  %138 = getelementptr i8, ptr %137, i64 56
  %139 = load ptr, ptr %138, align 8
  %result.i73.i = call ptr %139({ ptr, ptr, ptr, i32 } %133, ptr nocapture nofree noundef nonnull readonly %2) #16
  %140 = call { ptr, i160 } %result.i73.i({ ptr, ptr, ptr, i32 } %133, { ptr, ptr, ptr, i32 } %133, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i = extractvalue { ptr, i160 } %140, 0
  %141 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %142 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %121)
  %143 = getelementptr i8, ptr %137, i64 64
  %144 = load ptr, ptr %143, align 8
  %result.i74.i = call ptr %144({ ptr, ptr, ptr, i32 } %133, ptr nocapture nofree noundef nonnull readonly %2) #16
  %145 = call i32 %result.i74.i({ ptr, ptr, ptr, i32 } %133, { ptr, ptr, ptr, i32 } %133, ptr nonnull align 8 %2) #7
  %146 = icmp eq i32 %145, %48
  br i1 %146, label %._crit_edge.i, label %HashMap_get_keyK.exit.thread

._crit_edge.i:                                    ; preds = %124
  %147 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %148 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %121)
  %149 = getelementptr i8, ptr %137, i64 48
  %150 = load ptr, ptr %149, align 8
  %result.i75.i = call ptr %150({ ptr, ptr, ptr, i32 } %133, ptr nocapture nofree noundef nonnull readonly %2) #16
  %151 = call { ptr, i160 } %result.i75.i({ ptr, ptr, ptr, i32 } %133, { ptr, ptr, ptr, i32 } %133, ptr nonnull align 8 %2) #7
  %152 = load ptr, ptr %24, align 8
  %153 = call i1 %152({ ptr, i160 } %151, { ptr, i160 } %46) #7
  br i1 %153, label %HashMap_get_keyK.exit, label %HashMap_get_keyK.exit.thread

HashMap_get_keyK.exit.thread:                     ; preds = %HashMap_find_slot_keyK_hashPtri32.exit, %124, %._crit_edge.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %170

HashMap_get_keyK.exit:                            ; preds = %._crit_edge.i
  %154 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %155 = load ptr, ptr %18, align 8
  %156 = load ptr, ptr %155, align 8
  %157 = ptrtoint ptr %156 to i64
  %158 = getelementptr i8, ptr %.fca.0.extract51.i, i64 8
  %159 = getelementptr i8, ptr %.fca.0.extract51.i, i64 16
  %160 = getelementptr i8, ptr %.fca.0.extract51.i, i64 24
  %161 = getelementptr i8, ptr %.fca.0.extract51.i, i64 32
  %162 = load i64, ptr %158, align 4
  %163 = load i64, ptr %159, align 4
  %164 = load ptr, ptr %160, align 8
  %165 = load ptr, ptr %161, align 8
  %166 = load i64, ptr %156, align 4
  %result.i77.i = call i1 %164(i64 %163, i64 %162, i64 %166, i64 %157, ptr readonly %165) #5
  %cond.fr.i = freeze i1 %result.i77.i
  %spec.select.i = select i1 %cond.fr.i, ptr %.fca.0.extract51.i, ptr @nil_typ
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %167 = icmp eq ptr %spec.select.i, @nil_typ
  %168 = icmp eq ptr %spec.select.i, null
  %169 = or i1 %167, %168
  br i1 %169, label %170, label %._crit_edge1

170:                                              ; preds = %HashMap_get_keyK.exit.thread, %HashMap_get_keyK.exit
  %171 = add nuw i32 %45, 1
  %.sroa.0234.0.insert.ext = zext i32 %171 to i160
  %172 = load i32, ptr %33, align 8
  %173 = load i32, ptr %13, align 8
  %174 = icmp eq i32 %173, 0
  %175 = mul i32 %172, 10
  %176 = add i32 %175, 10
  %177 = mul i32 %173, 6
  %178 = icmp sge i32 %176, %177
  %.0.i943 = select i1 %174, i1 true, i1 %178
  br i1 %.0.i943, label %._crit_edge1.i945, label %HashMap_ensure_capacity_required_loadPtri32.exit

._crit_edge1.i945:                                ; preds = %170
  %179 = shl i32 %173, 1
  %spec.select.i946 = call i32 @llvm.smax.i32(i32 %179, i32 16)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %180 = load ptr, ptr %12, align 8
  %181 = zext nneg i32 %spec.select.i946 to i64
  %182 = shl nuw nsw i64 %181, 5
  %result.i.i1243 = call noalias ptr @bump_malloc_inner(i64 noundef %182, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1243, ptr %12, align 8
  store i32 %spec.select.i946, ptr %13, align 8
  store i32 0, ptr %35, align 4
  %183 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #38
  store i32 0, ptr %33, align 8
  %184 = icmp sgt i32 %173, 0
  br i1 %184, label %.lr.ph.i1244, label %HashMap_resize_new_capacityPtri32.exit

.lr.ph.i1244:                                     ; preds = %._crit_edge1.i945, %._crit_edge.i1245
  %.096.i = phi i32 [ %387, %._crit_edge.i1245 ], [ 0, %._crit_edge1.i945 ]
  %185 = zext nneg i32 %.096.i to i64
  %186 = shl nuw nsw i64 %185, 5
  %187 = getelementptr i8, ptr %180, i64 %186
  %188 = load ptr, ptr %187, align 8
  %189 = icmp ne ptr %188, @nil_typ
  %190 = icmp ne ptr %188, null
  %.not40.i = and i1 %189, %190
  br i1 %.not40.i, label %191, label %._crit_edge.i1245

191:                                              ; preds = %.lr.ph.i1244
  %192 = getelementptr i8, ptr %187, i64 8
  %193 = load i64, ptr %192, align 4
  %.sroa_idx.i1246 = getelementptr i8, ptr %187, i64 16
  %194 = load i64, ptr %.sroa_idx.i1246, align 4
  %195 = inttoptr i64 %193 to ptr
  %196 = inttoptr i64 %194 to ptr
  %hash_coef_ptr.i.i42.i = getelementptr i8, ptr %188, i64 8
  %tbl_size_ptr.i.i43.i = getelementptr i8, ptr %188, i64 16
  %offset_tbl_ptr.i.i44.i = getelementptr i8, ptr %188, i64 40
  %hash_coef.i.i45.i = load i64, ptr %hash_coef_ptr.i.i42.i, align 4, !noalias !82
  %tbl_size.i.i46.i = load i64, ptr %tbl_size_ptr.i.i43.i, align 4, !noalias !82
  %offset_tbl.i.i47.i = load ptr, ptr %offset_tbl_ptr.i.i44.i, align 8, !noalias !82
  %product.i.i.i48.i = mul i64 %hash_coef.i.i45.i, 4015701072841558310
  %shifted.i.i.i49.i = lshr i64 %product.i.i.i48.i, 32
  %xored.i.i.i50.i = xor i64 %shifted.i.i.i49.i, %product.i.i.i48.i
  %hash.i.i.i51.i = and i64 %xored.i.i.i50.i, %tbl_size.i.i46.i
  %offset_ptr.i.i52.i = getelementptr i32, ptr %offset_tbl.i.i47.i, i64 %hash.i.i.i51.i
  %offset.i.i53.i = load i32, ptr %offset_ptr.i.i52.i, align 4, !noalias !82
  %197 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %188, 0
  %198 = insertvalue { ptr, ptr, ptr, i32 } %197, ptr %195, 1
  %199 = insertvalue { ptr, ptr, ptr, i32 } %198, ptr %196, 2
  %200 = insertvalue { ptr, ptr, ptr, i32 } %199, i32 %offset.i.i53.i, 3
  %201 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %202 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %188)
  %203 = sext i32 %offset.i.i53.i to i64
  %204 = getelementptr ptr, ptr %188, i64 %203
  %205 = getelementptr i8, ptr %204, i64 56
  %206 = load ptr, ptr %205, align 8
  %result.i55.i = call ptr %206({ ptr, ptr, ptr, i32 } %200, ptr nocapture nofree noundef nonnull readonly %2) #16
  %207 = call { ptr, i160 } %result.i55.i({ ptr, ptr, ptr, i32 } %200, { ptr, ptr, ptr, i32 } %200, ptr nonnull align 8 %2) #7
  %.fca.0.extract29.i = extractvalue { ptr, i160 } %207, 0
  %208 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %209 = load ptr, ptr %5, align 8
  %210 = load ptr, ptr %209, align 8
  %211 = ptrtoint ptr %210 to i64
  %212 = getelementptr i8, ptr %.fca.0.extract29.i, i64 8
  %213 = getelementptr i8, ptr %.fca.0.extract29.i, i64 16
  %214 = getelementptr i8, ptr %.fca.0.extract29.i, i64 24
  %215 = getelementptr i8, ptr %.fca.0.extract29.i, i64 32
  %216 = load i64, ptr %212, align 4
  %217 = load i64, ptr %213, align 4
  %218 = load ptr, ptr %214, align 8
  %219 = load ptr, ptr %215, align 8
  %220 = load i64, ptr %210, align 4
  %result.i57.i = call i1 %218(i64 %217, i64 %216, i64 %220, i64 %211, ptr readonly %219) #5
  br i1 %result.i57.i, label %221, label %._crit_edge.i1245

221:                                              ; preds = %191
  %222 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %223 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %188)
  %224 = getelementptr i8, ptr %204, i64 48
  %225 = load ptr, ptr %224, align 8
  %result.i58.i = call ptr %225({ ptr, ptr, ptr, i32 } %200, ptr nocapture nofree noundef nonnull readonly %2) #16
  %226 = call { ptr, i160 } %result.i58.i({ ptr, ptr, ptr, i32 } %200, { ptr, ptr, ptr, i32 } %200, ptr nonnull align 8 %2) #7
  %227 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %228 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %188)
  %229 = getelementptr i8, ptr %204, i64 64
  %230 = load ptr, ptr %229, align 8
  %result.i59.i = call ptr %230({ ptr, ptr, ptr, i32 } %200, ptr nocapture nofree noundef nonnull readonly %2) #16
  %231 = call i32 %result.i59.i({ ptr, ptr, ptr, i32 } %200, { ptr, ptr, ptr, i32 } %200, ptr nonnull align 8 %2) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %4)
  %232 = load ptr, ptr %result.i283, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %233 = load i32, ptr %13, align 8
  %234 = add i32 %233, -1
  %235 = and i32 %234, %231
  %236 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %237 = load ptr, ptr %12, align 8
  %238 = sext i32 %235 to i64
  %239 = shl nsw i64 %238, 5
  %240 = getelementptr i8, ptr %237, i64 %239
  %241 = load ptr, ptr %240, align 8
  %242 = icmp eq ptr %241, @nil_typ
  %243 = icmp eq ptr %241, null
  %244 = or i1 %242, %243
  br i1 %244, label %HashMap_find_slot_keyK_hashPtri32.exit1701, label %.lr.ph.i1677

.lr.ph.i1677:                                     ; preds = %221
  %245 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %246

246:                                              ; preds = %._crit_edge.thread.i1692, %.lr.ph.i1677
  %247 = phi i32 [ %235, %.lr.ph.i1677 ], [ %289, %._crit_edge.thread.i1692 ]
  %spec.store.select.i16971767 = phi i32 [ -1, %.lr.ph.i1677 ], [ %spec.store.select.i1697, %._crit_edge.thread.i1692 ]
  %248 = phi ptr [ %241, %.lr.ph.i1677 ], [ %294, %._crit_edge.thread.i1692 ]
  %249 = phi ptr [ %240, %.lr.ph.i1677 ], [ %293, %._crit_edge.thread.i1692 ]
  %.sroa_idx.i1678 = getelementptr i8, ptr %249, i64 16
  %250 = load i64, ptr %.sroa_idx.i1678, align 4
  %251 = getelementptr i8, ptr %249, i64 8
  %252 = load i64, ptr %251, align 4
  %253 = inttoptr i64 %252 to ptr
  %254 = inttoptr i64 %250 to ptr
  %hash_coef_ptr.i.i56.i1679 = getelementptr i8, ptr %248, i64 8
  %tbl_size_ptr.i.i57.i1680 = getelementptr i8, ptr %248, i64 16
  %offset_tbl_ptr.i.i58.i1681 = getelementptr i8, ptr %248, i64 40
  %hash_coef.i.i59.i1682 = load i64, ptr %hash_coef_ptr.i.i56.i1679, align 4
  %tbl_size.i.i60.i1683 = load i64, ptr %tbl_size_ptr.i.i57.i1680, align 4
  %offset_tbl.i.i61.i1684 = load ptr, ptr %offset_tbl_ptr.i.i58.i1681, align 8
  %product.i.i.i62.i1685 = mul i64 %hash_coef.i.i59.i1682, 4015701072841558310
  %shifted.i.i.i63.i1686 = lshr i64 %product.i.i.i62.i1685, 32
  %xored.i.i.i64.i1687 = xor i64 %shifted.i.i.i63.i1686, %product.i.i.i62.i1685
  %hash.i.i.i65.i1688 = and i64 %xored.i.i.i64.i1687, %tbl_size.i.i60.i1683
  %offset_ptr.i.i66.i1689 = getelementptr i32, ptr %offset_tbl.i.i61.i1684, i64 %hash.i.i.i65.i1688
  %offset.i.i67.i1690 = load i32, ptr %offset_ptr.i.i66.i1689, align 4
  %255 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %248, 0
  %256 = insertvalue { ptr, ptr, ptr, i32 } %255, ptr %253, 1
  %257 = insertvalue { ptr, ptr, ptr, i32 } %256, ptr %254, 2
  %258 = insertvalue { ptr, ptr, ptr, i32 } %257, i32 %offset.i.i67.i1690, 3
  %259 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %248)
  %260 = sext i32 %offset.i.i67.i1690 to i64
  %261 = getelementptr ptr, ptr %248, i64 %260
  %262 = getelementptr i8, ptr %261, i64 64
  %263 = load ptr, ptr %262, align 8
  %result.i.i1691 = call ptr %263({ ptr, ptr, ptr, i32 } %258, ptr nocapture nofree noundef nonnull readonly %2) #16
  %264 = call i32 %result.i.i1691({ ptr, ptr, ptr, i32 } %258, { ptr, ptr, ptr, i32 } %258, ptr nonnull align 8 %2) #7
  %265 = icmp eq i32 %264, %231
  br i1 %265, label %._crit_edge.i1699, label %._crit_edge.thread.i1692

._crit_edge.i1699:                                ; preds = %246
  %266 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %267 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %248)
  %268 = getelementptr i8, ptr %261, i64 48
  %269 = load ptr, ptr %268, align 8
  %result.i69.i1700 = call ptr %269({ ptr, ptr, ptr, i32 } %258, ptr nocapture nofree noundef nonnull readonly %2) #16
  %270 = call { ptr, i160 } %result.i69.i1700({ ptr, ptr, ptr, i32 } %258, { ptr, ptr, ptr, i32 } %258, ptr nonnull align 8 %2) #7
  %271 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %272 = load ptr, ptr %11, align 8
  %273 = call i1 %272({ ptr, i160 } %270, { ptr, i160 } %226) #7
  br i1 %273, label %HashMap_find_slot_keyK_hashPtri32.exit1701.loopexit, label %._crit_edge.thread.i1692

._crit_edge.thread.i1692:                         ; preds = %._crit_edge.i1699, %246
  %274 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %275 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %248)
  %276 = getelementptr i8, ptr %261, i64 56
  %277 = load ptr, ptr %276, align 8
  %result.i70.i1693 = call ptr %277({ ptr, ptr, ptr, i32 } %258, ptr nocapture nofree noundef nonnull readonly %2) #16
  %278 = call { ptr, i160 } %result.i70.i1693({ ptr, ptr, ptr, i32 } %258, { ptr, ptr, ptr, i32 } %258, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i1694 = extractvalue { ptr, i160 } %278, 0
  %279 = getelementptr i8, ptr %.fca.0.extract19.i1694, i64 8
  %280 = getelementptr i8, ptr %.fca.0.extract19.i1694, i64 16
  %281 = getelementptr i8, ptr %.fca.0.extract19.i1694, i64 24
  %282 = getelementptr i8, ptr %.fca.0.extract19.i1694, i64 32
  %283 = load i64, ptr %279, align 4
  %284 = load i64, ptr %280, align 4
  %285 = load ptr, ptr %281, align 8
  %286 = load ptr, ptr %282, align 8
  %result.i71.i1695 = call i1 %285(i64 %284, i64 %283, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %286) #5
  %287 = icmp eq i32 %spec.store.select.i16971767, -1
  %or.cond.i1696 = select i1 %result.i71.i1695, i1 %287, i1 false
  %spec.store.select.i1697 = select i1 %or.cond.i1696, i32 %247, i32 %spec.store.select.i16971767
  %288 = add i32 %247, 1
  %289 = and i32 %288, %234
  %290 = load ptr, ptr %12, align 8
  %291 = sext i32 %289 to i64
  %292 = shl nsw i64 %291, 5
  %293 = getelementptr i8, ptr %290, i64 %292
  %294 = load ptr, ptr %293, align 8
  %295 = icmp eq ptr %294, @nil_typ
  %296 = icmp eq ptr %294, null
  %297 = or i1 %295, %296
  br i1 %297, label %._crit_edge105.loopexit.i1698, label %246

._crit_edge105.loopexit.i1698:                    ; preds = %._crit_edge.thread.i1692
  %298 = icmp eq i32 %spec.store.select.i1697, -1
  %.pre.i.pre1806 = select i1 %298, i32 %289, i32 %spec.store.select.i1697
  br label %HashMap_find_slot_keyK_hashPtri32.exit1701

HashMap_find_slot_keyK_hashPtri32.exit1701.loopexit: ; preds = %._crit_edge.i1699
  %.pre1876 = load ptr, ptr %12, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit1701

HashMap_find_slot_keyK_hashPtri32.exit1701:       ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1701.loopexit, %221, %._crit_edge105.loopexit.i1698
  %299 = phi ptr [ %290, %._crit_edge105.loopexit.i1698 ], [ %237, %221 ], [ %.pre1876, %HashMap_find_slot_keyK_hashPtri32.exit1701.loopexit ]
  %300 = phi i32 [ %.pre.i.pre1806, %._crit_edge105.loopexit.i1698 ], [ %235, %221 ], [ %247, %HashMap_find_slot_keyK_hashPtri32.exit1701.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %301 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %302 = sext i32 %300 to i64
  %303 = shl nsw i64 %302, 5
  %304 = getelementptr i8, ptr %299, i64 %303
  %305 = load ptr, ptr %304, align 8
  %306 = getelementptr i8, ptr %304, i64 8
  %307 = load i64, ptr %306, align 4
  %.sroa_idx.i1512 = getelementptr i8, ptr %304, i64 16
  %308 = load i64, ptr %.sroa_idx.i1512, align 4
  %309 = load ptr, ptr %5, align 8
  %310 = load ptr, ptr %232, align 8, !alias.scope !85
  %311 = getelementptr i8, ptr %310, i64 72
  %312 = load ptr, ptr %311, align 8, !alias.scope !85
  %result.i.i.i1514 = call { i64, i64 } %312(ptr nocapture nofree nonnull readonly %232) #5, !alias.scope !85
  %313 = extractvalue { i64, i64 } %result.i.i.i1514, 0
  %314 = extractvalue { i64, i64 } %result.i.i.i1514, 1
  %315 = call i64 @llvm.umax.i64(i64 %314, i64 8)
  %316 = urem i64 20, %314
  %317 = icmp eq i64 %316, 0
  %318 = sub i64 %314, %316
  %319 = select i1 %317, i64 0, i64 %318
  %320 = add i64 %313, 20
  %321 = add i64 %320, %319
  %322 = and i64 %321, 7
  %323 = icmp eq i64 %322, 0
  %324 = sub nuw nsw i64 40, %322
  %325 = select i1 %323, i64 32, i64 %324
  %326 = add i64 %325, %321
  %327 = urem i64 %326, %315
  %328 = icmp eq i64 %327, 0
  %329 = sub i64 %315, %327
  %330 = select i1 %328, i64 0, i64 %329
  %331 = add i64 %326, %330
  %result.i71.i1515 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %331, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %232, ptr %result.i71.i1515, align 8
  %332 = getelementptr inbounds i8, ptr %result.i71.i1515, i64 8
  store ptr %309, ptr %332, align 8
  %333 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i1515)
  %334 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %result.i71.i1515, 1
  %335 = insertvalue { ptr, ptr, ptr, i32 } %334, ptr undef, 2
  %336 = insertvalue { ptr, ptr, ptr, i32 } %335, i32 10, 3
  store ptr %232, ptr %4, align 8
  store ptr %309, ptr %37, align 8
  store ptr @_parameterization_Ptri32, ptr %38, align 8
  %337 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %4)
  %338 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Entry)
  %339 = load i64, ptr %212, align 4
  %340 = load i64, ptr %213, align 4
  %341 = load ptr, ptr %214, align 8
  %342 = load ptr, ptr %215, align 8
  %result.i.i117.i = call i1 %341(i64 %340, i64 %339, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %342) #5
  %343 = select i1 %result.i.i117.i, i64 9, i64 10
  %gep = getelementptr [14 x ptr], ptr getelementptr inbounds (i8, ptr @Entry, i64 80), i64 0, i64 %343
  %344 = load ptr, ptr %gep, align 8
  call void %344({ ptr, ptr, ptr, i32 } %336, { ptr, ptr, ptr, i32 } %336, ptr nonnull align 8 dereferenceable(24) %4, { ptr, i160 } %226, { ptr, i160 } %207, i32 %231) #7
  %345 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %346 = load ptr, ptr %12, align 8
  %347 = getelementptr i8, ptr %346, i64 %303
  store ptr @Entry, ptr %347, align 8
  %348 = getelementptr i8, ptr %347, i64 8
  %349 = ptrtoint ptr %result.i71.i1515 to i64
  store i64 %349, ptr %348, align 4
  %.sroa_idx4.i1516 = getelementptr i8, ptr %347, i64 24
  store i32 10, ptr %.sroa_idx4.i1516, align 4
  %350 = icmp eq ptr %305, @nil_typ
  %351 = icmp eq ptr %305, null
  %352 = or i1 %350, %351
  br i1 %352, label %353, label %356

353:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1701
  %354 = load i32, ptr %35, align 4
  %355 = add i32 %354, 1
  store i32 %355, ptr %35, align 4
  br label %._crit_edge.sink.split.i1533

356:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1701
  %357 = inttoptr i64 %307 to ptr
  %358 = inttoptr i64 %308 to ptr
  %hash_coef_ptr.i.i88.i1517 = getelementptr i8, ptr %305, i64 8
  %tbl_size_ptr.i.i89.i1518 = getelementptr i8, ptr %305, i64 16
  %offset_tbl_ptr.i.i90.i1519 = getelementptr i8, ptr %305, i64 40
  %hash_coef.i.i91.i1520 = load i64, ptr %hash_coef_ptr.i.i88.i1517, align 4, !noalias !88
  %tbl_size.i.i92.i1521 = load i64, ptr %tbl_size_ptr.i.i89.i1518, align 4, !noalias !88
  %offset_tbl.i.i93.i1522 = load ptr, ptr %offset_tbl_ptr.i.i90.i1519, align 8, !noalias !88
  %product.i.i.i94.i1523 = mul i64 %hash_coef.i.i91.i1520, 4015701072841558310
  %shifted.i.i.i95.i1524 = lshr i64 %product.i.i.i94.i1523, 32
  %xored.i.i.i96.i1525 = xor i64 %shifted.i.i.i95.i1524, %product.i.i.i94.i1523
  %hash.i.i.i97.i1526 = and i64 %xored.i.i.i96.i1525, %tbl_size.i.i92.i1521
  %offset_ptr.i.i98.i1527 = getelementptr i32, ptr %offset_tbl.i.i93.i1522, i64 %hash.i.i.i97.i1526
  %offset.i.i99.i1528 = load i32, ptr %offset_ptr.i.i98.i1527, align 4, !noalias !88
  %359 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %305, 0
  %360 = insertvalue { ptr, ptr, ptr, i32 } %359, ptr %357, 1
  %361 = insertvalue { ptr, ptr, ptr, i32 } %360, ptr %358, 2
  %362 = insertvalue { ptr, ptr, ptr, i32 } %361, i32 %offset.i.i99.i1528, 3
  %363 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %364 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %305)
  %365 = sext i32 %offset.i.i99.i1528 to i64
  %366 = getelementptr ptr, ptr %305, i64 %365
  %367 = getelementptr i8, ptr %366, i64 56
  %368 = load ptr, ptr %367, align 8
  %result.i101.i1529 = call ptr %368({ ptr, ptr, ptr, i32 } %362, ptr nocapture nofree noundef nonnull readonly %2) #16
  %369 = call { ptr, i160 } %result.i101.i1529({ ptr, ptr, ptr, i32 } %362, { ptr, ptr, ptr, i32 } %362, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i1530 = extractvalue { ptr, i160 } %369, 0
  %370 = getelementptr i8, ptr %.fca.0.extract51.i1530, i64 8
  %371 = getelementptr i8, ptr %.fca.0.extract51.i1530, i64 16
  %372 = getelementptr i8, ptr %.fca.0.extract51.i1530, i64 24
  %373 = getelementptr i8, ptr %.fca.0.extract51.i1530, i64 32
  %374 = load i64, ptr %370, align 4
  %375 = load i64, ptr %371, align 4
  %376 = load ptr, ptr %372, align 8
  %377 = load ptr, ptr %373, align 8
  %result.i102.i1531 = call i1 %376(i64 %375, i64 %374, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %377) #5
  br i1 %result.i102.i1531, label %._crit_edge.sink.split.i1533, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1535

._crit_edge.sink.split.i1533:                     ; preds = %356, %353
  %.sink159.i1534 = phi i64 [ 48, %353 ], [ 40, %356 ]
  %378 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %379 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i1534
  %380 = load ptr, ptr %379, align 8
  %381 = load ptr, ptr %380, align 8
  %382 = call i32 %381(ptr nonnull %result.i283) #36
  %383 = add i32 %382, 1
  %384 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %385 = getelementptr i8, ptr %380, i64 8
  %386 = load ptr, ptr %385, align 8
  call void %386(ptr nonnull %result.i283, i32 %383) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1535

HashMap_insert_internal_keyK_valueV_hashPtri32.exit1535: ; preds = %356, %._crit_edge.sink.split.i1533
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %4)
  br label %._crit_edge.i1245

._crit_edge.i1245:                                ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1535, %191, %.lr.ph.i1244
  %387 = add nuw nsw i32 %.096.i, 1
  %388 = icmp slt i32 %387, %173
  br i1 %388, label %.lr.ph.i1244, label %HashMap_resize_new_capacityPtri32.exit

HashMap_resize_new_capacityPtri32.exit:           ; preds = %._crit_edge.i1245, %._crit_edge1.i945
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_ensure_capacity_required_loadPtri32.exit

HashMap_ensure_capacity_required_loadPtri32.exit: ; preds = %170, %HashMap_resize_new_capacityPtri32.exit
  %389 = load ptr, ptr %10, align 8
  %390 = call i32 %389({ ptr, i160 } %46) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %391 = load ptr, ptr %result.i283, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %392 = load i32, ptr %13, align 8
  %393 = add i32 %392, -1
  %394 = and i32 %393, %390
  %395 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %396 = load ptr, ptr %12, align 8
  %397 = sext i32 %394 to i64
  %398 = shl nsw i64 %397, 5
  %399 = getelementptr i8, ptr %396, i64 %398
  %400 = load ptr, ptr %399, align 8
  %401 = icmp eq ptr %400, @nil_typ
  %402 = icmp eq ptr %400, null
  %403 = or i1 %401, %402
  br i1 %403, label %HashMap_find_slot_keyK_hashPtri32.exit1283, label %.lr.ph.i1259

.lr.ph.i1259:                                     ; preds = %HashMap_ensure_capacity_required_loadPtri32.exit
  %404 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %405

405:                                              ; preds = %._crit_edge.thread.i1274, %.lr.ph.i1259
  %406 = phi i32 [ %394, %.lr.ph.i1259 ], [ %448, %._crit_edge.thread.i1274 ]
  %spec.store.select.i12791409 = phi i32 [ -1, %.lr.ph.i1259 ], [ %spec.store.select.i1279, %._crit_edge.thread.i1274 ]
  %407 = phi ptr [ %400, %.lr.ph.i1259 ], [ %453, %._crit_edge.thread.i1274 ]
  %408 = phi ptr [ %399, %.lr.ph.i1259 ], [ %452, %._crit_edge.thread.i1274 ]
  %.sroa_idx.i1260 = getelementptr i8, ptr %408, i64 16
  %409 = load i64, ptr %.sroa_idx.i1260, align 4
  %410 = getelementptr i8, ptr %408, i64 8
  %411 = load i64, ptr %410, align 4
  %412 = inttoptr i64 %411 to ptr
  %413 = inttoptr i64 %409 to ptr
  %hash_coef_ptr.i.i56.i1261 = getelementptr i8, ptr %407, i64 8
  %tbl_size_ptr.i.i57.i1262 = getelementptr i8, ptr %407, i64 16
  %offset_tbl_ptr.i.i58.i1263 = getelementptr i8, ptr %407, i64 40
  %hash_coef.i.i59.i1264 = load i64, ptr %hash_coef_ptr.i.i56.i1261, align 4
  %tbl_size.i.i60.i1265 = load i64, ptr %tbl_size_ptr.i.i57.i1262, align 4
  %offset_tbl.i.i61.i1266 = load ptr, ptr %offset_tbl_ptr.i.i58.i1263, align 8
  %product.i.i.i62.i1267 = mul i64 %hash_coef.i.i59.i1264, 4015701072841558310
  %shifted.i.i.i63.i1268 = lshr i64 %product.i.i.i62.i1267, 32
  %xored.i.i.i64.i1269 = xor i64 %shifted.i.i.i63.i1268, %product.i.i.i62.i1267
  %hash.i.i.i65.i1270 = and i64 %xored.i.i.i64.i1269, %tbl_size.i.i60.i1265
  %offset_ptr.i.i66.i1271 = getelementptr i32, ptr %offset_tbl.i.i61.i1266, i64 %hash.i.i.i65.i1270
  %offset.i.i67.i1272 = load i32, ptr %offset_ptr.i.i66.i1271, align 4
  %414 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %407, 0
  %415 = insertvalue { ptr, ptr, ptr, i32 } %414, ptr %412, 1
  %416 = insertvalue { ptr, ptr, ptr, i32 } %415, ptr %413, 2
  %417 = insertvalue { ptr, ptr, ptr, i32 } %416, i32 %offset.i.i67.i1272, 3
  %418 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %407)
  %419 = sext i32 %offset.i.i67.i1272 to i64
  %420 = getelementptr ptr, ptr %407, i64 %419
  %421 = getelementptr i8, ptr %420, i64 64
  %422 = load ptr, ptr %421, align 8
  %result.i.i1273 = call ptr %422({ ptr, ptr, ptr, i32 } %417, ptr nocapture nofree noundef nonnull readonly %2) #16
  %423 = call i32 %result.i.i1273({ ptr, ptr, ptr, i32 } %417, { ptr, ptr, ptr, i32 } %417, ptr nonnull align 8 %2) #7
  %424 = icmp eq i32 %423, %390
  br i1 %424, label %._crit_edge.i1281, label %._crit_edge.thread.i1274

._crit_edge.i1281:                                ; preds = %405
  %425 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %426 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %407)
  %427 = getelementptr i8, ptr %420, i64 48
  %428 = load ptr, ptr %427, align 8
  %result.i69.i1282 = call ptr %428({ ptr, ptr, ptr, i32 } %417, ptr nocapture nofree noundef nonnull readonly %2) #16
  %429 = call { ptr, i160 } %result.i69.i1282({ ptr, ptr, ptr, i32 } %417, { ptr, ptr, ptr, i32 } %417, ptr nonnull align 8 %2) #7
  %430 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %431 = load ptr, ptr %11, align 8
  %432 = call i1 %431({ ptr, i160 } %429, { ptr, i160 } %46) #7
  br i1 %432, label %HashMap_find_slot_keyK_hashPtri32.exit1283.loopexit, label %._crit_edge.thread.i1274

._crit_edge.thread.i1274:                         ; preds = %._crit_edge.i1281, %405
  %433 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %434 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %407)
  %435 = getelementptr i8, ptr %420, i64 56
  %436 = load ptr, ptr %435, align 8
  %result.i70.i1275 = call ptr %436({ ptr, ptr, ptr, i32 } %417, ptr nocapture nofree noundef nonnull readonly %2) #16
  %437 = call { ptr, i160 } %result.i70.i1275({ ptr, ptr, ptr, i32 } %417, { ptr, ptr, ptr, i32 } %417, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i1276 = extractvalue { ptr, i160 } %437, 0
  %438 = getelementptr i8, ptr %.fca.0.extract19.i1276, i64 8
  %439 = getelementptr i8, ptr %.fca.0.extract19.i1276, i64 16
  %440 = getelementptr i8, ptr %.fca.0.extract19.i1276, i64 24
  %441 = getelementptr i8, ptr %.fca.0.extract19.i1276, i64 32
  %442 = load i64, ptr %438, align 4
  %443 = load i64, ptr %439, align 4
  %444 = load ptr, ptr %440, align 8
  %445 = load ptr, ptr %441, align 8
  %result.i71.i1277 = call i1 %444(i64 %443, i64 %442, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %445) #5
  %446 = icmp eq i32 %spec.store.select.i12791409, -1
  %or.cond.i1278 = select i1 %result.i71.i1277, i1 %446, i1 false
  %spec.store.select.i1279 = select i1 %or.cond.i1278, i32 %406, i32 %spec.store.select.i12791409
  %447 = add i32 %406, 1
  %448 = and i32 %447, %393
  %449 = load ptr, ptr %12, align 8
  %450 = sext i32 %448 to i64
  %451 = shl nsw i64 %450, 5
  %452 = getelementptr i8, ptr %449, i64 %451
  %453 = load ptr, ptr %452, align 8
  %454 = icmp eq ptr %453, @nil_typ
  %455 = icmp eq ptr %453, null
  %456 = or i1 %454, %455
  br i1 %456, label %._crit_edge105.loopexit.i1280, label %405

._crit_edge105.loopexit.i1280:                    ; preds = %._crit_edge.thread.i1274
  %457 = icmp eq i32 %spec.store.select.i1279, -1
  %.pre.i.pre1439 = select i1 %457, i32 %448, i32 %spec.store.select.i1279
  br label %HashMap_find_slot_keyK_hashPtri32.exit1283

HashMap_find_slot_keyK_hashPtri32.exit1283.loopexit: ; preds = %._crit_edge.i1281
  %.pre1494 = load ptr, ptr %12, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit1283

HashMap_find_slot_keyK_hashPtri32.exit1283:       ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1283.loopexit, %HashMap_ensure_capacity_required_loadPtri32.exit, %._crit_edge105.loopexit.i1280
  %458 = phi ptr [ %449, %._crit_edge105.loopexit.i1280 ], [ %396, %HashMap_ensure_capacity_required_loadPtri32.exit ], [ %.pre1494, %HashMap_find_slot_keyK_hashPtri32.exit1283.loopexit ]
  %459 = phi i32 [ %.pre.i.pre1439, %._crit_edge105.loopexit.i1280 ], [ %394, %HashMap_ensure_capacity_required_loadPtri32.exit ], [ %406, %HashMap_find_slot_keyK_hashPtri32.exit1283.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %460 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %461 = sext i32 %459 to i64
  %462 = shl nsw i64 %461, 5
  %463 = getelementptr i8, ptr %458, i64 %462
  %464 = load ptr, ptr %463, align 8
  %465 = getelementptr i8, ptr %463, i64 8
  %466 = load i64, ptr %465, align 4
  %.sroa_idx.i962 = getelementptr i8, ptr %463, i64 16
  %467 = load i64, ptr %.sroa_idx.i962, align 4
  %468 = load ptr, ptr %5, align 8
  %469 = load ptr, ptr %391, align 8, !alias.scope !91
  %470 = getelementptr i8, ptr %469, i64 72
  %471 = load ptr, ptr %470, align 8, !alias.scope !91
  %result.i.i.i = call { i64, i64 } %471(ptr nocapture nofree nonnull readonly %391) #5, !alias.scope !91
  %472 = extractvalue { i64, i64 } %result.i.i.i, 0
  %473 = extractvalue { i64, i64 } %result.i.i.i, 1
  %474 = call i64 @llvm.umax.i64(i64 %473, i64 8)
  %475 = urem i64 20, %473
  %476 = icmp eq i64 %475, 0
  %477 = sub i64 %473, %475
  %478 = select i1 %476, i64 0, i64 %477
  %479 = add i64 %472, 20
  %480 = add i64 %479, %478
  %481 = and i64 %480, 7
  %482 = icmp eq i64 %481, 0
  %483 = sub nuw nsw i64 40, %481
  %484 = select i1 %482, i64 32, i64 %483
  %485 = add i64 %484, %480
  %486 = urem i64 %485, %474
  %487 = icmp eq i64 %486, 0
  %488 = sub i64 %474, %486
  %489 = select i1 %487, i64 0, i64 %488
  %490 = add i64 %485, %489
  %result.i71.i964 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %490, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %391, ptr %result.i71.i964, align 8
  %491 = getelementptr inbounds i8, ptr %result.i71.i964, i64 8
  store ptr %468, ptr %491, align 8
  %492 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i964)
  %493 = load ptr, ptr %391, align 8
  %494 = getelementptr i8, ptr %493, i64 72
  %495 = load ptr, ptr %494, align 8
  %result.i.i1458 = call { i64, i64 } %495(ptr nocapture nofree nonnull readonly %391) #5
  %496 = extractvalue { i64, i64 } %result.i.i1458, 1
  %497 = urem i64 20, %496
  %498 = icmp eq i64 %497, 0
  %reass.sub1854 = sub i64 %496, %497
  %499 = add i64 %reass.sub1854, 20
  %500 = select i1 %498, i64 20, i64 %499
  %501 = getelementptr i8, ptr %result.i71.i964, i64 %500
  %502 = getelementptr i8, ptr %493, i64 64
  %503 = load ptr, ptr %502, align 8
  call void %503({ ptr, i160 } %46, ptr nocapture nofree nonnull readonly %391, ptr nocapture nofree writeonly %501) #13
  %504 = load ptr, ptr %result.i71.i964, align 8
  %505 = load ptr, ptr %504, align 8
  %506 = getelementptr i8, ptr %505, i64 72
  %507 = load ptr, ptr %506, align 8
  %result.i.i1459 = call { i64, i64 } %507(ptr nocapture nofree nonnull readonly %504) #5
  %508 = extractvalue { i64, i64 } %result.i.i1459, 0
  %509 = extractvalue { i64, i64 } %result.i.i1459, 1
  %510 = urem i64 20, %509
  %511 = icmp eq i64 %510, 0
  %512 = sub i64 %509, %510
  %513 = select i1 %511, i64 0, i64 %512
  %514 = add i64 %508, 20
  %515 = add i64 %514, %513
  %516 = and i64 %515, 7
  %517 = icmp eq i64 %516, 0
  %518 = sub nuw nsw i64 8, %516
  %519 = select i1 %517, i64 0, i64 %518
  %520 = getelementptr i8, ptr %result.i71.i964, i64 %515
  %521 = getelementptr i8, ptr %520, i64 %519
  store ptr @i32_typ, ptr %521, align 8
  %522 = getelementptr i8, ptr %521, i64 8
  store i160 %.sroa.0234.0.insert.ext, ptr %522, align 4
  %523 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @Entry) #34
  %524 = getelementptr inbounds i8, ptr %result.i71.i964, i64 16
  store i32 %390, ptr %524, align 8
  %525 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  store ptr @Entry, ptr %463, align 8
  %526 = ptrtoint ptr %result.i71.i964 to i64
  store i64 %526, ptr %465, align 4
  %.sroa_idx4.i = getelementptr i8, ptr %463, i64 24
  store i32 10, ptr %.sroa_idx4.i, align 4
  %527 = icmp eq ptr %464, @nil_typ
  %528 = icmp eq ptr %464, null
  %529 = or i1 %527, %528
  br i1 %529, label %530, label %533

530:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1283
  %531 = load i32, ptr %35, align 4
  %532 = add i32 %531, 1
  store i32 %532, ptr %35, align 4
  br label %._crit_edge.sink.split.i

533:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1283
  %534 = inttoptr i64 %466 to ptr
  %535 = inttoptr i64 %467 to ptr
  %hash_coef_ptr.i.i88.i = getelementptr i8, ptr %464, i64 8
  %tbl_size_ptr.i.i89.i = getelementptr i8, ptr %464, i64 16
  %offset_tbl_ptr.i.i90.i = getelementptr i8, ptr %464, i64 40
  %hash_coef.i.i91.i = load i64, ptr %hash_coef_ptr.i.i88.i, align 4, !noalias !94
  %tbl_size.i.i92.i = load i64, ptr %tbl_size_ptr.i.i89.i, align 4, !noalias !94
  %offset_tbl.i.i93.i = load ptr, ptr %offset_tbl_ptr.i.i90.i, align 8, !noalias !94
  %product.i.i.i94.i = mul i64 %hash_coef.i.i91.i, 4015701072841558310
  %shifted.i.i.i95.i = lshr i64 %product.i.i.i94.i, 32
  %xored.i.i.i96.i = xor i64 %shifted.i.i.i95.i, %product.i.i.i94.i
  %hash.i.i.i97.i = and i64 %xored.i.i.i96.i, %tbl_size.i.i92.i
  %offset_ptr.i.i98.i = getelementptr i32, ptr %offset_tbl.i.i93.i, i64 %hash.i.i.i97.i
  %offset.i.i99.i = load i32, ptr %offset_ptr.i.i98.i, align 4, !noalias !94
  %536 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %464, 0
  %537 = insertvalue { ptr, ptr, ptr, i32 } %536, ptr %534, 1
  %538 = insertvalue { ptr, ptr, ptr, i32 } %537, ptr %535, 2
  %539 = insertvalue { ptr, ptr, ptr, i32 } %538, i32 %offset.i.i99.i, 3
  %540 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %541 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %464)
  %542 = sext i32 %offset.i.i99.i to i64
  %543 = getelementptr ptr, ptr %464, i64 %542
  %544 = getelementptr i8, ptr %543, i64 56
  %545 = load ptr, ptr %544, align 8
  %result.i101.i = call ptr %545({ ptr, ptr, ptr, i32 } %539, ptr nocapture nofree noundef nonnull readonly %2) #16
  %546 = call { ptr, i160 } %result.i101.i({ ptr, ptr, ptr, i32 } %539, { ptr, ptr, ptr, i32 } %539, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i966 = extractvalue { ptr, i160 } %546, 0
  %547 = getelementptr i8, ptr %.fca.0.extract51.i966, i64 8
  %548 = getelementptr i8, ptr %.fca.0.extract51.i966, i64 16
  %549 = getelementptr i8, ptr %.fca.0.extract51.i966, i64 24
  %550 = getelementptr i8, ptr %.fca.0.extract51.i966, i64 32
  %551 = load i64, ptr %547, align 4
  %552 = load i64, ptr %548, align 4
  %553 = load ptr, ptr %549, align 8
  %554 = load ptr, ptr %550, align 8
  %result.i102.i = call i1 %553(i64 %552, i64 %551, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %554) #5
  br i1 %result.i102.i, label %._crit_edge.sink.split.i, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit

._crit_edge.sink.split.i:                         ; preds = %533, %530
  %.sink159.i = phi i64 [ 48, %530 ], [ 40, %533 ]
  %555 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %556 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i
  %557 = load ptr, ptr %556, align 8
  %558 = load ptr, ptr %557, align 8
  %559 = call i32 %558(ptr nonnull %result.i283) #36
  %560 = add i32 %559, 1
  %561 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %562 = getelementptr i8, ptr %557, i64 8
  %563 = load ptr, ptr %562, align 8
  call void %563(ptr nonnull %result.i283, i32 %560) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit

HashMap_insert_internal_keyK_valueV_hashPtri32.exit: ; preds = %533, %._crit_edge.sink.split.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %564 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  %565 = sext i32 %.0266528 to i64
  %566 = shl nsw i64 %565, 2
  %567 = getelementptr i8, ptr %result.i4.i, i64 %566
  store i32 %45, ptr %567, align 1
  store i1 true, ptr %.sroa.0224.sroa.0, align 8
  %.sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.0. = load i8, ptr %.sroa.0224.sroa.0, align 8
  %.sroa.0224.0.insert.ext = zext i8 %.sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.0. to i160
  %568 = load i32, ptr %34, align 8
  %569 = load i32, ptr %26, align 8
  %570 = icmp eq i32 %569, 0
  %571 = mul i32 %568, 10
  %572 = add i32 %571, 10
  %573 = mul i32 %569, 6
  %574 = icmp sge i32 %572, %573
  %.0.i982 = select i1 %570, i1 true, i1 %574
  br i1 %.0.i982, label %._crit_edge1.i984, label %HashMap_ensure_capacity_required_loadPtri32.exit988

._crit_edge1.i984:                                ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit
  %575 = shl i32 %569, 1
  %spec.select.i986 = call i32 @llvm.smax.i32(i32 %575, i32 16)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %576 = load ptr, ptr %25, align 8
  %577 = zext nneg i32 %spec.select.i986 to i64
  %578 = shl nuw nsw i64 %577, 5
  %result.i.i1311 = call noalias ptr @bump_malloc_inner(i64 noundef %578, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1311, ptr %25, align 8
  store i32 %spec.select.i986, ptr %26, align 8
  store i32 0, ptr %36, align 4
  %579 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #38
  store i32 0, ptr %34, align 8
  %580 = icmp sgt i32 %569, 0
  br i1 %580, label %.lr.ph.i1312, label %HashMap_resize_new_capacityPtri32.exit1338

.lr.ph.i1312:                                     ; preds = %._crit_edge1.i984, %._crit_edge.i1315
  %.096.i1313 = phi i32 [ %783, %._crit_edge.i1315 ], [ 0, %._crit_edge1.i984 ]
  %581 = zext nneg i32 %.096.i1313 to i64
  %582 = shl nuw nsw i64 %581, 5
  %583 = getelementptr i8, ptr %576, i64 %582
  %584 = load ptr, ptr %583, align 8
  %585 = icmp ne ptr %584, @nil_typ
  %586 = icmp ne ptr %584, null
  %.not40.i1314 = and i1 %585, %586
  br i1 %.not40.i1314, label %587, label %._crit_edge.i1315

587:                                              ; preds = %.lr.ph.i1312
  %588 = getelementptr i8, ptr %583, i64 8
  %589 = load i64, ptr %588, align 4
  %.sroa_idx.i1316 = getelementptr i8, ptr %583, i64 16
  %590 = load i64, ptr %.sroa_idx.i1316, align 4
  %591 = inttoptr i64 %589 to ptr
  %592 = inttoptr i64 %590 to ptr
  %hash_coef_ptr.i.i42.i1317 = getelementptr i8, ptr %584, i64 8
  %tbl_size_ptr.i.i43.i1318 = getelementptr i8, ptr %584, i64 16
  %offset_tbl_ptr.i.i44.i1319 = getelementptr i8, ptr %584, i64 40
  %hash_coef.i.i45.i1320 = load i64, ptr %hash_coef_ptr.i.i42.i1317, align 4, !noalias !97
  %tbl_size.i.i46.i1321 = load i64, ptr %tbl_size_ptr.i.i43.i1318, align 4, !noalias !97
  %offset_tbl.i.i47.i1322 = load ptr, ptr %offset_tbl_ptr.i.i44.i1319, align 8, !noalias !97
  %product.i.i.i48.i1323 = mul i64 %hash_coef.i.i45.i1320, 4015701072841558310
  %shifted.i.i.i49.i1324 = lshr i64 %product.i.i.i48.i1323, 32
  %xored.i.i.i50.i1325 = xor i64 %shifted.i.i.i49.i1324, %product.i.i.i48.i1323
  %hash.i.i.i51.i1326 = and i64 %xored.i.i.i50.i1325, %tbl_size.i.i46.i1321
  %offset_ptr.i.i52.i1327 = getelementptr i32, ptr %offset_tbl.i.i47.i1322, i64 %hash.i.i.i51.i1326
  %offset.i.i53.i1328 = load i32, ptr %offset_ptr.i.i52.i1327, align 4, !noalias !97
  %593 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %584, 0
  %594 = insertvalue { ptr, ptr, ptr, i32 } %593, ptr %591, 1
  %595 = insertvalue { ptr, ptr, ptr, i32 } %594, ptr %592, 2
  %596 = insertvalue { ptr, ptr, ptr, i32 } %595, i32 %offset.i.i53.i1328, 3
  %597 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %598 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %584)
  %599 = sext i32 %offset.i.i53.i1328 to i64
  %600 = getelementptr ptr, ptr %584, i64 %599
  %601 = getelementptr i8, ptr %600, i64 56
  %602 = load ptr, ptr %601, align 8
  %result.i55.i1329 = call ptr %602({ ptr, ptr, ptr, i32 } %596, ptr nocapture nofree noundef nonnull readonly %2) #16
  %603 = call { ptr, i160 } %result.i55.i1329({ ptr, ptr, ptr, i32 } %596, { ptr, ptr, ptr, i32 } %596, ptr nonnull align 8 %2) #7
  %.fca.0.extract29.i1330 = extractvalue { ptr, i160 } %603, 0
  %604 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %605 = load ptr, ptr %18, align 8
  %606 = load ptr, ptr %605, align 8
  %607 = ptrtoint ptr %606 to i64
  %608 = getelementptr i8, ptr %.fca.0.extract29.i1330, i64 8
  %609 = getelementptr i8, ptr %.fca.0.extract29.i1330, i64 16
  %610 = getelementptr i8, ptr %.fca.0.extract29.i1330, i64 24
  %611 = getelementptr i8, ptr %.fca.0.extract29.i1330, i64 32
  %612 = load i64, ptr %608, align 4
  %613 = load i64, ptr %609, align 4
  %614 = load ptr, ptr %610, align 8
  %615 = load ptr, ptr %611, align 8
  %616 = load i64, ptr %606, align 4
  %result.i57.i1332 = call i1 %614(i64 %613, i64 %612, i64 %616, i64 %607, ptr readonly %615) #5
  br i1 %result.i57.i1332, label %617, label %._crit_edge.i1315

617:                                              ; preds = %587
  %618 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %619 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %584)
  %620 = getelementptr i8, ptr %600, i64 48
  %621 = load ptr, ptr %620, align 8
  %result.i58.i1333 = call ptr %621({ ptr, ptr, ptr, i32 } %596, ptr nocapture nofree noundef nonnull readonly %2) #16
  %622 = call { ptr, i160 } %result.i58.i1333({ ptr, ptr, ptr, i32 } %596, { ptr, ptr, ptr, i32 } %596, ptr nonnull align 8 %2) #7
  %623 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %624 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %584)
  %625 = getelementptr i8, ptr %600, i64 64
  %626 = load ptr, ptr %625, align 8
  %result.i59.i1335 = call ptr %626({ ptr, ptr, ptr, i32 } %596, ptr nocapture nofree noundef nonnull readonly %2) #16
  %627 = call i32 %result.i59.i1335({ ptr, ptr, ptr, i32 } %596, { ptr, ptr, ptr, i32 } %596, ptr nonnull align 8 %2) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %3)
  %628 = load ptr, ptr %result.i326, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %629 = load i32, ptr %26, align 8
  %630 = add i32 %629, -1
  %631 = and i32 %630, %627
  %632 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %633 = load ptr, ptr %25, align 8
  %634 = sext i32 %631 to i64
  %635 = shl nsw i64 %634, 5
  %636 = getelementptr i8, ptr %633, i64 %635
  %637 = load ptr, ptr %636, align 8
  %638 = icmp eq ptr %637, @nil_typ
  %639 = icmp eq ptr %637, null
  %640 = or i1 %638, %639
  br i1 %640, label %HashMap_find_slot_keyK_hashPtri32.exit1746, label %.lr.ph.i1716

.lr.ph.i1716:                                     ; preds = %617
  %641 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %642

642:                                              ; preds = %._crit_edge.thread.i1732, %.lr.ph.i1716
  %643 = phi i32 [ %631, %.lr.ph.i1716 ], [ %685, %._crit_edge.thread.i1732 ]
  %spec.store.select.i17371773 = phi i32 [ -1, %.lr.ph.i1716 ], [ %spec.store.select.i1737, %._crit_edge.thread.i1732 ]
  %644 = phi ptr [ %637, %.lr.ph.i1716 ], [ %690, %._crit_edge.thread.i1732 ]
  %645 = phi ptr [ %636, %.lr.ph.i1716 ], [ %689, %._crit_edge.thread.i1732 ]
  %.sroa_idx.i1718 = getelementptr i8, ptr %645, i64 16
  %646 = load i64, ptr %.sroa_idx.i1718, align 4
  %647 = getelementptr i8, ptr %645, i64 8
  %648 = load i64, ptr %647, align 4
  %649 = inttoptr i64 %648 to ptr
  %650 = inttoptr i64 %646 to ptr
  %hash_coef_ptr.i.i56.i1719 = getelementptr i8, ptr %644, i64 8
  %tbl_size_ptr.i.i57.i1720 = getelementptr i8, ptr %644, i64 16
  %offset_tbl_ptr.i.i58.i1721 = getelementptr i8, ptr %644, i64 40
  %hash_coef.i.i59.i1722 = load i64, ptr %hash_coef_ptr.i.i56.i1719, align 4
  %tbl_size.i.i60.i1723 = load i64, ptr %tbl_size_ptr.i.i57.i1720, align 4
  %offset_tbl.i.i61.i1724 = load ptr, ptr %offset_tbl_ptr.i.i58.i1721, align 8
  %product.i.i.i62.i1725 = mul i64 %hash_coef.i.i59.i1722, 4015701072841558310
  %shifted.i.i.i63.i1726 = lshr i64 %product.i.i.i62.i1725, 32
  %xored.i.i.i64.i1727 = xor i64 %shifted.i.i.i63.i1726, %product.i.i.i62.i1725
  %hash.i.i.i65.i1728 = and i64 %xored.i.i.i64.i1727, %tbl_size.i.i60.i1723
  %offset_ptr.i.i66.i1729 = getelementptr i32, ptr %offset_tbl.i.i61.i1724, i64 %hash.i.i.i65.i1728
  %offset.i.i67.i1730 = load i32, ptr %offset_ptr.i.i66.i1729, align 4
  %651 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %644, 0
  %652 = insertvalue { ptr, ptr, ptr, i32 } %651, ptr %649, 1
  %653 = insertvalue { ptr, ptr, ptr, i32 } %652, ptr %650, 2
  %654 = insertvalue { ptr, ptr, ptr, i32 } %653, i32 %offset.i.i67.i1730, 3
  %655 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %644)
  %656 = sext i32 %offset.i.i67.i1730 to i64
  %657 = getelementptr ptr, ptr %644, i64 %656
  %658 = getelementptr i8, ptr %657, i64 64
  %659 = load ptr, ptr %658, align 8
  %result.i.i1731 = call ptr %659({ ptr, ptr, ptr, i32 } %654, ptr nocapture nofree noundef nonnull readonly %2) #16
  %660 = call i32 %result.i.i1731({ ptr, ptr, ptr, i32 } %654, { ptr, ptr, ptr, i32 } %654, ptr nonnull align 8 %2) #7
  %661 = icmp eq i32 %660, %627
  br i1 %661, label %._crit_edge.i1743, label %._crit_edge.thread.i1732

._crit_edge.i1743:                                ; preds = %642
  %662 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %663 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %644)
  %664 = getelementptr i8, ptr %657, i64 48
  %665 = load ptr, ptr %664, align 8
  %result.i69.i1744 = call ptr %665({ ptr, ptr, ptr, i32 } %654, ptr nocapture nofree noundef nonnull readonly %2) #16
  %666 = call { ptr, i160 } %result.i69.i1744({ ptr, ptr, ptr, i32 } %654, { ptr, ptr, ptr, i32 } %654, ptr nonnull align 8 %2) #7
  %667 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %668 = load ptr, ptr %24, align 8
  %669 = call i1 %668({ ptr, i160 } %666, { ptr, i160 } %622) #7
  br i1 %669, label %HashMap_find_slot_keyK_hashPtri32.exit1746.loopexit, label %._crit_edge.thread.i1732

._crit_edge.thread.i1732:                         ; preds = %._crit_edge.i1743, %642
  %670 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %671 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %644)
  %672 = getelementptr i8, ptr %657, i64 56
  %673 = load ptr, ptr %672, align 8
  %result.i70.i1733 = call ptr %673({ ptr, ptr, ptr, i32 } %654, ptr nocapture nofree noundef nonnull readonly %2) #16
  %674 = call { ptr, i160 } %result.i70.i1733({ ptr, ptr, ptr, i32 } %654, { ptr, ptr, ptr, i32 } %654, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i1734 = extractvalue { ptr, i160 } %674, 0
  %675 = getelementptr i8, ptr %.fca.0.extract19.i1734, i64 8
  %676 = getelementptr i8, ptr %.fca.0.extract19.i1734, i64 16
  %677 = getelementptr i8, ptr %.fca.0.extract19.i1734, i64 24
  %678 = getelementptr i8, ptr %.fca.0.extract19.i1734, i64 32
  %679 = load i64, ptr %675, align 4
  %680 = load i64, ptr %676, align 4
  %681 = load ptr, ptr %677, align 8
  %682 = load ptr, ptr %678, align 8
  %result.i71.i1735 = call i1 %681(i64 %680, i64 %679, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %682) #5
  %683 = icmp eq i32 %spec.store.select.i17371773, -1
  %or.cond.i1736 = select i1 %result.i71.i1735, i1 %683, i1 false
  %spec.store.select.i1737 = select i1 %or.cond.i1736, i32 %643, i32 %spec.store.select.i17371773
  %684 = add i32 %643, 1
  %685 = and i32 %684, %630
  %686 = load ptr, ptr %25, align 8
  %687 = sext i32 %685 to i64
  %688 = shl nsw i64 %687, 5
  %689 = getelementptr i8, ptr %686, i64 %688
  %690 = load ptr, ptr %689, align 8
  %691 = icmp eq ptr %690, @nil_typ
  %692 = icmp eq ptr %690, null
  %693 = or i1 %691, %692
  br i1 %693, label %._crit_edge105.loopexit.i1739, label %642

._crit_edge105.loopexit.i1739:                    ; preds = %._crit_edge.thread.i1732
  %694 = icmp eq i32 %spec.store.select.i1737, -1
  %.pre.i1742.pre = select i1 %694, i32 %685, i32 %spec.store.select.i1737
  br label %HashMap_find_slot_keyK_hashPtri32.exit1746

HashMap_find_slot_keyK_hashPtri32.exit1746.loopexit: ; preds = %._crit_edge.i1743
  %.pre1877 = load ptr, ptr %25, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit1746

HashMap_find_slot_keyK_hashPtri32.exit1746:       ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1746.loopexit, %617, %._crit_edge105.loopexit.i1739
  %695 = phi ptr [ %686, %._crit_edge105.loopexit.i1739 ], [ %633, %617 ], [ %.pre1877, %HashMap_find_slot_keyK_hashPtri32.exit1746.loopexit ]
  %696 = phi i32 [ %.pre.i1742.pre, %._crit_edge105.loopexit.i1739 ], [ %631, %617 ], [ %643, %HashMap_find_slot_keyK_hashPtri32.exit1746.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %697 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %698 = sext i32 %696 to i64
  %699 = shl nsw i64 %698, 5
  %700 = getelementptr i8, ptr %695, i64 %699
  %701 = load ptr, ptr %700, align 8
  %702 = getelementptr i8, ptr %700, i64 8
  %703 = load i64, ptr %702, align 4
  %.sroa_idx.i1555 = getelementptr i8, ptr %700, i64 16
  %704 = load i64, ptr %.sroa_idx.i1555, align 4
  %705 = load ptr, ptr %18, align 8
  %706 = load ptr, ptr %628, align 8, !alias.scope !100
  %707 = getelementptr i8, ptr %706, i64 72
  %708 = load ptr, ptr %707, align 8, !alias.scope !100
  %result.i.i.i1557 = call { i64, i64 } %708(ptr nocapture nofree nonnull readonly %628) #5, !alias.scope !100
  %709 = extractvalue { i64, i64 } %result.i.i.i1557, 0
  %710 = extractvalue { i64, i64 } %result.i.i.i1557, 1
  %711 = call i64 @llvm.umax.i64(i64 %710, i64 8)
  %712 = urem i64 20, %710
  %713 = icmp eq i64 %712, 0
  %714 = sub i64 %710, %712
  %715 = select i1 %713, i64 0, i64 %714
  %716 = add i64 %709, 20
  %717 = add i64 %716, %715
  %718 = and i64 %717, 7
  %719 = icmp eq i64 %718, 0
  %720 = sub nuw nsw i64 40, %718
  %721 = select i1 %719, i64 32, i64 %720
  %722 = add i64 %721, %717
  %723 = urem i64 %722, %711
  %724 = icmp eq i64 %723, 0
  %725 = sub i64 %711, %723
  %726 = select i1 %724, i64 0, i64 %725
  %727 = add i64 %722, %726
  %result.i71.i1558 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %727, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %628, ptr %result.i71.i1558, align 8
  %728 = getelementptr inbounds i8, ptr %result.i71.i1558, i64 8
  store ptr %705, ptr %728, align 8
  %729 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i1558)
  %730 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %result.i71.i1558, 1
  %731 = insertvalue { ptr, ptr, ptr, i32 } %730, ptr undef, 2
  %732 = insertvalue { ptr, ptr, ptr, i32 } %731, i32 10, 3
  store ptr %628, ptr %3, align 8
  store ptr %705, ptr %39, align 8
  store ptr @_parameterization_Ptri32, ptr %40, align 8
  %733 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %3)
  %734 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Entry)
  %735 = load i64, ptr %608, align 4
  %736 = load i64, ptr %609, align 4
  %737 = load ptr, ptr %610, align 8
  %738 = load ptr, ptr %611, align 8
  %result.i.i117.i1559 = call i1 %737(i64 %736, i64 %735, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %738) #5
  %739 = select i1 %result.i.i117.i1559, i64 9, i64 10
  %gep1597 = getelementptr [14 x ptr], ptr getelementptr inbounds (i8, ptr @Entry, i64 80), i64 0, i64 %739
  %740 = load ptr, ptr %gep1597, align 8
  call void %740({ ptr, ptr, ptr, i32 } %732, { ptr, ptr, ptr, i32 } %732, ptr nonnull align 8 dereferenceable(24) %3, { ptr, i160 } %622, { ptr, i160 } %603, i32 %627) #7
  %741 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %742 = load ptr, ptr %25, align 8
  %743 = getelementptr i8, ptr %742, i64 %699
  store ptr @Entry, ptr %743, align 8
  %744 = getelementptr i8, ptr %743, i64 8
  %745 = ptrtoint ptr %result.i71.i1558 to i64
  store i64 %745, ptr %744, align 4
  %.sroa_idx4.i1561 = getelementptr i8, ptr %743, i64 24
  store i32 10, ptr %.sroa_idx4.i1561, align 4
  %746 = icmp eq ptr %701, @nil_typ
  %747 = icmp eq ptr %701, null
  %748 = or i1 %746, %747
  br i1 %748, label %749, label %752

749:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1746
  %750 = load i32, ptr %36, align 4
  %751 = add i32 %750, 1
  store i32 %751, ptr %36, align 4
  br label %._crit_edge.sink.split.i1578

752:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1746
  %753 = inttoptr i64 %703 to ptr
  %754 = inttoptr i64 %704 to ptr
  %hash_coef_ptr.i.i88.i1562 = getelementptr i8, ptr %701, i64 8
  %tbl_size_ptr.i.i89.i1563 = getelementptr i8, ptr %701, i64 16
  %offset_tbl_ptr.i.i90.i1564 = getelementptr i8, ptr %701, i64 40
  %hash_coef.i.i91.i1565 = load i64, ptr %hash_coef_ptr.i.i88.i1562, align 4, !noalias !103
  %tbl_size.i.i92.i1566 = load i64, ptr %tbl_size_ptr.i.i89.i1563, align 4, !noalias !103
  %offset_tbl.i.i93.i1567 = load ptr, ptr %offset_tbl_ptr.i.i90.i1564, align 8, !noalias !103
  %product.i.i.i94.i1568 = mul i64 %hash_coef.i.i91.i1565, 4015701072841558310
  %shifted.i.i.i95.i1569 = lshr i64 %product.i.i.i94.i1568, 32
  %xored.i.i.i96.i1570 = xor i64 %shifted.i.i.i95.i1569, %product.i.i.i94.i1568
  %hash.i.i.i97.i1571 = and i64 %xored.i.i.i96.i1570, %tbl_size.i.i92.i1566
  %offset_ptr.i.i98.i1572 = getelementptr i32, ptr %offset_tbl.i.i93.i1567, i64 %hash.i.i.i97.i1571
  %offset.i.i99.i1573 = load i32, ptr %offset_ptr.i.i98.i1572, align 4, !noalias !103
  %755 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %701, 0
  %756 = insertvalue { ptr, ptr, ptr, i32 } %755, ptr %753, 1
  %757 = insertvalue { ptr, ptr, ptr, i32 } %756, ptr %754, 2
  %758 = insertvalue { ptr, ptr, ptr, i32 } %757, i32 %offset.i.i99.i1573, 3
  %759 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %760 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %701)
  %761 = sext i32 %offset.i.i99.i1573 to i64
  %762 = getelementptr ptr, ptr %701, i64 %761
  %763 = getelementptr i8, ptr %762, i64 56
  %764 = load ptr, ptr %763, align 8
  %result.i101.i1574 = call ptr %764({ ptr, ptr, ptr, i32 } %758, ptr nocapture nofree noundef nonnull readonly %2) #16
  %765 = call { ptr, i160 } %result.i101.i1574({ ptr, ptr, ptr, i32 } %758, { ptr, ptr, ptr, i32 } %758, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i1575 = extractvalue { ptr, i160 } %765, 0
  %766 = getelementptr i8, ptr %.fca.0.extract51.i1575, i64 8
  %767 = getelementptr i8, ptr %.fca.0.extract51.i1575, i64 16
  %768 = getelementptr i8, ptr %.fca.0.extract51.i1575, i64 24
  %769 = getelementptr i8, ptr %.fca.0.extract51.i1575, i64 32
  %770 = load i64, ptr %766, align 4
  %771 = load i64, ptr %767, align 4
  %772 = load ptr, ptr %768, align 8
  %773 = load ptr, ptr %769, align 8
  %result.i102.i1576 = call i1 %772(i64 %771, i64 %770, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %773) #5
  br i1 %result.i102.i1576, label %._crit_edge.sink.split.i1578, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1580

._crit_edge.sink.split.i1578:                     ; preds = %752, %749
  %.sink159.i1579 = phi i64 [ 48, %749 ], [ 40, %752 ]
  %774 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %775 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i1579
  %776 = load ptr, ptr %775, align 8
  %777 = load ptr, ptr %776, align 8
  %778 = call i32 %777(ptr nonnull %result.i326) #36
  %779 = add i32 %778, 1
  %780 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %781 = getelementptr i8, ptr %776, i64 8
  %782 = load ptr, ptr %781, align 8
  call void %782(ptr nonnull %result.i326, i32 %779) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1580

HashMap_insert_internal_keyK_valueV_hashPtri32.exit1580: ; preds = %752, %._crit_edge.sink.split.i1578
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %3)
  br label %._crit_edge.i1315

._crit_edge.i1315:                                ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1580, %587, %.lr.ph.i1312
  %783 = add nuw nsw i32 %.096.i1313, 1
  %784 = icmp slt i32 %783, %569
  br i1 %784, label %.lr.ph.i1312, label %HashMap_resize_new_capacityPtri32.exit1338

HashMap_resize_new_capacityPtri32.exit1338:       ; preds = %._crit_edge.i1315, %._crit_edge1.i984
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_ensure_capacity_required_loadPtri32.exit988

HashMap_ensure_capacity_required_loadPtri32.exit988: ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit, %HashMap_resize_new_capacityPtri32.exit1338
  %785 = load ptr, ptr %23, align 8
  %786 = call i32 %785({ ptr, i160 } %46) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %787 = load ptr, ptr %result.i326, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %788 = load i32, ptr %26, align 8
  %789 = add i32 %788, -1
  %790 = and i32 %789, %786
  %791 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %792 = load ptr, ptr %25, align 8
  %793 = sext i32 %790 to i64
  %794 = shl nsw i64 %793, 5
  %795 = getelementptr i8, ptr %792, i64 %794
  %796 = load ptr, ptr %795, align 8
  %797 = icmp eq ptr %796, @nil_typ
  %798 = icmp eq ptr %796, null
  %799 = or i1 %797, %798
  br i1 %799, label %HashMap_find_slot_keyK_hashPtri32.exit1383, label %.lr.ph.i1353

.lr.ph.i1353:                                     ; preds = %HashMap_ensure_capacity_required_loadPtri32.exit988
  %800 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %801

801:                                              ; preds = %._crit_edge.thread.i1369, %.lr.ph.i1353
  %802 = phi i32 [ %790, %.lr.ph.i1353 ], [ %844, %._crit_edge.thread.i1369 ]
  %spec.store.select.i13741415 = phi i32 [ -1, %.lr.ph.i1353 ], [ %spec.store.select.i1374, %._crit_edge.thread.i1369 ]
  %803 = phi ptr [ %796, %.lr.ph.i1353 ], [ %849, %._crit_edge.thread.i1369 ]
  %804 = phi ptr [ %795, %.lr.ph.i1353 ], [ %848, %._crit_edge.thread.i1369 ]
  %.sroa_idx.i1355 = getelementptr i8, ptr %804, i64 16
  %805 = load i64, ptr %.sroa_idx.i1355, align 4
  %806 = getelementptr i8, ptr %804, i64 8
  %807 = load i64, ptr %806, align 4
  %808 = inttoptr i64 %807 to ptr
  %809 = inttoptr i64 %805 to ptr
  %hash_coef_ptr.i.i56.i1356 = getelementptr i8, ptr %803, i64 8
  %tbl_size_ptr.i.i57.i1357 = getelementptr i8, ptr %803, i64 16
  %offset_tbl_ptr.i.i58.i1358 = getelementptr i8, ptr %803, i64 40
  %hash_coef.i.i59.i1359 = load i64, ptr %hash_coef_ptr.i.i56.i1356, align 4
  %tbl_size.i.i60.i1360 = load i64, ptr %tbl_size_ptr.i.i57.i1357, align 4
  %offset_tbl.i.i61.i1361 = load ptr, ptr %offset_tbl_ptr.i.i58.i1358, align 8
  %product.i.i.i62.i1362 = mul i64 %hash_coef.i.i59.i1359, 4015701072841558310
  %shifted.i.i.i63.i1363 = lshr i64 %product.i.i.i62.i1362, 32
  %xored.i.i.i64.i1364 = xor i64 %shifted.i.i.i63.i1363, %product.i.i.i62.i1362
  %hash.i.i.i65.i1365 = and i64 %xored.i.i.i64.i1364, %tbl_size.i.i60.i1360
  %offset_ptr.i.i66.i1366 = getelementptr i32, ptr %offset_tbl.i.i61.i1361, i64 %hash.i.i.i65.i1365
  %offset.i.i67.i1367 = load i32, ptr %offset_ptr.i.i66.i1366, align 4
  %810 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %803, 0
  %811 = insertvalue { ptr, ptr, ptr, i32 } %810, ptr %808, 1
  %812 = insertvalue { ptr, ptr, ptr, i32 } %811, ptr %809, 2
  %813 = insertvalue { ptr, ptr, ptr, i32 } %812, i32 %offset.i.i67.i1367, 3
  %814 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %803)
  %815 = sext i32 %offset.i.i67.i1367 to i64
  %816 = getelementptr ptr, ptr %803, i64 %815
  %817 = getelementptr i8, ptr %816, i64 64
  %818 = load ptr, ptr %817, align 8
  %result.i.i1368 = call ptr %818({ ptr, ptr, ptr, i32 } %813, ptr nocapture nofree noundef nonnull readonly %2) #16
  %819 = call i32 %result.i.i1368({ ptr, ptr, ptr, i32 } %813, { ptr, ptr, ptr, i32 } %813, ptr nonnull align 8 %2) #7
  %820 = icmp eq i32 %819, %786
  br i1 %820, label %._crit_edge.i1380, label %._crit_edge.thread.i1369

._crit_edge.i1380:                                ; preds = %801
  %821 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %822 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %803)
  %823 = getelementptr i8, ptr %816, i64 48
  %824 = load ptr, ptr %823, align 8
  %result.i69.i1381 = call ptr %824({ ptr, ptr, ptr, i32 } %813, ptr nocapture nofree noundef nonnull readonly %2) #16
  %825 = call { ptr, i160 } %result.i69.i1381({ ptr, ptr, ptr, i32 } %813, { ptr, ptr, ptr, i32 } %813, ptr nonnull align 8 %2) #7
  %826 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %827 = load ptr, ptr %24, align 8
  %828 = call i1 %827({ ptr, i160 } %825, { ptr, i160 } %46) #7
  br i1 %828, label %HashMap_find_slot_keyK_hashPtri32.exit1383.loopexit, label %._crit_edge.thread.i1369

._crit_edge.thread.i1369:                         ; preds = %._crit_edge.i1380, %801
  %829 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %830 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %803)
  %831 = getelementptr i8, ptr %816, i64 56
  %832 = load ptr, ptr %831, align 8
  %result.i70.i1370 = call ptr %832({ ptr, ptr, ptr, i32 } %813, ptr nocapture nofree noundef nonnull readonly %2) #16
  %833 = call { ptr, i160 } %result.i70.i1370({ ptr, ptr, ptr, i32 } %813, { ptr, ptr, ptr, i32 } %813, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i1371 = extractvalue { ptr, i160 } %833, 0
  %834 = getelementptr i8, ptr %.fca.0.extract19.i1371, i64 8
  %835 = getelementptr i8, ptr %.fca.0.extract19.i1371, i64 16
  %836 = getelementptr i8, ptr %.fca.0.extract19.i1371, i64 24
  %837 = getelementptr i8, ptr %.fca.0.extract19.i1371, i64 32
  %838 = load i64, ptr %834, align 4
  %839 = load i64, ptr %835, align 4
  %840 = load ptr, ptr %836, align 8
  %841 = load ptr, ptr %837, align 8
  %result.i71.i1372 = call i1 %840(i64 %839, i64 %838, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %841) #5
  %842 = icmp eq i32 %spec.store.select.i13741415, -1
  %or.cond.i1373 = select i1 %result.i71.i1372, i1 %842, i1 false
  %spec.store.select.i1374 = select i1 %or.cond.i1373, i32 %802, i32 %spec.store.select.i13741415
  %843 = add i32 %802, 1
  %844 = and i32 %843, %789
  %845 = load ptr, ptr %25, align 8
  %846 = sext i32 %844 to i64
  %847 = shl nsw i64 %846, 5
  %848 = getelementptr i8, ptr %845, i64 %847
  %849 = load ptr, ptr %848, align 8
  %850 = icmp eq ptr %849, @nil_typ
  %851 = icmp eq ptr %849, null
  %852 = or i1 %850, %851
  br i1 %852, label %._crit_edge105.loopexit.i1376, label %801

._crit_edge105.loopexit.i1376:                    ; preds = %._crit_edge.thread.i1369
  %853 = icmp eq i32 %spec.store.select.i1374, -1
  %.pre.i1379.pre = select i1 %853, i32 %844, i32 %spec.store.select.i1374
  br label %HashMap_find_slot_keyK_hashPtri32.exit1383

HashMap_find_slot_keyK_hashPtri32.exit1383.loopexit: ; preds = %._crit_edge.i1380
  %.pre1495 = load ptr, ptr %25, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit1383

HashMap_find_slot_keyK_hashPtri32.exit1383:       ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1383.loopexit, %HashMap_ensure_capacity_required_loadPtri32.exit988, %._crit_edge105.loopexit.i1376
  %854 = phi ptr [ %845, %._crit_edge105.loopexit.i1376 ], [ %792, %HashMap_ensure_capacity_required_loadPtri32.exit988 ], [ %.pre1495, %HashMap_find_slot_keyK_hashPtri32.exit1383.loopexit ]
  %855 = phi i32 [ %.pre.i1379.pre, %._crit_edge105.loopexit.i1376 ], [ %790, %HashMap_ensure_capacity_required_loadPtri32.exit988 ], [ %802, %HashMap_find_slot_keyK_hashPtri32.exit1383.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %856 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %857 = sext i32 %855 to i64
  %858 = shl nsw i64 %857, 5
  %859 = getelementptr i8, ptr %854, i64 %858
  %860 = load ptr, ptr %859, align 8
  %861 = getelementptr i8, ptr %859, i64 8
  %862 = load i64, ptr %861, align 4
  %.sroa_idx.i1008 = getelementptr i8, ptr %859, i64 16
  %863 = load i64, ptr %.sroa_idx.i1008, align 4
  %864 = load ptr, ptr %18, align 8
  %865 = load ptr, ptr %787, align 8, !alias.scope !106
  %866 = getelementptr i8, ptr %865, i64 72
  %867 = load ptr, ptr %866, align 8, !alias.scope !106
  %result.i.i.i1010 = call { i64, i64 } %867(ptr nocapture nofree nonnull readonly %787) #5, !alias.scope !106
  %868 = extractvalue { i64, i64 } %result.i.i.i1010, 0
  %869 = extractvalue { i64, i64 } %result.i.i.i1010, 1
  %870 = call i64 @llvm.umax.i64(i64 %869, i64 8)
  %871 = urem i64 20, %869
  %872 = icmp eq i64 %871, 0
  %873 = sub i64 %869, %871
  %874 = select i1 %872, i64 0, i64 %873
  %875 = add i64 %868, 20
  %876 = add i64 %875, %874
  %877 = and i64 %876, 7
  %878 = icmp eq i64 %877, 0
  %879 = sub nuw nsw i64 40, %877
  %880 = select i1 %878, i64 32, i64 %879
  %881 = add i64 %880, %876
  %882 = urem i64 %881, %870
  %883 = icmp eq i64 %882, 0
  %884 = sub i64 %870, %882
  %885 = select i1 %883, i64 0, i64 %884
  %886 = add i64 %881, %885
  %result.i71.i1011 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %886, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %787, ptr %result.i71.i1011, align 8
  %887 = getelementptr inbounds i8, ptr %result.i71.i1011, i64 8
  store ptr %864, ptr %887, align 8
  %888 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i1011)
  %889 = load ptr, ptr %787, align 8
  %890 = getelementptr i8, ptr %889, i64 72
  %891 = load ptr, ptr %890, align 8
  %result.i.i1462 = call { i64, i64 } %891(ptr nocapture nofree nonnull readonly %787) #5
  %892 = extractvalue { i64, i64 } %result.i.i1462, 1
  %893 = urem i64 20, %892
  %894 = icmp eq i64 %893, 0
  %reass.sub = sub i64 %892, %893
  %895 = add i64 %reass.sub, 20
  %896 = select i1 %894, i64 20, i64 %895
  %897 = getelementptr i8, ptr %result.i71.i1011, i64 %896
  %898 = getelementptr i8, ptr %889, i64 64
  %899 = load ptr, ptr %898, align 8
  call void %899({ ptr, i160 } %46, ptr nocapture nofree nonnull readonly %787, ptr nocapture nofree writeonly %897) #13
  %900 = load ptr, ptr %result.i71.i1011, align 8
  %901 = load ptr, ptr %900, align 8
  %902 = getelementptr i8, ptr %901, i64 72
  %903 = load ptr, ptr %902, align 8
  %result.i.i1464 = call { i64, i64 } %903(ptr nocapture nofree nonnull readonly %900) #5
  %904 = extractvalue { i64, i64 } %result.i.i1464, 0
  %905 = extractvalue { i64, i64 } %result.i.i1464, 1
  %906 = urem i64 20, %905
  %907 = icmp eq i64 %906, 0
  %908 = sub i64 %905, %906
  %909 = select i1 %907, i64 0, i64 %908
  %910 = add i64 %904, 20
  %911 = add i64 %910, %909
  %912 = and i64 %911, 7
  %913 = icmp eq i64 %912, 0
  %914 = sub nuw nsw i64 8, %912
  %915 = select i1 %913, i64 0, i64 %914
  %916 = getelementptr i8, ptr %result.i71.i1011, i64 %911
  %917 = getelementptr i8, ptr %916, i64 %915
  store ptr @bool_typ, ptr %917, align 8
  %918 = getelementptr i8, ptr %917, i64 8
  store i160 %.sroa.0224.0.insert.ext, ptr %918, align 4
  %919 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @Entry) #34
  %920 = getelementptr inbounds i8, ptr %result.i71.i1011, i64 16
  store i32 %786, ptr %920, align 8
  %921 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  store ptr @Entry, ptr %859, align 8
  %922 = ptrtoint ptr %result.i71.i1011 to i64
  store i64 %922, ptr %861, align 4
  %.sroa_idx4.i1014 = getelementptr i8, ptr %859, i64 24
  store i32 10, ptr %.sroa_idx4.i1014, align 4
  %923 = icmp eq ptr %860, @nil_typ
  %924 = icmp eq ptr %860, null
  %925 = or i1 %923, %924
  br i1 %925, label %926, label %929

926:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1383
  %927 = load i32, ptr %36, align 4
  %928 = add i32 %927, 1
  store i32 %928, ptr %36, align 4
  br label %._crit_edge.sink.split.i1031

929:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1383
  %930 = inttoptr i64 %862 to ptr
  %931 = inttoptr i64 %863 to ptr
  %hash_coef_ptr.i.i88.i1015 = getelementptr i8, ptr %860, i64 8
  %tbl_size_ptr.i.i89.i1016 = getelementptr i8, ptr %860, i64 16
  %offset_tbl_ptr.i.i90.i1017 = getelementptr i8, ptr %860, i64 40
  %hash_coef.i.i91.i1018 = load i64, ptr %hash_coef_ptr.i.i88.i1015, align 4, !noalias !109
  %tbl_size.i.i92.i1019 = load i64, ptr %tbl_size_ptr.i.i89.i1016, align 4, !noalias !109
  %offset_tbl.i.i93.i1020 = load ptr, ptr %offset_tbl_ptr.i.i90.i1017, align 8, !noalias !109
  %product.i.i.i94.i1021 = mul i64 %hash_coef.i.i91.i1018, 4015701072841558310
  %shifted.i.i.i95.i1022 = lshr i64 %product.i.i.i94.i1021, 32
  %xored.i.i.i96.i1023 = xor i64 %shifted.i.i.i95.i1022, %product.i.i.i94.i1021
  %hash.i.i.i97.i1024 = and i64 %xored.i.i.i96.i1023, %tbl_size.i.i92.i1019
  %offset_ptr.i.i98.i1025 = getelementptr i32, ptr %offset_tbl.i.i93.i1020, i64 %hash.i.i.i97.i1024
  %offset.i.i99.i1026 = load i32, ptr %offset_ptr.i.i98.i1025, align 4, !noalias !109
  %932 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %860, 0
  %933 = insertvalue { ptr, ptr, ptr, i32 } %932, ptr %930, 1
  %934 = insertvalue { ptr, ptr, ptr, i32 } %933, ptr %931, 2
  %935 = insertvalue { ptr, ptr, ptr, i32 } %934, i32 %offset.i.i99.i1026, 3
  %936 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %937 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %860)
  %938 = sext i32 %offset.i.i99.i1026 to i64
  %939 = getelementptr ptr, ptr %860, i64 %938
  %940 = getelementptr i8, ptr %939, i64 56
  %941 = load ptr, ptr %940, align 8
  %result.i101.i1027 = call ptr %941({ ptr, ptr, ptr, i32 } %935, ptr nocapture nofree noundef nonnull readonly %2) #16
  %942 = call { ptr, i160 } %result.i101.i1027({ ptr, ptr, ptr, i32 } %935, { ptr, ptr, ptr, i32 } %935, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i1028 = extractvalue { ptr, i160 } %942, 0
  %943 = getelementptr i8, ptr %.fca.0.extract51.i1028, i64 8
  %944 = getelementptr i8, ptr %.fca.0.extract51.i1028, i64 16
  %945 = getelementptr i8, ptr %.fca.0.extract51.i1028, i64 24
  %946 = getelementptr i8, ptr %.fca.0.extract51.i1028, i64 32
  %947 = load i64, ptr %943, align 4
  %948 = load i64, ptr %944, align 4
  %949 = load ptr, ptr %945, align 8
  %950 = load ptr, ptr %946, align 8
  %result.i102.i1029 = call i1 %949(i64 %948, i64 %947, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %950) #5
  br i1 %result.i102.i1029, label %._crit_edge.sink.split.i1031, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1033

._crit_edge.sink.split.i1031:                     ; preds = %929, %926
  %.sink159.i1032 = phi i64 [ 48, %926 ], [ 40, %929 ]
  %951 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %952 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i1032
  %953 = load ptr, ptr %952, align 8
  %954 = load ptr, ptr %953, align 8
  %955 = call i32 %954(ptr nonnull %result.i326) #36
  %956 = add i32 %955, 1
  %957 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %958 = getelementptr i8, ptr %953, i64 8
  %959 = load ptr, ptr %958, align 8
  call void %959(ptr nonnull %result.i326, i32 %956) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1033

HashMap_insert_internal_keyK_valueV_hashPtri32.exit1033: ; preds = %929, %._crit_edge.sink.split.i1031
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %960 = sext i32 %171 to i64
  %961 = add i64 %.0275527, %960
  %962 = add nsw i32 %.0266528, 1
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1033, %HashMap_get_keyK.exit
  %.2277 = phi i64 [ %961, %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1033 ], [ %.0275527, %HashMap_get_keyK.exit ]
  %.2268 = phi i32 [ %962, %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1033 ], [ %.0266528, %HashMap_get_keyK.exit ]
  %963 = add nuw nsw i32 %.0264529, 1
  %964 = icmp slt i32 %.2268, %0
  %965 = icmp slt i32 %963, %28
  %spec.select = select i1 %964, i1 %965, i1 false
  br i1 %spec.select, label %41, label %._crit_edge3._crit_edge

._crit_edge3._crit_edge:                          ; preds = %._crit_edge1, %1
  %.0275.lcssa = phi i64 [ 0, %1 ], [ %.2277, %._crit_edge1 ]
  %.0266.lcssa = phi i32 [ 0, %1 ], [ %.2268, %._crit_edge1 ]
  %966 = icmp slt i32 %.0266.lcssa, %0
  br i1 %966, label %._crit_edge.lr.ph.i, label %._crit_edge4

._crit_edge.lr.ph.i:                              ; preds = %._crit_edge3._crit_edge
  %result.i355 = call noalias align 32 dereferenceable_or_null(30) ptr @bump_malloc_inner(i64 noundef 30, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <29 x i8> <i8 87, i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 67, i8 111, i8 117, i8 108, i8 100, i8 32, i8 111, i8 110, i8 108, i8 121, i8 32, i8 103, i8 101, i8 110, i8 101, i8 114, i8 97, i8 116, i8 101, i8 32>, ptr %result.i355, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %967 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %968 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1047 = call noalias dereferenceable_or_null(30) ptr @bump_malloc_inner(i64 noundef 30, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(29) %result.i.i1047, ptr noundef nonnull align 32 dereferenceable(29) %result.i355, i64 29, i1 false)
  %969 = getelementptr i8, ptr %result.i.i1047, i64 29
  store i8 0, ptr %969, align 1
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1047)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %970 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0266.lcssa) #17
  %result.i361 = call noalias align 64 dereferenceable_or_null(34) ptr @bump_malloc_inner(i64 noundef 34, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %971 = load <33 x i8>, ptr @uyexo__unique_keys_for_random_hit_test, align 64
  store <33 x i8> %971, ptr %result.i361, align 64
  %972 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %973 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %974 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1062 = call noalias dereferenceable_or_null(34) ptr @bump_malloc_inner(i64 noundef 34, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(33) %result.i.i1062, ptr noundef nonnull align 64 dereferenceable(33) %result.i361, i64 33, i1 false)
  %975 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %976 = getelementptr i8, ptr %result.i.i1062, i64 33
  store i8 0, ptr %976, align 1
  %puts.i780 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1062)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %._crit_edge4

._crit_edge4:                                     ; preds = %._crit_edge3._crit_edge, %._crit_edge.lr.ph.i
  %.0274 = phi i32 [ %.0266.lcssa, %._crit_edge.lr.ph.i ], [ %0, %._crit_edge3._crit_edge ]
  %977 = call i64 @clock()
  %978 = icmp sgt i32 %.0274, 0
  br i1 %978, label %.lr.ph535.preheader, label %._crit_edge.lr.ph.i1146

.lr.ph535.preheader:                              ; preds = %._crit_edge4
  %979 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  br label %.lr.ph535

.lr.ph535:                                        ; preds = %.lr.ph535.preheader, %._crit_edge5
  %.0263534 = phi i64 [ %.2, %._crit_edge5 ], [ 0, %.lr.ph535.preheader ]
  %.0269533 = phi i1 [ %.2271, %._crit_edge5 ], [ true, %.lr.ph535.preheader ]
  %.0272532 = phi i32 [ %1118, %._crit_edge5 ], [ 0, %.lr.ph535.preheader ]
  %980 = zext nneg i32 %.0272532 to i64
  %981 = shl nuw nsw i64 %980, 2
  %982 = getelementptr i8, ptr %result.i4.i, i64 %981
  %983 = load i32, ptr %982, align 1
  %.sroa.2.sroa.0.0.insert.ext.i = zext i32 %983 to i160
  %984 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %985 = load ptr, ptr %10, align 8
  %986 = call i32 %985({ ptr, i160 } %984) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %987 = load i32, ptr %13, align 8
  %988 = add i32 %987, -1
  %989 = and i32 %988, %986
  %990 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %991 = load ptr, ptr %12, align 8
  %992 = sext i32 %989 to i64
  %993 = shl nsw i64 %992, 5
  %994 = getelementptr i8, ptr %991, i64 %993
  %995 = load ptr, ptr %994, align 8
  %996 = icmp eq ptr %995, @nil_typ
  %997 = icmp eq ptr %995, null
  %998 = or i1 %996, %997
  br i1 %998, label %HashMap_find_slot_keyK_hashPtri32.exit1112, label %.lr.ph.i1082

.lr.ph.i1082:                                     ; preds = %.lr.ph535
  %999 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1000

1000:                                             ; preds = %._crit_edge.thread.i1098, %.lr.ph.i1082
  %1001 = phi i32 [ %989, %.lr.ph.i1082 ], [ %1043, %._crit_edge.thread.i1098 ]
  %spec.store.select.i11031200 = phi i32 [ -1, %.lr.ph.i1082 ], [ %spec.store.select.i1103, %._crit_edge.thread.i1098 ]
  %1002 = phi ptr [ %995, %.lr.ph.i1082 ], [ %1048, %._crit_edge.thread.i1098 ]
  %1003 = phi ptr [ %994, %.lr.ph.i1082 ], [ %1047, %._crit_edge.thread.i1098 ]
  %.sroa_idx.i1084 = getelementptr i8, ptr %1003, i64 16
  %1004 = load i64, ptr %.sroa_idx.i1084, align 4
  %1005 = getelementptr i8, ptr %1003, i64 8
  %1006 = load i64, ptr %1005, align 4
  %1007 = inttoptr i64 %1006 to ptr
  %1008 = inttoptr i64 %1004 to ptr
  %hash_coef_ptr.i.i56.i1085 = getelementptr i8, ptr %1002, i64 8
  %tbl_size_ptr.i.i57.i1086 = getelementptr i8, ptr %1002, i64 16
  %offset_tbl_ptr.i.i58.i1087 = getelementptr i8, ptr %1002, i64 40
  %hash_coef.i.i59.i1088 = load i64, ptr %hash_coef_ptr.i.i56.i1085, align 4
  %tbl_size.i.i60.i1089 = load i64, ptr %tbl_size_ptr.i.i57.i1086, align 4
  %offset_tbl.i.i61.i1090 = load ptr, ptr %offset_tbl_ptr.i.i58.i1087, align 8
  %product.i.i.i62.i1091 = mul i64 %hash_coef.i.i59.i1088, 4015701072841558310
  %shifted.i.i.i63.i1092 = lshr i64 %product.i.i.i62.i1091, 32
  %xored.i.i.i64.i1093 = xor i64 %shifted.i.i.i63.i1092, %product.i.i.i62.i1091
  %hash.i.i.i65.i1094 = and i64 %xored.i.i.i64.i1093, %tbl_size.i.i60.i1089
  %offset_ptr.i.i66.i1095 = getelementptr i32, ptr %offset_tbl.i.i61.i1090, i64 %hash.i.i.i65.i1094
  %offset.i.i67.i1096 = load i32, ptr %offset_ptr.i.i66.i1095, align 4
  %1009 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1002, 0
  %1010 = insertvalue { ptr, ptr, ptr, i32 } %1009, ptr %1007, 1
  %1011 = insertvalue { ptr, ptr, ptr, i32 } %1010, ptr %1008, 2
  %1012 = insertvalue { ptr, ptr, ptr, i32 } %1011, i32 %offset.i.i67.i1096, 3
  %1013 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1002)
  %1014 = sext i32 %offset.i.i67.i1096 to i64
  %1015 = getelementptr ptr, ptr %1002, i64 %1014
  %1016 = getelementptr i8, ptr %1015, i64 64
  %1017 = load ptr, ptr %1016, align 8
  %result.i.i1097 = call ptr %1017({ ptr, ptr, ptr, i32 } %1012, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1018 = call i32 %result.i.i1097({ ptr, ptr, ptr, i32 } %1012, { ptr, ptr, ptr, i32 } %1012, ptr nonnull align 8 %2) #7
  %1019 = icmp eq i32 %1018, %986
  br i1 %1019, label %._crit_edge.i1109, label %._crit_edge.thread.i1098

._crit_edge.i1109:                                ; preds = %1000
  %1020 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1021 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1002)
  %1022 = getelementptr i8, ptr %1015, i64 48
  %1023 = load ptr, ptr %1022, align 8
  %result.i69.i1110 = call ptr %1023({ ptr, ptr, ptr, i32 } %1012, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1024 = call { ptr, i160 } %result.i69.i1110({ ptr, ptr, ptr, i32 } %1012, { ptr, ptr, ptr, i32 } %1012, ptr nonnull align 8 %2) #7
  %1025 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1026 = load ptr, ptr %11, align 8
  %1027 = call i1 %1026({ ptr, i160 } %1024, { ptr, i160 } %984) #7
  br i1 %1027, label %HashMap_find_slot_keyK_hashPtri32.exit1112.loopexit, label %._crit_edge.thread.i1098

._crit_edge.thread.i1098:                         ; preds = %._crit_edge.i1109, %1000
  %1028 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1029 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1002)
  %1030 = getelementptr i8, ptr %1015, i64 56
  %1031 = load ptr, ptr %1030, align 8
  %result.i70.i1099 = call ptr %1031({ ptr, ptr, ptr, i32 } %1012, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1032 = call { ptr, i160 } %result.i70.i1099({ ptr, ptr, ptr, i32 } %1012, { ptr, ptr, ptr, i32 } %1012, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i1100 = extractvalue { ptr, i160 } %1032, 0
  %1033 = getelementptr i8, ptr %.fca.0.extract19.i1100, i64 8
  %1034 = getelementptr i8, ptr %.fca.0.extract19.i1100, i64 16
  %1035 = getelementptr i8, ptr %.fca.0.extract19.i1100, i64 24
  %1036 = getelementptr i8, ptr %.fca.0.extract19.i1100, i64 32
  %1037 = load i64, ptr %1033, align 4
  %1038 = load i64, ptr %1034, align 4
  %1039 = load ptr, ptr %1035, align 8
  %1040 = load ptr, ptr %1036, align 8
  %result.i71.i1101 = call i1 %1039(i64 %1038, i64 %1037, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %1040) #5
  %1041 = icmp eq i32 %spec.store.select.i11031200, -1
  %or.cond.i1102 = select i1 %result.i71.i1101, i1 %1041, i1 false
  %spec.store.select.i1103 = select i1 %or.cond.i1102, i32 %1001, i32 %spec.store.select.i11031200
  %1042 = add i32 %1001, 1
  %1043 = and i32 %1042, %988
  %1044 = load ptr, ptr %12, align 8
  %1045 = sext i32 %1043 to i64
  %1046 = shl nsw i64 %1045, 5
  %1047 = getelementptr i8, ptr %1044, i64 %1046
  %1048 = load ptr, ptr %1047, align 8
  %1049 = icmp eq ptr %1048, @nil_typ
  %1050 = icmp eq ptr %1048, null
  %1051 = or i1 %1049, %1050
  br i1 %1051, label %._crit_edge105.loopexit.i1105, label %1000

._crit_edge105.loopexit.i1105:                    ; preds = %._crit_edge.thread.i1098
  %1052 = icmp eq i32 %spec.store.select.i1103, -1
  %.pre.i1108.pre = select i1 %1052, i32 %1043, i32 %spec.store.select.i1103
  br label %HashMap_find_slot_keyK_hashPtri32.exit1112

HashMap_find_slot_keyK_hashPtri32.exit1112.loopexit: ; preds = %._crit_edge.i1109
  %.pre1235 = load ptr, ptr %12, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit1112

HashMap_find_slot_keyK_hashPtri32.exit1112:       ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1112.loopexit, %.lr.ph535, %._crit_edge105.loopexit.i1105
  %1053 = phi ptr [ %1044, %._crit_edge105.loopexit.i1105 ], [ %991, %.lr.ph535 ], [ %.pre1235, %HashMap_find_slot_keyK_hashPtri32.exit1112.loopexit ]
  %1054 = phi i32 [ %.pre.i1108.pre, %._crit_edge105.loopexit.i1105 ], [ %989, %.lr.ph535 ], [ %1001, %HashMap_find_slot_keyK_hashPtri32.exit1112.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1055 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1056 = sext i32 %1054 to i64
  %1057 = shl nsw i64 %1056, 5
  %1058 = getelementptr i8, ptr %1053, i64 %1057
  %1059 = load ptr, ptr %1058, align 8
  %1060 = icmp ne ptr %1059, @nil_typ
  %1061 = icmp ne ptr %1059, null
  %.not57.i813 = and i1 %1060, %1061
  br i1 %.not57.i813, label %1062, label %HashMap_get_keyK.exit841.thread

1062:                                             ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1112
  %1063 = getelementptr i8, ptr %1058, i64 8
  %1064 = load i64, ptr %1063, align 4
  %.sroa_idx.i817 = getelementptr i8, ptr %1058, i64 16
  %1065 = load i64, ptr %.sroa_idx.i817, align 4
  %1066 = inttoptr i64 %1064 to ptr
  %1067 = inttoptr i64 %1065 to ptr
  %hash_coef_ptr.i.i60.i818 = getelementptr i8, ptr %1059, i64 8
  %tbl_size_ptr.i.i61.i819 = getelementptr i8, ptr %1059, i64 16
  %offset_tbl_ptr.i.i62.i820 = getelementptr i8, ptr %1059, i64 40
  %hash_coef.i.i63.i821 = load i64, ptr %hash_coef_ptr.i.i60.i818, align 4, !noalias !112
  %tbl_size.i.i64.i822 = load i64, ptr %tbl_size_ptr.i.i61.i819, align 4, !noalias !112
  %offset_tbl.i.i65.i823 = load ptr, ptr %offset_tbl_ptr.i.i62.i820, align 8, !noalias !112
  %product.i.i.i66.i824 = mul i64 %hash_coef.i.i63.i821, 4015701072841558310
  %shifted.i.i.i67.i825 = lshr i64 %product.i.i.i66.i824, 32
  %xored.i.i.i68.i826 = xor i64 %shifted.i.i.i67.i825, %product.i.i.i66.i824
  %hash.i.i.i69.i827 = and i64 %xored.i.i.i68.i826, %tbl_size.i.i64.i822
  %offset_ptr.i.i70.i828 = getelementptr i32, ptr %offset_tbl.i.i65.i823, i64 %hash.i.i.i69.i827
  %offset.i.i71.i829 = load i32, ptr %offset_ptr.i.i70.i828, align 4, !noalias !112
  %1068 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1059, 0
  %1069 = insertvalue { ptr, ptr, ptr, i32 } %1068, ptr %1066, 1
  %1070 = insertvalue { ptr, ptr, ptr, i32 } %1069, ptr %1067, 2
  %1071 = insertvalue { ptr, ptr, ptr, i32 } %1070, i32 %offset.i.i71.i829, 3
  %1072 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1073 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1059)
  %1074 = sext i32 %offset.i.i71.i829 to i64
  %1075 = getelementptr ptr, ptr %1059, i64 %1074
  %1076 = getelementptr i8, ptr %1075, i64 56
  %1077 = load ptr, ptr %1076, align 8
  %result.i73.i830 = call ptr %1077({ ptr, ptr, ptr, i32 } %1071, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1078 = call { ptr, i160 } %result.i73.i830({ ptr, ptr, ptr, i32 } %1071, { ptr, ptr, ptr, i32 } %1071, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i831 = extractvalue { ptr, i160 } %1078, 0
  %.fca.1.extract52.i832 = extractvalue { ptr, i160 } %1078, 1
  %1079 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1080 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1059)
  %1081 = getelementptr i8, ptr %1075, i64 64
  %1082 = load ptr, ptr %1081, align 8
  %result.i74.i833 = call ptr %1082({ ptr, ptr, ptr, i32 } %1071, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1083 = call i32 %result.i74.i833({ ptr, ptr, ptr, i32 } %1071, { ptr, ptr, ptr, i32 } %1071, ptr nonnull align 8 %2) #7
  %1084 = icmp eq i32 %1083, %986
  br i1 %1084, label %._crit_edge.i834, label %HashMap_get_keyK.exit841.thread

._crit_edge.i834:                                 ; preds = %1062
  %1085 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1086 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1059)
  %1087 = getelementptr i8, ptr %1075, i64 48
  %1088 = load ptr, ptr %1087, align 8
  %result.i75.i835 = call ptr %1088({ ptr, ptr, ptr, i32 } %1071, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1089 = call { ptr, i160 } %result.i75.i835({ ptr, ptr, ptr, i32 } %1071, { ptr, ptr, ptr, i32 } %1071, ptr nonnull align 8 %2) #7
  %1090 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1091 = load ptr, ptr %11, align 8
  %1092 = call i1 %1091({ ptr, i160 } %1089, { ptr, i160 } %984) #7
  br i1 %1092, label %HashMap_get_keyK.exit841, label %HashMap_get_keyK.exit841.thread

HashMap_get_keyK.exit841.thread:                  ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1112, %1062, %._crit_edge.i834
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %._crit_edge.lr.ph.i1127

HashMap_get_keyK.exit841:                         ; preds = %._crit_edge.i834
  %1093 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1094 = load ptr, ptr %5, align 8
  %1095 = load ptr, ptr %1094, align 8
  %1096 = ptrtoint ptr %1095 to i64
  %1097 = getelementptr i8, ptr %.fca.0.extract51.i831, i64 8
  %1098 = getelementptr i8, ptr %.fca.0.extract51.i831, i64 16
  %1099 = getelementptr i8, ptr %.fca.0.extract51.i831, i64 24
  %1100 = getelementptr i8, ptr %.fca.0.extract51.i831, i64 32
  %1101 = load i64, ptr %1097, align 4
  %1102 = load i64, ptr %1098, align 4
  %1103 = load ptr, ptr %1099, align 8
  %1104 = load ptr, ptr %1100, align 8
  %1105 = load i64, ptr %1095, align 4
  %result.i77.i838 = call i1 %1103(i64 %1102, i64 %1101, i64 %1105, i64 %1096, ptr readonly %1104) #5
  %cond.fr.i839 = freeze i1 %result.i77.i838
  %spec.select.i840 = select i1 %cond.fr.i839, ptr %.fca.0.extract51.i831, ptr @nil_typ
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1106 = icmp ne ptr %spec.select.i840, @nil_typ
  %1107 = icmp ne ptr %spec.select.i840, null
  %.not281 = and i1 %1106, %1107
  br i1 %.not281, label %1108, label %._crit_edge.lr.ph.i1127

1108:                                             ; preds = %HashMap_get_keyK.exit841
  %.sroa.2.8.extract.trunc = trunc i160 %.fca.1.extract52.i832 to i32
  %1109 = sext i32 %.sroa.2.8.extract.trunc to i64
  %1110 = add i64 %.0263534, %1109
  br label %._crit_edge5

._crit_edge.lr.ph.i1127:                          ; preds = %HashMap_get_keyK.exit841, %HashMap_get_keyK.exit841.thread
  %result.i368 = call noalias align 64 dereferenceable_or_null(52) ptr @bump_malloc_inner(i64 noundef 52, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %1111 = load <51 x i8>, ptr @umtrl_Error_Nil_returned_during_random_hit_test_for_key_, align 64
  store <51 x i8> %1111, ptr %result.i368, align 64
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1112 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1113 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1126 = call noalias dereferenceable_or_null(52) ptr @bump_malloc_inner(i64 noundef 52, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(51) %result.i.i1126, ptr noundef nonnull align 64 dereferenceable(51) %result.i368, i64 51, i1 false)
  %1114 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %1115 = getelementptr i8, ptr %result.i.i1126, i64 51
  store i8 0, ptr %1115, align 1
  %puts.i861 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1126)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1116 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %1117 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %983) #17
  br label %._crit_edge5

._crit_edge5:                                     ; preds = %1108, %._crit_edge.lr.ph.i1127
  %.2271 = phi i1 [ %.0269533, %1108 ], [ false, %._crit_edge.lr.ph.i1127 ]
  %.2 = phi i64 [ %1110, %1108 ], [ %.0263534, %._crit_edge.lr.ph.i1127 ]
  %1118 = add nuw nsw i32 %.0272532, 1
  %1119 = icmp slt i32 %1118, %.0274
  br i1 %1119, label %.lr.ph535, label %._crit_edge.lr.ph.i1146

._crit_edge.lr.ph.i1146:                          ; preds = %._crit_edge5, %._crit_edge4
  %.0269.lcssa = phi i1 [ true, %._crit_edge4 ], [ %.2271, %._crit_edge5 ]
  %.0263.lcssa = phi i64 [ 0, %._crit_edge4 ], [ %.2, %._crit_edge5 ]
  %1120 = call i64 @clock()
  %result.i374 = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 71, i8 101, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109, i8 32, i8 72, i8 105, i8 116>, ptr %result.i374, align 16
  %1121 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #34
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1122 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1123 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1145 = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i1145, ptr noundef nonnull align 16 dereferenceable(14) %result.i374, i64 14, i1 false)
  %1124 = sub i64 %1120, %977
  %1125 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %1126 = getelementptr i8, ptr %result.i.i1145, i64 14
  store i8 0, ptr %1126, align 1
  %puts.i881 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1145)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i97.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i97.i, align 16
  %result.i.i375.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i375.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i97.i, i64 14, i1 false)
  %puts.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i375.i)
  %1127 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0274) #17
  %result.i103.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i103.i, align 16
  %result.i.i389.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i389.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i103.i, i64 14, i1 false)
  %puts.i313.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i389.i)
  %1128 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %1124) #17
  %result.i109.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i109.i, align 4
  %result.i.i408.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i408.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i109.i, i64 3, i1 false)
  %puts.i333.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i408.i)
  br i1 %978, label %._crit_edge1.i, label %._crit_edge.lr.ph.i1165

._crit_edge1.i:                                   ; preds = %._crit_edge.lr.ph.i1146
  %1129 = icmp sgt i64 %1124, 0
  br i1 %1129, label %1130, label %._crit_edge.lr.ph.i428.i

1130:                                             ; preds = %._crit_edge1.i
  %1131 = zext nneg i32 %.0274 to i64
  %1132 = mul i64 %1124, 1000000
  %1133 = sdiv i64 %1132, %1131
  br label %._crit_edge.lr.ph.i428.i

._crit_edge.lr.ph.i428.i:                         ; preds = %1130, %._crit_edge1.i
  %.0.i = phi i64 [ %1133, %1130 ], [ 0, %._crit_edge1.i ]
  %result.i114.i = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i114.i, align 16
  %result.i.i427.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i427.i, ptr noundef nonnull align 16 dereferenceable(15) %result.i114.i, i64 15, i1 false)
  %puts.i353.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i427.i)
  %1134 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0.i) #17
  %result.i120.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i120.i, align 4
  %1135 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %result.i.i446.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i446.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i120.i, i64 3, i1 false)
  %1136 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %puts.i373.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i446.i)
  br label %._crit_edge.lr.ph.i1165

._crit_edge.lr.ph.i1165:                          ; preds = %._crit_edge.lr.ph.i1146, %._crit_edge.lr.ph.i428.i
  %.not = icmp eq i64 %.0263.lcssa, %.0275.lcssa
  %result.i378 = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i378, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1137 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1138 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1164 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i1164, ptr noundef nonnull align 32 dereferenceable(18) %result.i378, i64 18, i1 false)
  %spec.select282 = select i1 %.not, i1 %.0269.lcssa, i1 false
  %1139 = getelementptr i8, ptr %result.i.i1164, i64 18
  store i8 0, ptr %1139, align 1
  %puts.i901 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1164)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %. = select i1 %spec.select282, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %1140 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1141 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1142 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1183 = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <4 x i8> %., ptr %result.i.i1183, align 1
  %1143 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %1144 = getelementptr i8, ptr %result.i.i1183, i64 4
  store i8 0, ptr %1144, align 1
  %puts.i921 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1183)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  ret void
}

define void @benchmark_get_random_miss(i32 %0) local_unnamed_addr {
  %2 = alloca [0 x ptr], align 8
  %3 = alloca [3 x ptr], align 8
  %4 = alloca [3 x ptr], align 8
  %oldProtect.i434 = alloca i32, align 4
  %oldProtect.i430 = alloca i32, align 4
  %oldProtect.i389 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %.sroa.0323.sroa.0 = alloca i8, align 8
  %result.i385 = tail call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i385, align 8
  %5 = getelementptr inbounds i8, ptr %result.i385, i64 8
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %result.i385, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %6, align 8
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i385) #38
  %result.i386 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i)
  %result.i387 = call i32 @VirtualProtect(ptr nofree %result.i386, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i386, ptr noalias nofree noundef nonnull readnone @aezirnfvtu, ptr noalias nofree noundef nonnull readnone @i32_hasher) #38
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i386) #39
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i386) #38
  %result.i388 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i389)
  %result.i390 = call i32 @VirtualProtect(ptr nofree %result.i388, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i389) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i389)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i388, ptr noalias nofree noundef nonnull readnone @uapuynspes, ptr noalias nofree noundef nonnull readnone @i32_eq) #38
  %ret.i391 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i388) #39
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i388) #38
  %10 = getelementptr inbounds i8, ptr %result.i385, i64 48
  store ptr %ret.i, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %result.i385, i64 56
  store ptr %ret.i391, ptr %11, align 8
  %result.i.i724 = call noalias dereferenceable_or_null(512) ptr @bump_malloc_inner(i64 noundef 512, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %12 = getelementptr inbounds i8, ptr %result.i385, i64 24
  store ptr %result.i.i724, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %result.i385, i64 32
  store i32 16, ptr %13, align 8
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #34
  %result.i428 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i428, align 8
  %15 = getelementptr inbounds i8, ptr %result.i428, i64 8
  store ptr @_parameterization_Ptri1, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i428, i64 16
  store ptr @_parameterization_PairPtri32._Ptri1, ptr %16, align 8
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i428)
  %result.i429 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i430)
  %result.i431 = call i32 @VirtualProtect(ptr nofree %result.i429, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i430) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i430)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i429, ptr noalias nofree noundef nonnull readnone @eptcgwbewk, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %ret.i432 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i429) #39
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i429)
  %result.i433 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i434)
  %result.i435 = call i32 @VirtualProtect(ptr nofree %result.i433, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i434) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i434)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i433, ptr noalias nofree noundef nonnull readnone @pcqqahzzfu, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %ret.i436 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i433) #39
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i433)
  %20 = getelementptr inbounds i8, ptr %result.i428, i64 48
  store ptr %ret.i432, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i428, i64 56
  store ptr %ret.i436, ptr %21, align 8
  %result.i.i763 = call noalias dereferenceable_or_null(512) ptr @bump_malloc_inner(i64 noundef 512, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %22 = getelementptr inbounds i8, ptr %result.i428, i64 24
  store ptr %result.i.i763, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %result.i428, i64 32
  store i32 16, ptr %23, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #34
  %25 = mul i32 %0, 10
  %26 = icmp sgt i32 %0, 0
  %27 = icmp sgt i32 %25, 0
  %spec.select706 = and i1 %26, %27
  br i1 %spec.select706, label %.lr.ph, label %._crit_edge3._crit_edge

.lr.ph:                                           ; preds = %1
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #34
  %30 = getelementptr inbounds i8, ptr %result.i385, i64 40
  %31 = getelementptr inbounds i8, ptr %result.i428, i64 40
  %32 = getelementptr inbounds i8, ptr %result.i385, i64 36
  %33 = getelementptr inbounds i8, ptr %result.i428, i64 36
  %34 = getelementptr inbounds i8, ptr %4, i64 8
  %35 = getelementptr inbounds i8, ptr %4, i64 16
  %36 = getelementptr inbounds i8, ptr %3, i64 8
  %37 = getelementptr inbounds i8, ptr %3, i64 16
  br label %38

38:                                               ; preds = %.lr.ph, %._crit_edge1
  %39 = phi i32 [ 789, %.lr.ph ], [ %42, %._crit_edge1 ]
  %.0358708 = phi i32 [ 0, %.lr.ph ], [ %954, %._crit_edge1 ]
  %.0361707 = phi i32 [ 0, %.lr.ph ], [ %.2363, %._crit_edge1 ]
  %40 = mul i32 %39, 1103515245
  %41 = add i32 %40, 12345
  %42 = and i32 %41, 2147483647
  %.sroa.0347.0.insert.ext = zext nneg i32 %42 to i160
  %43 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0347.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %44 = load ptr, ptr %20, align 8
  %45 = call i32 %44({ ptr, i160 } %43) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %46 = load i32, ptr %23, align 8
  %47 = add i32 %46, -1
  %48 = and i32 %47, %45
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %50 = load ptr, ptr %22, align 8
  %51 = sext i32 %48 to i64
  %52 = shl nsw i64 %51, 5
  %53 = getelementptr i8, ptr %50, i64 %52
  %54 = load ptr, ptr %53, align 8
  %55 = icmp eq ptr %54, @nil_typ
  %56 = icmp eq ptr %54, null
  %57 = or i1 %55, %56
  br i1 %57, label %HashMap_find_slot_keyK_hashPtri32.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %38
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %59

59:                                               ; preds = %._crit_edge.thread.i, %.lr.ph.i
  %60 = phi i32 [ %48, %.lr.ph.i ], [ %102, %._crit_edge.thread.i ]
  %spec.store.select.i1599 = phi i32 [ -1, %.lr.ph.i ], [ %spec.store.select.i, %._crit_edge.thread.i ]
  %61 = phi ptr [ %54, %.lr.ph.i ], [ %107, %._crit_edge.thread.i ]
  %62 = phi ptr [ %53, %.lr.ph.i ], [ %106, %._crit_edge.thread.i ]
  %.sroa_idx.i1251 = getelementptr i8, ptr %62, i64 16
  %63 = load i64, ptr %.sroa_idx.i1251, align 4
  %64 = getelementptr i8, ptr %62, i64 8
  %65 = load i64, ptr %64, align 4
  %66 = inttoptr i64 %65 to ptr
  %67 = inttoptr i64 %63 to ptr
  %hash_coef_ptr.i.i56.i = getelementptr i8, ptr %61, i64 8
  %tbl_size_ptr.i.i57.i = getelementptr i8, ptr %61, i64 16
  %offset_tbl_ptr.i.i58.i = getelementptr i8, ptr %61, i64 40
  %hash_coef.i.i59.i = load i64, ptr %hash_coef_ptr.i.i56.i, align 4
  %tbl_size.i.i60.i = load i64, ptr %tbl_size_ptr.i.i57.i, align 4
  %offset_tbl.i.i61.i = load ptr, ptr %offset_tbl_ptr.i.i58.i, align 8
  %product.i.i.i62.i = mul i64 %hash_coef.i.i59.i, 4015701072841558310
  %shifted.i.i.i63.i = lshr i64 %product.i.i.i62.i, 32
  %xored.i.i.i64.i = xor i64 %shifted.i.i.i63.i, %product.i.i.i62.i
  %hash.i.i.i65.i = and i64 %xored.i.i.i64.i, %tbl_size.i.i60.i
  %offset_ptr.i.i66.i = getelementptr i32, ptr %offset_tbl.i.i61.i, i64 %hash.i.i.i65.i
  %offset.i.i67.i = load i32, ptr %offset_ptr.i.i66.i, align 4
  %68 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %61, 0
  %69 = insertvalue { ptr, ptr, ptr, i32 } %68, ptr %66, 1
  %70 = insertvalue { ptr, ptr, ptr, i32 } %69, ptr %67, 2
  %71 = insertvalue { ptr, ptr, ptr, i32 } %70, i32 %offset.i.i67.i, 3
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %61)
  %73 = sext i32 %offset.i.i67.i to i64
  %74 = getelementptr ptr, ptr %61, i64 %73
  %75 = getelementptr i8, ptr %74, i64 64
  %76 = load ptr, ptr %75, align 8
  %result.i.i = call ptr %76({ ptr, ptr, ptr, i32 } %71, ptr nocapture nofree noundef nonnull readonly %2) #16
  %77 = call i32 %result.i.i({ ptr, ptr, ptr, i32 } %71, { ptr, ptr, ptr, i32 } %71, ptr nonnull align 8 %2) #7
  %78 = icmp eq i32 %77, %45
  br i1 %78, label %._crit_edge.i1252, label %._crit_edge.thread.i

._crit_edge.i1252:                                ; preds = %59
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %61)
  %81 = getelementptr i8, ptr %74, i64 48
  %82 = load ptr, ptr %81, align 8
  %result.i69.i = call ptr %82({ ptr, ptr, ptr, i32 } %71, ptr nocapture nofree noundef nonnull readonly %2) #16
  %83 = call { ptr, i160 } %result.i69.i({ ptr, ptr, ptr, i32 } %71, { ptr, ptr, ptr, i32 } %71, ptr nonnull align 8 %2) #7
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %85 = load ptr, ptr %21, align 8
  %86 = call i1 %85({ ptr, i160 } %83, { ptr, i160 } %43) #7
  br i1 %86, label %HashMap_find_slot_keyK_hashPtri32.exit.loopexit, label %._crit_edge.thread.i

._crit_edge.thread.i:                             ; preds = %._crit_edge.i1252, %59
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %88 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %61)
  %89 = getelementptr i8, ptr %74, i64 56
  %90 = load ptr, ptr %89, align 8
  %result.i70.i = call ptr %90({ ptr, ptr, ptr, i32 } %71, ptr nocapture nofree noundef nonnull readonly %2) #16
  %91 = call { ptr, i160 } %result.i70.i({ ptr, ptr, ptr, i32 } %71, { ptr, ptr, ptr, i32 } %71, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i = extractvalue { ptr, i160 } %91, 0
  %92 = getelementptr i8, ptr %.fca.0.extract19.i, i64 8
  %93 = getelementptr i8, ptr %.fca.0.extract19.i, i64 16
  %94 = getelementptr i8, ptr %.fca.0.extract19.i, i64 24
  %95 = getelementptr i8, ptr %.fca.0.extract19.i, i64 32
  %96 = load i64, ptr %92, align 4
  %97 = load i64, ptr %93, align 4
  %98 = load ptr, ptr %94, align 8
  %99 = load ptr, ptr %95, align 8
  %result.i71.i = call i1 %98(i64 %97, i64 %96, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %99) #5
  %100 = icmp eq i32 %spec.store.select.i1599, -1
  %or.cond.i = select i1 %result.i71.i, i1 %100, i1 false
  %spec.store.select.i = select i1 %or.cond.i, i32 %60, i32 %spec.store.select.i1599
  %101 = add i32 %60, 1
  %102 = and i32 %101, %47
  %103 = load ptr, ptr %22, align 8
  %104 = sext i32 %102 to i64
  %105 = shl nsw i64 %104, 5
  %106 = getelementptr i8, ptr %103, i64 %105
  %107 = load ptr, ptr %106, align 8
  %108 = icmp eq ptr %107, @nil_typ
  %109 = icmp eq ptr %107, null
  %110 = or i1 %108, %109
  br i1 %110, label %._crit_edge105.loopexit.i, label %59

._crit_edge105.loopexit.i:                        ; preds = %._crit_edge.thread.i
  %111 = icmp eq i32 %spec.store.select.i, -1
  %.pre.i.pre = select i1 %111, i32 %102, i32 %spec.store.select.i
  br label %HashMap_find_slot_keyK_hashPtri32.exit

HashMap_find_slot_keyK_hashPtri32.exit.loopexit:  ; preds = %._crit_edge.i1252
  %.pre = load ptr, ptr %22, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit

HashMap_find_slot_keyK_hashPtri32.exit:           ; preds = %HashMap_find_slot_keyK_hashPtri32.exit.loopexit, %38, %._crit_edge105.loopexit.i
  %112 = phi ptr [ %103, %._crit_edge105.loopexit.i ], [ %50, %38 ], [ %.pre, %HashMap_find_slot_keyK_hashPtri32.exit.loopexit ]
  %113 = phi i32 [ %.pre.i.pre, %._crit_edge105.loopexit.i ], [ %48, %38 ], [ %60, %HashMap_find_slot_keyK_hashPtri32.exit.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %114 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %115 = sext i32 %113 to i64
  %116 = shl nsw i64 %115, 5
  %117 = getelementptr i8, ptr %112, i64 %116
  %118 = load ptr, ptr %117, align 8
  %119 = icmp ne ptr %118, @nil_typ
  %120 = icmp ne ptr %118, null
  %.not57.i = and i1 %119, %120
  br i1 %.not57.i, label %121, label %HashMap_get_keyK.exit.thread

121:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit
  %122 = getelementptr i8, ptr %117, i64 8
  %123 = load i64, ptr %122, align 4
  %.sroa_idx.i = getelementptr i8, ptr %117, i64 16
  %124 = load i64, ptr %.sroa_idx.i, align 4
  %125 = inttoptr i64 %123 to ptr
  %126 = inttoptr i64 %124 to ptr
  %hash_coef_ptr.i.i60.i = getelementptr i8, ptr %118, i64 8
  %tbl_size_ptr.i.i61.i = getelementptr i8, ptr %118, i64 16
  %offset_tbl_ptr.i.i62.i = getelementptr i8, ptr %118, i64 40
  %hash_coef.i.i63.i = load i64, ptr %hash_coef_ptr.i.i60.i, align 4, !noalias !115
  %tbl_size.i.i64.i = load i64, ptr %tbl_size_ptr.i.i61.i, align 4, !noalias !115
  %offset_tbl.i.i65.i = load ptr, ptr %offset_tbl_ptr.i.i62.i, align 8, !noalias !115
  %product.i.i.i66.i = mul i64 %hash_coef.i.i63.i, 4015701072841558310
  %shifted.i.i.i67.i = lshr i64 %product.i.i.i66.i, 32
  %xored.i.i.i68.i = xor i64 %shifted.i.i.i67.i, %product.i.i.i66.i
  %hash.i.i.i69.i = and i64 %xored.i.i.i68.i, %tbl_size.i.i64.i
  %offset_ptr.i.i70.i = getelementptr i32, ptr %offset_tbl.i.i65.i, i64 %hash.i.i.i69.i
  %offset.i.i71.i = load i32, ptr %offset_ptr.i.i70.i, align 4, !noalias !115
  %127 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %118, 0
  %128 = insertvalue { ptr, ptr, ptr, i32 } %127, ptr %125, 1
  %129 = insertvalue { ptr, ptr, ptr, i32 } %128, ptr %126, 2
  %130 = insertvalue { ptr, ptr, ptr, i32 } %129, i32 %offset.i.i71.i, 3
  %131 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %132 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %118)
  %133 = sext i32 %offset.i.i71.i to i64
  %134 = getelementptr ptr, ptr %118, i64 %133
  %135 = getelementptr i8, ptr %134, i64 56
  %136 = load ptr, ptr %135, align 8
  %result.i73.i = call ptr %136({ ptr, ptr, ptr, i32 } %130, ptr nocapture nofree noundef nonnull readonly %2) #16
  %137 = call { ptr, i160 } %result.i73.i({ ptr, ptr, ptr, i32 } %130, { ptr, ptr, ptr, i32 } %130, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i = extractvalue { ptr, i160 } %137, 0
  %138 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %139 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %118)
  %140 = getelementptr i8, ptr %134, i64 64
  %141 = load ptr, ptr %140, align 8
  %result.i74.i = call ptr %141({ ptr, ptr, ptr, i32 } %130, ptr nocapture nofree noundef nonnull readonly %2) #16
  %142 = call i32 %result.i74.i({ ptr, ptr, ptr, i32 } %130, { ptr, ptr, ptr, i32 } %130, ptr nonnull align 8 %2) #7
  %143 = icmp eq i32 %142, %45
  br i1 %143, label %._crit_edge.i, label %HashMap_get_keyK.exit.thread

._crit_edge.i:                                    ; preds = %121
  %144 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %145 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %118)
  %146 = getelementptr i8, ptr %134, i64 48
  %147 = load ptr, ptr %146, align 8
  %result.i75.i = call ptr %147({ ptr, ptr, ptr, i32 } %130, ptr nocapture nofree noundef nonnull readonly %2) #16
  %148 = call { ptr, i160 } %result.i75.i({ ptr, ptr, ptr, i32 } %130, { ptr, ptr, ptr, i32 } %130, ptr nonnull align 8 %2) #7
  %149 = load ptr, ptr %21, align 8
  %150 = call i1 %149({ ptr, i160 } %148, { ptr, i160 } %43) #7
  br i1 %150, label %HashMap_get_keyK.exit, label %HashMap_get_keyK.exit.thread

HashMap_get_keyK.exit.thread:                     ; preds = %HashMap_find_slot_keyK_hashPtri32.exit, %121, %._crit_edge.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %167

HashMap_get_keyK.exit:                            ; preds = %._crit_edge.i
  %151 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %152 = load ptr, ptr %15, align 8
  %153 = load ptr, ptr %152, align 8
  %154 = ptrtoint ptr %153 to i64
  %155 = getelementptr i8, ptr %.fca.0.extract51.i, i64 8
  %156 = getelementptr i8, ptr %.fca.0.extract51.i, i64 16
  %157 = getelementptr i8, ptr %.fca.0.extract51.i, i64 24
  %158 = getelementptr i8, ptr %.fca.0.extract51.i, i64 32
  %159 = load i64, ptr %155, align 4
  %160 = load i64, ptr %156, align 4
  %161 = load ptr, ptr %157, align 8
  %162 = load ptr, ptr %158, align 8
  %163 = load i64, ptr %153, align 4
  %result.i77.i = call i1 %161(i64 %160, i64 %159, i64 %163, i64 %154, ptr readonly %162) #5
  %cond.fr.i = freeze i1 %result.i77.i
  %spec.select.i = select i1 %cond.fr.i, ptr %.fca.0.extract51.i, ptr @nil_typ
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %164 = icmp eq ptr %spec.select.i, @nil_typ
  %165 = icmp eq ptr %spec.select.i, null
  %166 = or i1 %164, %165
  br i1 %166, label %167, label %._crit_edge1

167:                                              ; preds = %HashMap_get_keyK.exit.thread, %HashMap_get_keyK.exit
  %168 = add nuw i32 %42, 1
  %.sroa.0330.0.insert.ext = zext i32 %168 to i160
  %169 = load i32, ptr %30, align 8
  %170 = load i32, ptr %13, align 8
  %171 = icmp eq i32 %170, 0
  %172 = mul i32 %169, 10
  %173 = add i32 %172, 10
  %174 = mul i32 %170, 6
  %175 = icmp sge i32 %173, %174
  %.0.i1265 = select i1 %171, i1 true, i1 %175
  br i1 %.0.i1265, label %._crit_edge1.i1267, label %HashMap_ensure_capacity_required_loadPtri32.exit

._crit_edge1.i1267:                               ; preds = %167
  %176 = shl i32 %170, 1
  %spec.select.i1268 = call i32 @llvm.smax.i32(i32 %176, i32 16)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %177 = load ptr, ptr %12, align 8
  %178 = zext nneg i32 %spec.select.i1268 to i64
  %179 = shl nuw nsw i64 %178, 5
  %result.i.i1677 = call noalias ptr @bump_malloc_inner(i64 noundef %179, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1677, ptr %12, align 8
  store i32 %spec.select.i1268, ptr %13, align 8
  store i32 0, ptr %32, align 4
  %180 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #38
  store i32 0, ptr %30, align 8
  %181 = icmp sgt i32 %170, 0
  br i1 %181, label %.lr.ph.i1678, label %HashMap_resize_new_capacityPtri32.exit

.lr.ph.i1678:                                     ; preds = %._crit_edge1.i1267, %._crit_edge.i1679
  %.096.i = phi i32 [ %384, %._crit_edge.i1679 ], [ 0, %._crit_edge1.i1267 ]
  %182 = zext nneg i32 %.096.i to i64
  %183 = shl nuw nsw i64 %182, 5
  %184 = getelementptr i8, ptr %177, i64 %183
  %185 = load ptr, ptr %184, align 8
  %186 = icmp ne ptr %185, @nil_typ
  %187 = icmp ne ptr %185, null
  %.not40.i = and i1 %186, %187
  br i1 %.not40.i, label %188, label %._crit_edge.i1679

188:                                              ; preds = %.lr.ph.i1678
  %189 = getelementptr i8, ptr %184, i64 8
  %190 = load i64, ptr %189, align 4
  %.sroa_idx.i1680 = getelementptr i8, ptr %184, i64 16
  %191 = load i64, ptr %.sroa_idx.i1680, align 4
  %192 = inttoptr i64 %190 to ptr
  %193 = inttoptr i64 %191 to ptr
  %hash_coef_ptr.i.i42.i = getelementptr i8, ptr %185, i64 8
  %tbl_size_ptr.i.i43.i = getelementptr i8, ptr %185, i64 16
  %offset_tbl_ptr.i.i44.i = getelementptr i8, ptr %185, i64 40
  %hash_coef.i.i45.i = load i64, ptr %hash_coef_ptr.i.i42.i, align 4, !noalias !118
  %tbl_size.i.i46.i = load i64, ptr %tbl_size_ptr.i.i43.i, align 4, !noalias !118
  %offset_tbl.i.i47.i = load ptr, ptr %offset_tbl_ptr.i.i44.i, align 8, !noalias !118
  %product.i.i.i48.i = mul i64 %hash_coef.i.i45.i, 4015701072841558310
  %shifted.i.i.i49.i = lshr i64 %product.i.i.i48.i, 32
  %xored.i.i.i50.i = xor i64 %shifted.i.i.i49.i, %product.i.i.i48.i
  %hash.i.i.i51.i = and i64 %xored.i.i.i50.i, %tbl_size.i.i46.i
  %offset_ptr.i.i52.i = getelementptr i32, ptr %offset_tbl.i.i47.i, i64 %hash.i.i.i51.i
  %offset.i.i53.i = load i32, ptr %offset_ptr.i.i52.i, align 4, !noalias !118
  %194 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %185, 0
  %195 = insertvalue { ptr, ptr, ptr, i32 } %194, ptr %192, 1
  %196 = insertvalue { ptr, ptr, ptr, i32 } %195, ptr %193, 2
  %197 = insertvalue { ptr, ptr, ptr, i32 } %196, i32 %offset.i.i53.i, 3
  %198 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %199 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %185)
  %200 = sext i32 %offset.i.i53.i to i64
  %201 = getelementptr ptr, ptr %185, i64 %200
  %202 = getelementptr i8, ptr %201, i64 56
  %203 = load ptr, ptr %202, align 8
  %result.i55.i = call ptr %203({ ptr, ptr, ptr, i32 } %197, ptr nocapture nofree noundef nonnull readonly %2) #16
  %204 = call { ptr, i160 } %result.i55.i({ ptr, ptr, ptr, i32 } %197, { ptr, ptr, ptr, i32 } %197, ptr nonnull align 8 %2) #7
  %.fca.0.extract29.i = extractvalue { ptr, i160 } %204, 0
  %205 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %206 = load ptr, ptr %5, align 8
  %207 = load ptr, ptr %206, align 8
  %208 = ptrtoint ptr %207 to i64
  %209 = getelementptr i8, ptr %.fca.0.extract29.i, i64 8
  %210 = getelementptr i8, ptr %.fca.0.extract29.i, i64 16
  %211 = getelementptr i8, ptr %.fca.0.extract29.i, i64 24
  %212 = getelementptr i8, ptr %.fca.0.extract29.i, i64 32
  %213 = load i64, ptr %209, align 4
  %214 = load i64, ptr %210, align 4
  %215 = load ptr, ptr %211, align 8
  %216 = load ptr, ptr %212, align 8
  %217 = load i64, ptr %207, align 4
  %result.i57.i = call i1 %215(i64 %214, i64 %213, i64 %217, i64 %208, ptr readonly %216) #5
  br i1 %result.i57.i, label %218, label %._crit_edge.i1679

218:                                              ; preds = %188
  %219 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %220 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %185)
  %221 = getelementptr i8, ptr %201, i64 48
  %222 = load ptr, ptr %221, align 8
  %result.i58.i = call ptr %222({ ptr, ptr, ptr, i32 } %197, ptr nocapture nofree noundef nonnull readonly %2) #16
  %223 = call { ptr, i160 } %result.i58.i({ ptr, ptr, ptr, i32 } %197, { ptr, ptr, ptr, i32 } %197, ptr nonnull align 8 %2) #7
  %224 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %225 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %185)
  %226 = getelementptr i8, ptr %201, i64 64
  %227 = load ptr, ptr %226, align 8
  %result.i59.i = call ptr %227({ ptr, ptr, ptr, i32 } %197, ptr nocapture nofree noundef nonnull readonly %2) #16
  %228 = call i32 %result.i59.i({ ptr, ptr, ptr, i32 } %197, { ptr, ptr, ptr, i32 } %197, ptr nonnull align 8 %2) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %4)
  %229 = load ptr, ptr %result.i385, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %230 = load i32, ptr %13, align 8
  %231 = add i32 %230, -1
  %232 = and i32 %231, %228
  %233 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %234 = load ptr, ptr %12, align 8
  %235 = sext i32 %232 to i64
  %236 = shl nsw i64 %235, 5
  %237 = getelementptr i8, ptr %234, i64 %236
  %238 = load ptr, ptr %237, align 8
  %239 = icmp eq ptr %238, @nil_typ
  %240 = icmp eq ptr %238, null
  %241 = or i1 %239, %240
  br i1 %241, label %HashMap_find_slot_keyK_hashPtri32.exit2183, label %.lr.ph.i2159

.lr.ph.i2159:                                     ; preds = %218
  %242 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %243

243:                                              ; preds = %._crit_edge.thread.i2174, %.lr.ph.i2159
  %244 = phi i32 [ %232, %.lr.ph.i2159 ], [ %286, %._crit_edge.thread.i2174 ]
  %spec.store.select.i21792253 = phi i32 [ -1, %.lr.ph.i2159 ], [ %spec.store.select.i2179, %._crit_edge.thread.i2174 ]
  %245 = phi ptr [ %238, %.lr.ph.i2159 ], [ %291, %._crit_edge.thread.i2174 ]
  %246 = phi ptr [ %237, %.lr.ph.i2159 ], [ %290, %._crit_edge.thread.i2174 ]
  %.sroa_idx.i2160 = getelementptr i8, ptr %246, i64 16
  %247 = load i64, ptr %.sroa_idx.i2160, align 4
  %248 = getelementptr i8, ptr %246, i64 8
  %249 = load i64, ptr %248, align 4
  %250 = inttoptr i64 %249 to ptr
  %251 = inttoptr i64 %247 to ptr
  %hash_coef_ptr.i.i56.i2161 = getelementptr i8, ptr %245, i64 8
  %tbl_size_ptr.i.i57.i2162 = getelementptr i8, ptr %245, i64 16
  %offset_tbl_ptr.i.i58.i2163 = getelementptr i8, ptr %245, i64 40
  %hash_coef.i.i59.i2164 = load i64, ptr %hash_coef_ptr.i.i56.i2161, align 4
  %tbl_size.i.i60.i2165 = load i64, ptr %tbl_size_ptr.i.i57.i2162, align 4
  %offset_tbl.i.i61.i2166 = load ptr, ptr %offset_tbl_ptr.i.i58.i2163, align 8
  %product.i.i.i62.i2167 = mul i64 %hash_coef.i.i59.i2164, 4015701072841558310
  %shifted.i.i.i63.i2168 = lshr i64 %product.i.i.i62.i2167, 32
  %xored.i.i.i64.i2169 = xor i64 %shifted.i.i.i63.i2168, %product.i.i.i62.i2167
  %hash.i.i.i65.i2170 = and i64 %xored.i.i.i64.i2169, %tbl_size.i.i60.i2165
  %offset_ptr.i.i66.i2171 = getelementptr i32, ptr %offset_tbl.i.i61.i2166, i64 %hash.i.i.i65.i2170
  %offset.i.i67.i2172 = load i32, ptr %offset_ptr.i.i66.i2171, align 4
  %252 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %245, 0
  %253 = insertvalue { ptr, ptr, ptr, i32 } %252, ptr %250, 1
  %254 = insertvalue { ptr, ptr, ptr, i32 } %253, ptr %251, 2
  %255 = insertvalue { ptr, ptr, ptr, i32 } %254, i32 %offset.i.i67.i2172, 3
  %256 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %245)
  %257 = sext i32 %offset.i.i67.i2172 to i64
  %258 = getelementptr ptr, ptr %245, i64 %257
  %259 = getelementptr i8, ptr %258, i64 64
  %260 = load ptr, ptr %259, align 8
  %result.i.i2173 = call ptr %260({ ptr, ptr, ptr, i32 } %255, ptr nocapture nofree noundef nonnull readonly %2) #16
  %261 = call i32 %result.i.i2173({ ptr, ptr, ptr, i32 } %255, { ptr, ptr, ptr, i32 } %255, ptr nonnull align 8 %2) #7
  %262 = icmp eq i32 %261, %228
  br i1 %262, label %._crit_edge.i2181, label %._crit_edge.thread.i2174

._crit_edge.i2181:                                ; preds = %243
  %263 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %264 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %245)
  %265 = getelementptr i8, ptr %258, i64 48
  %266 = load ptr, ptr %265, align 8
  %result.i69.i2182 = call ptr %266({ ptr, ptr, ptr, i32 } %255, ptr nocapture nofree noundef nonnull readonly %2) #16
  %267 = call { ptr, i160 } %result.i69.i2182({ ptr, ptr, ptr, i32 } %255, { ptr, ptr, ptr, i32 } %255, ptr nonnull align 8 %2) #7
  %268 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %269 = load ptr, ptr %11, align 8
  %270 = call i1 %269({ ptr, i160 } %267, { ptr, i160 } %223) #7
  br i1 %270, label %HashMap_find_slot_keyK_hashPtri32.exit2183.loopexit, label %._crit_edge.thread.i2174

._crit_edge.thread.i2174:                         ; preds = %._crit_edge.i2181, %243
  %271 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %272 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %245)
  %273 = getelementptr i8, ptr %258, i64 56
  %274 = load ptr, ptr %273, align 8
  %result.i70.i2175 = call ptr %274({ ptr, ptr, ptr, i32 } %255, ptr nocapture nofree noundef nonnull readonly %2) #16
  %275 = call { ptr, i160 } %result.i70.i2175({ ptr, ptr, ptr, i32 } %255, { ptr, ptr, ptr, i32 } %255, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i2176 = extractvalue { ptr, i160 } %275, 0
  %276 = getelementptr i8, ptr %.fca.0.extract19.i2176, i64 8
  %277 = getelementptr i8, ptr %.fca.0.extract19.i2176, i64 16
  %278 = getelementptr i8, ptr %.fca.0.extract19.i2176, i64 24
  %279 = getelementptr i8, ptr %.fca.0.extract19.i2176, i64 32
  %280 = load i64, ptr %276, align 4
  %281 = load i64, ptr %277, align 4
  %282 = load ptr, ptr %278, align 8
  %283 = load ptr, ptr %279, align 8
  %result.i71.i2177 = call i1 %282(i64 %281, i64 %280, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %283) #5
  %284 = icmp eq i32 %spec.store.select.i21792253, -1
  %or.cond.i2178 = select i1 %result.i71.i2177, i1 %284, i1 false
  %spec.store.select.i2179 = select i1 %or.cond.i2178, i32 %244, i32 %spec.store.select.i21792253
  %285 = add i32 %244, 1
  %286 = and i32 %285, %231
  %287 = load ptr, ptr %12, align 8
  %288 = sext i32 %286 to i64
  %289 = shl nsw i64 %288, 5
  %290 = getelementptr i8, ptr %287, i64 %289
  %291 = load ptr, ptr %290, align 8
  %292 = icmp eq ptr %291, @nil_typ
  %293 = icmp eq ptr %291, null
  %294 = or i1 %292, %293
  br i1 %294, label %._crit_edge105.loopexit.i2180, label %243

._crit_edge105.loopexit.i2180:                    ; preds = %._crit_edge.thread.i2174
  %295 = icmp eq i32 %spec.store.select.i2179, -1
  %.pre.i.pre2296 = select i1 %295, i32 %286, i32 %spec.store.select.i2179
  br label %HashMap_find_slot_keyK_hashPtri32.exit2183

HashMap_find_slot_keyK_hashPtri32.exit2183.loopexit: ; preds = %._crit_edge.i2181
  %.pre2378 = load ptr, ptr %12, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit2183

HashMap_find_slot_keyK_hashPtri32.exit2183:       ; preds = %HashMap_find_slot_keyK_hashPtri32.exit2183.loopexit, %218, %._crit_edge105.loopexit.i2180
  %296 = phi ptr [ %287, %._crit_edge105.loopexit.i2180 ], [ %234, %218 ], [ %.pre2378, %HashMap_find_slot_keyK_hashPtri32.exit2183.loopexit ]
  %297 = phi i32 [ %.pre.i.pre2296, %._crit_edge105.loopexit.i2180 ], [ %232, %218 ], [ %244, %HashMap_find_slot_keyK_hashPtri32.exit2183.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %298 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %299 = sext i32 %297 to i64
  %300 = shl nsw i64 %299, 5
  %301 = getelementptr i8, ptr %296, i64 %300
  %302 = load ptr, ptr %301, align 8
  %303 = getelementptr i8, ptr %301, i64 8
  %304 = load i64, ptr %303, align 4
  %.sroa_idx.i1970 = getelementptr i8, ptr %301, i64 16
  %305 = load i64, ptr %.sroa_idx.i1970, align 4
  %306 = load ptr, ptr %5, align 8
  %307 = load ptr, ptr %229, align 8, !alias.scope !121
  %308 = getelementptr i8, ptr %307, i64 72
  %309 = load ptr, ptr %308, align 8, !alias.scope !121
  %result.i.i.i1972 = call { i64, i64 } %309(ptr nocapture nofree nonnull readonly %229) #5, !alias.scope !121
  %310 = extractvalue { i64, i64 } %result.i.i.i1972, 0
  %311 = extractvalue { i64, i64 } %result.i.i.i1972, 1
  %312 = call i64 @llvm.umax.i64(i64 %311, i64 8)
  %313 = urem i64 20, %311
  %314 = icmp eq i64 %313, 0
  %315 = sub i64 %311, %313
  %316 = select i1 %314, i64 0, i64 %315
  %317 = add i64 %310, 20
  %318 = add i64 %317, %316
  %319 = and i64 %318, 7
  %320 = icmp eq i64 %319, 0
  %321 = sub nuw nsw i64 40, %319
  %322 = select i1 %320, i64 32, i64 %321
  %323 = add i64 %322, %318
  %324 = urem i64 %323, %312
  %325 = icmp eq i64 %324, 0
  %326 = sub i64 %312, %324
  %327 = select i1 %325, i64 0, i64 %326
  %328 = add i64 %323, %327
  %result.i71.i1973 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %328, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %229, ptr %result.i71.i1973, align 8
  %329 = getelementptr inbounds i8, ptr %result.i71.i1973, i64 8
  store ptr %306, ptr %329, align 8
  %330 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i1973)
  %331 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %result.i71.i1973, 1
  %332 = insertvalue { ptr, ptr, ptr, i32 } %331, ptr undef, 2
  %333 = insertvalue { ptr, ptr, ptr, i32 } %332, i32 10, 3
  store ptr %229, ptr %4, align 8
  store ptr %306, ptr %34, align 8
  store ptr @_parameterization_Ptri32, ptr %35, align 8
  %334 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %4)
  %335 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Entry)
  %336 = load i64, ptr %209, align 4
  %337 = load i64, ptr %210, align 4
  %338 = load ptr, ptr %211, align 8
  %339 = load ptr, ptr %212, align 8
  %result.i.i117.i = call i1 %338(i64 %337, i64 %336, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %339) #5
  %340 = select i1 %result.i.i117.i, i64 9, i64 10
  %gep = getelementptr [14 x ptr], ptr getelementptr inbounds (i8, ptr @Entry, i64 80), i64 0, i64 %340
  %341 = load ptr, ptr %gep, align 8
  call void %341({ ptr, ptr, ptr, i32 } %333, { ptr, ptr, ptr, i32 } %333, ptr nonnull align 8 dereferenceable(24) %4, { ptr, i160 } %223, { ptr, i160 } %204, i32 %228) #7
  %342 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %343 = load ptr, ptr %12, align 8
  %344 = getelementptr i8, ptr %343, i64 %300
  store ptr @Entry, ptr %344, align 8
  %345 = getelementptr i8, ptr %344, i64 8
  %346 = ptrtoint ptr %result.i71.i1973 to i64
  store i64 %346, ptr %345, align 4
  %.sroa_idx4.i1974 = getelementptr i8, ptr %344, i64 24
  store i32 10, ptr %.sroa_idx4.i1974, align 4
  %347 = icmp eq ptr %302, @nil_typ
  %348 = icmp eq ptr %302, null
  %349 = or i1 %347, %348
  br i1 %349, label %350, label %353

350:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit2183
  %351 = load i32, ptr %32, align 4
  %352 = add i32 %351, 1
  store i32 %352, ptr %32, align 4
  br label %._crit_edge.sink.split.i1991

353:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit2183
  %354 = inttoptr i64 %304 to ptr
  %355 = inttoptr i64 %305 to ptr
  %hash_coef_ptr.i.i88.i1975 = getelementptr i8, ptr %302, i64 8
  %tbl_size_ptr.i.i89.i1976 = getelementptr i8, ptr %302, i64 16
  %offset_tbl_ptr.i.i90.i1977 = getelementptr i8, ptr %302, i64 40
  %hash_coef.i.i91.i1978 = load i64, ptr %hash_coef_ptr.i.i88.i1975, align 4, !noalias !124
  %tbl_size.i.i92.i1979 = load i64, ptr %tbl_size_ptr.i.i89.i1976, align 4, !noalias !124
  %offset_tbl.i.i93.i1980 = load ptr, ptr %offset_tbl_ptr.i.i90.i1977, align 8, !noalias !124
  %product.i.i.i94.i1981 = mul i64 %hash_coef.i.i91.i1978, 4015701072841558310
  %shifted.i.i.i95.i1982 = lshr i64 %product.i.i.i94.i1981, 32
  %xored.i.i.i96.i1983 = xor i64 %shifted.i.i.i95.i1982, %product.i.i.i94.i1981
  %hash.i.i.i97.i1984 = and i64 %xored.i.i.i96.i1983, %tbl_size.i.i92.i1979
  %offset_ptr.i.i98.i1985 = getelementptr i32, ptr %offset_tbl.i.i93.i1980, i64 %hash.i.i.i97.i1984
  %offset.i.i99.i1986 = load i32, ptr %offset_ptr.i.i98.i1985, align 4, !noalias !124
  %356 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %302, 0
  %357 = insertvalue { ptr, ptr, ptr, i32 } %356, ptr %354, 1
  %358 = insertvalue { ptr, ptr, ptr, i32 } %357, ptr %355, 2
  %359 = insertvalue { ptr, ptr, ptr, i32 } %358, i32 %offset.i.i99.i1986, 3
  %360 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %361 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %302)
  %362 = sext i32 %offset.i.i99.i1986 to i64
  %363 = getelementptr ptr, ptr %302, i64 %362
  %364 = getelementptr i8, ptr %363, i64 56
  %365 = load ptr, ptr %364, align 8
  %result.i101.i1987 = call ptr %365({ ptr, ptr, ptr, i32 } %359, ptr nocapture nofree noundef nonnull readonly %2) #16
  %366 = call { ptr, i160 } %result.i101.i1987({ ptr, ptr, ptr, i32 } %359, { ptr, ptr, ptr, i32 } %359, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i1988 = extractvalue { ptr, i160 } %366, 0
  %367 = getelementptr i8, ptr %.fca.0.extract51.i1988, i64 8
  %368 = getelementptr i8, ptr %.fca.0.extract51.i1988, i64 16
  %369 = getelementptr i8, ptr %.fca.0.extract51.i1988, i64 24
  %370 = getelementptr i8, ptr %.fca.0.extract51.i1988, i64 32
  %371 = load i64, ptr %367, align 4
  %372 = load i64, ptr %368, align 4
  %373 = load ptr, ptr %369, align 8
  %374 = load ptr, ptr %370, align 8
  %result.i102.i1989 = call i1 %373(i64 %372, i64 %371, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %374) #5
  br i1 %result.i102.i1989, label %._crit_edge.sink.split.i1991, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1993

._crit_edge.sink.split.i1991:                     ; preds = %353, %350
  %.sink159.i1992 = phi i64 [ 48, %350 ], [ 40, %353 ]
  %375 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %376 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i1992
  %377 = load ptr, ptr %376, align 8
  %378 = load ptr, ptr %377, align 8
  %379 = call i32 %378(ptr nonnull %result.i385) #36
  %380 = add i32 %379, 1
  %381 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %382 = getelementptr i8, ptr %377, i64 8
  %383 = load ptr, ptr %382, align 8
  call void %383(ptr nonnull %result.i385, i32 %380) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1993

HashMap_insert_internal_keyK_valueV_hashPtri32.exit1993: ; preds = %353, %._crit_edge.sink.split.i1991
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %4)
  br label %._crit_edge.i1679

._crit_edge.i1679:                                ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1993, %188, %.lr.ph.i1678
  %384 = add nuw nsw i32 %.096.i, 1
  %385 = icmp slt i32 %384, %170
  br i1 %385, label %.lr.ph.i1678, label %HashMap_resize_new_capacityPtri32.exit

HashMap_resize_new_capacityPtri32.exit:           ; preds = %._crit_edge.i1679, %._crit_edge1.i1267
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_ensure_capacity_required_loadPtri32.exit

HashMap_ensure_capacity_required_loadPtri32.exit: ; preds = %167, %HashMap_resize_new_capacityPtri32.exit
  %386 = load ptr, ptr %10, align 8
  %387 = call i32 %386({ ptr, i160 } %43) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %388 = load ptr, ptr %result.i385, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %389 = load i32, ptr %13, align 8
  %390 = add i32 %389, -1
  %391 = and i32 %390, %387
  %392 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %393 = load ptr, ptr %12, align 8
  %394 = sext i32 %391 to i64
  %395 = shl nsw i64 %394, 5
  %396 = getelementptr i8, ptr %393, i64 %395
  %397 = load ptr, ptr %396, align 8
  %398 = icmp eq ptr %397, @nil_typ
  %399 = icmp eq ptr %397, null
  %400 = or i1 %398, %399
  br i1 %400, label %HashMap_find_slot_keyK_hashPtri32.exit1717, label %.lr.ph.i1693

.lr.ph.i1693:                                     ; preds = %HashMap_ensure_capacity_required_loadPtri32.exit
  %401 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %402

402:                                              ; preds = %._crit_edge.thread.i1708, %.lr.ph.i1693
  %403 = phi i32 [ %391, %.lr.ph.i1693 ], [ %445, %._crit_edge.thread.i1708 ]
  %spec.store.select.i17131847 = phi i32 [ -1, %.lr.ph.i1693 ], [ %spec.store.select.i1713, %._crit_edge.thread.i1708 ]
  %404 = phi ptr [ %397, %.lr.ph.i1693 ], [ %450, %._crit_edge.thread.i1708 ]
  %405 = phi ptr [ %396, %.lr.ph.i1693 ], [ %449, %._crit_edge.thread.i1708 ]
  %.sroa_idx.i1694 = getelementptr i8, ptr %405, i64 16
  %406 = load i64, ptr %.sroa_idx.i1694, align 4
  %407 = getelementptr i8, ptr %405, i64 8
  %408 = load i64, ptr %407, align 4
  %409 = inttoptr i64 %408 to ptr
  %410 = inttoptr i64 %406 to ptr
  %hash_coef_ptr.i.i56.i1695 = getelementptr i8, ptr %404, i64 8
  %tbl_size_ptr.i.i57.i1696 = getelementptr i8, ptr %404, i64 16
  %offset_tbl_ptr.i.i58.i1697 = getelementptr i8, ptr %404, i64 40
  %hash_coef.i.i59.i1698 = load i64, ptr %hash_coef_ptr.i.i56.i1695, align 4
  %tbl_size.i.i60.i1699 = load i64, ptr %tbl_size_ptr.i.i57.i1696, align 4
  %offset_tbl.i.i61.i1700 = load ptr, ptr %offset_tbl_ptr.i.i58.i1697, align 8
  %product.i.i.i62.i1701 = mul i64 %hash_coef.i.i59.i1698, 4015701072841558310
  %shifted.i.i.i63.i1702 = lshr i64 %product.i.i.i62.i1701, 32
  %xored.i.i.i64.i1703 = xor i64 %shifted.i.i.i63.i1702, %product.i.i.i62.i1701
  %hash.i.i.i65.i1704 = and i64 %xored.i.i.i64.i1703, %tbl_size.i.i60.i1699
  %offset_ptr.i.i66.i1705 = getelementptr i32, ptr %offset_tbl.i.i61.i1700, i64 %hash.i.i.i65.i1704
  %offset.i.i67.i1706 = load i32, ptr %offset_ptr.i.i66.i1705, align 4
  %411 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %404, 0
  %412 = insertvalue { ptr, ptr, ptr, i32 } %411, ptr %409, 1
  %413 = insertvalue { ptr, ptr, ptr, i32 } %412, ptr %410, 2
  %414 = insertvalue { ptr, ptr, ptr, i32 } %413, i32 %offset.i.i67.i1706, 3
  %415 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %404)
  %416 = sext i32 %offset.i.i67.i1706 to i64
  %417 = getelementptr ptr, ptr %404, i64 %416
  %418 = getelementptr i8, ptr %417, i64 64
  %419 = load ptr, ptr %418, align 8
  %result.i.i1707 = call ptr %419({ ptr, ptr, ptr, i32 } %414, ptr nocapture nofree noundef nonnull readonly %2) #16
  %420 = call i32 %result.i.i1707({ ptr, ptr, ptr, i32 } %414, { ptr, ptr, ptr, i32 } %414, ptr nonnull align 8 %2) #7
  %421 = icmp eq i32 %420, %387
  br i1 %421, label %._crit_edge.i1715, label %._crit_edge.thread.i1708

._crit_edge.i1715:                                ; preds = %402
  %422 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %423 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %404)
  %424 = getelementptr i8, ptr %417, i64 48
  %425 = load ptr, ptr %424, align 8
  %result.i69.i1716 = call ptr %425({ ptr, ptr, ptr, i32 } %414, ptr nocapture nofree noundef nonnull readonly %2) #16
  %426 = call { ptr, i160 } %result.i69.i1716({ ptr, ptr, ptr, i32 } %414, { ptr, ptr, ptr, i32 } %414, ptr nonnull align 8 %2) #7
  %427 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %428 = load ptr, ptr %11, align 8
  %429 = call i1 %428({ ptr, i160 } %426, { ptr, i160 } %43) #7
  br i1 %429, label %HashMap_find_slot_keyK_hashPtri32.exit1717.loopexit, label %._crit_edge.thread.i1708

._crit_edge.thread.i1708:                         ; preds = %._crit_edge.i1715, %402
  %430 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %431 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %404)
  %432 = getelementptr i8, ptr %417, i64 56
  %433 = load ptr, ptr %432, align 8
  %result.i70.i1709 = call ptr %433({ ptr, ptr, ptr, i32 } %414, ptr nocapture nofree noundef nonnull readonly %2) #16
  %434 = call { ptr, i160 } %result.i70.i1709({ ptr, ptr, ptr, i32 } %414, { ptr, ptr, ptr, i32 } %414, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i1710 = extractvalue { ptr, i160 } %434, 0
  %435 = getelementptr i8, ptr %.fca.0.extract19.i1710, i64 8
  %436 = getelementptr i8, ptr %.fca.0.extract19.i1710, i64 16
  %437 = getelementptr i8, ptr %.fca.0.extract19.i1710, i64 24
  %438 = getelementptr i8, ptr %.fca.0.extract19.i1710, i64 32
  %439 = load i64, ptr %435, align 4
  %440 = load i64, ptr %436, align 4
  %441 = load ptr, ptr %437, align 8
  %442 = load ptr, ptr %438, align 8
  %result.i71.i1711 = call i1 %441(i64 %440, i64 %439, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %442) #5
  %443 = icmp eq i32 %spec.store.select.i17131847, -1
  %or.cond.i1712 = select i1 %result.i71.i1711, i1 %443, i1 false
  %spec.store.select.i1713 = select i1 %or.cond.i1712, i32 %403, i32 %spec.store.select.i17131847
  %444 = add i32 %403, 1
  %445 = and i32 %444, %390
  %446 = load ptr, ptr %12, align 8
  %447 = sext i32 %445 to i64
  %448 = shl nsw i64 %447, 5
  %449 = getelementptr i8, ptr %446, i64 %448
  %450 = load ptr, ptr %449, align 8
  %451 = icmp eq ptr %450, @nil_typ
  %452 = icmp eq ptr %450, null
  %453 = or i1 %451, %452
  br i1 %453, label %._crit_edge105.loopexit.i1714, label %402

._crit_edge105.loopexit.i1714:                    ; preds = %._crit_edge.thread.i1708
  %454 = icmp eq i32 %spec.store.select.i1713, -1
  %.pre.i.pre1881 = select i1 %454, i32 %445, i32 %spec.store.select.i1713
  br label %HashMap_find_slot_keyK_hashPtri32.exit1717

HashMap_find_slot_keyK_hashPtri32.exit1717.loopexit: ; preds = %._crit_edge.i1715
  %.pre1948 = load ptr, ptr %12, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit1717

HashMap_find_slot_keyK_hashPtri32.exit1717:       ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1717.loopexit, %HashMap_ensure_capacity_required_loadPtri32.exit, %._crit_edge105.loopexit.i1714
  %455 = phi ptr [ %446, %._crit_edge105.loopexit.i1714 ], [ %393, %HashMap_ensure_capacity_required_loadPtri32.exit ], [ %.pre1948, %HashMap_find_slot_keyK_hashPtri32.exit1717.loopexit ]
  %456 = phi i32 [ %.pre.i.pre1881, %._crit_edge105.loopexit.i1714 ], [ %391, %HashMap_ensure_capacity_required_loadPtri32.exit ], [ %403, %HashMap_find_slot_keyK_hashPtri32.exit1717.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %457 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %458 = sext i32 %456 to i64
  %459 = shl nsw i64 %458, 5
  %460 = getelementptr i8, ptr %455, i64 %459
  %461 = load ptr, ptr %460, align 8
  %462 = getelementptr i8, ptr %460, i64 8
  %463 = load i64, ptr %462, align 4
  %.sroa_idx.i1284 = getelementptr i8, ptr %460, i64 16
  %464 = load i64, ptr %.sroa_idx.i1284, align 4
  %465 = load ptr, ptr %5, align 8
  %466 = load ptr, ptr %388, align 8, !alias.scope !127
  %467 = getelementptr i8, ptr %466, i64 72
  %468 = load ptr, ptr %467, align 8, !alias.scope !127
  %result.i.i.i = call { i64, i64 } %468(ptr nocapture nofree nonnull readonly %388) #5, !alias.scope !127
  %469 = extractvalue { i64, i64 } %result.i.i.i, 0
  %470 = extractvalue { i64, i64 } %result.i.i.i, 1
  %471 = call i64 @llvm.umax.i64(i64 %470, i64 8)
  %472 = urem i64 20, %470
  %473 = icmp eq i64 %472, 0
  %474 = sub i64 %470, %472
  %475 = select i1 %473, i64 0, i64 %474
  %476 = add i64 %469, 20
  %477 = add i64 %476, %475
  %478 = and i64 %477, 7
  %479 = icmp eq i64 %478, 0
  %480 = sub nuw nsw i64 40, %478
  %481 = select i1 %479, i64 32, i64 %480
  %482 = add i64 %481, %477
  %483 = urem i64 %482, %471
  %484 = icmp eq i64 %483, 0
  %485 = sub i64 %471, %483
  %486 = select i1 %484, i64 0, i64 %485
  %487 = add i64 %482, %486
  %result.i71.i1286 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %487, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %388, ptr %result.i71.i1286, align 8
  %488 = getelementptr inbounds i8, ptr %result.i71.i1286, i64 8
  store ptr %465, ptr %488, align 8
  %489 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i1286)
  %490 = load ptr, ptr %388, align 8
  %491 = getelementptr i8, ptr %490, i64 72
  %492 = load ptr, ptr %491, align 8
  %result.i.i1904 = call { i64, i64 } %492(ptr nocapture nofree nonnull readonly %388) #5
  %493 = extractvalue { i64, i64 } %result.i.i1904, 1
  %494 = urem i64 20, %493
  %495 = icmp eq i64 %494, 0
  %reass.sub2352 = sub i64 %493, %494
  %496 = add i64 %reass.sub2352, 20
  %497 = select i1 %495, i64 20, i64 %496
  %498 = getelementptr i8, ptr %result.i71.i1286, i64 %497
  %499 = getelementptr i8, ptr %490, i64 64
  %500 = load ptr, ptr %499, align 8
  call void %500({ ptr, i160 } %43, ptr nocapture nofree nonnull readonly %388, ptr nocapture nofree writeonly %498) #13
  %501 = load ptr, ptr %result.i71.i1286, align 8
  %502 = load ptr, ptr %501, align 8
  %503 = getelementptr i8, ptr %502, i64 72
  %504 = load ptr, ptr %503, align 8
  %result.i.i1905 = call { i64, i64 } %504(ptr nocapture nofree nonnull readonly %501) #5
  %505 = extractvalue { i64, i64 } %result.i.i1905, 0
  %506 = extractvalue { i64, i64 } %result.i.i1905, 1
  %507 = urem i64 20, %506
  %508 = icmp eq i64 %507, 0
  %509 = sub i64 %506, %507
  %510 = select i1 %508, i64 0, i64 %509
  %511 = add i64 %505, 20
  %512 = add i64 %511, %510
  %513 = and i64 %512, 7
  %514 = icmp eq i64 %513, 0
  %515 = sub nuw nsw i64 8, %513
  %516 = select i1 %514, i64 0, i64 %515
  %517 = getelementptr i8, ptr %result.i71.i1286, i64 %512
  %518 = getelementptr i8, ptr %517, i64 %516
  store ptr @i32_typ, ptr %518, align 8
  %519 = getelementptr i8, ptr %518, i64 8
  store i160 %.sroa.0330.0.insert.ext, ptr %519, align 4
  %520 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @Entry) #34
  %521 = getelementptr inbounds i8, ptr %result.i71.i1286, i64 16
  store i32 %387, ptr %521, align 8
  %522 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  store ptr @Entry, ptr %460, align 8
  %523 = ptrtoint ptr %result.i71.i1286 to i64
  store i64 %523, ptr %462, align 4
  %.sroa_idx4.i = getelementptr i8, ptr %460, i64 24
  store i32 10, ptr %.sroa_idx4.i, align 4
  %524 = icmp eq ptr %461, @nil_typ
  %525 = icmp eq ptr %461, null
  %526 = or i1 %524, %525
  br i1 %526, label %527, label %530

527:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1717
  %528 = load i32, ptr %32, align 4
  %529 = add i32 %528, 1
  store i32 %529, ptr %32, align 4
  br label %._crit_edge.sink.split.i

530:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1717
  %531 = inttoptr i64 %463 to ptr
  %532 = inttoptr i64 %464 to ptr
  %hash_coef_ptr.i.i88.i = getelementptr i8, ptr %461, i64 8
  %tbl_size_ptr.i.i89.i = getelementptr i8, ptr %461, i64 16
  %offset_tbl_ptr.i.i90.i = getelementptr i8, ptr %461, i64 40
  %hash_coef.i.i91.i = load i64, ptr %hash_coef_ptr.i.i88.i, align 4, !noalias !130
  %tbl_size.i.i92.i = load i64, ptr %tbl_size_ptr.i.i89.i, align 4, !noalias !130
  %offset_tbl.i.i93.i = load ptr, ptr %offset_tbl_ptr.i.i90.i, align 8, !noalias !130
  %product.i.i.i94.i = mul i64 %hash_coef.i.i91.i, 4015701072841558310
  %shifted.i.i.i95.i = lshr i64 %product.i.i.i94.i, 32
  %xored.i.i.i96.i = xor i64 %shifted.i.i.i95.i, %product.i.i.i94.i
  %hash.i.i.i97.i = and i64 %xored.i.i.i96.i, %tbl_size.i.i92.i
  %offset_ptr.i.i98.i = getelementptr i32, ptr %offset_tbl.i.i93.i, i64 %hash.i.i.i97.i
  %offset.i.i99.i = load i32, ptr %offset_ptr.i.i98.i, align 4, !noalias !130
  %533 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %461, 0
  %534 = insertvalue { ptr, ptr, ptr, i32 } %533, ptr %531, 1
  %535 = insertvalue { ptr, ptr, ptr, i32 } %534, ptr %532, 2
  %536 = insertvalue { ptr, ptr, ptr, i32 } %535, i32 %offset.i.i99.i, 3
  %537 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %538 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %461)
  %539 = sext i32 %offset.i.i99.i to i64
  %540 = getelementptr ptr, ptr %461, i64 %539
  %541 = getelementptr i8, ptr %540, i64 56
  %542 = load ptr, ptr %541, align 8
  %result.i101.i = call ptr %542({ ptr, ptr, ptr, i32 } %536, ptr nocapture nofree noundef nonnull readonly %2) #16
  %543 = call { ptr, i160 } %result.i101.i({ ptr, ptr, ptr, i32 } %536, { ptr, ptr, ptr, i32 } %536, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i1288 = extractvalue { ptr, i160 } %543, 0
  %544 = getelementptr i8, ptr %.fca.0.extract51.i1288, i64 8
  %545 = getelementptr i8, ptr %.fca.0.extract51.i1288, i64 16
  %546 = getelementptr i8, ptr %.fca.0.extract51.i1288, i64 24
  %547 = getelementptr i8, ptr %.fca.0.extract51.i1288, i64 32
  %548 = load i64, ptr %544, align 4
  %549 = load i64, ptr %545, align 4
  %550 = load ptr, ptr %546, align 8
  %551 = load ptr, ptr %547, align 8
  %result.i102.i = call i1 %550(i64 %549, i64 %548, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %551) #5
  br i1 %result.i102.i, label %._crit_edge.sink.split.i, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit

._crit_edge.sink.split.i:                         ; preds = %530, %527
  %.sink159.i = phi i64 [ 48, %527 ], [ 40, %530 ]
  %552 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %553 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i
  %554 = load ptr, ptr %553, align 8
  %555 = load ptr, ptr %554, align 8
  %556 = call i32 %555(ptr nonnull %result.i385) #36
  %557 = add i32 %556, 1
  %558 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %559 = getelementptr i8, ptr %554, i64 8
  %560 = load ptr, ptr %559, align 8
  call void %560(ptr nonnull %result.i385, i32 %557) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit

HashMap_insert_internal_keyK_valueV_hashPtri32.exit: ; preds = %530, %._crit_edge.sink.split.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  store i1 true, ptr %.sroa.0323.sroa.0, align 8
  %.sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.0. = load i8, ptr %.sroa.0323.sroa.0, align 8
  %.sroa.0323.0.insert.ext = zext i8 %.sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.sroa.0.0..sroa.0323.0. to i160
  %561 = load i32, ptr %31, align 8
  %562 = load i32, ptr %23, align 8
  %563 = icmp eq i32 %562, 0
  %564 = mul i32 %561, 10
  %565 = add i32 %564, 10
  %566 = mul i32 %562, 6
  %567 = icmp sge i32 %565, %566
  %.0.i1303 = select i1 %563, i1 true, i1 %567
  br i1 %.0.i1303, label %._crit_edge1.i1305, label %HashMap_ensure_capacity_required_loadPtri32.exit1309

._crit_edge1.i1305:                               ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit
  %568 = shl i32 %562, 1
  %spec.select.i1307 = call i32 @llvm.smax.i32(i32 %568, i32 16)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %569 = load ptr, ptr %22, align 8
  %570 = zext nneg i32 %spec.select.i1307 to i64
  %571 = shl nuw nsw i64 %570, 5
  %result.i.i1745 = call noalias ptr @bump_malloc_inner(i64 noundef %571, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1745, ptr %22, align 8
  store i32 %spec.select.i1307, ptr %23, align 8
  store i32 0, ptr %33, align 4
  %572 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #38
  store i32 0, ptr %31, align 8
  %573 = icmp sgt i32 %562, 0
  br i1 %573, label %.lr.ph.i1746, label %HashMap_resize_new_capacityPtri32.exit1772

.lr.ph.i1746:                                     ; preds = %._crit_edge1.i1305, %._crit_edge.i1749
  %.096.i1747 = phi i32 [ %776, %._crit_edge.i1749 ], [ 0, %._crit_edge1.i1305 ]
  %574 = zext nneg i32 %.096.i1747 to i64
  %575 = shl nuw nsw i64 %574, 5
  %576 = getelementptr i8, ptr %569, i64 %575
  %577 = load ptr, ptr %576, align 8
  %578 = icmp ne ptr %577, @nil_typ
  %579 = icmp ne ptr %577, null
  %.not40.i1748 = and i1 %578, %579
  br i1 %.not40.i1748, label %580, label %._crit_edge.i1749

580:                                              ; preds = %.lr.ph.i1746
  %581 = getelementptr i8, ptr %576, i64 8
  %582 = load i64, ptr %581, align 4
  %.sroa_idx.i1750 = getelementptr i8, ptr %576, i64 16
  %583 = load i64, ptr %.sroa_idx.i1750, align 4
  %584 = inttoptr i64 %582 to ptr
  %585 = inttoptr i64 %583 to ptr
  %hash_coef_ptr.i.i42.i1751 = getelementptr i8, ptr %577, i64 8
  %tbl_size_ptr.i.i43.i1752 = getelementptr i8, ptr %577, i64 16
  %offset_tbl_ptr.i.i44.i1753 = getelementptr i8, ptr %577, i64 40
  %hash_coef.i.i45.i1754 = load i64, ptr %hash_coef_ptr.i.i42.i1751, align 4, !noalias !133
  %tbl_size.i.i46.i1755 = load i64, ptr %tbl_size_ptr.i.i43.i1752, align 4, !noalias !133
  %offset_tbl.i.i47.i1756 = load ptr, ptr %offset_tbl_ptr.i.i44.i1753, align 8, !noalias !133
  %product.i.i.i48.i1757 = mul i64 %hash_coef.i.i45.i1754, 4015701072841558310
  %shifted.i.i.i49.i1758 = lshr i64 %product.i.i.i48.i1757, 32
  %xored.i.i.i50.i1759 = xor i64 %shifted.i.i.i49.i1758, %product.i.i.i48.i1757
  %hash.i.i.i51.i1760 = and i64 %xored.i.i.i50.i1759, %tbl_size.i.i46.i1755
  %offset_ptr.i.i52.i1761 = getelementptr i32, ptr %offset_tbl.i.i47.i1756, i64 %hash.i.i.i51.i1760
  %offset.i.i53.i1762 = load i32, ptr %offset_ptr.i.i52.i1761, align 4, !noalias !133
  %586 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %577, 0
  %587 = insertvalue { ptr, ptr, ptr, i32 } %586, ptr %584, 1
  %588 = insertvalue { ptr, ptr, ptr, i32 } %587, ptr %585, 2
  %589 = insertvalue { ptr, ptr, ptr, i32 } %588, i32 %offset.i.i53.i1762, 3
  %590 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %591 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %577)
  %592 = sext i32 %offset.i.i53.i1762 to i64
  %593 = getelementptr ptr, ptr %577, i64 %592
  %594 = getelementptr i8, ptr %593, i64 56
  %595 = load ptr, ptr %594, align 8
  %result.i55.i1763 = call ptr %595({ ptr, ptr, ptr, i32 } %589, ptr nocapture nofree noundef nonnull readonly %2) #16
  %596 = call { ptr, i160 } %result.i55.i1763({ ptr, ptr, ptr, i32 } %589, { ptr, ptr, ptr, i32 } %589, ptr nonnull align 8 %2) #7
  %.fca.0.extract29.i1764 = extractvalue { ptr, i160 } %596, 0
  %597 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %598 = load ptr, ptr %15, align 8
  %599 = load ptr, ptr %598, align 8
  %600 = ptrtoint ptr %599 to i64
  %601 = getelementptr i8, ptr %.fca.0.extract29.i1764, i64 8
  %602 = getelementptr i8, ptr %.fca.0.extract29.i1764, i64 16
  %603 = getelementptr i8, ptr %.fca.0.extract29.i1764, i64 24
  %604 = getelementptr i8, ptr %.fca.0.extract29.i1764, i64 32
  %605 = load i64, ptr %601, align 4
  %606 = load i64, ptr %602, align 4
  %607 = load ptr, ptr %603, align 8
  %608 = load ptr, ptr %604, align 8
  %609 = load i64, ptr %599, align 4
  %result.i57.i1766 = call i1 %607(i64 %606, i64 %605, i64 %609, i64 %600, ptr readonly %608) #5
  br i1 %result.i57.i1766, label %610, label %._crit_edge.i1749

610:                                              ; preds = %580
  %611 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %612 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %577)
  %613 = getelementptr i8, ptr %593, i64 48
  %614 = load ptr, ptr %613, align 8
  %result.i58.i1767 = call ptr %614({ ptr, ptr, ptr, i32 } %589, ptr nocapture nofree noundef nonnull readonly %2) #16
  %615 = call { ptr, i160 } %result.i58.i1767({ ptr, ptr, ptr, i32 } %589, { ptr, ptr, ptr, i32 } %589, ptr nonnull align 8 %2) #7
  %616 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %617 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %577)
  %618 = getelementptr i8, ptr %593, i64 64
  %619 = load ptr, ptr %618, align 8
  %result.i59.i1769 = call ptr %619({ ptr, ptr, ptr, i32 } %589, ptr nocapture nofree noundef nonnull readonly %2) #16
  %620 = call i32 %result.i59.i1769({ ptr, ptr, ptr, i32 } %589, { ptr, ptr, ptr, i32 } %589, ptr nonnull align 8 %2) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %3)
  %621 = load ptr, ptr %result.i428, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %622 = load i32, ptr %23, align 8
  %623 = add i32 %622, -1
  %624 = and i32 %623, %620
  %625 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %626 = load ptr, ptr %22, align 8
  %627 = sext i32 %624 to i64
  %628 = shl nsw i64 %627, 5
  %629 = getelementptr i8, ptr %626, i64 %628
  %630 = load ptr, ptr %629, align 8
  %631 = icmp eq ptr %630, @nil_typ
  %632 = icmp eq ptr %630, null
  %633 = or i1 %631, %632
  br i1 %633, label %HashMap_find_slot_keyK_hashPtri32.exit2228, label %.lr.ph.i2198

.lr.ph.i2198:                                     ; preds = %610
  %634 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %635

635:                                              ; preds = %._crit_edge.thread.i2214, %.lr.ph.i2198
  %636 = phi i32 [ %624, %.lr.ph.i2198 ], [ %678, %._crit_edge.thread.i2214 ]
  %spec.store.select.i22192259 = phi i32 [ -1, %.lr.ph.i2198 ], [ %spec.store.select.i2219, %._crit_edge.thread.i2214 ]
  %637 = phi ptr [ %630, %.lr.ph.i2198 ], [ %683, %._crit_edge.thread.i2214 ]
  %638 = phi ptr [ %629, %.lr.ph.i2198 ], [ %682, %._crit_edge.thread.i2214 ]
  %.sroa_idx.i2200 = getelementptr i8, ptr %638, i64 16
  %639 = load i64, ptr %.sroa_idx.i2200, align 4
  %640 = getelementptr i8, ptr %638, i64 8
  %641 = load i64, ptr %640, align 4
  %642 = inttoptr i64 %641 to ptr
  %643 = inttoptr i64 %639 to ptr
  %hash_coef_ptr.i.i56.i2201 = getelementptr i8, ptr %637, i64 8
  %tbl_size_ptr.i.i57.i2202 = getelementptr i8, ptr %637, i64 16
  %offset_tbl_ptr.i.i58.i2203 = getelementptr i8, ptr %637, i64 40
  %hash_coef.i.i59.i2204 = load i64, ptr %hash_coef_ptr.i.i56.i2201, align 4
  %tbl_size.i.i60.i2205 = load i64, ptr %tbl_size_ptr.i.i57.i2202, align 4
  %offset_tbl.i.i61.i2206 = load ptr, ptr %offset_tbl_ptr.i.i58.i2203, align 8
  %product.i.i.i62.i2207 = mul i64 %hash_coef.i.i59.i2204, 4015701072841558310
  %shifted.i.i.i63.i2208 = lshr i64 %product.i.i.i62.i2207, 32
  %xored.i.i.i64.i2209 = xor i64 %shifted.i.i.i63.i2208, %product.i.i.i62.i2207
  %hash.i.i.i65.i2210 = and i64 %xored.i.i.i64.i2209, %tbl_size.i.i60.i2205
  %offset_ptr.i.i66.i2211 = getelementptr i32, ptr %offset_tbl.i.i61.i2206, i64 %hash.i.i.i65.i2210
  %offset.i.i67.i2212 = load i32, ptr %offset_ptr.i.i66.i2211, align 4
  %644 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %637, 0
  %645 = insertvalue { ptr, ptr, ptr, i32 } %644, ptr %642, 1
  %646 = insertvalue { ptr, ptr, ptr, i32 } %645, ptr %643, 2
  %647 = insertvalue { ptr, ptr, ptr, i32 } %646, i32 %offset.i.i67.i2212, 3
  %648 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %637)
  %649 = sext i32 %offset.i.i67.i2212 to i64
  %650 = getelementptr ptr, ptr %637, i64 %649
  %651 = getelementptr i8, ptr %650, i64 64
  %652 = load ptr, ptr %651, align 8
  %result.i.i2213 = call ptr %652({ ptr, ptr, ptr, i32 } %647, ptr nocapture nofree noundef nonnull readonly %2) #16
  %653 = call i32 %result.i.i2213({ ptr, ptr, ptr, i32 } %647, { ptr, ptr, ptr, i32 } %647, ptr nonnull align 8 %2) #7
  %654 = icmp eq i32 %653, %620
  br i1 %654, label %._crit_edge.i2225, label %._crit_edge.thread.i2214

._crit_edge.i2225:                                ; preds = %635
  %655 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %656 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %637)
  %657 = getelementptr i8, ptr %650, i64 48
  %658 = load ptr, ptr %657, align 8
  %result.i69.i2226 = call ptr %658({ ptr, ptr, ptr, i32 } %647, ptr nocapture nofree noundef nonnull readonly %2) #16
  %659 = call { ptr, i160 } %result.i69.i2226({ ptr, ptr, ptr, i32 } %647, { ptr, ptr, ptr, i32 } %647, ptr nonnull align 8 %2) #7
  %660 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %661 = load ptr, ptr %21, align 8
  %662 = call i1 %661({ ptr, i160 } %659, { ptr, i160 } %615) #7
  br i1 %662, label %HashMap_find_slot_keyK_hashPtri32.exit2228.loopexit, label %._crit_edge.thread.i2214

._crit_edge.thread.i2214:                         ; preds = %._crit_edge.i2225, %635
  %663 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %664 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %637)
  %665 = getelementptr i8, ptr %650, i64 56
  %666 = load ptr, ptr %665, align 8
  %result.i70.i2215 = call ptr %666({ ptr, ptr, ptr, i32 } %647, ptr nocapture nofree noundef nonnull readonly %2) #16
  %667 = call { ptr, i160 } %result.i70.i2215({ ptr, ptr, ptr, i32 } %647, { ptr, ptr, ptr, i32 } %647, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i2216 = extractvalue { ptr, i160 } %667, 0
  %668 = getelementptr i8, ptr %.fca.0.extract19.i2216, i64 8
  %669 = getelementptr i8, ptr %.fca.0.extract19.i2216, i64 16
  %670 = getelementptr i8, ptr %.fca.0.extract19.i2216, i64 24
  %671 = getelementptr i8, ptr %.fca.0.extract19.i2216, i64 32
  %672 = load i64, ptr %668, align 4
  %673 = load i64, ptr %669, align 4
  %674 = load ptr, ptr %670, align 8
  %675 = load ptr, ptr %671, align 8
  %result.i71.i2217 = call i1 %674(i64 %673, i64 %672, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %675) #5
  %676 = icmp eq i32 %spec.store.select.i22192259, -1
  %or.cond.i2218 = select i1 %result.i71.i2217, i1 %676, i1 false
  %spec.store.select.i2219 = select i1 %or.cond.i2218, i32 %636, i32 %spec.store.select.i22192259
  %677 = add i32 %636, 1
  %678 = and i32 %677, %623
  %679 = load ptr, ptr %22, align 8
  %680 = sext i32 %678 to i64
  %681 = shl nsw i64 %680, 5
  %682 = getelementptr i8, ptr %679, i64 %681
  %683 = load ptr, ptr %682, align 8
  %684 = icmp eq ptr %683, @nil_typ
  %685 = icmp eq ptr %683, null
  %686 = or i1 %684, %685
  br i1 %686, label %._crit_edge105.loopexit.i2221, label %635

._crit_edge105.loopexit.i2221:                    ; preds = %._crit_edge.thread.i2214
  %687 = icmp eq i32 %spec.store.select.i2219, -1
  %.pre.i2224.pre = select i1 %687, i32 %678, i32 %spec.store.select.i2219
  br label %HashMap_find_slot_keyK_hashPtri32.exit2228

HashMap_find_slot_keyK_hashPtri32.exit2228.loopexit: ; preds = %._crit_edge.i2225
  %.pre2379 = load ptr, ptr %22, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit2228

HashMap_find_slot_keyK_hashPtri32.exit2228:       ; preds = %HashMap_find_slot_keyK_hashPtri32.exit2228.loopexit, %610, %._crit_edge105.loopexit.i2221
  %688 = phi ptr [ %679, %._crit_edge105.loopexit.i2221 ], [ %626, %610 ], [ %.pre2379, %HashMap_find_slot_keyK_hashPtri32.exit2228.loopexit ]
  %689 = phi i32 [ %.pre.i2224.pre, %._crit_edge105.loopexit.i2221 ], [ %624, %610 ], [ %636, %HashMap_find_slot_keyK_hashPtri32.exit2228.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %690 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %691 = sext i32 %689 to i64
  %692 = shl nsw i64 %691, 5
  %693 = getelementptr i8, ptr %688, i64 %692
  %694 = load ptr, ptr %693, align 8
  %695 = getelementptr i8, ptr %693, i64 8
  %696 = load i64, ptr %695, align 4
  %.sroa_idx.i2013 = getelementptr i8, ptr %693, i64 16
  %697 = load i64, ptr %.sroa_idx.i2013, align 4
  %698 = load ptr, ptr %15, align 8
  %699 = load ptr, ptr %621, align 8, !alias.scope !136
  %700 = getelementptr i8, ptr %699, i64 72
  %701 = load ptr, ptr %700, align 8, !alias.scope !136
  %result.i.i.i2015 = call { i64, i64 } %701(ptr nocapture nofree nonnull readonly %621) #5, !alias.scope !136
  %702 = extractvalue { i64, i64 } %result.i.i.i2015, 0
  %703 = extractvalue { i64, i64 } %result.i.i.i2015, 1
  %704 = call i64 @llvm.umax.i64(i64 %703, i64 8)
  %705 = urem i64 20, %703
  %706 = icmp eq i64 %705, 0
  %707 = sub i64 %703, %705
  %708 = select i1 %706, i64 0, i64 %707
  %709 = add i64 %702, 20
  %710 = add i64 %709, %708
  %711 = and i64 %710, 7
  %712 = icmp eq i64 %711, 0
  %713 = sub nuw nsw i64 40, %711
  %714 = select i1 %712, i64 32, i64 %713
  %715 = add i64 %714, %710
  %716 = urem i64 %715, %704
  %717 = icmp eq i64 %716, 0
  %718 = sub i64 %704, %716
  %719 = select i1 %717, i64 0, i64 %718
  %720 = add i64 %715, %719
  %result.i71.i2016 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %720, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %621, ptr %result.i71.i2016, align 8
  %721 = getelementptr inbounds i8, ptr %result.i71.i2016, i64 8
  store ptr %698, ptr %721, align 8
  %722 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i2016)
  %723 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %result.i71.i2016, 1
  %724 = insertvalue { ptr, ptr, ptr, i32 } %723, ptr undef, 2
  %725 = insertvalue { ptr, ptr, ptr, i32 } %724, i32 10, 3
  store ptr %621, ptr %3, align 8
  store ptr %698, ptr %36, align 8
  store ptr @_parameterization_Ptri32, ptr %37, align 8
  %726 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %3)
  %727 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Entry)
  %728 = load i64, ptr %601, align 4
  %729 = load i64, ptr %602, align 4
  %730 = load ptr, ptr %603, align 8
  %731 = load ptr, ptr %604, align 8
  %result.i.i117.i2017 = call i1 %730(i64 %729, i64 %728, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %731) #5
  %732 = select i1 %result.i.i117.i2017, i64 9, i64 10
  %gep2059 = getelementptr [14 x ptr], ptr getelementptr inbounds (i8, ptr @Entry, i64 80), i64 0, i64 %732
  %733 = load ptr, ptr %gep2059, align 8
  call void %733({ ptr, ptr, ptr, i32 } %725, { ptr, ptr, ptr, i32 } %725, ptr nonnull align 8 dereferenceable(24) %3, { ptr, i160 } %615, { ptr, i160 } %596, i32 %620) #7
  %734 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %735 = load ptr, ptr %22, align 8
  %736 = getelementptr i8, ptr %735, i64 %692
  store ptr @Entry, ptr %736, align 8
  %737 = getelementptr i8, ptr %736, i64 8
  %738 = ptrtoint ptr %result.i71.i2016 to i64
  store i64 %738, ptr %737, align 4
  %.sroa_idx4.i2019 = getelementptr i8, ptr %736, i64 24
  store i32 10, ptr %.sroa_idx4.i2019, align 4
  %739 = icmp eq ptr %694, @nil_typ
  %740 = icmp eq ptr %694, null
  %741 = or i1 %739, %740
  br i1 %741, label %742, label %745

742:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit2228
  %743 = load i32, ptr %33, align 4
  %744 = add i32 %743, 1
  store i32 %744, ptr %33, align 4
  br label %._crit_edge.sink.split.i2036

745:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit2228
  %746 = inttoptr i64 %696 to ptr
  %747 = inttoptr i64 %697 to ptr
  %hash_coef_ptr.i.i88.i2020 = getelementptr i8, ptr %694, i64 8
  %tbl_size_ptr.i.i89.i2021 = getelementptr i8, ptr %694, i64 16
  %offset_tbl_ptr.i.i90.i2022 = getelementptr i8, ptr %694, i64 40
  %hash_coef.i.i91.i2023 = load i64, ptr %hash_coef_ptr.i.i88.i2020, align 4, !noalias !139
  %tbl_size.i.i92.i2024 = load i64, ptr %tbl_size_ptr.i.i89.i2021, align 4, !noalias !139
  %offset_tbl.i.i93.i2025 = load ptr, ptr %offset_tbl_ptr.i.i90.i2022, align 8, !noalias !139
  %product.i.i.i94.i2026 = mul i64 %hash_coef.i.i91.i2023, 4015701072841558310
  %shifted.i.i.i95.i2027 = lshr i64 %product.i.i.i94.i2026, 32
  %xored.i.i.i96.i2028 = xor i64 %shifted.i.i.i95.i2027, %product.i.i.i94.i2026
  %hash.i.i.i97.i2029 = and i64 %xored.i.i.i96.i2028, %tbl_size.i.i92.i2024
  %offset_ptr.i.i98.i2030 = getelementptr i32, ptr %offset_tbl.i.i93.i2025, i64 %hash.i.i.i97.i2029
  %offset.i.i99.i2031 = load i32, ptr %offset_ptr.i.i98.i2030, align 4, !noalias !139
  %748 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %694, 0
  %749 = insertvalue { ptr, ptr, ptr, i32 } %748, ptr %746, 1
  %750 = insertvalue { ptr, ptr, ptr, i32 } %749, ptr %747, 2
  %751 = insertvalue { ptr, ptr, ptr, i32 } %750, i32 %offset.i.i99.i2031, 3
  %752 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %753 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %694)
  %754 = sext i32 %offset.i.i99.i2031 to i64
  %755 = getelementptr ptr, ptr %694, i64 %754
  %756 = getelementptr i8, ptr %755, i64 56
  %757 = load ptr, ptr %756, align 8
  %result.i101.i2032 = call ptr %757({ ptr, ptr, ptr, i32 } %751, ptr nocapture nofree noundef nonnull readonly %2) #16
  %758 = call { ptr, i160 } %result.i101.i2032({ ptr, ptr, ptr, i32 } %751, { ptr, ptr, ptr, i32 } %751, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i2033 = extractvalue { ptr, i160 } %758, 0
  %759 = getelementptr i8, ptr %.fca.0.extract51.i2033, i64 8
  %760 = getelementptr i8, ptr %.fca.0.extract51.i2033, i64 16
  %761 = getelementptr i8, ptr %.fca.0.extract51.i2033, i64 24
  %762 = getelementptr i8, ptr %.fca.0.extract51.i2033, i64 32
  %763 = load i64, ptr %759, align 4
  %764 = load i64, ptr %760, align 4
  %765 = load ptr, ptr %761, align 8
  %766 = load ptr, ptr %762, align 8
  %result.i102.i2034 = call i1 %765(i64 %764, i64 %763, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %766) #5
  br i1 %result.i102.i2034, label %._crit_edge.sink.split.i2036, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit2038

._crit_edge.sink.split.i2036:                     ; preds = %745, %742
  %.sink159.i2037 = phi i64 [ 48, %742 ], [ 40, %745 ]
  %767 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %768 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i2037
  %769 = load ptr, ptr %768, align 8
  %770 = load ptr, ptr %769, align 8
  %771 = call i32 %770(ptr nonnull %result.i428) #36
  %772 = add i32 %771, 1
  %773 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %774 = getelementptr i8, ptr %769, i64 8
  %775 = load ptr, ptr %774, align 8
  call void %775(ptr nonnull %result.i428, i32 %772) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit2038

HashMap_insert_internal_keyK_valueV_hashPtri32.exit2038: ; preds = %745, %._crit_edge.sink.split.i2036
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %3)
  br label %._crit_edge.i1749

._crit_edge.i1749:                                ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit2038, %580, %.lr.ph.i1746
  %776 = add nuw nsw i32 %.096.i1747, 1
  %777 = icmp slt i32 %776, %562
  br i1 %777, label %.lr.ph.i1746, label %HashMap_resize_new_capacityPtri32.exit1772

HashMap_resize_new_capacityPtri32.exit1772:       ; preds = %._crit_edge.i1749, %._crit_edge1.i1305
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_ensure_capacity_required_loadPtri32.exit1309

HashMap_ensure_capacity_required_loadPtri32.exit1309: ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit, %HashMap_resize_new_capacityPtri32.exit1772
  %778 = load ptr, ptr %20, align 8
  %779 = call i32 %778({ ptr, i160 } %43) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %780 = load ptr, ptr %result.i428, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %781 = load i32, ptr %23, align 8
  %782 = add i32 %781, -1
  %783 = and i32 %782, %779
  %784 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %785 = load ptr, ptr %22, align 8
  %786 = sext i32 %783 to i64
  %787 = shl nsw i64 %786, 5
  %788 = getelementptr i8, ptr %785, i64 %787
  %789 = load ptr, ptr %788, align 8
  %790 = icmp eq ptr %789, @nil_typ
  %791 = icmp eq ptr %789, null
  %792 = or i1 %790, %791
  br i1 %792, label %HashMap_find_slot_keyK_hashPtri32.exit1817, label %.lr.ph.i1787

.lr.ph.i1787:                                     ; preds = %HashMap_ensure_capacity_required_loadPtri32.exit1309
  %793 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %794

794:                                              ; preds = %._crit_edge.thread.i1803, %.lr.ph.i1787
  %795 = phi i32 [ %783, %.lr.ph.i1787 ], [ %837, %._crit_edge.thread.i1803 ]
  %spec.store.select.i18081853 = phi i32 [ -1, %.lr.ph.i1787 ], [ %spec.store.select.i1808, %._crit_edge.thread.i1803 ]
  %796 = phi ptr [ %789, %.lr.ph.i1787 ], [ %842, %._crit_edge.thread.i1803 ]
  %797 = phi ptr [ %788, %.lr.ph.i1787 ], [ %841, %._crit_edge.thread.i1803 ]
  %.sroa_idx.i1789 = getelementptr i8, ptr %797, i64 16
  %798 = load i64, ptr %.sroa_idx.i1789, align 4
  %799 = getelementptr i8, ptr %797, i64 8
  %800 = load i64, ptr %799, align 4
  %801 = inttoptr i64 %800 to ptr
  %802 = inttoptr i64 %798 to ptr
  %hash_coef_ptr.i.i56.i1790 = getelementptr i8, ptr %796, i64 8
  %tbl_size_ptr.i.i57.i1791 = getelementptr i8, ptr %796, i64 16
  %offset_tbl_ptr.i.i58.i1792 = getelementptr i8, ptr %796, i64 40
  %hash_coef.i.i59.i1793 = load i64, ptr %hash_coef_ptr.i.i56.i1790, align 4
  %tbl_size.i.i60.i1794 = load i64, ptr %tbl_size_ptr.i.i57.i1791, align 4
  %offset_tbl.i.i61.i1795 = load ptr, ptr %offset_tbl_ptr.i.i58.i1792, align 8
  %product.i.i.i62.i1796 = mul i64 %hash_coef.i.i59.i1793, 4015701072841558310
  %shifted.i.i.i63.i1797 = lshr i64 %product.i.i.i62.i1796, 32
  %xored.i.i.i64.i1798 = xor i64 %shifted.i.i.i63.i1797, %product.i.i.i62.i1796
  %hash.i.i.i65.i1799 = and i64 %xored.i.i.i64.i1798, %tbl_size.i.i60.i1794
  %offset_ptr.i.i66.i1800 = getelementptr i32, ptr %offset_tbl.i.i61.i1795, i64 %hash.i.i.i65.i1799
  %offset.i.i67.i1801 = load i32, ptr %offset_ptr.i.i66.i1800, align 4
  %803 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %796, 0
  %804 = insertvalue { ptr, ptr, ptr, i32 } %803, ptr %801, 1
  %805 = insertvalue { ptr, ptr, ptr, i32 } %804, ptr %802, 2
  %806 = insertvalue { ptr, ptr, ptr, i32 } %805, i32 %offset.i.i67.i1801, 3
  %807 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %796)
  %808 = sext i32 %offset.i.i67.i1801 to i64
  %809 = getelementptr ptr, ptr %796, i64 %808
  %810 = getelementptr i8, ptr %809, i64 64
  %811 = load ptr, ptr %810, align 8
  %result.i.i1802 = call ptr %811({ ptr, ptr, ptr, i32 } %806, ptr nocapture nofree noundef nonnull readonly %2) #16
  %812 = call i32 %result.i.i1802({ ptr, ptr, ptr, i32 } %806, { ptr, ptr, ptr, i32 } %806, ptr nonnull align 8 %2) #7
  %813 = icmp eq i32 %812, %779
  br i1 %813, label %._crit_edge.i1814, label %._crit_edge.thread.i1803

._crit_edge.i1814:                                ; preds = %794
  %814 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %815 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %796)
  %816 = getelementptr i8, ptr %809, i64 48
  %817 = load ptr, ptr %816, align 8
  %result.i69.i1815 = call ptr %817({ ptr, ptr, ptr, i32 } %806, ptr nocapture nofree noundef nonnull readonly %2) #16
  %818 = call { ptr, i160 } %result.i69.i1815({ ptr, ptr, ptr, i32 } %806, { ptr, ptr, ptr, i32 } %806, ptr nonnull align 8 %2) #7
  %819 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %820 = load ptr, ptr %21, align 8
  %821 = call i1 %820({ ptr, i160 } %818, { ptr, i160 } %43) #7
  br i1 %821, label %HashMap_find_slot_keyK_hashPtri32.exit1817.loopexit, label %._crit_edge.thread.i1803

._crit_edge.thread.i1803:                         ; preds = %._crit_edge.i1814, %794
  %822 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %823 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %796)
  %824 = getelementptr i8, ptr %809, i64 56
  %825 = load ptr, ptr %824, align 8
  %result.i70.i1804 = call ptr %825({ ptr, ptr, ptr, i32 } %806, ptr nocapture nofree noundef nonnull readonly %2) #16
  %826 = call { ptr, i160 } %result.i70.i1804({ ptr, ptr, ptr, i32 } %806, { ptr, ptr, ptr, i32 } %806, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i1805 = extractvalue { ptr, i160 } %826, 0
  %827 = getelementptr i8, ptr %.fca.0.extract19.i1805, i64 8
  %828 = getelementptr i8, ptr %.fca.0.extract19.i1805, i64 16
  %829 = getelementptr i8, ptr %.fca.0.extract19.i1805, i64 24
  %830 = getelementptr i8, ptr %.fca.0.extract19.i1805, i64 32
  %831 = load i64, ptr %827, align 4
  %832 = load i64, ptr %828, align 4
  %833 = load ptr, ptr %829, align 8
  %834 = load ptr, ptr %830, align 8
  %result.i71.i1806 = call i1 %833(i64 %832, i64 %831, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %834) #5
  %835 = icmp eq i32 %spec.store.select.i18081853, -1
  %or.cond.i1807 = select i1 %result.i71.i1806, i1 %835, i1 false
  %spec.store.select.i1808 = select i1 %or.cond.i1807, i32 %795, i32 %spec.store.select.i18081853
  %836 = add i32 %795, 1
  %837 = and i32 %836, %782
  %838 = load ptr, ptr %22, align 8
  %839 = sext i32 %837 to i64
  %840 = shl nsw i64 %839, 5
  %841 = getelementptr i8, ptr %838, i64 %840
  %842 = load ptr, ptr %841, align 8
  %843 = icmp eq ptr %842, @nil_typ
  %844 = icmp eq ptr %842, null
  %845 = or i1 %843, %844
  br i1 %845, label %._crit_edge105.loopexit.i1810, label %794

._crit_edge105.loopexit.i1810:                    ; preds = %._crit_edge.thread.i1803
  %846 = icmp eq i32 %spec.store.select.i1808, -1
  %.pre.i1813.pre = select i1 %846, i32 %837, i32 %spec.store.select.i1808
  br label %HashMap_find_slot_keyK_hashPtri32.exit1817

HashMap_find_slot_keyK_hashPtri32.exit1817.loopexit: ; preds = %._crit_edge.i1814
  %.pre1949 = load ptr, ptr %22, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit1817

HashMap_find_slot_keyK_hashPtri32.exit1817:       ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1817.loopexit, %HashMap_ensure_capacity_required_loadPtri32.exit1309, %._crit_edge105.loopexit.i1810
  %847 = phi ptr [ %838, %._crit_edge105.loopexit.i1810 ], [ %785, %HashMap_ensure_capacity_required_loadPtri32.exit1309 ], [ %.pre1949, %HashMap_find_slot_keyK_hashPtri32.exit1817.loopexit ]
  %848 = phi i32 [ %.pre.i1813.pre, %._crit_edge105.loopexit.i1810 ], [ %783, %HashMap_ensure_capacity_required_loadPtri32.exit1309 ], [ %795, %HashMap_find_slot_keyK_hashPtri32.exit1817.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %849 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %850 = sext i32 %848 to i64
  %851 = shl nsw i64 %850, 5
  %852 = getelementptr i8, ptr %847, i64 %851
  %853 = load ptr, ptr %852, align 8
  %854 = getelementptr i8, ptr %852, i64 8
  %855 = load i64, ptr %854, align 4
  %.sroa_idx.i1329 = getelementptr i8, ptr %852, i64 16
  %856 = load i64, ptr %.sroa_idx.i1329, align 4
  %857 = load ptr, ptr %15, align 8
  %858 = load ptr, ptr %780, align 8, !alias.scope !142
  %859 = getelementptr i8, ptr %858, i64 72
  %860 = load ptr, ptr %859, align 8, !alias.scope !142
  %result.i.i.i1331 = call { i64, i64 } %860(ptr nocapture nofree nonnull readonly %780) #5, !alias.scope !142
  %861 = extractvalue { i64, i64 } %result.i.i.i1331, 0
  %862 = extractvalue { i64, i64 } %result.i.i.i1331, 1
  %863 = call i64 @llvm.umax.i64(i64 %862, i64 8)
  %864 = urem i64 20, %862
  %865 = icmp eq i64 %864, 0
  %866 = sub i64 %862, %864
  %867 = select i1 %865, i64 0, i64 %866
  %868 = add i64 %861, 20
  %869 = add i64 %868, %867
  %870 = and i64 %869, 7
  %871 = icmp eq i64 %870, 0
  %872 = sub nuw nsw i64 40, %870
  %873 = select i1 %871, i64 32, i64 %872
  %874 = add i64 %873, %869
  %875 = urem i64 %874, %863
  %876 = icmp eq i64 %875, 0
  %877 = sub i64 %863, %875
  %878 = select i1 %876, i64 0, i64 %877
  %879 = add i64 %874, %878
  %result.i71.i1332 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %879, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %780, ptr %result.i71.i1332, align 8
  %880 = getelementptr inbounds i8, ptr %result.i71.i1332, i64 8
  store ptr %857, ptr %880, align 8
  %881 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i1332)
  %882 = load ptr, ptr %780, align 8
  %883 = getelementptr i8, ptr %882, i64 72
  %884 = load ptr, ptr %883, align 8
  %result.i.i1908 = call { i64, i64 } %884(ptr nocapture nofree nonnull readonly %780) #5
  %885 = extractvalue { i64, i64 } %result.i.i1908, 1
  %886 = urem i64 20, %885
  %887 = icmp eq i64 %886, 0
  %reass.sub = sub i64 %885, %886
  %888 = add i64 %reass.sub, 20
  %889 = select i1 %887, i64 20, i64 %888
  %890 = getelementptr i8, ptr %result.i71.i1332, i64 %889
  %891 = getelementptr i8, ptr %882, i64 64
  %892 = load ptr, ptr %891, align 8
  call void %892({ ptr, i160 } %43, ptr nocapture nofree nonnull readonly %780, ptr nocapture nofree writeonly %890) #13
  %893 = load ptr, ptr %result.i71.i1332, align 8
  %894 = load ptr, ptr %893, align 8
  %895 = getelementptr i8, ptr %894, i64 72
  %896 = load ptr, ptr %895, align 8
  %result.i.i1910 = call { i64, i64 } %896(ptr nocapture nofree nonnull readonly %893) #5
  %897 = extractvalue { i64, i64 } %result.i.i1910, 0
  %898 = extractvalue { i64, i64 } %result.i.i1910, 1
  %899 = urem i64 20, %898
  %900 = icmp eq i64 %899, 0
  %901 = sub i64 %898, %899
  %902 = select i1 %900, i64 0, i64 %901
  %903 = add i64 %897, 20
  %904 = add i64 %903, %902
  %905 = and i64 %904, 7
  %906 = icmp eq i64 %905, 0
  %907 = sub nuw nsw i64 8, %905
  %908 = select i1 %906, i64 0, i64 %907
  %909 = getelementptr i8, ptr %result.i71.i1332, i64 %904
  %910 = getelementptr i8, ptr %909, i64 %908
  store ptr @bool_typ, ptr %910, align 8
  %911 = getelementptr i8, ptr %910, i64 8
  store i160 %.sroa.0323.0.insert.ext, ptr %911, align 4
  %912 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @Entry) #34
  %913 = getelementptr inbounds i8, ptr %result.i71.i1332, i64 16
  store i32 %779, ptr %913, align 8
  %914 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  store ptr @Entry, ptr %852, align 8
  %915 = ptrtoint ptr %result.i71.i1332 to i64
  store i64 %915, ptr %854, align 4
  %.sroa_idx4.i1335 = getelementptr i8, ptr %852, i64 24
  store i32 10, ptr %.sroa_idx4.i1335, align 4
  %916 = icmp eq ptr %853, @nil_typ
  %917 = icmp eq ptr %853, null
  %918 = or i1 %916, %917
  br i1 %918, label %919, label %922

919:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1817
  %920 = load i32, ptr %33, align 4
  %921 = add i32 %920, 1
  store i32 %921, ptr %33, align 4
  br label %._crit_edge.sink.split.i1352

922:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1817
  %923 = inttoptr i64 %855 to ptr
  %924 = inttoptr i64 %856 to ptr
  %hash_coef_ptr.i.i88.i1336 = getelementptr i8, ptr %853, i64 8
  %tbl_size_ptr.i.i89.i1337 = getelementptr i8, ptr %853, i64 16
  %offset_tbl_ptr.i.i90.i1338 = getelementptr i8, ptr %853, i64 40
  %hash_coef.i.i91.i1339 = load i64, ptr %hash_coef_ptr.i.i88.i1336, align 4, !noalias !145
  %tbl_size.i.i92.i1340 = load i64, ptr %tbl_size_ptr.i.i89.i1337, align 4, !noalias !145
  %offset_tbl.i.i93.i1341 = load ptr, ptr %offset_tbl_ptr.i.i90.i1338, align 8, !noalias !145
  %product.i.i.i94.i1342 = mul i64 %hash_coef.i.i91.i1339, 4015701072841558310
  %shifted.i.i.i95.i1343 = lshr i64 %product.i.i.i94.i1342, 32
  %xored.i.i.i96.i1344 = xor i64 %shifted.i.i.i95.i1343, %product.i.i.i94.i1342
  %hash.i.i.i97.i1345 = and i64 %xored.i.i.i96.i1344, %tbl_size.i.i92.i1340
  %offset_ptr.i.i98.i1346 = getelementptr i32, ptr %offset_tbl.i.i93.i1341, i64 %hash.i.i.i97.i1345
  %offset.i.i99.i1347 = load i32, ptr %offset_ptr.i.i98.i1346, align 4, !noalias !145
  %925 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %853, 0
  %926 = insertvalue { ptr, ptr, ptr, i32 } %925, ptr %923, 1
  %927 = insertvalue { ptr, ptr, ptr, i32 } %926, ptr %924, 2
  %928 = insertvalue { ptr, ptr, ptr, i32 } %927, i32 %offset.i.i99.i1347, 3
  %929 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %930 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %853)
  %931 = sext i32 %offset.i.i99.i1347 to i64
  %932 = getelementptr ptr, ptr %853, i64 %931
  %933 = getelementptr i8, ptr %932, i64 56
  %934 = load ptr, ptr %933, align 8
  %result.i101.i1348 = call ptr %934({ ptr, ptr, ptr, i32 } %928, ptr nocapture nofree noundef nonnull readonly %2) #16
  %935 = call { ptr, i160 } %result.i101.i1348({ ptr, ptr, ptr, i32 } %928, { ptr, ptr, ptr, i32 } %928, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i1349 = extractvalue { ptr, i160 } %935, 0
  %936 = getelementptr i8, ptr %.fca.0.extract51.i1349, i64 8
  %937 = getelementptr i8, ptr %.fca.0.extract51.i1349, i64 16
  %938 = getelementptr i8, ptr %.fca.0.extract51.i1349, i64 24
  %939 = getelementptr i8, ptr %.fca.0.extract51.i1349, i64 32
  %940 = load i64, ptr %936, align 4
  %941 = load i64, ptr %937, align 4
  %942 = load ptr, ptr %938, align 8
  %943 = load ptr, ptr %939, align 8
  %result.i102.i1350 = call i1 %942(i64 %941, i64 %940, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %943) #5
  br i1 %result.i102.i1350, label %._crit_edge.sink.split.i1352, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1354

._crit_edge.sink.split.i1352:                     ; preds = %922, %919
  %.sink159.i1353 = phi i64 [ 48, %919 ], [ 40, %922 ]
  %944 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %945 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i1353
  %946 = load ptr, ptr %945, align 8
  %947 = load ptr, ptr %946, align 8
  %948 = call i32 %947(ptr nonnull %result.i428) #36
  %949 = add i32 %948, 1
  %950 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %951 = getelementptr i8, ptr %946, i64 8
  %952 = load ptr, ptr %951, align 8
  call void %952(ptr nonnull %result.i428, i32 %949) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1354

HashMap_insert_internal_keyK_valueV_hashPtri32.exit1354: ; preds = %922, %._crit_edge.sink.split.i1352
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %953 = add nsw i32 %.0361707, 1
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1354, %HashMap_get_keyK.exit
  %.2363 = phi i32 [ %953, %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1354 ], [ %.0361707, %HashMap_get_keyK.exit ]
  %954 = add nuw nsw i32 %.0358708, 1
  %955 = icmp slt i32 %.2363, %0
  %956 = icmp slt i32 %954, %25
  %spec.select = select i1 %955, i1 %956, i1 false
  br i1 %spec.select, label %38, label %._crit_edge3._crit_edge

._crit_edge3._crit_edge:                          ; preds = %._crit_edge1, %1
  %957 = sext i32 %0 to i64
  %958 = shl nsw i64 %957, 2
  %result.i4.i = call noalias ptr @bump_malloc_inner(i64 noundef %958, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %959 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #34
  %960 = mul i32 %0, 20
  %961 = icmp sgt i32 %960, 0
  %spec.select384709 = and i1 %26, %961
  br i1 %spec.select384709, label %.lr.ph712, label %._crit_edge7._crit_edge

.lr.ph712:                                        ; preds = %._crit_edge3._crit_edge
  %962 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %963 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #34
  br label %964

964:                                              ; preds = %.lr.ph712, %._crit_edge5
  %965 = phi i32 [ 987, %.lr.ph712 ], [ %968, %._crit_edge5 ]
  %.0357711 = phi i32 [ 0, %.lr.ph712 ], [ %.2, %._crit_edge5 ]
  %.2360710 = phi i32 [ 0, %.lr.ph712 ], [ %1100, %._crit_edge5 ]
  %966 = mul i32 %965, 1103515245
  %967 = add i32 %966, 12345
  %968 = and i32 %967, 2147483647
  %.sroa.0285.0.insert.ext = zext nneg i32 %968 to i160
  %969 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0285.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %970 = load ptr, ptr %20, align 8
  %971 = call i32 %970({ ptr, i160 } %969) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %972 = load i32, ptr %23, align 8
  %973 = add i32 %972, -1
  %974 = and i32 %973, %971
  %975 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %976 = load ptr, ptr %22, align 8
  %977 = sext i32 %974 to i64
  %978 = shl nsw i64 %977, 5
  %979 = getelementptr i8, ptr %976, i64 %978
  %980 = load ptr, ptr %979, align 8
  %981 = icmp eq ptr %980, @nil_typ
  %982 = icmp eq ptr %980, null
  %983 = or i1 %981, %982
  br i1 %983, label %HashMap_find_slot_keyK_hashPtri32.exit1399, label %.lr.ph.i1369

.lr.ph.i1369:                                     ; preds = %964
  %984 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %985

985:                                              ; preds = %._crit_edge.thread.i1385, %.lr.ph.i1369
  %986 = phi i32 [ %974, %.lr.ph.i1369 ], [ %1028, %._crit_edge.thread.i1385 ]
  %spec.store.select.i13901606 = phi i32 [ -1, %.lr.ph.i1369 ], [ %spec.store.select.i1390, %._crit_edge.thread.i1385 ]
  %987 = phi ptr [ %980, %.lr.ph.i1369 ], [ %1033, %._crit_edge.thread.i1385 ]
  %988 = phi ptr [ %979, %.lr.ph.i1369 ], [ %1032, %._crit_edge.thread.i1385 ]
  %.sroa_idx.i1371 = getelementptr i8, ptr %988, i64 16
  %989 = load i64, ptr %.sroa_idx.i1371, align 4
  %990 = getelementptr i8, ptr %988, i64 8
  %991 = load i64, ptr %990, align 4
  %992 = inttoptr i64 %991 to ptr
  %993 = inttoptr i64 %989 to ptr
  %hash_coef_ptr.i.i56.i1372 = getelementptr i8, ptr %987, i64 8
  %tbl_size_ptr.i.i57.i1373 = getelementptr i8, ptr %987, i64 16
  %offset_tbl_ptr.i.i58.i1374 = getelementptr i8, ptr %987, i64 40
  %hash_coef.i.i59.i1375 = load i64, ptr %hash_coef_ptr.i.i56.i1372, align 4
  %tbl_size.i.i60.i1376 = load i64, ptr %tbl_size_ptr.i.i57.i1373, align 4
  %offset_tbl.i.i61.i1377 = load ptr, ptr %offset_tbl_ptr.i.i58.i1374, align 8
  %product.i.i.i62.i1378 = mul i64 %hash_coef.i.i59.i1375, 4015701072841558310
  %shifted.i.i.i63.i1379 = lshr i64 %product.i.i.i62.i1378, 32
  %xored.i.i.i64.i1380 = xor i64 %shifted.i.i.i63.i1379, %product.i.i.i62.i1378
  %hash.i.i.i65.i1381 = and i64 %xored.i.i.i64.i1380, %tbl_size.i.i60.i1376
  %offset_ptr.i.i66.i1382 = getelementptr i32, ptr %offset_tbl.i.i61.i1377, i64 %hash.i.i.i65.i1381
  %offset.i.i67.i1383 = load i32, ptr %offset_ptr.i.i66.i1382, align 4
  %994 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %987, 0
  %995 = insertvalue { ptr, ptr, ptr, i32 } %994, ptr %992, 1
  %996 = insertvalue { ptr, ptr, ptr, i32 } %995, ptr %993, 2
  %997 = insertvalue { ptr, ptr, ptr, i32 } %996, i32 %offset.i.i67.i1383, 3
  %998 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %987)
  %999 = sext i32 %offset.i.i67.i1383 to i64
  %1000 = getelementptr ptr, ptr %987, i64 %999
  %1001 = getelementptr i8, ptr %1000, i64 64
  %1002 = load ptr, ptr %1001, align 8
  %result.i.i1384 = call ptr %1002({ ptr, ptr, ptr, i32 } %997, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1003 = call i32 %result.i.i1384({ ptr, ptr, ptr, i32 } %997, { ptr, ptr, ptr, i32 } %997, ptr nonnull align 8 %2) #7
  %1004 = icmp eq i32 %1003, %971
  br i1 %1004, label %._crit_edge.i1396, label %._crit_edge.thread.i1385

._crit_edge.i1396:                                ; preds = %985
  %1005 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1006 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %987)
  %1007 = getelementptr i8, ptr %1000, i64 48
  %1008 = load ptr, ptr %1007, align 8
  %result.i69.i1397 = call ptr %1008({ ptr, ptr, ptr, i32 } %997, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1009 = call { ptr, i160 } %result.i69.i1397({ ptr, ptr, ptr, i32 } %997, { ptr, ptr, ptr, i32 } %997, ptr nonnull align 8 %2) #7
  %1010 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1011 = load ptr, ptr %21, align 8
  %1012 = call i1 %1011({ ptr, i160 } %1009, { ptr, i160 } %969) #7
  br i1 %1012, label %HashMap_find_slot_keyK_hashPtri32.exit1399.loopexit, label %._crit_edge.thread.i1385

._crit_edge.thread.i1385:                         ; preds = %._crit_edge.i1396, %985
  %1013 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1014 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %987)
  %1015 = getelementptr i8, ptr %1000, i64 56
  %1016 = load ptr, ptr %1015, align 8
  %result.i70.i1386 = call ptr %1016({ ptr, ptr, ptr, i32 } %997, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1017 = call { ptr, i160 } %result.i70.i1386({ ptr, ptr, ptr, i32 } %997, { ptr, ptr, ptr, i32 } %997, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i1387 = extractvalue { ptr, i160 } %1017, 0
  %1018 = getelementptr i8, ptr %.fca.0.extract19.i1387, i64 8
  %1019 = getelementptr i8, ptr %.fca.0.extract19.i1387, i64 16
  %1020 = getelementptr i8, ptr %.fca.0.extract19.i1387, i64 24
  %1021 = getelementptr i8, ptr %.fca.0.extract19.i1387, i64 32
  %1022 = load i64, ptr %1018, align 4
  %1023 = load i64, ptr %1019, align 4
  %1024 = load ptr, ptr %1020, align 8
  %1025 = load ptr, ptr %1021, align 8
  %result.i71.i1388 = call i1 %1024(i64 %1023, i64 %1022, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %1025) #5
  %1026 = icmp eq i32 %spec.store.select.i13901606, -1
  %or.cond.i1389 = select i1 %result.i71.i1388, i1 %1026, i1 false
  %spec.store.select.i1390 = select i1 %or.cond.i1389, i32 %986, i32 %spec.store.select.i13901606
  %1027 = add i32 %986, 1
  %1028 = and i32 %1027, %973
  %1029 = load ptr, ptr %22, align 8
  %1030 = sext i32 %1028 to i64
  %1031 = shl nsw i64 %1030, 5
  %1032 = getelementptr i8, ptr %1029, i64 %1031
  %1033 = load ptr, ptr %1032, align 8
  %1034 = icmp eq ptr %1033, @nil_typ
  %1035 = icmp eq ptr %1033, null
  %1036 = or i1 %1034, %1035
  br i1 %1036, label %._crit_edge105.loopexit.i1392, label %985

._crit_edge105.loopexit.i1392:                    ; preds = %._crit_edge.thread.i1385
  %1037 = icmp eq i32 %spec.store.select.i1390, -1
  %.pre.i1395.pre = select i1 %1037, i32 %1028, i32 %spec.store.select.i1390
  br label %HashMap_find_slot_keyK_hashPtri32.exit1399

HashMap_find_slot_keyK_hashPtri32.exit1399.loopexit: ; preds = %._crit_edge.i1396
  %.pre1664 = load ptr, ptr %22, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit1399

HashMap_find_slot_keyK_hashPtri32.exit1399:       ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1399.loopexit, %964, %._crit_edge105.loopexit.i1392
  %1038 = phi ptr [ %1029, %._crit_edge105.loopexit.i1392 ], [ %976, %964 ], [ %.pre1664, %HashMap_find_slot_keyK_hashPtri32.exit1399.loopexit ]
  %1039 = phi i32 [ %.pre.i1395.pre, %._crit_edge105.loopexit.i1392 ], [ %974, %964 ], [ %986, %HashMap_find_slot_keyK_hashPtri32.exit1399.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1040 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1041 = sext i32 %1039 to i64
  %1042 = shl nsw i64 %1041, 5
  %1043 = getelementptr i8, ptr %1038, i64 %1042
  %1044 = load ptr, ptr %1043, align 8
  %1045 = icmp ne ptr %1044, @nil_typ
  %1046 = icmp ne ptr %1044, null
  %.not57.i984 = and i1 %1045, %1046
  br i1 %.not57.i984, label %1047, label %HashMap_get_keyK.exit1012.thread

1047:                                             ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1399
  %1048 = getelementptr i8, ptr %1043, i64 8
  %1049 = load i64, ptr %1048, align 4
  %.sroa_idx.i988 = getelementptr i8, ptr %1043, i64 16
  %1050 = load i64, ptr %.sroa_idx.i988, align 4
  %1051 = inttoptr i64 %1049 to ptr
  %1052 = inttoptr i64 %1050 to ptr
  %hash_coef_ptr.i.i60.i989 = getelementptr i8, ptr %1044, i64 8
  %tbl_size_ptr.i.i61.i990 = getelementptr i8, ptr %1044, i64 16
  %offset_tbl_ptr.i.i62.i991 = getelementptr i8, ptr %1044, i64 40
  %hash_coef.i.i63.i992 = load i64, ptr %hash_coef_ptr.i.i60.i989, align 4, !noalias !148
  %tbl_size.i.i64.i993 = load i64, ptr %tbl_size_ptr.i.i61.i990, align 4, !noalias !148
  %offset_tbl.i.i65.i994 = load ptr, ptr %offset_tbl_ptr.i.i62.i991, align 8, !noalias !148
  %product.i.i.i66.i995 = mul i64 %hash_coef.i.i63.i992, 4015701072841558310
  %shifted.i.i.i67.i996 = lshr i64 %product.i.i.i66.i995, 32
  %xored.i.i.i68.i997 = xor i64 %shifted.i.i.i67.i996, %product.i.i.i66.i995
  %hash.i.i.i69.i998 = and i64 %xored.i.i.i68.i997, %tbl_size.i.i64.i993
  %offset_ptr.i.i70.i999 = getelementptr i32, ptr %offset_tbl.i.i65.i994, i64 %hash.i.i.i69.i998
  %offset.i.i71.i1000 = load i32, ptr %offset_ptr.i.i70.i999, align 4, !noalias !148
  %1053 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1044, 0
  %1054 = insertvalue { ptr, ptr, ptr, i32 } %1053, ptr %1051, 1
  %1055 = insertvalue { ptr, ptr, ptr, i32 } %1054, ptr %1052, 2
  %1056 = insertvalue { ptr, ptr, ptr, i32 } %1055, i32 %offset.i.i71.i1000, 3
  %1057 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1058 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1044)
  %1059 = sext i32 %offset.i.i71.i1000 to i64
  %1060 = getelementptr ptr, ptr %1044, i64 %1059
  %1061 = getelementptr i8, ptr %1060, i64 56
  %1062 = load ptr, ptr %1061, align 8
  %result.i73.i1001 = call ptr %1062({ ptr, ptr, ptr, i32 } %1056, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1063 = call { ptr, i160 } %result.i73.i1001({ ptr, ptr, ptr, i32 } %1056, { ptr, ptr, ptr, i32 } %1056, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i1002 = extractvalue { ptr, i160 } %1063, 0
  %1064 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1065 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1044)
  %1066 = getelementptr i8, ptr %1060, i64 64
  %1067 = load ptr, ptr %1066, align 8
  %result.i74.i1004 = call ptr %1067({ ptr, ptr, ptr, i32 } %1056, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1068 = call i32 %result.i74.i1004({ ptr, ptr, ptr, i32 } %1056, { ptr, ptr, ptr, i32 } %1056, ptr nonnull align 8 %2) #7
  %1069 = icmp eq i32 %1068, %971
  br i1 %1069, label %._crit_edge.i1005, label %HashMap_get_keyK.exit1012.thread

._crit_edge.i1005:                                ; preds = %1047
  %1070 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1071 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1044)
  %1072 = getelementptr i8, ptr %1060, i64 48
  %1073 = load ptr, ptr %1072, align 8
  %result.i75.i1006 = call ptr %1073({ ptr, ptr, ptr, i32 } %1056, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1074 = call { ptr, i160 } %result.i75.i1006({ ptr, ptr, ptr, i32 } %1056, { ptr, ptr, ptr, i32 } %1056, ptr nonnull align 8 %2) #7
  %1075 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1076 = load ptr, ptr %21, align 8
  %1077 = call i1 %1076({ ptr, i160 } %1074, { ptr, i160 } %969) #7
  br i1 %1077, label %HashMap_get_keyK.exit1012, label %HashMap_get_keyK.exit1012.thread

HashMap_get_keyK.exit1012.thread:                 ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1399, %1047, %._crit_edge.i1005
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %1094

HashMap_get_keyK.exit1012:                        ; preds = %._crit_edge.i1005
  %1078 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1079 = load ptr, ptr %15, align 8
  %1080 = load ptr, ptr %1079, align 8
  %1081 = ptrtoint ptr %1080 to i64
  %1082 = getelementptr i8, ptr %.fca.0.extract51.i1002, i64 8
  %1083 = getelementptr i8, ptr %.fca.0.extract51.i1002, i64 16
  %1084 = getelementptr i8, ptr %.fca.0.extract51.i1002, i64 24
  %1085 = getelementptr i8, ptr %.fca.0.extract51.i1002, i64 32
  %1086 = load i64, ptr %1082, align 4
  %1087 = load i64, ptr %1083, align 4
  %1088 = load ptr, ptr %1084, align 8
  %1089 = load ptr, ptr %1085, align 8
  %1090 = load i64, ptr %1080, align 4
  %result.i77.i1009 = call i1 %1088(i64 %1087, i64 %1086, i64 %1090, i64 %1081, ptr readonly %1089) #5
  %cond.fr.i1010 = freeze i1 %result.i77.i1009
  %spec.select.i1011 = select i1 %cond.fr.i1010, ptr %.fca.0.extract51.i1002, ptr @nil_typ
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1091 = icmp eq ptr %spec.select.i1011, @nil_typ
  %1092 = icmp eq ptr %spec.select.i1011, null
  %1093 = or i1 %1091, %1092
  br i1 %1093, label %1094, label %._crit_edge5

1094:                                             ; preds = %HashMap_get_keyK.exit1012.thread, %HashMap_get_keyK.exit1012
  %1095 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  %1096 = sext i32 %.0357711 to i64
  %1097 = shl nsw i64 %1096, 2
  %1098 = getelementptr i8, ptr %result.i4.i, i64 %1097
  store i32 %968, ptr %1098, align 1
  %1099 = add nsw i32 %.0357711, 1
  br label %._crit_edge5

._crit_edge5:                                     ; preds = %1094, %HashMap_get_keyK.exit1012
  %.2 = phi i32 [ %1099, %1094 ], [ %.0357711, %HashMap_get_keyK.exit1012 ]
  %1100 = add nuw nsw i32 %.2360710, 1
  %1101 = icmp slt i32 %.2, %0
  %1102 = icmp slt i32 %1100, %960
  %spec.select384 = select i1 %1101, i1 %1102, i1 false
  br i1 %spec.select384, label %964, label %._crit_edge7._crit_edge

._crit_edge7._crit_edge:                          ; preds = %._crit_edge5, %._crit_edge3._crit_edge
  %.0357.lcssa = phi i32 [ 0, %._crit_edge3._crit_edge ], [ %.2, %._crit_edge5 ]
  %1103 = icmp slt i32 %.0357.lcssa, %0
  br i1 %1103, label %._crit_edge.lr.ph.i, label %._crit_edge8

._crit_edge.lr.ph.i:                              ; preds = %._crit_edge7._crit_edge
  %result.i476 = call noalias align 32 dereferenceable_or_null(30) ptr @bump_malloc_inner(i64 noundef 30, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <29 x i8> <i8 87, i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 67, i8 111, i8 117, i8 108, i8 100, i8 32, i8 111, i8 110, i8 108, i8 121, i8 32, i8 103, i8 101, i8 110, i8 101, i8 114, i8 97, i8 116, i8 101, i8 32>, ptr %result.i476, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1104 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1105 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1413 = call noalias dereferenceable_or_null(30) ptr @bump_malloc_inner(i64 noundef 30, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(29) %result.i.i1413, ptr noundef nonnull align 32 dereferenceable(29) %result.i476, i64 29, i1 false)
  %1106 = getelementptr i8, ptr %result.i.i1413, i64 29
  store i8 0, ptr %1106, align 1
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1413)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1107 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0357.lcssa) #17
  %result.i482 = call noalias align 32 dereferenceable_or_null(23) ptr @bump_malloc_inner(i64 noundef 23, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <22 x i8> <i8 32, i8 103, i8 117, i8 97, i8 114, i8 97, i8 110, i8 116, i8 101, i8 101, i8 100, i8 32, i8 109, i8 105, i8 115, i8 115, i8 32, i8 107, i8 101, i8 121, i8 115, i8 46>, ptr %result.i482, align 32
  %1108 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1109 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1110 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1428 = call noalias dereferenceable_or_null(23) ptr @bump_malloc_inner(i64 noundef 23, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(22) %result.i.i1428, ptr noundef nonnull align 32 dereferenceable(22) %result.i482, i64 22, i1 false)
  %1111 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %1112 = getelementptr i8, ptr %result.i.i1428, i64 22
  store i8 0, ptr %1112, align 1
  %puts.i1061 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1428)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %._crit_edge8

._crit_edge8:                                     ; preds = %._crit_edge7._crit_edge, %._crit_edge.lr.ph.i
  %.0380 = phi i32 [ %.0357.lcssa, %._crit_edge.lr.ph.i ], [ %0, %._crit_edge7._crit_edge ]
  %1113 = call i64 @clock()
  %1114 = icmp sgt i32 %.0380, 0
  br i1 %1114, label %._crit_edge9.preheader, label %1256

._crit_edge9.preheader:                           ; preds = %._crit_edge8
  %1115 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  br label %._crit_edge9

._crit_edge9:                                     ; preds = %._crit_edge9.preheader, %HashMap_get_keyK.exit1122
  %.0365715 = phi i32 [ %.2367, %HashMap_get_keyK.exit1122 ], [ 0, %._crit_edge9.preheader ]
  %.0368714 = phi i32 [ %.2370, %HashMap_get_keyK.exit1122 ], [ 0, %._crit_edge9.preheader ]
  %.0371713 = phi i32 [ %1248, %HashMap_get_keyK.exit1122 ], [ 0, %._crit_edge9.preheader ]
  %1116 = zext nneg i32 %.0371713 to i64
  %1117 = shl nuw nsw i64 %1116, 2
  %1118 = getelementptr i8, ptr %result.i4.i, i64 %1117
  %1119 = load i32, ptr %1118, align 1
  %.sroa.2.sroa.0.0.insert.ext.i = zext i32 %1119 to i160
  %1120 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1121 = load ptr, ptr %10, align 8
  %1122 = call i32 %1121({ ptr, i160 } %1120) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1123 = load i32, ptr %13, align 8
  %1124 = add i32 %1123, -1
  %1125 = and i32 %1124, %1122
  %1126 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1127 = load ptr, ptr %12, align 8
  %1128 = sext i32 %1125 to i64
  %1129 = shl nsw i64 %1128, 5
  %1130 = getelementptr i8, ptr %1127, i64 %1129
  %1131 = load ptr, ptr %1130, align 8
  %1132 = icmp eq ptr %1131, @nil_typ
  %1133 = icmp eq ptr %1131, null
  %1134 = or i1 %1132, %1133
  br i1 %1134, label %HashMap_find_slot_keyK_hashPtri32.exit1478, label %.lr.ph.i1448

.lr.ph.i1448:                                     ; preds = %._crit_edge9
  %1135 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1136

1136:                                             ; preds = %._crit_edge.thread.i1464, %.lr.ph.i1448
  %1137 = phi i32 [ %1125, %.lr.ph.i1448 ], [ %1179, %._crit_edge.thread.i1464 ]
  %spec.store.select.i14691612 = phi i32 [ -1, %.lr.ph.i1448 ], [ %spec.store.select.i1469, %._crit_edge.thread.i1464 ]
  %1138 = phi ptr [ %1131, %.lr.ph.i1448 ], [ %1184, %._crit_edge.thread.i1464 ]
  %1139 = phi ptr [ %1130, %.lr.ph.i1448 ], [ %1183, %._crit_edge.thread.i1464 ]
  %.sroa_idx.i1450 = getelementptr i8, ptr %1139, i64 16
  %1140 = load i64, ptr %.sroa_idx.i1450, align 4
  %1141 = getelementptr i8, ptr %1139, i64 8
  %1142 = load i64, ptr %1141, align 4
  %1143 = inttoptr i64 %1142 to ptr
  %1144 = inttoptr i64 %1140 to ptr
  %hash_coef_ptr.i.i56.i1451 = getelementptr i8, ptr %1138, i64 8
  %tbl_size_ptr.i.i57.i1452 = getelementptr i8, ptr %1138, i64 16
  %offset_tbl_ptr.i.i58.i1453 = getelementptr i8, ptr %1138, i64 40
  %hash_coef.i.i59.i1454 = load i64, ptr %hash_coef_ptr.i.i56.i1451, align 4
  %tbl_size.i.i60.i1455 = load i64, ptr %tbl_size_ptr.i.i57.i1452, align 4
  %offset_tbl.i.i61.i1456 = load ptr, ptr %offset_tbl_ptr.i.i58.i1453, align 8
  %product.i.i.i62.i1457 = mul i64 %hash_coef.i.i59.i1454, 4015701072841558310
  %shifted.i.i.i63.i1458 = lshr i64 %product.i.i.i62.i1457, 32
  %xored.i.i.i64.i1459 = xor i64 %shifted.i.i.i63.i1458, %product.i.i.i62.i1457
  %hash.i.i.i65.i1460 = and i64 %xored.i.i.i64.i1459, %tbl_size.i.i60.i1455
  %offset_ptr.i.i66.i1461 = getelementptr i32, ptr %offset_tbl.i.i61.i1456, i64 %hash.i.i.i65.i1460
  %offset.i.i67.i1462 = load i32, ptr %offset_ptr.i.i66.i1461, align 4
  %1145 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1138, 0
  %1146 = insertvalue { ptr, ptr, ptr, i32 } %1145, ptr %1143, 1
  %1147 = insertvalue { ptr, ptr, ptr, i32 } %1146, ptr %1144, 2
  %1148 = insertvalue { ptr, ptr, ptr, i32 } %1147, i32 %offset.i.i67.i1462, 3
  %1149 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1138)
  %1150 = sext i32 %offset.i.i67.i1462 to i64
  %1151 = getelementptr ptr, ptr %1138, i64 %1150
  %1152 = getelementptr i8, ptr %1151, i64 64
  %1153 = load ptr, ptr %1152, align 8
  %result.i.i1463 = call ptr %1153({ ptr, ptr, ptr, i32 } %1148, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1154 = call i32 %result.i.i1463({ ptr, ptr, ptr, i32 } %1148, { ptr, ptr, ptr, i32 } %1148, ptr nonnull align 8 %2) #7
  %1155 = icmp eq i32 %1154, %1122
  br i1 %1155, label %._crit_edge.i1475, label %._crit_edge.thread.i1464

._crit_edge.i1475:                                ; preds = %1136
  %1156 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1157 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1138)
  %1158 = getelementptr i8, ptr %1151, i64 48
  %1159 = load ptr, ptr %1158, align 8
  %result.i69.i1476 = call ptr %1159({ ptr, ptr, ptr, i32 } %1148, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1160 = call { ptr, i160 } %result.i69.i1476({ ptr, ptr, ptr, i32 } %1148, { ptr, ptr, ptr, i32 } %1148, ptr nonnull align 8 %2) #7
  %1161 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1162 = load ptr, ptr %11, align 8
  %1163 = call i1 %1162({ ptr, i160 } %1160, { ptr, i160 } %1120) #7
  br i1 %1163, label %HashMap_find_slot_keyK_hashPtri32.exit1478.loopexit, label %._crit_edge.thread.i1464

._crit_edge.thread.i1464:                         ; preds = %._crit_edge.i1475, %1136
  %1164 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1165 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1138)
  %1166 = getelementptr i8, ptr %1151, i64 56
  %1167 = load ptr, ptr %1166, align 8
  %result.i70.i1465 = call ptr %1167({ ptr, ptr, ptr, i32 } %1148, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1168 = call { ptr, i160 } %result.i70.i1465({ ptr, ptr, ptr, i32 } %1148, { ptr, ptr, ptr, i32 } %1148, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i1466 = extractvalue { ptr, i160 } %1168, 0
  %1169 = getelementptr i8, ptr %.fca.0.extract19.i1466, i64 8
  %1170 = getelementptr i8, ptr %.fca.0.extract19.i1466, i64 16
  %1171 = getelementptr i8, ptr %.fca.0.extract19.i1466, i64 24
  %1172 = getelementptr i8, ptr %.fca.0.extract19.i1466, i64 32
  %1173 = load i64, ptr %1169, align 4
  %1174 = load i64, ptr %1170, align 4
  %1175 = load ptr, ptr %1171, align 8
  %1176 = load ptr, ptr %1172, align 8
  %result.i71.i1467 = call i1 %1175(i64 %1174, i64 %1173, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %1176) #5
  %1177 = icmp eq i32 %spec.store.select.i14691612, -1
  %or.cond.i1468 = select i1 %result.i71.i1467, i1 %1177, i1 false
  %spec.store.select.i1469 = select i1 %or.cond.i1468, i32 %1137, i32 %spec.store.select.i14691612
  %1178 = add i32 %1137, 1
  %1179 = and i32 %1178, %1124
  %1180 = load ptr, ptr %12, align 8
  %1181 = sext i32 %1179 to i64
  %1182 = shl nsw i64 %1181, 5
  %1183 = getelementptr i8, ptr %1180, i64 %1182
  %1184 = load ptr, ptr %1183, align 8
  %1185 = icmp eq ptr %1184, @nil_typ
  %1186 = icmp eq ptr %1184, null
  %1187 = or i1 %1185, %1186
  br i1 %1187, label %._crit_edge105.loopexit.i1471, label %1136

._crit_edge105.loopexit.i1471:                    ; preds = %._crit_edge.thread.i1464
  %1188 = icmp eq i32 %spec.store.select.i1469, -1
  %.pre.i1474.pre = select i1 %1188, i32 %1179, i32 %spec.store.select.i1469
  br label %HashMap_find_slot_keyK_hashPtri32.exit1478

HashMap_find_slot_keyK_hashPtri32.exit1478.loopexit: ; preds = %._crit_edge.i1475
  %.pre1665 = load ptr, ptr %12, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit1478

HashMap_find_slot_keyK_hashPtri32.exit1478:       ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1478.loopexit, %._crit_edge9, %._crit_edge105.loopexit.i1471
  %1189 = phi ptr [ %1180, %._crit_edge105.loopexit.i1471 ], [ %1127, %._crit_edge9 ], [ %.pre1665, %HashMap_find_slot_keyK_hashPtri32.exit1478.loopexit ]
  %1190 = phi i32 [ %.pre.i1474.pre, %._crit_edge105.loopexit.i1471 ], [ %1125, %._crit_edge9 ], [ %1137, %HashMap_find_slot_keyK_hashPtri32.exit1478.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1191 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1192 = sext i32 %1190 to i64
  %1193 = shl nsw i64 %1192, 5
  %1194 = getelementptr i8, ptr %1189, i64 %1193
  %1195 = load ptr, ptr %1194, align 8
  %1196 = icmp ne ptr %1195, @nil_typ
  %1197 = icmp ne ptr %1195, null
  %.not57.i1094 = and i1 %1196, %1197
  br i1 %.not57.i1094, label %1198, label %HashMap_get_keyK.exit1122

1198:                                             ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1478
  %1199 = getelementptr i8, ptr %1194, i64 8
  %1200 = load i64, ptr %1199, align 4
  %.sroa_idx.i1098 = getelementptr i8, ptr %1194, i64 16
  %1201 = load i64, ptr %.sroa_idx.i1098, align 4
  %1202 = inttoptr i64 %1200 to ptr
  %1203 = inttoptr i64 %1201 to ptr
  %hash_coef_ptr.i.i60.i1099 = getelementptr i8, ptr %1195, i64 8
  %tbl_size_ptr.i.i61.i1100 = getelementptr i8, ptr %1195, i64 16
  %offset_tbl_ptr.i.i62.i1101 = getelementptr i8, ptr %1195, i64 40
  %hash_coef.i.i63.i1102 = load i64, ptr %hash_coef_ptr.i.i60.i1099, align 4, !noalias !151
  %tbl_size.i.i64.i1103 = load i64, ptr %tbl_size_ptr.i.i61.i1100, align 4, !noalias !151
  %offset_tbl.i.i65.i1104 = load ptr, ptr %offset_tbl_ptr.i.i62.i1101, align 8, !noalias !151
  %product.i.i.i66.i1105 = mul i64 %hash_coef.i.i63.i1102, 4015701072841558310
  %shifted.i.i.i67.i1106 = lshr i64 %product.i.i.i66.i1105, 32
  %xored.i.i.i68.i1107 = xor i64 %shifted.i.i.i67.i1106, %product.i.i.i66.i1105
  %hash.i.i.i69.i1108 = and i64 %xored.i.i.i68.i1107, %tbl_size.i.i64.i1103
  %offset_ptr.i.i70.i1109 = getelementptr i32, ptr %offset_tbl.i.i65.i1104, i64 %hash.i.i.i69.i1108
  %offset.i.i71.i1110 = load i32, ptr %offset_ptr.i.i70.i1109, align 4, !noalias !151
  %1204 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1195, 0
  %1205 = insertvalue { ptr, ptr, ptr, i32 } %1204, ptr %1202, 1
  %1206 = insertvalue { ptr, ptr, ptr, i32 } %1205, ptr %1203, 2
  %1207 = insertvalue { ptr, ptr, ptr, i32 } %1206, i32 %offset.i.i71.i1110, 3
  %1208 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1209 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1195)
  %1210 = sext i32 %offset.i.i71.i1110 to i64
  %1211 = getelementptr ptr, ptr %1195, i64 %1210
  %1212 = getelementptr i8, ptr %1211, i64 56
  %1213 = load ptr, ptr %1212, align 8
  %result.i73.i1111 = call ptr %1213({ ptr, ptr, ptr, i32 } %1207, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1214 = call { ptr, i160 } %result.i73.i1111({ ptr, ptr, ptr, i32 } %1207, { ptr, ptr, ptr, i32 } %1207, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i1112 = extractvalue { ptr, i160 } %1214, 0
  %1215 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1216 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1195)
  %1217 = getelementptr i8, ptr %1211, i64 64
  %1218 = load ptr, ptr %1217, align 8
  %result.i74.i1114 = call ptr %1218({ ptr, ptr, ptr, i32 } %1207, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1219 = call i32 %result.i74.i1114({ ptr, ptr, ptr, i32 } %1207, { ptr, ptr, ptr, i32 } %1207, ptr nonnull align 8 %2) #7
  %1220 = icmp eq i32 %1219, %1122
  br i1 %1220, label %._crit_edge.i1115, label %HashMap_get_keyK.exit1122

._crit_edge.i1115:                                ; preds = %1198
  %1221 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1222 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1195)
  %1223 = getelementptr i8, ptr %1211, i64 48
  %1224 = load ptr, ptr %1223, align 8
  %result.i75.i1116 = call ptr %1224({ ptr, ptr, ptr, i32 } %1207, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1225 = call { ptr, i160 } %result.i75.i1116({ ptr, ptr, ptr, i32 } %1207, { ptr, ptr, ptr, i32 } %1207, ptr nonnull align 8 %2) #7
  %1226 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1227 = load ptr, ptr %11, align 8
  %1228 = call i1 %1227({ ptr, i160 } %1225, { ptr, i160 } %1120) #7
  br i1 %1228, label %1229, label %HashMap_get_keyK.exit1122

1229:                                             ; preds = %._crit_edge.i1115
  %1230 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1231 = load ptr, ptr %5, align 8
  %1232 = load ptr, ptr %1231, align 8
  %1233 = ptrtoint ptr %1232 to i64
  %1234 = getelementptr i8, ptr %.fca.0.extract51.i1112, i64 8
  %1235 = getelementptr i8, ptr %.fca.0.extract51.i1112, i64 16
  %1236 = getelementptr i8, ptr %.fca.0.extract51.i1112, i64 24
  %1237 = getelementptr i8, ptr %.fca.0.extract51.i1112, i64 32
  %1238 = load i64, ptr %1234, align 4
  %1239 = load i64, ptr %1235, align 4
  %1240 = load ptr, ptr %1236, align 8
  %1241 = load ptr, ptr %1237, align 8
  %1242 = load i64, ptr %1232, align 4
  %result.i77.i1119 = call i1 %1240(i64 %1239, i64 %1238, i64 %1242, i64 %1233, ptr readonly %1241) #5
  %cond.fr.i1120 = freeze i1 %result.i77.i1119
  %spec.select.i1121 = select i1 %cond.fr.i1120, ptr %.fca.0.extract51.i1112, ptr @nil_typ
  br label %HashMap_get_keyK.exit1122

HashMap_get_keyK.exit1122:                        ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1478, %1198, %._crit_edge.i1115, %1229
  %1243 = phi ptr [ @nil_typ, %HashMap_find_slot_keyK_hashPtri32.exit1478 ], [ @nil_typ, %1198 ], [ @nil_typ, %._crit_edge.i1115 ], [ %spec.select.i1121, %1229 ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1244 = icmp eq ptr %1243, @nil_typ
  %1245 = icmp eq ptr %1243, null
  %1246 = or i1 %1244, %1245
  %.0365..0368 = select i1 %1246, i32 %.0365715, i32 %.0368714
  %1247 = add i32 %.0365..0368, 1
  %.2370 = select i1 %1246, i32 %.0368714, i32 %1247
  %.2367 = select i1 %1246, i32 %1247, i32 %.0365715
  %1248 = add nuw nsw i32 %.0371713, 1
  %1249 = icmp slt i32 %1248, %.0380
  br i1 %1249, label %._crit_edge9, label %1250

1250:                                             ; preds = %HashMap_get_keyK.exit1122
  %1251 = call i64 @clock()
  %1252 = mul i32 %.2370, 100
  %1253 = sdiv i32 %1252, %.0380
  %1254 = icmp slt i32 %1253, 5
  %1255 = select i1 %1254, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  br label %._crit_edge.lr.ph.i1493

1256:                                             ; preds = %._crit_edge8
  %1257 = call i64 @clock()
  br label %._crit_edge.lr.ph.i1493

._crit_edge.lr.ph.i1493:                          ; preds = %1256, %1250
  %1258 = phi i64 [ %1251, %1250 ], [ %1257, %1256 ]
  %.0365.lcssa722 = phi i32 [ %.2367, %1250 ], [ 0, %1256 ]
  %.0368.lcssa720 = phi i32 [ %.2370, %1250 ], [ 0, %1256 ]
  %.reg2mem27.0.in = phi <4 x i8> [ %1255, %1250 ], [ <i8 80, i8 65, i8 83, i8 83>, %1256 ]
  %result.i489 = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <15 x i8> <i8 71, i8 101, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109, i8 32, i8 77, i8 105, i8 115, i8 115>, ptr %result.i489, align 16
  %1259 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #34
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1260 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1261 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1492 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i1492, ptr noundef nonnull align 16 dereferenceable(15) %result.i489, i64 15, i1 false)
  %1262 = sub i64 %1258, %1113
  %1263 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %1264 = getelementptr i8, ptr %result.i.i1492, i64 15
  store i8 0, ptr %1264, align 1
  %puts.i1142 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1492)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i97.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i97.i, align 16
  %result.i.i375.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i375.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i97.i, i64 14, i1 false)
  %puts.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i375.i)
  %1265 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0380) #17
  %result.i103.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i103.i, align 16
  %result.i.i389.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i389.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i103.i, i64 14, i1 false)
  %puts.i313.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i389.i)
  %1266 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %1262) #17
  %result.i109.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i109.i, align 4
  %result.i.i408.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i408.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i109.i, i64 3, i1 false)
  %puts.i333.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i408.i)
  br i1 %1114, label %._crit_edge1.i, label %._crit_edge.lr.ph.i1512

._crit_edge1.i:                                   ; preds = %._crit_edge.lr.ph.i1493
  %1267 = icmp sgt i64 %1262, 0
  br i1 %1267, label %1268, label %._crit_edge.lr.ph.i428.i

1268:                                             ; preds = %._crit_edge1.i
  %1269 = zext nneg i32 %.0380 to i64
  %1270 = mul i64 %1262, 1000000
  %1271 = sdiv i64 %1270, %1269
  br label %._crit_edge.lr.ph.i428.i

._crit_edge.lr.ph.i428.i:                         ; preds = %1268, %._crit_edge1.i
  %.0.i = phi i64 [ %1271, %1268 ], [ 0, %._crit_edge1.i ]
  %result.i114.i = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i114.i, align 16
  %result.i.i427.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i427.i, ptr noundef nonnull align 16 dereferenceable(15) %result.i114.i, i64 15, i1 false)
  %puts.i353.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i427.i)
  %1272 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0.i) #17
  %result.i120.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i120.i, align 4
  %result.i.i446.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i446.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i120.i, i64 3, i1 false)
  %puts.i373.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i446.i)
  br label %._crit_edge.lr.ph.i1512

._crit_edge.lr.ph.i1512:                          ; preds = %._crit_edge.lr.ph.i1493, %._crit_edge.lr.ph.i428.i
  %result.i493 = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i493, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1273 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1274 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1511 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i1511, ptr noundef nonnull align 32 dereferenceable(18) %result.i493, i64 18, i1 false)
  %1275 = getelementptr i8, ptr %result.i.i1511, i64 18
  store i8 0, ptr %1275, align 1
  %puts.i1162 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1511)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1276 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1277 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1530 = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <4 x i8> %.reg2mem27.0.in, ptr %result.i.i1530, align 1
  %1278 = getelementptr i8, ptr %result.i.i1530, i64 4
  store i8 0, ptr %1278, align 1
  %puts.i1182 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1530)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i508 = call noalias align 16 dereferenceable_or_null(14) ptr @bump_malloc_inner(i64 noundef 14, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <13 x i8> <i8 32, i8 32, i8 32, i8 32, i8 40, i8 77, i8 105, i8 115, i8 115, i8 101, i8 115, i8 58, i8 32>, ptr %result.i508, align 16
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1279 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1280 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1549 = call noalias dereferenceable_or_null(14) ptr @bump_malloc_inner(i64 noundef 14, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(13) %result.i.i1549, ptr noundef nonnull align 16 dereferenceable(13) %result.i508, i64 13, i1 false)
  %1281 = getelementptr i8, ptr %result.i.i1549, i64 13
  store i8 0, ptr %1281, align 1
  %puts.i1202 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1549)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1282 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0365.lcssa722) #17
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1283 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1284 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1568 = call noalias dereferenceable_or_null(9) ptr @bump_malloc_inner(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store i64 2322295501682647084, ptr %result.i.i1568, align 1
  %1285 = getelementptr i8, ptr %result.i.i1568, i64 8
  store i8 0, ptr %1285, align 1
  %puts.i1222 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1568)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1286 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0368.lcssa720) #17
  %1287 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1288 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1289 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1587 = call noalias dereferenceable_or_null(2) ptr @bump_malloc_inner(i64 noundef 2, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store i8 41, ptr %result.i.i1587, align 1
  %1290 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %1291 = getelementptr i8, ptr %result.i.i1587, i64 1
  store i8 0, ptr %1291, align 1
  %puts.i1242 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1587)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  ret void
}

define void @benchmark_remove_random(i32 %0) local_unnamed_addr {
  %2 = alloca [0 x ptr], align 8
  %3 = alloca [3 x ptr], align 8
  %4 = alloca [3 x ptr], align 8
  %oldProtect.i427 = alloca i32, align 4
  %oldProtect.i423 = alloca i32, align 4
  %oldProtect.i382 = alloca i32, align 4
  %oldProtect.i = alloca i32, align 4
  %.sroa.0316.sroa.0 = alloca i8, align 8
  %result.i378 = tail call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i378, align 8
  %5 = getelementptr inbounds i8, ptr %result.i378, i64 8
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %6 = getelementptr inbounds i8, ptr %result.i378, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %6, align 8
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i378) #38
  %result.i379 = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i)
  %result.i380 = call i32 @VirtualProtect(ptr nofree %result.i379, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i379, ptr noalias nofree noundef nonnull readnone @wnqcnuwksw, ptr noalias nofree noundef nonnull readnone @i32_hasher) #38
  %ret.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i379) #39
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i379) #38
  %result.i381 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i382)
  %result.i383 = call i32 @VirtualProtect(ptr nofree %result.i381, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i382) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i382)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i381, ptr noalias nofree noundef nonnull readnone @jxklgmxkzf, ptr noalias nofree noundef nonnull readnone @i32_eq) #38
  %ret.i384 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i381) #39
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i381) #38
  %10 = getelementptr inbounds i8, ptr %result.i378, i64 48
  store ptr %ret.i, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %result.i378, i64 56
  store ptr %ret.i384, ptr %11, align 8
  %result.i.i736 = call noalias dereferenceable_or_null(512) ptr @bump_malloc_inner(i64 noundef 512, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %12 = getelementptr inbounds i8, ptr %result.i378, i64 24
  store ptr %result.i.i736, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %result.i378, i64 32
  store i32 16, ptr %13, align 8
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #34
  %result.i404 = call noalias nonnull align 8 dereferenceable(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i404, align 8
  %15 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %result.i404)
  %16 = getelementptr inbounds i8, ptr %result.i404, i64 20
  store i32 %0, ptr %16, align 4
  %17 = sext i32 %0 to i64
  %18 = shl nsw i64 %17, 2
  %result.i4.i = call noalias ptr @bump_malloc_inner(i64 noundef %18, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %19 = getelementptr inbounds i8, ptr %result.i404, i64 8
  store ptr %result.i4.i, ptr %19, align 8
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #34
  %result.i421 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i421, align 8
  %21 = getelementptr inbounds i8, ptr %result.i421, i64 8
  store ptr @_parameterization_Ptri1, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i421, i64 16
  store ptr @_parameterization_PairPtri32._Ptri1, ptr %22, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i421)
  %result.i422 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i423)
  %result.i424 = call i32 @VirtualProtect(ptr nofree %result.i422, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i423) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i423)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i422, ptr noalias nofree noundef nonnull readnone @fwguoiyozn, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %ret.i425 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i422) #39
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i422)
  %result.i426 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i427)
  %result.i428 = call i32 @VirtualProtect(ptr nofree %result.i426, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i427) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i427)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i426, ptr noalias nofree noundef nonnull readnone @obvzesuyhl, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %ret.i429 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i426) #39
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i426)
  %26 = getelementptr inbounds i8, ptr %result.i421, i64 48
  store ptr %ret.i425, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %result.i421, i64 56
  store ptr %ret.i429, ptr %27, align 8
  %result.i.i776 = call noalias dereferenceable_or_null(512) ptr @bump_malloc_inner(i64 noundef 512, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %28 = getelementptr inbounds i8, ptr %result.i421, i64 24
  store ptr %result.i.i776, ptr %28, align 8
  %29 = getelementptr inbounds i8, ptr %result.i421, i64 32
  store i32 16, ptr %29, align 8
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #34
  %31 = mul i32 %0, 10
  %32 = icmp sgt i32 %0, 0
  %33 = icmp sgt i32 %31, 0
  %spec.select714 = and i1 %32, %33
  br i1 %spec.select714, label %.lr.ph, label %._crit_edge3._crit_edge

.lr.ph:                                           ; preds = %1
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #34
  %36 = getelementptr inbounds i8, ptr %result.i378, i64 40
  %37 = getelementptr inbounds i8, ptr %result.i421, i64 40
  %38 = getelementptr inbounds i8, ptr %result.i378, i64 36
  %39 = getelementptr inbounds i8, ptr %result.i421, i64 36
  %40 = getelementptr inbounds i8, ptr %4, i64 8
  %41 = getelementptr inbounds i8, ptr %4, i64 16
  %42 = getelementptr inbounds i8, ptr %3, i64 8
  %43 = getelementptr inbounds i8, ptr %3, i64 16
  br label %44

44:                                               ; preds = %.lr.ph, %._crit_edge1
  %45 = phi i32 [ 101112, %.lr.ph ], [ %48, %._crit_edge1 ]
  %.0355716 = phi i32 [ 0, %.lr.ph ], [ %964, %._crit_edge1 ]
  %.0357715 = phi i32 [ 0, %.lr.ph ], [ %.2359, %._crit_edge1 ]
  %46 = mul i32 %45, 1103515245
  %47 = add i32 %46, 12345
  %48 = and i32 %47, 2147483647
  %.sroa.0343.0.insert.ext = zext nneg i32 %48 to i160
  %49 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0343.0.insert.ext, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %50 = load ptr, ptr %26, align 8
  %51 = call i32 %50({ ptr, i160 } %49) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %52 = load i32, ptr %29, align 8
  %53 = add i32 %52, -1
  %54 = and i32 %53, %51
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %56 = load ptr, ptr %28, align 8
  %57 = sext i32 %54 to i64
  %58 = shl nsw i64 %57, 5
  %59 = getelementptr i8, ptr %56, i64 %58
  %60 = load ptr, ptr %59, align 8
  %61 = icmp eq ptr %60, @nil_typ
  %62 = icmp eq ptr %60, null
  %63 = or i1 %61, %62
  br i1 %63, label %HashMap_find_slot_keyK_hashPtri32.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %44
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %65

65:                                               ; preds = %._crit_edge.thread.i, %.lr.ph.i
  %66 = phi i32 [ %54, %.lr.ph.i ], [ %108, %._crit_edge.thread.i ]
  %spec.store.select.i1646 = phi i32 [ -1, %.lr.ph.i ], [ %spec.store.select.i, %._crit_edge.thread.i ]
  %67 = phi ptr [ %60, %.lr.ph.i ], [ %113, %._crit_edge.thread.i ]
  %68 = phi ptr [ %59, %.lr.ph.i ], [ %112, %._crit_edge.thread.i ]
  %.sroa_idx.i1277 = getelementptr i8, ptr %68, i64 16
  %69 = load i64, ptr %.sroa_idx.i1277, align 4
  %70 = getelementptr i8, ptr %68, i64 8
  %71 = load i64, ptr %70, align 4
  %72 = inttoptr i64 %71 to ptr
  %73 = inttoptr i64 %69 to ptr
  %hash_coef_ptr.i.i56.i = getelementptr i8, ptr %67, i64 8
  %tbl_size_ptr.i.i57.i = getelementptr i8, ptr %67, i64 16
  %offset_tbl_ptr.i.i58.i = getelementptr i8, ptr %67, i64 40
  %hash_coef.i.i59.i = load i64, ptr %hash_coef_ptr.i.i56.i, align 4
  %tbl_size.i.i60.i = load i64, ptr %tbl_size_ptr.i.i57.i, align 4
  %offset_tbl.i.i61.i = load ptr, ptr %offset_tbl_ptr.i.i58.i, align 8
  %product.i.i.i62.i = mul i64 %hash_coef.i.i59.i, 4015701072841558310
  %shifted.i.i.i63.i = lshr i64 %product.i.i.i62.i, 32
  %xored.i.i.i64.i = xor i64 %shifted.i.i.i63.i, %product.i.i.i62.i
  %hash.i.i.i65.i = and i64 %xored.i.i.i64.i, %tbl_size.i.i60.i
  %offset_ptr.i.i66.i = getelementptr i32, ptr %offset_tbl.i.i61.i, i64 %hash.i.i.i65.i
  %offset.i.i67.i = load i32, ptr %offset_ptr.i.i66.i, align 4
  %74 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %67, 0
  %75 = insertvalue { ptr, ptr, ptr, i32 } %74, ptr %72, 1
  %76 = insertvalue { ptr, ptr, ptr, i32 } %75, ptr %73, 2
  %77 = insertvalue { ptr, ptr, ptr, i32 } %76, i32 %offset.i.i67.i, 3
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %67)
  %79 = sext i32 %offset.i.i67.i to i64
  %80 = getelementptr ptr, ptr %67, i64 %79
  %81 = getelementptr i8, ptr %80, i64 64
  %82 = load ptr, ptr %81, align 8
  %result.i.i = call ptr %82({ ptr, ptr, ptr, i32 } %77, ptr nocapture nofree noundef nonnull readonly %2) #16
  %83 = call i32 %result.i.i({ ptr, ptr, ptr, i32 } %77, { ptr, ptr, ptr, i32 } %77, ptr nonnull align 8 %2) #7
  %84 = icmp eq i32 %83, %51
  br i1 %84, label %._crit_edge.i1278, label %._crit_edge.thread.i

._crit_edge.i1278:                                ; preds = %65
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %86 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %67)
  %87 = getelementptr i8, ptr %80, i64 48
  %88 = load ptr, ptr %87, align 8
  %result.i69.i = call ptr %88({ ptr, ptr, ptr, i32 } %77, ptr nocapture nofree noundef nonnull readonly %2) #16
  %89 = call { ptr, i160 } %result.i69.i({ ptr, ptr, ptr, i32 } %77, { ptr, ptr, ptr, i32 } %77, ptr nonnull align 8 %2) #7
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %91 = load ptr, ptr %27, align 8
  %92 = call i1 %91({ ptr, i160 } %89, { ptr, i160 } %49) #7
  br i1 %92, label %HashMap_find_slot_keyK_hashPtri32.exit.loopexit, label %._crit_edge.thread.i

._crit_edge.thread.i:                             ; preds = %._crit_edge.i1278, %65
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %94 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %67)
  %95 = getelementptr i8, ptr %80, i64 56
  %96 = load ptr, ptr %95, align 8
  %result.i70.i = call ptr %96({ ptr, ptr, ptr, i32 } %77, ptr nocapture nofree noundef nonnull readonly %2) #16
  %97 = call { ptr, i160 } %result.i70.i({ ptr, ptr, ptr, i32 } %77, { ptr, ptr, ptr, i32 } %77, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i = extractvalue { ptr, i160 } %97, 0
  %98 = getelementptr i8, ptr %.fca.0.extract19.i, i64 8
  %99 = getelementptr i8, ptr %.fca.0.extract19.i, i64 16
  %100 = getelementptr i8, ptr %.fca.0.extract19.i, i64 24
  %101 = getelementptr i8, ptr %.fca.0.extract19.i, i64 32
  %102 = load i64, ptr %98, align 4
  %103 = load i64, ptr %99, align 4
  %104 = load ptr, ptr %100, align 8
  %105 = load ptr, ptr %101, align 8
  %result.i71.i = call i1 %104(i64 %103, i64 %102, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %105) #5
  %106 = icmp eq i32 %spec.store.select.i1646, -1
  %or.cond.i = select i1 %result.i71.i, i1 %106, i1 false
  %spec.store.select.i = select i1 %or.cond.i, i32 %66, i32 %spec.store.select.i1646
  %107 = add i32 %66, 1
  %108 = and i32 %107, %53
  %109 = load ptr, ptr %28, align 8
  %110 = sext i32 %108 to i64
  %111 = shl nsw i64 %110, 5
  %112 = getelementptr i8, ptr %109, i64 %111
  %113 = load ptr, ptr %112, align 8
  %114 = icmp eq ptr %113, @nil_typ
  %115 = icmp eq ptr %113, null
  %116 = or i1 %114, %115
  br i1 %116, label %._crit_edge105.loopexit.i, label %65

._crit_edge105.loopexit.i:                        ; preds = %._crit_edge.thread.i
  %117 = icmp eq i32 %spec.store.select.i, -1
  %.pre.i.pre = select i1 %117, i32 %108, i32 %spec.store.select.i
  br label %HashMap_find_slot_keyK_hashPtri32.exit

HashMap_find_slot_keyK_hashPtri32.exit.loopexit:  ; preds = %._crit_edge.i1278
  %.pre = load ptr, ptr %28, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit

HashMap_find_slot_keyK_hashPtri32.exit:           ; preds = %HashMap_find_slot_keyK_hashPtri32.exit.loopexit, %44, %._crit_edge105.loopexit.i
  %118 = phi ptr [ %109, %._crit_edge105.loopexit.i ], [ %56, %44 ], [ %.pre, %HashMap_find_slot_keyK_hashPtri32.exit.loopexit ]
  %119 = phi i32 [ %.pre.i.pre, %._crit_edge105.loopexit.i ], [ %54, %44 ], [ %66, %HashMap_find_slot_keyK_hashPtri32.exit.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %120 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %121 = sext i32 %119 to i64
  %122 = shl nsw i64 %121, 5
  %123 = getelementptr i8, ptr %118, i64 %122
  %124 = load ptr, ptr %123, align 8
  %125 = icmp ne ptr %124, @nil_typ
  %126 = icmp ne ptr %124, null
  %.not57.i = and i1 %125, %126
  br i1 %.not57.i, label %127, label %HashMap_get_keyK.exit.thread

127:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit
  %128 = getelementptr i8, ptr %123, i64 8
  %129 = load i64, ptr %128, align 4
  %.sroa_idx.i = getelementptr i8, ptr %123, i64 16
  %130 = load i64, ptr %.sroa_idx.i, align 4
  %131 = inttoptr i64 %129 to ptr
  %132 = inttoptr i64 %130 to ptr
  %hash_coef_ptr.i.i60.i = getelementptr i8, ptr %124, i64 8
  %tbl_size_ptr.i.i61.i = getelementptr i8, ptr %124, i64 16
  %offset_tbl_ptr.i.i62.i = getelementptr i8, ptr %124, i64 40
  %hash_coef.i.i63.i = load i64, ptr %hash_coef_ptr.i.i60.i, align 4, !noalias !154
  %tbl_size.i.i64.i = load i64, ptr %tbl_size_ptr.i.i61.i, align 4, !noalias !154
  %offset_tbl.i.i65.i = load ptr, ptr %offset_tbl_ptr.i.i62.i, align 8, !noalias !154
  %product.i.i.i66.i = mul i64 %hash_coef.i.i63.i, 4015701072841558310
  %shifted.i.i.i67.i = lshr i64 %product.i.i.i66.i, 32
  %xored.i.i.i68.i = xor i64 %shifted.i.i.i67.i, %product.i.i.i66.i
  %hash.i.i.i69.i = and i64 %xored.i.i.i68.i, %tbl_size.i.i64.i
  %offset_ptr.i.i70.i = getelementptr i32, ptr %offset_tbl.i.i65.i, i64 %hash.i.i.i69.i
  %offset.i.i71.i = load i32, ptr %offset_ptr.i.i70.i, align 4, !noalias !154
  %133 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %124, 0
  %134 = insertvalue { ptr, ptr, ptr, i32 } %133, ptr %131, 1
  %135 = insertvalue { ptr, ptr, ptr, i32 } %134, ptr %132, 2
  %136 = insertvalue { ptr, ptr, ptr, i32 } %135, i32 %offset.i.i71.i, 3
  %137 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %138 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %124)
  %139 = sext i32 %offset.i.i71.i to i64
  %140 = getelementptr ptr, ptr %124, i64 %139
  %141 = getelementptr i8, ptr %140, i64 56
  %142 = load ptr, ptr %141, align 8
  %result.i73.i = call ptr %142({ ptr, ptr, ptr, i32 } %136, ptr nocapture nofree noundef nonnull readonly %2) #16
  %143 = call { ptr, i160 } %result.i73.i({ ptr, ptr, ptr, i32 } %136, { ptr, ptr, ptr, i32 } %136, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i = extractvalue { ptr, i160 } %143, 0
  %144 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %145 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %124)
  %146 = getelementptr i8, ptr %140, i64 64
  %147 = load ptr, ptr %146, align 8
  %result.i74.i = call ptr %147({ ptr, ptr, ptr, i32 } %136, ptr nocapture nofree noundef nonnull readonly %2) #16
  %148 = call i32 %result.i74.i({ ptr, ptr, ptr, i32 } %136, { ptr, ptr, ptr, i32 } %136, ptr nonnull align 8 %2) #7
  %149 = icmp eq i32 %148, %51
  br i1 %149, label %._crit_edge.i, label %HashMap_get_keyK.exit.thread

._crit_edge.i:                                    ; preds = %127
  %150 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %151 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %124)
  %152 = getelementptr i8, ptr %140, i64 48
  %153 = load ptr, ptr %152, align 8
  %result.i75.i = call ptr %153({ ptr, ptr, ptr, i32 } %136, ptr nocapture nofree noundef nonnull readonly %2) #16
  %154 = call { ptr, i160 } %result.i75.i({ ptr, ptr, ptr, i32 } %136, { ptr, ptr, ptr, i32 } %136, ptr nonnull align 8 %2) #7
  %155 = load ptr, ptr %27, align 8
  %156 = call i1 %155({ ptr, i160 } %154, { ptr, i160 } %49) #7
  br i1 %156, label %HashMap_get_keyK.exit, label %HashMap_get_keyK.exit.thread

HashMap_get_keyK.exit.thread:                     ; preds = %HashMap_find_slot_keyK_hashPtri32.exit, %127, %._crit_edge.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %173

HashMap_get_keyK.exit:                            ; preds = %._crit_edge.i
  %157 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %158 = load ptr, ptr %21, align 8
  %159 = load ptr, ptr %158, align 8
  %160 = ptrtoint ptr %159 to i64
  %161 = getelementptr i8, ptr %.fca.0.extract51.i, i64 8
  %162 = getelementptr i8, ptr %.fca.0.extract51.i, i64 16
  %163 = getelementptr i8, ptr %.fca.0.extract51.i, i64 24
  %164 = getelementptr i8, ptr %.fca.0.extract51.i, i64 32
  %165 = load i64, ptr %161, align 4
  %166 = load i64, ptr %162, align 4
  %167 = load ptr, ptr %163, align 8
  %168 = load ptr, ptr %164, align 8
  %169 = load i64, ptr %159, align 4
  %result.i77.i = call i1 %167(i64 %166, i64 %165, i64 %169, i64 %160, ptr readonly %168) #5
  %cond.fr.i = freeze i1 %result.i77.i
  %spec.select.i = select i1 %cond.fr.i, ptr %.fca.0.extract51.i, ptr @nil_typ
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %170 = icmp eq ptr %spec.select.i, @nil_typ
  %171 = icmp eq ptr %spec.select.i, null
  %172 = or i1 %170, %171
  br i1 %172, label %173, label %._crit_edge1

173:                                              ; preds = %HashMap_get_keyK.exit.thread, %HashMap_get_keyK.exit
  %174 = add nuw i32 %48, 1
  %.sroa.0326.0.insert.ext = zext i32 %174 to i160
  %175 = load i32, ptr %36, align 8
  %176 = load i32, ptr %13, align 8
  %177 = icmp eq i32 %176, 0
  %178 = mul i32 %175, 10
  %179 = add i32 %178, 10
  %180 = mul i32 %176, 6
  %181 = icmp sge i32 %179, %180
  %.0.i1291 = select i1 %177, i1 true, i1 %181
  br i1 %.0.i1291, label %._crit_edge1.i1293, label %HashMap_ensure_capacity_required_loadPtri32.exit

._crit_edge1.i1293:                               ; preds = %173
  %182 = shl i32 %176, 1
  %spec.select.i1294 = call i32 @llvm.smax.i32(i32 %182, i32 16)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %183 = load ptr, ptr %12, align 8
  %184 = zext nneg i32 %spec.select.i1294 to i64
  %185 = shl nuw nsw i64 %184, 5
  %result.i.i1725 = call noalias ptr @bump_malloc_inner(i64 noundef %185, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1725, ptr %12, align 8
  store i32 %spec.select.i1294, ptr %13, align 8
  store i32 0, ptr %38, align 4
  %186 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #38
  store i32 0, ptr %36, align 8
  %187 = icmp sgt i32 %176, 0
  br i1 %187, label %.lr.ph.i1726, label %HashMap_resize_new_capacityPtri32.exit

.lr.ph.i1726:                                     ; preds = %._crit_edge1.i1293, %._crit_edge.i1727
  %.096.i = phi i32 [ %390, %._crit_edge.i1727 ], [ 0, %._crit_edge1.i1293 ]
  %188 = zext nneg i32 %.096.i to i64
  %189 = shl nuw nsw i64 %188, 5
  %190 = getelementptr i8, ptr %183, i64 %189
  %191 = load ptr, ptr %190, align 8
  %192 = icmp ne ptr %191, @nil_typ
  %193 = icmp ne ptr %191, null
  %.not40.i = and i1 %192, %193
  br i1 %.not40.i, label %194, label %._crit_edge.i1727

194:                                              ; preds = %.lr.ph.i1726
  %195 = getelementptr i8, ptr %190, i64 8
  %196 = load i64, ptr %195, align 4
  %.sroa_idx.i1728 = getelementptr i8, ptr %190, i64 16
  %197 = load i64, ptr %.sroa_idx.i1728, align 4
  %198 = inttoptr i64 %196 to ptr
  %199 = inttoptr i64 %197 to ptr
  %hash_coef_ptr.i.i42.i = getelementptr i8, ptr %191, i64 8
  %tbl_size_ptr.i.i43.i = getelementptr i8, ptr %191, i64 16
  %offset_tbl_ptr.i.i44.i = getelementptr i8, ptr %191, i64 40
  %hash_coef.i.i45.i = load i64, ptr %hash_coef_ptr.i.i42.i, align 4, !noalias !157
  %tbl_size.i.i46.i = load i64, ptr %tbl_size_ptr.i.i43.i, align 4, !noalias !157
  %offset_tbl.i.i47.i = load ptr, ptr %offset_tbl_ptr.i.i44.i, align 8, !noalias !157
  %product.i.i.i48.i = mul i64 %hash_coef.i.i45.i, 4015701072841558310
  %shifted.i.i.i49.i = lshr i64 %product.i.i.i48.i, 32
  %xored.i.i.i50.i = xor i64 %shifted.i.i.i49.i, %product.i.i.i48.i
  %hash.i.i.i51.i = and i64 %xored.i.i.i50.i, %tbl_size.i.i46.i
  %offset_ptr.i.i52.i = getelementptr i32, ptr %offset_tbl.i.i47.i, i64 %hash.i.i.i51.i
  %offset.i.i53.i = load i32, ptr %offset_ptr.i.i52.i, align 4, !noalias !157
  %200 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %191, 0
  %201 = insertvalue { ptr, ptr, ptr, i32 } %200, ptr %198, 1
  %202 = insertvalue { ptr, ptr, ptr, i32 } %201, ptr %199, 2
  %203 = insertvalue { ptr, ptr, ptr, i32 } %202, i32 %offset.i.i53.i, 3
  %204 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %205 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %191)
  %206 = sext i32 %offset.i.i53.i to i64
  %207 = getelementptr ptr, ptr %191, i64 %206
  %208 = getelementptr i8, ptr %207, i64 56
  %209 = load ptr, ptr %208, align 8
  %result.i55.i = call ptr %209({ ptr, ptr, ptr, i32 } %203, ptr nocapture nofree noundef nonnull readonly %2) #16
  %210 = call { ptr, i160 } %result.i55.i({ ptr, ptr, ptr, i32 } %203, { ptr, ptr, ptr, i32 } %203, ptr nonnull align 8 %2) #7
  %.fca.0.extract29.i = extractvalue { ptr, i160 } %210, 0
  %211 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %212 = load ptr, ptr %5, align 8
  %213 = load ptr, ptr %212, align 8
  %214 = ptrtoint ptr %213 to i64
  %215 = getelementptr i8, ptr %.fca.0.extract29.i, i64 8
  %216 = getelementptr i8, ptr %.fca.0.extract29.i, i64 16
  %217 = getelementptr i8, ptr %.fca.0.extract29.i, i64 24
  %218 = getelementptr i8, ptr %.fca.0.extract29.i, i64 32
  %219 = load i64, ptr %215, align 4
  %220 = load i64, ptr %216, align 4
  %221 = load ptr, ptr %217, align 8
  %222 = load ptr, ptr %218, align 8
  %223 = load i64, ptr %213, align 4
  %result.i57.i = call i1 %221(i64 %220, i64 %219, i64 %223, i64 %214, ptr readonly %222) #5
  br i1 %result.i57.i, label %224, label %._crit_edge.i1727

224:                                              ; preds = %194
  %225 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %226 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %191)
  %227 = getelementptr i8, ptr %207, i64 48
  %228 = load ptr, ptr %227, align 8
  %result.i58.i = call ptr %228({ ptr, ptr, ptr, i32 } %203, ptr nocapture nofree noundef nonnull readonly %2) #16
  %229 = call { ptr, i160 } %result.i58.i({ ptr, ptr, ptr, i32 } %203, { ptr, ptr, ptr, i32 } %203, ptr nonnull align 8 %2) #7
  %230 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %231 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %191)
  %232 = getelementptr i8, ptr %207, i64 64
  %233 = load ptr, ptr %232, align 8
  %result.i59.i = call ptr %233({ ptr, ptr, ptr, i32 } %203, ptr nocapture nofree noundef nonnull readonly %2) #16
  %234 = call i32 %result.i59.i({ ptr, ptr, ptr, i32 } %203, { ptr, ptr, ptr, i32 } %203, ptr nonnull align 8 %2) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %4)
  %235 = load ptr, ptr %result.i378, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %236 = load i32, ptr %13, align 8
  %237 = add i32 %236, -1
  %238 = and i32 %237, %234
  %239 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %240 = load ptr, ptr %12, align 8
  %241 = sext i32 %238 to i64
  %242 = shl nsw i64 %241, 5
  %243 = getelementptr i8, ptr %240, i64 %242
  %244 = load ptr, ptr %243, align 8
  %245 = icmp eq ptr %244, @nil_typ
  %246 = icmp eq ptr %244, null
  %247 = or i1 %245, %246
  br i1 %247, label %HashMap_find_slot_keyK_hashPtri32.exit2237, label %.lr.ph.i2213

.lr.ph.i2213:                                     ; preds = %224
  %248 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %249

249:                                              ; preds = %._crit_edge.thread.i2228, %.lr.ph.i2213
  %250 = phi i32 [ %238, %.lr.ph.i2213 ], [ %292, %._crit_edge.thread.i2228 ]
  %spec.store.select.i22332308 = phi i32 [ -1, %.lr.ph.i2213 ], [ %spec.store.select.i2233, %._crit_edge.thread.i2228 ]
  %251 = phi ptr [ %244, %.lr.ph.i2213 ], [ %297, %._crit_edge.thread.i2228 ]
  %252 = phi ptr [ %243, %.lr.ph.i2213 ], [ %296, %._crit_edge.thread.i2228 ]
  %.sroa_idx.i2214 = getelementptr i8, ptr %252, i64 16
  %253 = load i64, ptr %.sroa_idx.i2214, align 4
  %254 = getelementptr i8, ptr %252, i64 8
  %255 = load i64, ptr %254, align 4
  %256 = inttoptr i64 %255 to ptr
  %257 = inttoptr i64 %253 to ptr
  %hash_coef_ptr.i.i56.i2215 = getelementptr i8, ptr %251, i64 8
  %tbl_size_ptr.i.i57.i2216 = getelementptr i8, ptr %251, i64 16
  %offset_tbl_ptr.i.i58.i2217 = getelementptr i8, ptr %251, i64 40
  %hash_coef.i.i59.i2218 = load i64, ptr %hash_coef_ptr.i.i56.i2215, align 4
  %tbl_size.i.i60.i2219 = load i64, ptr %tbl_size_ptr.i.i57.i2216, align 4
  %offset_tbl.i.i61.i2220 = load ptr, ptr %offset_tbl_ptr.i.i58.i2217, align 8
  %product.i.i.i62.i2221 = mul i64 %hash_coef.i.i59.i2218, 4015701072841558310
  %shifted.i.i.i63.i2222 = lshr i64 %product.i.i.i62.i2221, 32
  %xored.i.i.i64.i2223 = xor i64 %shifted.i.i.i63.i2222, %product.i.i.i62.i2221
  %hash.i.i.i65.i2224 = and i64 %xored.i.i.i64.i2223, %tbl_size.i.i60.i2219
  %offset_ptr.i.i66.i2225 = getelementptr i32, ptr %offset_tbl.i.i61.i2220, i64 %hash.i.i.i65.i2224
  %offset.i.i67.i2226 = load i32, ptr %offset_ptr.i.i66.i2225, align 4
  %258 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %251, 0
  %259 = insertvalue { ptr, ptr, ptr, i32 } %258, ptr %256, 1
  %260 = insertvalue { ptr, ptr, ptr, i32 } %259, ptr %257, 2
  %261 = insertvalue { ptr, ptr, ptr, i32 } %260, i32 %offset.i.i67.i2226, 3
  %262 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %251)
  %263 = sext i32 %offset.i.i67.i2226 to i64
  %264 = getelementptr ptr, ptr %251, i64 %263
  %265 = getelementptr i8, ptr %264, i64 64
  %266 = load ptr, ptr %265, align 8
  %result.i.i2227 = call ptr %266({ ptr, ptr, ptr, i32 } %261, ptr nocapture nofree noundef nonnull readonly %2) #16
  %267 = call i32 %result.i.i2227({ ptr, ptr, ptr, i32 } %261, { ptr, ptr, ptr, i32 } %261, ptr nonnull align 8 %2) #7
  %268 = icmp eq i32 %267, %234
  br i1 %268, label %._crit_edge.i2235, label %._crit_edge.thread.i2228

._crit_edge.i2235:                                ; preds = %249
  %269 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %270 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %251)
  %271 = getelementptr i8, ptr %264, i64 48
  %272 = load ptr, ptr %271, align 8
  %result.i69.i2236 = call ptr %272({ ptr, ptr, ptr, i32 } %261, ptr nocapture nofree noundef nonnull readonly %2) #16
  %273 = call { ptr, i160 } %result.i69.i2236({ ptr, ptr, ptr, i32 } %261, { ptr, ptr, ptr, i32 } %261, ptr nonnull align 8 %2) #7
  %274 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %275 = load ptr, ptr %11, align 8
  %276 = call i1 %275({ ptr, i160 } %273, { ptr, i160 } %229) #7
  br i1 %276, label %HashMap_find_slot_keyK_hashPtri32.exit2237.loopexit, label %._crit_edge.thread.i2228

._crit_edge.thread.i2228:                         ; preds = %._crit_edge.i2235, %249
  %277 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %278 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %251)
  %279 = getelementptr i8, ptr %264, i64 56
  %280 = load ptr, ptr %279, align 8
  %result.i70.i2229 = call ptr %280({ ptr, ptr, ptr, i32 } %261, ptr nocapture nofree noundef nonnull readonly %2) #16
  %281 = call { ptr, i160 } %result.i70.i2229({ ptr, ptr, ptr, i32 } %261, { ptr, ptr, ptr, i32 } %261, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i2230 = extractvalue { ptr, i160 } %281, 0
  %282 = getelementptr i8, ptr %.fca.0.extract19.i2230, i64 8
  %283 = getelementptr i8, ptr %.fca.0.extract19.i2230, i64 16
  %284 = getelementptr i8, ptr %.fca.0.extract19.i2230, i64 24
  %285 = getelementptr i8, ptr %.fca.0.extract19.i2230, i64 32
  %286 = load i64, ptr %282, align 4
  %287 = load i64, ptr %283, align 4
  %288 = load ptr, ptr %284, align 8
  %289 = load ptr, ptr %285, align 8
  %result.i71.i2231 = call i1 %288(i64 %287, i64 %286, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %289) #5
  %290 = icmp eq i32 %spec.store.select.i22332308, -1
  %or.cond.i2232 = select i1 %result.i71.i2231, i1 %290, i1 false
  %spec.store.select.i2233 = select i1 %or.cond.i2232, i32 %250, i32 %spec.store.select.i22332308
  %291 = add i32 %250, 1
  %292 = and i32 %291, %237
  %293 = load ptr, ptr %12, align 8
  %294 = sext i32 %292 to i64
  %295 = shl nsw i64 %294, 5
  %296 = getelementptr i8, ptr %293, i64 %295
  %297 = load ptr, ptr %296, align 8
  %298 = icmp eq ptr %297, @nil_typ
  %299 = icmp eq ptr %297, null
  %300 = or i1 %298, %299
  br i1 %300, label %._crit_edge105.loopexit.i2234, label %249

._crit_edge105.loopexit.i2234:                    ; preds = %._crit_edge.thread.i2228
  %301 = icmp eq i32 %spec.store.select.i2233, -1
  %.pre.i.pre2352 = select i1 %301, i32 %292, i32 %spec.store.select.i2233
  br label %HashMap_find_slot_keyK_hashPtri32.exit2237

HashMap_find_slot_keyK_hashPtri32.exit2237.loopexit: ; preds = %._crit_edge.i2235
  %.pre2437 = load ptr, ptr %12, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit2237

HashMap_find_slot_keyK_hashPtri32.exit2237:       ; preds = %HashMap_find_slot_keyK_hashPtri32.exit2237.loopexit, %224, %._crit_edge105.loopexit.i2234
  %302 = phi ptr [ %293, %._crit_edge105.loopexit.i2234 ], [ %240, %224 ], [ %.pre2437, %HashMap_find_slot_keyK_hashPtri32.exit2237.loopexit ]
  %303 = phi i32 [ %.pre.i.pre2352, %._crit_edge105.loopexit.i2234 ], [ %238, %224 ], [ %250, %HashMap_find_slot_keyK_hashPtri32.exit2237.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %304 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %305 = sext i32 %303 to i64
  %306 = shl nsw i64 %305, 5
  %307 = getelementptr i8, ptr %302, i64 %306
  %308 = load ptr, ptr %307, align 8
  %309 = getelementptr i8, ptr %307, i64 8
  %310 = load i64, ptr %309, align 4
  %.sroa_idx.i2021 = getelementptr i8, ptr %307, i64 16
  %311 = load i64, ptr %.sroa_idx.i2021, align 4
  %312 = load ptr, ptr %5, align 8
  %313 = load ptr, ptr %235, align 8, !alias.scope !160
  %314 = getelementptr i8, ptr %313, i64 72
  %315 = load ptr, ptr %314, align 8, !alias.scope !160
  %result.i.i.i2023 = call { i64, i64 } %315(ptr nocapture nofree nonnull readonly %235) #5, !alias.scope !160
  %316 = extractvalue { i64, i64 } %result.i.i.i2023, 0
  %317 = extractvalue { i64, i64 } %result.i.i.i2023, 1
  %318 = call i64 @llvm.umax.i64(i64 %317, i64 8)
  %319 = urem i64 20, %317
  %320 = icmp eq i64 %319, 0
  %321 = sub i64 %317, %319
  %322 = select i1 %320, i64 0, i64 %321
  %323 = add i64 %316, 20
  %324 = add i64 %323, %322
  %325 = and i64 %324, 7
  %326 = icmp eq i64 %325, 0
  %327 = sub nuw nsw i64 40, %325
  %328 = select i1 %326, i64 32, i64 %327
  %329 = add i64 %328, %324
  %330 = urem i64 %329, %318
  %331 = icmp eq i64 %330, 0
  %332 = sub i64 %318, %330
  %333 = select i1 %331, i64 0, i64 %332
  %334 = add i64 %329, %333
  %result.i71.i2024 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %334, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %235, ptr %result.i71.i2024, align 8
  %335 = getelementptr inbounds i8, ptr %result.i71.i2024, i64 8
  store ptr %312, ptr %335, align 8
  %336 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i2024)
  %337 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %result.i71.i2024, 1
  %338 = insertvalue { ptr, ptr, ptr, i32 } %337, ptr undef, 2
  %339 = insertvalue { ptr, ptr, ptr, i32 } %338, i32 10, 3
  store ptr %235, ptr %4, align 8
  store ptr %312, ptr %40, align 8
  store ptr @_parameterization_Ptri32, ptr %41, align 8
  %340 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %4)
  %341 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Entry)
  %342 = load i64, ptr %215, align 4
  %343 = load i64, ptr %216, align 4
  %344 = load ptr, ptr %217, align 8
  %345 = load ptr, ptr %218, align 8
  %result.i.i117.i = call i1 %344(i64 %343, i64 %342, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %345) #5
  %346 = select i1 %result.i.i117.i, i64 9, i64 10
  %gep = getelementptr [14 x ptr], ptr getelementptr inbounds (i8, ptr @Entry, i64 80), i64 0, i64 %346
  %347 = load ptr, ptr %gep, align 8
  call void %347({ ptr, ptr, ptr, i32 } %339, { ptr, ptr, ptr, i32 } %339, ptr nonnull align 8 dereferenceable(24) %4, { ptr, i160 } %229, { ptr, i160 } %210, i32 %234) #7
  %348 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %349 = load ptr, ptr %12, align 8
  %350 = getelementptr i8, ptr %349, i64 %306
  store ptr @Entry, ptr %350, align 8
  %351 = getelementptr i8, ptr %350, i64 8
  %352 = ptrtoint ptr %result.i71.i2024 to i64
  store i64 %352, ptr %351, align 4
  %.sroa_idx4.i2025 = getelementptr i8, ptr %350, i64 24
  store i32 10, ptr %.sroa_idx4.i2025, align 4
  %353 = icmp eq ptr %308, @nil_typ
  %354 = icmp eq ptr %308, null
  %355 = or i1 %353, %354
  br i1 %355, label %356, label %359

356:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit2237
  %357 = load i32, ptr %38, align 4
  %358 = add i32 %357, 1
  store i32 %358, ptr %38, align 4
  br label %._crit_edge.sink.split.i2042

359:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit2237
  %360 = inttoptr i64 %310 to ptr
  %361 = inttoptr i64 %311 to ptr
  %hash_coef_ptr.i.i88.i2026 = getelementptr i8, ptr %308, i64 8
  %tbl_size_ptr.i.i89.i2027 = getelementptr i8, ptr %308, i64 16
  %offset_tbl_ptr.i.i90.i2028 = getelementptr i8, ptr %308, i64 40
  %hash_coef.i.i91.i2029 = load i64, ptr %hash_coef_ptr.i.i88.i2026, align 4, !noalias !163
  %tbl_size.i.i92.i2030 = load i64, ptr %tbl_size_ptr.i.i89.i2027, align 4, !noalias !163
  %offset_tbl.i.i93.i2031 = load ptr, ptr %offset_tbl_ptr.i.i90.i2028, align 8, !noalias !163
  %product.i.i.i94.i2032 = mul i64 %hash_coef.i.i91.i2029, 4015701072841558310
  %shifted.i.i.i95.i2033 = lshr i64 %product.i.i.i94.i2032, 32
  %xored.i.i.i96.i2034 = xor i64 %shifted.i.i.i95.i2033, %product.i.i.i94.i2032
  %hash.i.i.i97.i2035 = and i64 %xored.i.i.i96.i2034, %tbl_size.i.i92.i2030
  %offset_ptr.i.i98.i2036 = getelementptr i32, ptr %offset_tbl.i.i93.i2031, i64 %hash.i.i.i97.i2035
  %offset.i.i99.i2037 = load i32, ptr %offset_ptr.i.i98.i2036, align 4, !noalias !163
  %362 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %308, 0
  %363 = insertvalue { ptr, ptr, ptr, i32 } %362, ptr %360, 1
  %364 = insertvalue { ptr, ptr, ptr, i32 } %363, ptr %361, 2
  %365 = insertvalue { ptr, ptr, ptr, i32 } %364, i32 %offset.i.i99.i2037, 3
  %366 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %367 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %308)
  %368 = sext i32 %offset.i.i99.i2037 to i64
  %369 = getelementptr ptr, ptr %308, i64 %368
  %370 = getelementptr i8, ptr %369, i64 56
  %371 = load ptr, ptr %370, align 8
  %result.i101.i2038 = call ptr %371({ ptr, ptr, ptr, i32 } %365, ptr nocapture nofree noundef nonnull readonly %2) #16
  %372 = call { ptr, i160 } %result.i101.i2038({ ptr, ptr, ptr, i32 } %365, { ptr, ptr, ptr, i32 } %365, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i2039 = extractvalue { ptr, i160 } %372, 0
  %373 = getelementptr i8, ptr %.fca.0.extract51.i2039, i64 8
  %374 = getelementptr i8, ptr %.fca.0.extract51.i2039, i64 16
  %375 = getelementptr i8, ptr %.fca.0.extract51.i2039, i64 24
  %376 = getelementptr i8, ptr %.fca.0.extract51.i2039, i64 32
  %377 = load i64, ptr %373, align 4
  %378 = load i64, ptr %374, align 4
  %379 = load ptr, ptr %375, align 8
  %380 = load ptr, ptr %376, align 8
  %result.i102.i2040 = call i1 %379(i64 %378, i64 %377, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %380) #5
  br i1 %result.i102.i2040, label %._crit_edge.sink.split.i2042, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit2044

._crit_edge.sink.split.i2042:                     ; preds = %359, %356
  %.sink159.i2043 = phi i64 [ 48, %356 ], [ 40, %359 ]
  %381 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %382 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i2043
  %383 = load ptr, ptr %382, align 8
  %384 = load ptr, ptr %383, align 8
  %385 = call i32 %384(ptr nonnull %result.i378) #36
  %386 = add i32 %385, 1
  %387 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %388 = getelementptr i8, ptr %383, i64 8
  %389 = load ptr, ptr %388, align 8
  call void %389(ptr nonnull %result.i378, i32 %386) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit2044

HashMap_insert_internal_keyK_valueV_hashPtri32.exit2044: ; preds = %359, %._crit_edge.sink.split.i2042
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %4)
  br label %._crit_edge.i1727

._crit_edge.i1727:                                ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit2044, %194, %.lr.ph.i1726
  %390 = add nuw nsw i32 %.096.i, 1
  %391 = icmp slt i32 %390, %176
  br i1 %391, label %.lr.ph.i1726, label %HashMap_resize_new_capacityPtri32.exit

HashMap_resize_new_capacityPtri32.exit:           ; preds = %._crit_edge.i1727, %._crit_edge1.i1293
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_ensure_capacity_required_loadPtri32.exit

HashMap_ensure_capacity_required_loadPtri32.exit: ; preds = %173, %HashMap_resize_new_capacityPtri32.exit
  %392 = load ptr, ptr %10, align 8
  %393 = call i32 %392({ ptr, i160 } %49) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %394 = load ptr, ptr %result.i378, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %395 = load i32, ptr %13, align 8
  %396 = add i32 %395, -1
  %397 = and i32 %396, %393
  %398 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %399 = load ptr, ptr %12, align 8
  %400 = sext i32 %397 to i64
  %401 = shl nsw i64 %400, 5
  %402 = getelementptr i8, ptr %399, i64 %401
  %403 = load ptr, ptr %402, align 8
  %404 = icmp eq ptr %403, @nil_typ
  %405 = icmp eq ptr %403, null
  %406 = or i1 %404, %405
  br i1 %406, label %HashMap_find_slot_keyK_hashPtri32.exit1765, label %.lr.ph.i1741

.lr.ph.i1741:                                     ; preds = %HashMap_ensure_capacity_required_loadPtri32.exit
  %407 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %408

408:                                              ; preds = %._crit_edge.thread.i1756, %.lr.ph.i1741
  %409 = phi i32 [ %397, %.lr.ph.i1741 ], [ %451, %._crit_edge.thread.i1756 ]
  %spec.store.select.i17611895 = phi i32 [ -1, %.lr.ph.i1741 ], [ %spec.store.select.i1761, %._crit_edge.thread.i1756 ]
  %410 = phi ptr [ %403, %.lr.ph.i1741 ], [ %456, %._crit_edge.thread.i1756 ]
  %411 = phi ptr [ %402, %.lr.ph.i1741 ], [ %455, %._crit_edge.thread.i1756 ]
  %.sroa_idx.i1742 = getelementptr i8, ptr %411, i64 16
  %412 = load i64, ptr %.sroa_idx.i1742, align 4
  %413 = getelementptr i8, ptr %411, i64 8
  %414 = load i64, ptr %413, align 4
  %415 = inttoptr i64 %414 to ptr
  %416 = inttoptr i64 %412 to ptr
  %hash_coef_ptr.i.i56.i1743 = getelementptr i8, ptr %410, i64 8
  %tbl_size_ptr.i.i57.i1744 = getelementptr i8, ptr %410, i64 16
  %offset_tbl_ptr.i.i58.i1745 = getelementptr i8, ptr %410, i64 40
  %hash_coef.i.i59.i1746 = load i64, ptr %hash_coef_ptr.i.i56.i1743, align 4
  %tbl_size.i.i60.i1747 = load i64, ptr %tbl_size_ptr.i.i57.i1744, align 4
  %offset_tbl.i.i61.i1748 = load ptr, ptr %offset_tbl_ptr.i.i58.i1745, align 8
  %product.i.i.i62.i1749 = mul i64 %hash_coef.i.i59.i1746, 4015701072841558310
  %shifted.i.i.i63.i1750 = lshr i64 %product.i.i.i62.i1749, 32
  %xored.i.i.i64.i1751 = xor i64 %shifted.i.i.i63.i1750, %product.i.i.i62.i1749
  %hash.i.i.i65.i1752 = and i64 %xored.i.i.i64.i1751, %tbl_size.i.i60.i1747
  %offset_ptr.i.i66.i1753 = getelementptr i32, ptr %offset_tbl.i.i61.i1748, i64 %hash.i.i.i65.i1752
  %offset.i.i67.i1754 = load i32, ptr %offset_ptr.i.i66.i1753, align 4
  %417 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %410, 0
  %418 = insertvalue { ptr, ptr, ptr, i32 } %417, ptr %415, 1
  %419 = insertvalue { ptr, ptr, ptr, i32 } %418, ptr %416, 2
  %420 = insertvalue { ptr, ptr, ptr, i32 } %419, i32 %offset.i.i67.i1754, 3
  %421 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %410)
  %422 = sext i32 %offset.i.i67.i1754 to i64
  %423 = getelementptr ptr, ptr %410, i64 %422
  %424 = getelementptr i8, ptr %423, i64 64
  %425 = load ptr, ptr %424, align 8
  %result.i.i1755 = call ptr %425({ ptr, ptr, ptr, i32 } %420, ptr nocapture nofree noundef nonnull readonly %2) #16
  %426 = call i32 %result.i.i1755({ ptr, ptr, ptr, i32 } %420, { ptr, ptr, ptr, i32 } %420, ptr nonnull align 8 %2) #7
  %427 = icmp eq i32 %426, %393
  br i1 %427, label %._crit_edge.i1763, label %._crit_edge.thread.i1756

._crit_edge.i1763:                                ; preds = %408
  %428 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %429 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %410)
  %430 = getelementptr i8, ptr %423, i64 48
  %431 = load ptr, ptr %430, align 8
  %result.i69.i1764 = call ptr %431({ ptr, ptr, ptr, i32 } %420, ptr nocapture nofree noundef nonnull readonly %2) #16
  %432 = call { ptr, i160 } %result.i69.i1764({ ptr, ptr, ptr, i32 } %420, { ptr, ptr, ptr, i32 } %420, ptr nonnull align 8 %2) #7
  %433 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %434 = load ptr, ptr %11, align 8
  %435 = call i1 %434({ ptr, i160 } %432, { ptr, i160 } %49) #7
  br i1 %435, label %HashMap_find_slot_keyK_hashPtri32.exit1765.loopexit, label %._crit_edge.thread.i1756

._crit_edge.thread.i1756:                         ; preds = %._crit_edge.i1763, %408
  %436 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %437 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %410)
  %438 = getelementptr i8, ptr %423, i64 56
  %439 = load ptr, ptr %438, align 8
  %result.i70.i1757 = call ptr %439({ ptr, ptr, ptr, i32 } %420, ptr nocapture nofree noundef nonnull readonly %2) #16
  %440 = call { ptr, i160 } %result.i70.i1757({ ptr, ptr, ptr, i32 } %420, { ptr, ptr, ptr, i32 } %420, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i1758 = extractvalue { ptr, i160 } %440, 0
  %441 = getelementptr i8, ptr %.fca.0.extract19.i1758, i64 8
  %442 = getelementptr i8, ptr %.fca.0.extract19.i1758, i64 16
  %443 = getelementptr i8, ptr %.fca.0.extract19.i1758, i64 24
  %444 = getelementptr i8, ptr %.fca.0.extract19.i1758, i64 32
  %445 = load i64, ptr %441, align 4
  %446 = load i64, ptr %442, align 4
  %447 = load ptr, ptr %443, align 8
  %448 = load ptr, ptr %444, align 8
  %result.i71.i1759 = call i1 %447(i64 %446, i64 %445, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %448) #5
  %449 = icmp eq i32 %spec.store.select.i17611895, -1
  %or.cond.i1760 = select i1 %result.i71.i1759, i1 %449, i1 false
  %spec.store.select.i1761 = select i1 %or.cond.i1760, i32 %409, i32 %spec.store.select.i17611895
  %450 = add i32 %409, 1
  %451 = and i32 %450, %396
  %452 = load ptr, ptr %12, align 8
  %453 = sext i32 %451 to i64
  %454 = shl nsw i64 %453, 5
  %455 = getelementptr i8, ptr %452, i64 %454
  %456 = load ptr, ptr %455, align 8
  %457 = icmp eq ptr %456, @nil_typ
  %458 = icmp eq ptr %456, null
  %459 = or i1 %457, %458
  br i1 %459, label %._crit_edge105.loopexit.i1762, label %408

._crit_edge105.loopexit.i1762:                    ; preds = %._crit_edge.thread.i1756
  %460 = icmp eq i32 %spec.store.select.i1761, -1
  %.pre.i.pre1929 = select i1 %460, i32 %451, i32 %spec.store.select.i1761
  br label %HashMap_find_slot_keyK_hashPtri32.exit1765

HashMap_find_slot_keyK_hashPtri32.exit1765.loopexit: ; preds = %._crit_edge.i1763
  %.pre1999 = load ptr, ptr %12, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit1765

HashMap_find_slot_keyK_hashPtri32.exit1765:       ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1765.loopexit, %HashMap_ensure_capacity_required_loadPtri32.exit, %._crit_edge105.loopexit.i1762
  %461 = phi ptr [ %452, %._crit_edge105.loopexit.i1762 ], [ %399, %HashMap_ensure_capacity_required_loadPtri32.exit ], [ %.pre1999, %HashMap_find_slot_keyK_hashPtri32.exit1765.loopexit ]
  %462 = phi i32 [ %.pre.i.pre1929, %._crit_edge105.loopexit.i1762 ], [ %397, %HashMap_ensure_capacity_required_loadPtri32.exit ], [ %409, %HashMap_find_slot_keyK_hashPtri32.exit1765.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %463 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %464 = sext i32 %462 to i64
  %465 = shl nsw i64 %464, 5
  %466 = getelementptr i8, ptr %461, i64 %465
  %467 = load ptr, ptr %466, align 8
  %468 = getelementptr i8, ptr %466, i64 8
  %469 = load i64, ptr %468, align 4
  %.sroa_idx.i1310 = getelementptr i8, ptr %466, i64 16
  %470 = load i64, ptr %.sroa_idx.i1310, align 4
  %471 = load ptr, ptr %5, align 8
  %472 = load ptr, ptr %394, align 8, !alias.scope !166
  %473 = getelementptr i8, ptr %472, i64 72
  %474 = load ptr, ptr %473, align 8, !alias.scope !166
  %result.i.i.i1312 = call { i64, i64 } %474(ptr nocapture nofree nonnull readonly %394) #5, !alias.scope !166
  %475 = extractvalue { i64, i64 } %result.i.i.i1312, 0
  %476 = extractvalue { i64, i64 } %result.i.i.i1312, 1
  %477 = call i64 @llvm.umax.i64(i64 %476, i64 8)
  %478 = urem i64 20, %476
  %479 = icmp eq i64 %478, 0
  %480 = sub i64 %476, %478
  %481 = select i1 %479, i64 0, i64 %480
  %482 = add i64 %475, 20
  %483 = add i64 %482, %481
  %484 = and i64 %483, 7
  %485 = icmp eq i64 %484, 0
  %486 = sub nuw nsw i64 40, %484
  %487 = select i1 %485, i64 32, i64 %486
  %488 = add i64 %487, %483
  %489 = urem i64 %488, %477
  %490 = icmp eq i64 %489, 0
  %491 = sub i64 %477, %489
  %492 = select i1 %490, i64 0, i64 %491
  %493 = add i64 %488, %492
  %result.i71.i1313 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %493, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %394, ptr %result.i71.i1313, align 8
  %494 = getelementptr inbounds i8, ptr %result.i71.i1313, i64 8
  store ptr %471, ptr %494, align 8
  %495 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i1313)
  %496 = load ptr, ptr %394, align 8
  %497 = getelementptr i8, ptr %496, i64 72
  %498 = load ptr, ptr %497, align 8
  %result.i.i1952 = call { i64, i64 } %498(ptr nocapture nofree nonnull readonly %394) #5
  %499 = extractvalue { i64, i64 } %result.i.i1952, 1
  %500 = urem i64 20, %499
  %501 = icmp eq i64 %500, 0
  %reass.sub2409 = sub i64 %499, %500
  %502 = add i64 %reass.sub2409, 20
  %503 = select i1 %501, i64 20, i64 %502
  %504 = getelementptr i8, ptr %result.i71.i1313, i64 %503
  %505 = getelementptr i8, ptr %496, i64 64
  %506 = load ptr, ptr %505, align 8
  call void %506({ ptr, i160 } %49, ptr nocapture nofree nonnull readonly %394, ptr nocapture nofree writeonly %504) #13
  %507 = load ptr, ptr %result.i71.i1313, align 8
  %508 = load ptr, ptr %507, align 8
  %509 = getelementptr i8, ptr %508, i64 72
  %510 = load ptr, ptr %509, align 8
  %result.i.i1953 = call { i64, i64 } %510(ptr nocapture nofree nonnull readonly %507) #5
  %511 = extractvalue { i64, i64 } %result.i.i1953, 0
  %512 = extractvalue { i64, i64 } %result.i.i1953, 1
  %513 = urem i64 20, %512
  %514 = icmp eq i64 %513, 0
  %515 = sub i64 %512, %513
  %516 = select i1 %514, i64 0, i64 %515
  %517 = add i64 %511, 20
  %518 = add i64 %517, %516
  %519 = and i64 %518, 7
  %520 = icmp eq i64 %519, 0
  %521 = sub nuw nsw i64 8, %519
  %522 = select i1 %520, i64 0, i64 %521
  %523 = getelementptr i8, ptr %result.i71.i1313, i64 %518
  %524 = getelementptr i8, ptr %523, i64 %522
  store ptr @i32_typ, ptr %524, align 8
  %525 = getelementptr i8, ptr %524, i64 8
  store i160 %.sroa.0326.0.insert.ext, ptr %525, align 4
  %526 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @Entry) #34
  %527 = getelementptr inbounds i8, ptr %result.i71.i1313, i64 16
  store i32 %393, ptr %527, align 8
  %528 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  store ptr @Entry, ptr %466, align 8
  %529 = ptrtoint ptr %result.i71.i1313 to i64
  store i64 %529, ptr %468, align 4
  %.sroa_idx4.i = getelementptr i8, ptr %466, i64 24
  store i32 10, ptr %.sroa_idx4.i, align 4
  %530 = icmp eq ptr %467, @nil_typ
  %531 = icmp eq ptr %467, null
  %532 = or i1 %530, %531
  br i1 %532, label %533, label %536

533:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1765
  %534 = load i32, ptr %38, align 4
  %535 = add i32 %534, 1
  store i32 %535, ptr %38, align 4
  br label %._crit_edge.sink.split.i

536:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1765
  %537 = inttoptr i64 %469 to ptr
  %538 = inttoptr i64 %470 to ptr
  %hash_coef_ptr.i.i88.i = getelementptr i8, ptr %467, i64 8
  %tbl_size_ptr.i.i89.i = getelementptr i8, ptr %467, i64 16
  %offset_tbl_ptr.i.i90.i = getelementptr i8, ptr %467, i64 40
  %hash_coef.i.i91.i = load i64, ptr %hash_coef_ptr.i.i88.i, align 4, !noalias !169
  %tbl_size.i.i92.i = load i64, ptr %tbl_size_ptr.i.i89.i, align 4, !noalias !169
  %offset_tbl.i.i93.i = load ptr, ptr %offset_tbl_ptr.i.i90.i, align 8, !noalias !169
  %product.i.i.i94.i = mul i64 %hash_coef.i.i91.i, 4015701072841558310
  %shifted.i.i.i95.i = lshr i64 %product.i.i.i94.i, 32
  %xored.i.i.i96.i = xor i64 %shifted.i.i.i95.i, %product.i.i.i94.i
  %hash.i.i.i97.i = and i64 %xored.i.i.i96.i, %tbl_size.i.i92.i
  %offset_ptr.i.i98.i = getelementptr i32, ptr %offset_tbl.i.i93.i, i64 %hash.i.i.i97.i
  %offset.i.i99.i = load i32, ptr %offset_ptr.i.i98.i, align 4, !noalias !169
  %539 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %467, 0
  %540 = insertvalue { ptr, ptr, ptr, i32 } %539, ptr %537, 1
  %541 = insertvalue { ptr, ptr, ptr, i32 } %540, ptr %538, 2
  %542 = insertvalue { ptr, ptr, ptr, i32 } %541, i32 %offset.i.i99.i, 3
  %543 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %544 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %467)
  %545 = sext i32 %offset.i.i99.i to i64
  %546 = getelementptr ptr, ptr %467, i64 %545
  %547 = getelementptr i8, ptr %546, i64 56
  %548 = load ptr, ptr %547, align 8
  %result.i101.i = call ptr %548({ ptr, ptr, ptr, i32 } %542, ptr nocapture nofree noundef nonnull readonly %2) #16
  %549 = call { ptr, i160 } %result.i101.i({ ptr, ptr, ptr, i32 } %542, { ptr, ptr, ptr, i32 } %542, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i1315 = extractvalue { ptr, i160 } %549, 0
  %550 = getelementptr i8, ptr %.fca.0.extract51.i1315, i64 8
  %551 = getelementptr i8, ptr %.fca.0.extract51.i1315, i64 16
  %552 = getelementptr i8, ptr %.fca.0.extract51.i1315, i64 24
  %553 = getelementptr i8, ptr %.fca.0.extract51.i1315, i64 32
  %554 = load i64, ptr %550, align 4
  %555 = load i64, ptr %551, align 4
  %556 = load ptr, ptr %552, align 8
  %557 = load ptr, ptr %553, align 8
  %result.i102.i = call i1 %556(i64 %555, i64 %554, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %557) #5
  br i1 %result.i102.i, label %._crit_edge.sink.split.i, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit

._crit_edge.sink.split.i:                         ; preds = %536, %533
  %.sink159.i = phi i64 [ 48, %533 ], [ 40, %536 ]
  %558 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %559 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i
  %560 = load ptr, ptr %559, align 8
  %561 = load ptr, ptr %560, align 8
  %562 = call i32 %561(ptr nonnull %result.i378) #36
  %563 = add i32 %562, 1
  %564 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %565 = getelementptr i8, ptr %560, i64 8
  %566 = load ptr, ptr %565, align 8
  call void %566(ptr nonnull %result.i378, i32 %563) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit

HashMap_insert_internal_keyK_valueV_hashPtri32.exit: ; preds = %536, %._crit_edge.sink.split.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %567 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  %568 = sext i32 %.0357715 to i64
  %569 = shl nsw i64 %568, 2
  %570 = getelementptr i8, ptr %result.i4.i, i64 %569
  store i32 %48, ptr %570, align 1
  store i1 true, ptr %.sroa.0316.sroa.0, align 8
  %.sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.0. = load i8, ptr %.sroa.0316.sroa.0, align 8
  %.sroa.0316.0.insert.ext = zext i8 %.sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.sroa.0.0..sroa.0316.0. to i160
  %571 = load i32, ptr %37, align 8
  %572 = load i32, ptr %29, align 8
  %573 = icmp eq i32 %572, 0
  %574 = mul i32 %571, 10
  %575 = add i32 %574, 10
  %576 = mul i32 %572, 6
  %577 = icmp sge i32 %575, %576
  %.0.i1330 = select i1 %573, i1 true, i1 %577
  br i1 %.0.i1330, label %._crit_edge1.i1332, label %HashMap_ensure_capacity_required_loadPtri32.exit1336

._crit_edge1.i1332:                               ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit
  %578 = shl i32 %572, 1
  %spec.select.i1334 = call i32 @llvm.smax.i32(i32 %578, i32 16)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %579 = load ptr, ptr %28, align 8
  %580 = zext nneg i32 %spec.select.i1334 to i64
  %581 = shl nuw nsw i64 %580, 5
  %result.i.i1793 = call noalias ptr @bump_malloc_inner(i64 noundef %581, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1793, ptr %28, align 8
  store i32 %spec.select.i1334, ptr %29, align 8
  store i32 0, ptr %39, align 4
  %582 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #38
  store i32 0, ptr %37, align 8
  %583 = icmp sgt i32 %572, 0
  br i1 %583, label %.lr.ph.i1794, label %HashMap_resize_new_capacityPtri32.exit1820

.lr.ph.i1794:                                     ; preds = %._crit_edge1.i1332, %._crit_edge.i1797
  %.096.i1795 = phi i32 [ %786, %._crit_edge.i1797 ], [ 0, %._crit_edge1.i1332 ]
  %584 = zext nneg i32 %.096.i1795 to i64
  %585 = shl nuw nsw i64 %584, 5
  %586 = getelementptr i8, ptr %579, i64 %585
  %587 = load ptr, ptr %586, align 8
  %588 = icmp ne ptr %587, @nil_typ
  %589 = icmp ne ptr %587, null
  %.not40.i1796 = and i1 %588, %589
  br i1 %.not40.i1796, label %590, label %._crit_edge.i1797

590:                                              ; preds = %.lr.ph.i1794
  %591 = getelementptr i8, ptr %586, i64 8
  %592 = load i64, ptr %591, align 4
  %.sroa_idx.i1798 = getelementptr i8, ptr %586, i64 16
  %593 = load i64, ptr %.sroa_idx.i1798, align 4
  %594 = inttoptr i64 %592 to ptr
  %595 = inttoptr i64 %593 to ptr
  %hash_coef_ptr.i.i42.i1799 = getelementptr i8, ptr %587, i64 8
  %tbl_size_ptr.i.i43.i1800 = getelementptr i8, ptr %587, i64 16
  %offset_tbl_ptr.i.i44.i1801 = getelementptr i8, ptr %587, i64 40
  %hash_coef.i.i45.i1802 = load i64, ptr %hash_coef_ptr.i.i42.i1799, align 4, !noalias !172
  %tbl_size.i.i46.i1803 = load i64, ptr %tbl_size_ptr.i.i43.i1800, align 4, !noalias !172
  %offset_tbl.i.i47.i1804 = load ptr, ptr %offset_tbl_ptr.i.i44.i1801, align 8, !noalias !172
  %product.i.i.i48.i1805 = mul i64 %hash_coef.i.i45.i1802, 4015701072841558310
  %shifted.i.i.i49.i1806 = lshr i64 %product.i.i.i48.i1805, 32
  %xored.i.i.i50.i1807 = xor i64 %shifted.i.i.i49.i1806, %product.i.i.i48.i1805
  %hash.i.i.i51.i1808 = and i64 %xored.i.i.i50.i1807, %tbl_size.i.i46.i1803
  %offset_ptr.i.i52.i1809 = getelementptr i32, ptr %offset_tbl.i.i47.i1804, i64 %hash.i.i.i51.i1808
  %offset.i.i53.i1810 = load i32, ptr %offset_ptr.i.i52.i1809, align 4, !noalias !172
  %596 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %587, 0
  %597 = insertvalue { ptr, ptr, ptr, i32 } %596, ptr %594, 1
  %598 = insertvalue { ptr, ptr, ptr, i32 } %597, ptr %595, 2
  %599 = insertvalue { ptr, ptr, ptr, i32 } %598, i32 %offset.i.i53.i1810, 3
  %600 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %601 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %587)
  %602 = sext i32 %offset.i.i53.i1810 to i64
  %603 = getelementptr ptr, ptr %587, i64 %602
  %604 = getelementptr i8, ptr %603, i64 56
  %605 = load ptr, ptr %604, align 8
  %result.i55.i1811 = call ptr %605({ ptr, ptr, ptr, i32 } %599, ptr nocapture nofree noundef nonnull readonly %2) #16
  %606 = call { ptr, i160 } %result.i55.i1811({ ptr, ptr, ptr, i32 } %599, { ptr, ptr, ptr, i32 } %599, ptr nonnull align 8 %2) #7
  %.fca.0.extract29.i1812 = extractvalue { ptr, i160 } %606, 0
  %607 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %608 = load ptr, ptr %21, align 8
  %609 = load ptr, ptr %608, align 8
  %610 = ptrtoint ptr %609 to i64
  %611 = getelementptr i8, ptr %.fca.0.extract29.i1812, i64 8
  %612 = getelementptr i8, ptr %.fca.0.extract29.i1812, i64 16
  %613 = getelementptr i8, ptr %.fca.0.extract29.i1812, i64 24
  %614 = getelementptr i8, ptr %.fca.0.extract29.i1812, i64 32
  %615 = load i64, ptr %611, align 4
  %616 = load i64, ptr %612, align 4
  %617 = load ptr, ptr %613, align 8
  %618 = load ptr, ptr %614, align 8
  %619 = load i64, ptr %609, align 4
  %result.i57.i1814 = call i1 %617(i64 %616, i64 %615, i64 %619, i64 %610, ptr readonly %618) #5
  br i1 %result.i57.i1814, label %620, label %._crit_edge.i1797

620:                                              ; preds = %590
  %621 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %622 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %587)
  %623 = getelementptr i8, ptr %603, i64 48
  %624 = load ptr, ptr %623, align 8
  %result.i58.i1815 = call ptr %624({ ptr, ptr, ptr, i32 } %599, ptr nocapture nofree noundef nonnull readonly %2) #16
  %625 = call { ptr, i160 } %result.i58.i1815({ ptr, ptr, ptr, i32 } %599, { ptr, ptr, ptr, i32 } %599, ptr nonnull align 8 %2) #7
  %626 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %627 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %587)
  %628 = getelementptr i8, ptr %603, i64 64
  %629 = load ptr, ptr %628, align 8
  %result.i59.i1817 = call ptr %629({ ptr, ptr, ptr, i32 } %599, ptr nocapture nofree noundef nonnull readonly %2) #16
  %630 = call i32 %result.i59.i1817({ ptr, ptr, ptr, i32 } %599, { ptr, ptr, ptr, i32 } %599, ptr nonnull align 8 %2) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %3)
  %631 = load ptr, ptr %result.i421, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %632 = load i32, ptr %29, align 8
  %633 = add i32 %632, -1
  %634 = and i32 %633, %630
  %635 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %636 = load ptr, ptr %28, align 8
  %637 = sext i32 %634 to i64
  %638 = shl nsw i64 %637, 5
  %639 = getelementptr i8, ptr %636, i64 %638
  %640 = load ptr, ptr %639, align 8
  %641 = icmp eq ptr %640, @nil_typ
  %642 = icmp eq ptr %640, null
  %643 = or i1 %641, %642
  br i1 %643, label %HashMap_find_slot_keyK_hashPtri32.exit2282, label %.lr.ph.i2252

.lr.ph.i2252:                                     ; preds = %620
  %644 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %645

645:                                              ; preds = %._crit_edge.thread.i2268, %.lr.ph.i2252
  %646 = phi i32 [ %634, %.lr.ph.i2252 ], [ %688, %._crit_edge.thread.i2268 ]
  %spec.store.select.i22732314 = phi i32 [ -1, %.lr.ph.i2252 ], [ %spec.store.select.i2273, %._crit_edge.thread.i2268 ]
  %647 = phi ptr [ %640, %.lr.ph.i2252 ], [ %693, %._crit_edge.thread.i2268 ]
  %648 = phi ptr [ %639, %.lr.ph.i2252 ], [ %692, %._crit_edge.thread.i2268 ]
  %.sroa_idx.i2254 = getelementptr i8, ptr %648, i64 16
  %649 = load i64, ptr %.sroa_idx.i2254, align 4
  %650 = getelementptr i8, ptr %648, i64 8
  %651 = load i64, ptr %650, align 4
  %652 = inttoptr i64 %651 to ptr
  %653 = inttoptr i64 %649 to ptr
  %hash_coef_ptr.i.i56.i2255 = getelementptr i8, ptr %647, i64 8
  %tbl_size_ptr.i.i57.i2256 = getelementptr i8, ptr %647, i64 16
  %offset_tbl_ptr.i.i58.i2257 = getelementptr i8, ptr %647, i64 40
  %hash_coef.i.i59.i2258 = load i64, ptr %hash_coef_ptr.i.i56.i2255, align 4
  %tbl_size.i.i60.i2259 = load i64, ptr %tbl_size_ptr.i.i57.i2256, align 4
  %offset_tbl.i.i61.i2260 = load ptr, ptr %offset_tbl_ptr.i.i58.i2257, align 8
  %product.i.i.i62.i2261 = mul i64 %hash_coef.i.i59.i2258, 4015701072841558310
  %shifted.i.i.i63.i2262 = lshr i64 %product.i.i.i62.i2261, 32
  %xored.i.i.i64.i2263 = xor i64 %shifted.i.i.i63.i2262, %product.i.i.i62.i2261
  %hash.i.i.i65.i2264 = and i64 %xored.i.i.i64.i2263, %tbl_size.i.i60.i2259
  %offset_ptr.i.i66.i2265 = getelementptr i32, ptr %offset_tbl.i.i61.i2260, i64 %hash.i.i.i65.i2264
  %offset.i.i67.i2266 = load i32, ptr %offset_ptr.i.i66.i2265, align 4
  %654 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %647, 0
  %655 = insertvalue { ptr, ptr, ptr, i32 } %654, ptr %652, 1
  %656 = insertvalue { ptr, ptr, ptr, i32 } %655, ptr %653, 2
  %657 = insertvalue { ptr, ptr, ptr, i32 } %656, i32 %offset.i.i67.i2266, 3
  %658 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %647)
  %659 = sext i32 %offset.i.i67.i2266 to i64
  %660 = getelementptr ptr, ptr %647, i64 %659
  %661 = getelementptr i8, ptr %660, i64 64
  %662 = load ptr, ptr %661, align 8
  %result.i.i2267 = call ptr %662({ ptr, ptr, ptr, i32 } %657, ptr nocapture nofree noundef nonnull readonly %2) #16
  %663 = call i32 %result.i.i2267({ ptr, ptr, ptr, i32 } %657, { ptr, ptr, ptr, i32 } %657, ptr nonnull align 8 %2) #7
  %664 = icmp eq i32 %663, %630
  br i1 %664, label %._crit_edge.i2279, label %._crit_edge.thread.i2268

._crit_edge.i2279:                                ; preds = %645
  %665 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %666 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %647)
  %667 = getelementptr i8, ptr %660, i64 48
  %668 = load ptr, ptr %667, align 8
  %result.i69.i2280 = call ptr %668({ ptr, ptr, ptr, i32 } %657, ptr nocapture nofree noundef nonnull readonly %2) #16
  %669 = call { ptr, i160 } %result.i69.i2280({ ptr, ptr, ptr, i32 } %657, { ptr, ptr, ptr, i32 } %657, ptr nonnull align 8 %2) #7
  %670 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %671 = load ptr, ptr %27, align 8
  %672 = call i1 %671({ ptr, i160 } %669, { ptr, i160 } %625) #7
  br i1 %672, label %HashMap_find_slot_keyK_hashPtri32.exit2282.loopexit, label %._crit_edge.thread.i2268

._crit_edge.thread.i2268:                         ; preds = %._crit_edge.i2279, %645
  %673 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %674 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %647)
  %675 = getelementptr i8, ptr %660, i64 56
  %676 = load ptr, ptr %675, align 8
  %result.i70.i2269 = call ptr %676({ ptr, ptr, ptr, i32 } %657, ptr nocapture nofree noundef nonnull readonly %2) #16
  %677 = call { ptr, i160 } %result.i70.i2269({ ptr, ptr, ptr, i32 } %657, { ptr, ptr, ptr, i32 } %657, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i2270 = extractvalue { ptr, i160 } %677, 0
  %678 = getelementptr i8, ptr %.fca.0.extract19.i2270, i64 8
  %679 = getelementptr i8, ptr %.fca.0.extract19.i2270, i64 16
  %680 = getelementptr i8, ptr %.fca.0.extract19.i2270, i64 24
  %681 = getelementptr i8, ptr %.fca.0.extract19.i2270, i64 32
  %682 = load i64, ptr %678, align 4
  %683 = load i64, ptr %679, align 4
  %684 = load ptr, ptr %680, align 8
  %685 = load ptr, ptr %681, align 8
  %result.i71.i2271 = call i1 %684(i64 %683, i64 %682, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %685) #5
  %686 = icmp eq i32 %spec.store.select.i22732314, -1
  %or.cond.i2272 = select i1 %result.i71.i2271, i1 %686, i1 false
  %spec.store.select.i2273 = select i1 %or.cond.i2272, i32 %646, i32 %spec.store.select.i22732314
  %687 = add i32 %646, 1
  %688 = and i32 %687, %633
  %689 = load ptr, ptr %28, align 8
  %690 = sext i32 %688 to i64
  %691 = shl nsw i64 %690, 5
  %692 = getelementptr i8, ptr %689, i64 %691
  %693 = load ptr, ptr %692, align 8
  %694 = icmp eq ptr %693, @nil_typ
  %695 = icmp eq ptr %693, null
  %696 = or i1 %694, %695
  br i1 %696, label %._crit_edge105.loopexit.i2275, label %645

._crit_edge105.loopexit.i2275:                    ; preds = %._crit_edge.thread.i2268
  %697 = icmp eq i32 %spec.store.select.i2273, -1
  %.pre.i2278.pre = select i1 %697, i32 %688, i32 %spec.store.select.i2273
  br label %HashMap_find_slot_keyK_hashPtri32.exit2282

HashMap_find_slot_keyK_hashPtri32.exit2282.loopexit: ; preds = %._crit_edge.i2279
  %.pre2438 = load ptr, ptr %28, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit2282

HashMap_find_slot_keyK_hashPtri32.exit2282:       ; preds = %HashMap_find_slot_keyK_hashPtri32.exit2282.loopexit, %620, %._crit_edge105.loopexit.i2275
  %698 = phi ptr [ %689, %._crit_edge105.loopexit.i2275 ], [ %636, %620 ], [ %.pre2438, %HashMap_find_slot_keyK_hashPtri32.exit2282.loopexit ]
  %699 = phi i32 [ %.pre.i2278.pre, %._crit_edge105.loopexit.i2275 ], [ %634, %620 ], [ %646, %HashMap_find_slot_keyK_hashPtri32.exit2282.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %700 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %701 = sext i32 %699 to i64
  %702 = shl nsw i64 %701, 5
  %703 = getelementptr i8, ptr %698, i64 %702
  %704 = load ptr, ptr %703, align 8
  %705 = getelementptr i8, ptr %703, i64 8
  %706 = load i64, ptr %705, align 4
  %.sroa_idx.i2064 = getelementptr i8, ptr %703, i64 16
  %707 = load i64, ptr %.sroa_idx.i2064, align 4
  %708 = load ptr, ptr %21, align 8
  %709 = load ptr, ptr %631, align 8, !alias.scope !175
  %710 = getelementptr i8, ptr %709, i64 72
  %711 = load ptr, ptr %710, align 8, !alias.scope !175
  %result.i.i.i2066 = call { i64, i64 } %711(ptr nocapture nofree nonnull readonly %631) #5, !alias.scope !175
  %712 = extractvalue { i64, i64 } %result.i.i.i2066, 0
  %713 = extractvalue { i64, i64 } %result.i.i.i2066, 1
  %714 = call i64 @llvm.umax.i64(i64 %713, i64 8)
  %715 = urem i64 20, %713
  %716 = icmp eq i64 %715, 0
  %717 = sub i64 %713, %715
  %718 = select i1 %716, i64 0, i64 %717
  %719 = add i64 %712, 20
  %720 = add i64 %719, %718
  %721 = and i64 %720, 7
  %722 = icmp eq i64 %721, 0
  %723 = sub nuw nsw i64 40, %721
  %724 = select i1 %722, i64 32, i64 %723
  %725 = add i64 %724, %720
  %726 = urem i64 %725, %714
  %727 = icmp eq i64 %726, 0
  %728 = sub i64 %714, %726
  %729 = select i1 %727, i64 0, i64 %728
  %730 = add i64 %725, %729
  %result.i71.i2067 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %730, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %631, ptr %result.i71.i2067, align 8
  %731 = getelementptr inbounds i8, ptr %result.i71.i2067, i64 8
  store ptr %708, ptr %731, align 8
  %732 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i2067)
  %733 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %result.i71.i2067, 1
  %734 = insertvalue { ptr, ptr, ptr, i32 } %733, ptr undef, 2
  %735 = insertvalue { ptr, ptr, ptr, i32 } %734, i32 10, 3
  store ptr %631, ptr %3, align 8
  store ptr %708, ptr %42, align 8
  store ptr @_parameterization_Ptri32, ptr %43, align 8
  %736 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %3)
  %737 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Entry)
  %738 = load i64, ptr %611, align 4
  %739 = load i64, ptr %612, align 4
  %740 = load ptr, ptr %613, align 8
  %741 = load ptr, ptr %614, align 8
  %result.i.i117.i2068 = call i1 %740(i64 %739, i64 %738, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %741) #5
  %742 = select i1 %result.i.i117.i2068, i64 9, i64 10
  %gep2111 = getelementptr [14 x ptr], ptr getelementptr inbounds (i8, ptr @Entry, i64 80), i64 0, i64 %742
  %743 = load ptr, ptr %gep2111, align 8
  call void %743({ ptr, ptr, ptr, i32 } %735, { ptr, ptr, ptr, i32 } %735, ptr nonnull align 8 dereferenceable(24) %3, { ptr, i160 } %625, { ptr, i160 } %606, i32 %630) #7
  %744 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %745 = load ptr, ptr %28, align 8
  %746 = getelementptr i8, ptr %745, i64 %702
  store ptr @Entry, ptr %746, align 8
  %747 = getelementptr i8, ptr %746, i64 8
  %748 = ptrtoint ptr %result.i71.i2067 to i64
  store i64 %748, ptr %747, align 4
  %.sroa_idx4.i2070 = getelementptr i8, ptr %746, i64 24
  store i32 10, ptr %.sroa_idx4.i2070, align 4
  %749 = icmp eq ptr %704, @nil_typ
  %750 = icmp eq ptr %704, null
  %751 = or i1 %749, %750
  br i1 %751, label %752, label %755

752:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit2282
  %753 = load i32, ptr %39, align 4
  %754 = add i32 %753, 1
  store i32 %754, ptr %39, align 4
  br label %._crit_edge.sink.split.i2087

755:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit2282
  %756 = inttoptr i64 %706 to ptr
  %757 = inttoptr i64 %707 to ptr
  %hash_coef_ptr.i.i88.i2071 = getelementptr i8, ptr %704, i64 8
  %tbl_size_ptr.i.i89.i2072 = getelementptr i8, ptr %704, i64 16
  %offset_tbl_ptr.i.i90.i2073 = getelementptr i8, ptr %704, i64 40
  %hash_coef.i.i91.i2074 = load i64, ptr %hash_coef_ptr.i.i88.i2071, align 4, !noalias !178
  %tbl_size.i.i92.i2075 = load i64, ptr %tbl_size_ptr.i.i89.i2072, align 4, !noalias !178
  %offset_tbl.i.i93.i2076 = load ptr, ptr %offset_tbl_ptr.i.i90.i2073, align 8, !noalias !178
  %product.i.i.i94.i2077 = mul i64 %hash_coef.i.i91.i2074, 4015701072841558310
  %shifted.i.i.i95.i2078 = lshr i64 %product.i.i.i94.i2077, 32
  %xored.i.i.i96.i2079 = xor i64 %shifted.i.i.i95.i2078, %product.i.i.i94.i2077
  %hash.i.i.i97.i2080 = and i64 %xored.i.i.i96.i2079, %tbl_size.i.i92.i2075
  %offset_ptr.i.i98.i2081 = getelementptr i32, ptr %offset_tbl.i.i93.i2076, i64 %hash.i.i.i97.i2080
  %offset.i.i99.i2082 = load i32, ptr %offset_ptr.i.i98.i2081, align 4, !noalias !178
  %758 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %704, 0
  %759 = insertvalue { ptr, ptr, ptr, i32 } %758, ptr %756, 1
  %760 = insertvalue { ptr, ptr, ptr, i32 } %759, ptr %757, 2
  %761 = insertvalue { ptr, ptr, ptr, i32 } %760, i32 %offset.i.i99.i2082, 3
  %762 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %763 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %704)
  %764 = sext i32 %offset.i.i99.i2082 to i64
  %765 = getelementptr ptr, ptr %704, i64 %764
  %766 = getelementptr i8, ptr %765, i64 56
  %767 = load ptr, ptr %766, align 8
  %result.i101.i2083 = call ptr %767({ ptr, ptr, ptr, i32 } %761, ptr nocapture nofree noundef nonnull readonly %2) #16
  %768 = call { ptr, i160 } %result.i101.i2083({ ptr, ptr, ptr, i32 } %761, { ptr, ptr, ptr, i32 } %761, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i2084 = extractvalue { ptr, i160 } %768, 0
  %769 = getelementptr i8, ptr %.fca.0.extract51.i2084, i64 8
  %770 = getelementptr i8, ptr %.fca.0.extract51.i2084, i64 16
  %771 = getelementptr i8, ptr %.fca.0.extract51.i2084, i64 24
  %772 = getelementptr i8, ptr %.fca.0.extract51.i2084, i64 32
  %773 = load i64, ptr %769, align 4
  %774 = load i64, ptr %770, align 4
  %775 = load ptr, ptr %771, align 8
  %776 = load ptr, ptr %772, align 8
  %result.i102.i2085 = call i1 %775(i64 %774, i64 %773, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %776) #5
  br i1 %result.i102.i2085, label %._crit_edge.sink.split.i2087, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit2089

._crit_edge.sink.split.i2087:                     ; preds = %755, %752
  %.sink159.i2088 = phi i64 [ 48, %752 ], [ 40, %755 ]
  %777 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %778 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i2088
  %779 = load ptr, ptr %778, align 8
  %780 = load ptr, ptr %779, align 8
  %781 = call i32 %780(ptr nonnull %result.i421) #36
  %782 = add i32 %781, 1
  %783 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %784 = getelementptr i8, ptr %779, i64 8
  %785 = load ptr, ptr %784, align 8
  call void %785(ptr nonnull %result.i421, i32 %782) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit2089

HashMap_insert_internal_keyK_valueV_hashPtri32.exit2089: ; preds = %755, %._crit_edge.sink.split.i2087
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %3)
  br label %._crit_edge.i1797

._crit_edge.i1797:                                ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit2089, %590, %.lr.ph.i1794
  %786 = add nuw nsw i32 %.096.i1795, 1
  %787 = icmp slt i32 %786, %572
  br i1 %787, label %.lr.ph.i1794, label %HashMap_resize_new_capacityPtri32.exit1820

HashMap_resize_new_capacityPtri32.exit1820:       ; preds = %._crit_edge.i1797, %._crit_edge1.i1332
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %HashMap_ensure_capacity_required_loadPtri32.exit1336

HashMap_ensure_capacity_required_loadPtri32.exit1336: ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit, %HashMap_resize_new_capacityPtri32.exit1820
  %788 = load ptr, ptr %26, align 8
  %789 = call i32 %788({ ptr, i160 } %49) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %790 = load ptr, ptr %result.i421, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %791 = load i32, ptr %29, align 8
  %792 = add i32 %791, -1
  %793 = and i32 %792, %789
  %794 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %795 = load ptr, ptr %28, align 8
  %796 = sext i32 %793 to i64
  %797 = shl nsw i64 %796, 5
  %798 = getelementptr i8, ptr %795, i64 %797
  %799 = load ptr, ptr %798, align 8
  %800 = icmp eq ptr %799, @nil_typ
  %801 = icmp eq ptr %799, null
  %802 = or i1 %800, %801
  br i1 %802, label %HashMap_find_slot_keyK_hashPtri32.exit1865, label %.lr.ph.i1835

.lr.ph.i1835:                                     ; preds = %HashMap_ensure_capacity_required_loadPtri32.exit1336
  %803 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %804

804:                                              ; preds = %._crit_edge.thread.i1851, %.lr.ph.i1835
  %805 = phi i32 [ %793, %.lr.ph.i1835 ], [ %847, %._crit_edge.thread.i1851 ]
  %spec.store.select.i18561901 = phi i32 [ -1, %.lr.ph.i1835 ], [ %spec.store.select.i1856, %._crit_edge.thread.i1851 ]
  %806 = phi ptr [ %799, %.lr.ph.i1835 ], [ %852, %._crit_edge.thread.i1851 ]
  %807 = phi ptr [ %798, %.lr.ph.i1835 ], [ %851, %._crit_edge.thread.i1851 ]
  %.sroa_idx.i1837 = getelementptr i8, ptr %807, i64 16
  %808 = load i64, ptr %.sroa_idx.i1837, align 4
  %809 = getelementptr i8, ptr %807, i64 8
  %810 = load i64, ptr %809, align 4
  %811 = inttoptr i64 %810 to ptr
  %812 = inttoptr i64 %808 to ptr
  %hash_coef_ptr.i.i56.i1838 = getelementptr i8, ptr %806, i64 8
  %tbl_size_ptr.i.i57.i1839 = getelementptr i8, ptr %806, i64 16
  %offset_tbl_ptr.i.i58.i1840 = getelementptr i8, ptr %806, i64 40
  %hash_coef.i.i59.i1841 = load i64, ptr %hash_coef_ptr.i.i56.i1838, align 4
  %tbl_size.i.i60.i1842 = load i64, ptr %tbl_size_ptr.i.i57.i1839, align 4
  %offset_tbl.i.i61.i1843 = load ptr, ptr %offset_tbl_ptr.i.i58.i1840, align 8
  %product.i.i.i62.i1844 = mul i64 %hash_coef.i.i59.i1841, 4015701072841558310
  %shifted.i.i.i63.i1845 = lshr i64 %product.i.i.i62.i1844, 32
  %xored.i.i.i64.i1846 = xor i64 %shifted.i.i.i63.i1845, %product.i.i.i62.i1844
  %hash.i.i.i65.i1847 = and i64 %xored.i.i.i64.i1846, %tbl_size.i.i60.i1842
  %offset_ptr.i.i66.i1848 = getelementptr i32, ptr %offset_tbl.i.i61.i1843, i64 %hash.i.i.i65.i1847
  %offset.i.i67.i1849 = load i32, ptr %offset_ptr.i.i66.i1848, align 4
  %813 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %806, 0
  %814 = insertvalue { ptr, ptr, ptr, i32 } %813, ptr %811, 1
  %815 = insertvalue { ptr, ptr, ptr, i32 } %814, ptr %812, 2
  %816 = insertvalue { ptr, ptr, ptr, i32 } %815, i32 %offset.i.i67.i1849, 3
  %817 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %806)
  %818 = sext i32 %offset.i.i67.i1849 to i64
  %819 = getelementptr ptr, ptr %806, i64 %818
  %820 = getelementptr i8, ptr %819, i64 64
  %821 = load ptr, ptr %820, align 8
  %result.i.i1850 = call ptr %821({ ptr, ptr, ptr, i32 } %816, ptr nocapture nofree noundef nonnull readonly %2) #16
  %822 = call i32 %result.i.i1850({ ptr, ptr, ptr, i32 } %816, { ptr, ptr, ptr, i32 } %816, ptr nonnull align 8 %2) #7
  %823 = icmp eq i32 %822, %789
  br i1 %823, label %._crit_edge.i1862, label %._crit_edge.thread.i1851

._crit_edge.i1862:                                ; preds = %804
  %824 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %825 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %806)
  %826 = getelementptr i8, ptr %819, i64 48
  %827 = load ptr, ptr %826, align 8
  %result.i69.i1863 = call ptr %827({ ptr, ptr, ptr, i32 } %816, ptr nocapture nofree noundef nonnull readonly %2) #16
  %828 = call { ptr, i160 } %result.i69.i1863({ ptr, ptr, ptr, i32 } %816, { ptr, ptr, ptr, i32 } %816, ptr nonnull align 8 %2) #7
  %829 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %830 = load ptr, ptr %27, align 8
  %831 = call i1 %830({ ptr, i160 } %828, { ptr, i160 } %49) #7
  br i1 %831, label %HashMap_find_slot_keyK_hashPtri32.exit1865.loopexit, label %._crit_edge.thread.i1851

._crit_edge.thread.i1851:                         ; preds = %._crit_edge.i1862, %804
  %832 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %833 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %806)
  %834 = getelementptr i8, ptr %819, i64 56
  %835 = load ptr, ptr %834, align 8
  %result.i70.i1852 = call ptr %835({ ptr, ptr, ptr, i32 } %816, ptr nocapture nofree noundef nonnull readonly %2) #16
  %836 = call { ptr, i160 } %result.i70.i1852({ ptr, ptr, ptr, i32 } %816, { ptr, ptr, ptr, i32 } %816, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i1853 = extractvalue { ptr, i160 } %836, 0
  %837 = getelementptr i8, ptr %.fca.0.extract19.i1853, i64 8
  %838 = getelementptr i8, ptr %.fca.0.extract19.i1853, i64 16
  %839 = getelementptr i8, ptr %.fca.0.extract19.i1853, i64 24
  %840 = getelementptr i8, ptr %.fca.0.extract19.i1853, i64 32
  %841 = load i64, ptr %837, align 4
  %842 = load i64, ptr %838, align 4
  %843 = load ptr, ptr %839, align 8
  %844 = load ptr, ptr %840, align 8
  %result.i71.i1854 = call i1 %843(i64 %842, i64 %841, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %844) #5
  %845 = icmp eq i32 %spec.store.select.i18561901, -1
  %or.cond.i1855 = select i1 %result.i71.i1854, i1 %845, i1 false
  %spec.store.select.i1856 = select i1 %or.cond.i1855, i32 %805, i32 %spec.store.select.i18561901
  %846 = add i32 %805, 1
  %847 = and i32 %846, %792
  %848 = load ptr, ptr %28, align 8
  %849 = sext i32 %847 to i64
  %850 = shl nsw i64 %849, 5
  %851 = getelementptr i8, ptr %848, i64 %850
  %852 = load ptr, ptr %851, align 8
  %853 = icmp eq ptr %852, @nil_typ
  %854 = icmp eq ptr %852, null
  %855 = or i1 %853, %854
  br i1 %855, label %._crit_edge105.loopexit.i1858, label %804

._crit_edge105.loopexit.i1858:                    ; preds = %._crit_edge.thread.i1851
  %856 = icmp eq i32 %spec.store.select.i1856, -1
  %.pre.i1861.pre = select i1 %856, i32 %847, i32 %spec.store.select.i1856
  br label %HashMap_find_slot_keyK_hashPtri32.exit1865

HashMap_find_slot_keyK_hashPtri32.exit1865.loopexit: ; preds = %._crit_edge.i1862
  %.pre2000 = load ptr, ptr %28, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit1865

HashMap_find_slot_keyK_hashPtri32.exit1865:       ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1865.loopexit, %HashMap_ensure_capacity_required_loadPtri32.exit1336, %._crit_edge105.loopexit.i1858
  %857 = phi ptr [ %848, %._crit_edge105.loopexit.i1858 ], [ %795, %HashMap_ensure_capacity_required_loadPtri32.exit1336 ], [ %.pre2000, %HashMap_find_slot_keyK_hashPtri32.exit1865.loopexit ]
  %858 = phi i32 [ %.pre.i1861.pre, %._crit_edge105.loopexit.i1858 ], [ %793, %HashMap_ensure_capacity_required_loadPtri32.exit1336 ], [ %805, %HashMap_find_slot_keyK_hashPtri32.exit1865.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %859 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %860 = sext i32 %858 to i64
  %861 = shl nsw i64 %860, 5
  %862 = getelementptr i8, ptr %857, i64 %861
  %863 = load ptr, ptr %862, align 8
  %864 = getelementptr i8, ptr %862, i64 8
  %865 = load i64, ptr %864, align 4
  %.sroa_idx.i1356 = getelementptr i8, ptr %862, i64 16
  %866 = load i64, ptr %.sroa_idx.i1356, align 4
  %867 = load ptr, ptr %21, align 8
  %868 = load ptr, ptr %790, align 8, !alias.scope !181
  %869 = getelementptr i8, ptr %868, i64 72
  %870 = load ptr, ptr %869, align 8, !alias.scope !181
  %result.i.i.i1358 = call { i64, i64 } %870(ptr nocapture nofree nonnull readonly %790) #5, !alias.scope !181
  %871 = extractvalue { i64, i64 } %result.i.i.i1358, 0
  %872 = extractvalue { i64, i64 } %result.i.i.i1358, 1
  %873 = call i64 @llvm.umax.i64(i64 %872, i64 8)
  %874 = urem i64 20, %872
  %875 = icmp eq i64 %874, 0
  %876 = sub i64 %872, %874
  %877 = select i1 %875, i64 0, i64 %876
  %878 = add i64 %871, 20
  %879 = add i64 %878, %877
  %880 = and i64 %879, 7
  %881 = icmp eq i64 %880, 0
  %882 = sub nuw nsw i64 40, %880
  %883 = select i1 %881, i64 32, i64 %882
  %884 = add i64 %883, %879
  %885 = urem i64 %884, %873
  %886 = icmp eq i64 %885, 0
  %887 = sub i64 %873, %885
  %888 = select i1 %886, i64 0, i64 %887
  %889 = add i64 %884, %888
  %result.i71.i1359 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %889, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %790, ptr %result.i71.i1359, align 8
  %890 = getelementptr inbounds i8, ptr %result.i71.i1359, i64 8
  store ptr %867, ptr %890, align 8
  %891 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i1359)
  %892 = load ptr, ptr %790, align 8
  %893 = getelementptr i8, ptr %892, i64 72
  %894 = load ptr, ptr %893, align 8
  %result.i.i1956 = call { i64, i64 } %894(ptr nocapture nofree nonnull readonly %790) #5
  %895 = extractvalue { i64, i64 } %result.i.i1956, 1
  %896 = urem i64 20, %895
  %897 = icmp eq i64 %896, 0
  %reass.sub2410 = sub i64 %895, %896
  %898 = add i64 %reass.sub2410, 20
  %899 = select i1 %897, i64 20, i64 %898
  %900 = getelementptr i8, ptr %result.i71.i1359, i64 %899
  %901 = getelementptr i8, ptr %892, i64 64
  %902 = load ptr, ptr %901, align 8
  call void %902({ ptr, i160 } %49, ptr nocapture nofree nonnull readonly %790, ptr nocapture nofree writeonly %900) #13
  %903 = load ptr, ptr %result.i71.i1359, align 8
  %904 = load ptr, ptr %903, align 8
  %905 = getelementptr i8, ptr %904, i64 72
  %906 = load ptr, ptr %905, align 8
  %result.i.i1958 = call { i64, i64 } %906(ptr nocapture nofree nonnull readonly %903) #5
  %907 = extractvalue { i64, i64 } %result.i.i1958, 0
  %908 = extractvalue { i64, i64 } %result.i.i1958, 1
  %909 = urem i64 20, %908
  %910 = icmp eq i64 %909, 0
  %911 = sub i64 %908, %909
  %912 = select i1 %910, i64 0, i64 %911
  %913 = add i64 %907, 20
  %914 = add i64 %913, %912
  %915 = and i64 %914, 7
  %916 = icmp eq i64 %915, 0
  %917 = sub nuw nsw i64 8, %915
  %918 = select i1 %916, i64 0, i64 %917
  %919 = getelementptr i8, ptr %result.i71.i1359, i64 %914
  %920 = getelementptr i8, ptr %919, i64 %918
  store ptr @bool_typ, ptr %920, align 8
  %921 = getelementptr i8, ptr %920, i64 8
  store i160 %.sroa.0316.0.insert.ext, ptr %921, align 4
  %922 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @Entry) #34
  %923 = getelementptr inbounds i8, ptr %result.i71.i1359, i64 16
  store i32 %789, ptr %923, align 8
  %924 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  store ptr @Entry, ptr %862, align 8
  %925 = ptrtoint ptr %result.i71.i1359 to i64
  store i64 %925, ptr %864, align 4
  %.sroa_idx4.i1362 = getelementptr i8, ptr %862, i64 24
  store i32 10, ptr %.sroa_idx4.i1362, align 4
  %926 = icmp eq ptr %863, @nil_typ
  %927 = icmp eq ptr %863, null
  %928 = or i1 %926, %927
  br i1 %928, label %929, label %932

929:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1865
  %930 = load i32, ptr %39, align 4
  %931 = add i32 %930, 1
  store i32 %931, ptr %39, align 4
  br label %._crit_edge.sink.split.i1379

932:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1865
  %933 = inttoptr i64 %865 to ptr
  %934 = inttoptr i64 %866 to ptr
  %hash_coef_ptr.i.i88.i1363 = getelementptr i8, ptr %863, i64 8
  %tbl_size_ptr.i.i89.i1364 = getelementptr i8, ptr %863, i64 16
  %offset_tbl_ptr.i.i90.i1365 = getelementptr i8, ptr %863, i64 40
  %hash_coef.i.i91.i1366 = load i64, ptr %hash_coef_ptr.i.i88.i1363, align 4, !noalias !184
  %tbl_size.i.i92.i1367 = load i64, ptr %tbl_size_ptr.i.i89.i1364, align 4, !noalias !184
  %offset_tbl.i.i93.i1368 = load ptr, ptr %offset_tbl_ptr.i.i90.i1365, align 8, !noalias !184
  %product.i.i.i94.i1369 = mul i64 %hash_coef.i.i91.i1366, 4015701072841558310
  %shifted.i.i.i95.i1370 = lshr i64 %product.i.i.i94.i1369, 32
  %xored.i.i.i96.i1371 = xor i64 %shifted.i.i.i95.i1370, %product.i.i.i94.i1369
  %hash.i.i.i97.i1372 = and i64 %xored.i.i.i96.i1371, %tbl_size.i.i92.i1367
  %offset_ptr.i.i98.i1373 = getelementptr i32, ptr %offset_tbl.i.i93.i1368, i64 %hash.i.i.i97.i1372
  %offset.i.i99.i1374 = load i32, ptr %offset_ptr.i.i98.i1373, align 4, !noalias !184
  %935 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %863, 0
  %936 = insertvalue { ptr, ptr, ptr, i32 } %935, ptr %933, 1
  %937 = insertvalue { ptr, ptr, ptr, i32 } %936, ptr %934, 2
  %938 = insertvalue { ptr, ptr, ptr, i32 } %937, i32 %offset.i.i99.i1374, 3
  %939 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %940 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %863)
  %941 = sext i32 %offset.i.i99.i1374 to i64
  %942 = getelementptr ptr, ptr %863, i64 %941
  %943 = getelementptr i8, ptr %942, i64 56
  %944 = load ptr, ptr %943, align 8
  %result.i101.i1375 = call ptr %944({ ptr, ptr, ptr, i32 } %938, ptr nocapture nofree noundef nonnull readonly %2) #16
  %945 = call { ptr, i160 } %result.i101.i1375({ ptr, ptr, ptr, i32 } %938, { ptr, ptr, ptr, i32 } %938, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i1376 = extractvalue { ptr, i160 } %945, 0
  %946 = getelementptr i8, ptr %.fca.0.extract51.i1376, i64 8
  %947 = getelementptr i8, ptr %.fca.0.extract51.i1376, i64 16
  %948 = getelementptr i8, ptr %.fca.0.extract51.i1376, i64 24
  %949 = getelementptr i8, ptr %.fca.0.extract51.i1376, i64 32
  %950 = load i64, ptr %946, align 4
  %951 = load i64, ptr %947, align 4
  %952 = load ptr, ptr %948, align 8
  %953 = load ptr, ptr %949, align 8
  %result.i102.i1377 = call i1 %952(i64 %951, i64 %950, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %953) #5
  br i1 %result.i102.i1377, label %._crit_edge.sink.split.i1379, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1381

._crit_edge.sink.split.i1379:                     ; preds = %932, %929
  %.sink159.i1380 = phi i64 [ 48, %929 ], [ 40, %932 ]
  %954 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %955 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i1380
  %956 = load ptr, ptr %955, align 8
  %957 = load ptr, ptr %956, align 8
  %958 = call i32 %957(ptr nonnull %result.i421) #36
  %959 = add i32 %958, 1
  %960 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %961 = getelementptr i8, ptr %956, i64 8
  %962 = load ptr, ptr %961, align 8
  call void %962(ptr nonnull %result.i421, i32 %959) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1381

HashMap_insert_internal_keyK_valueV_hashPtri32.exit1381: ; preds = %932, %._crit_edge.sink.split.i1379
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %963 = add nsw i32 %.0357715, 1
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1381, %HashMap_get_keyK.exit
  %.2359 = phi i32 [ %963, %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1381 ], [ %.0357715, %HashMap_get_keyK.exit ]
  %964 = add nuw nsw i32 %.0355716, 1
  %965 = icmp slt i32 %.2359, %0
  %966 = icmp slt i32 %964, %31
  %spec.select = select i1 %965, i1 %966, i1 false
  br i1 %spec.select, label %44, label %._crit_edge3._crit_edge

._crit_edge3._crit_edge:                          ; preds = %._crit_edge1, %1
  %.0357.lcssa = phi i32 [ 0, %1 ], [ %.2359, %._crit_edge1 ]
  %967 = icmp slt i32 %.0357.lcssa, %0
  br i1 %967, label %._crit_edge.lr.ph.i, label %._crit_edge4

._crit_edge.lr.ph.i:                              ; preds = %._crit_edge3._crit_edge
  %result.i450 = call noalias align 32 dereferenceable_or_null(30) ptr @bump_malloc_inner(i64 noundef 30, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <29 x i8> <i8 87, i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 67, i8 111, i8 117, i8 108, i8 100, i8 32, i8 111, i8 110, i8 108, i8 121, i8 32, i8 103, i8 101, i8 110, i8 101, i8 114, i8 97, i8 116, i8 101, i8 32>, ptr %result.i450, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %968 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %969 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1395 = call noalias dereferenceable_or_null(30) ptr @bump_malloc_inner(i64 noundef 30, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(29) %result.i.i1395, ptr noundef nonnull align 32 dereferenceable(29) %result.i450, i64 29, i1 false)
  %970 = getelementptr i8, ptr %result.i.i1395, i64 29
  store i8 0, ptr %970, align 1
  %puts.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1395)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %971 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0357.lcssa) #17
  %result.i456 = call noalias align 32 dereferenceable_or_null(30) ptr @bump_malloc_inner(i64 noundef 30, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <29 x i8> <i8 32, i8 117, i8 110, i8 105, i8 113, i8 117, i8 101, i8 32, i8 107, i8 101, i8 121, i8 115, i8 32, i8 102, i8 111, i8 114, i8 32, i8 114, i8 101, i8 109, i8 111, i8 118, i8 101, i8 32, i8 116, i8 101, i8 115, i8 116, i8 46>, ptr %result.i456, align 32
  %972 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %973 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %974 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1410 = call noalias dereferenceable_or_null(30) ptr @bump_malloc_inner(i64 noundef 30, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(29) %result.i.i1410, ptr noundef nonnull align 32 dereferenceable(29) %result.i456, i64 29, i1 false)
  %975 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %976 = getelementptr i8, ptr %result.i.i1410, i64 29
  store i8 0, ptr %976, align 1
  %puts.i1016 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1410)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %._crit_edge4

._crit_edge4:                                     ; preds = %._crit_edge3._crit_edge, %._crit_edge.lr.ph.i
  %.0365 = phi i32 [ %.0357.lcssa, %._crit_edge.lr.ph.i ], [ %0, %._crit_edge3._crit_edge ]
  %977 = call i64 @clock()
  %978 = icmp sgt i32 %.0365, 0
  br i1 %978, label %.lr.ph723.preheader, label %._crit_edge8

.lr.ph723.preheader:                              ; preds = %._crit_edge4
  %979 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  %980 = getelementptr inbounds i8, ptr %result.i378, i64 36
  br label %.lr.ph723

.lr.ph723:                                        ; preds = %.lr.ph723.preheader, %._crit_edge5
  %.0354722 = phi i32 [ %.2, %._crit_edge5 ], [ 0, %.lr.ph723.preheader ]
  %.0360721 = phi i1 [ %.3, %._crit_edge5 ], [ true, %.lr.ph723.preheader ]
  %.0363720 = phi i32 [ %1211, %._crit_edge5 ], [ 0, %.lr.ph723.preheader ]
  %981 = load ptr, ptr %19, align 8
  %982 = zext nneg i32 %.0363720 to i64
  %983 = shl nuw nsw i64 %982, 2
  %984 = getelementptr i8, ptr %981, i64 %983
  %985 = load i32, ptr %984, align 1
  %.sroa.2.sroa.0.0.insert.ext.i = zext i32 %985 to i160
  %986 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %987 = load ptr, ptr %10, align 8
  %988 = call i32 %987({ ptr, i160 } %986) #7
  %989 = load ptr, ptr %result.i378, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %990 = load i32, ptr %13, align 8
  %991 = add i32 %990, -1
  %992 = and i32 %991, %988
  %993 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %994 = load ptr, ptr %12, align 8
  %995 = sext i32 %992 to i64
  %996 = shl nsw i64 %995, 5
  %997 = getelementptr i8, ptr %994, i64 %996
  %998 = load ptr, ptr %997, align 8
  %999 = icmp eq ptr %998, @nil_typ
  %1000 = icmp eq ptr %998, null
  %1001 = or i1 %999, %1000
  br i1 %1001, label %HashMap_find_slot_keyK_hashPtri32.exit1460, label %.lr.ph.i1430

.lr.ph.i1430:                                     ; preds = %.lr.ph723
  %1002 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1003

1003:                                             ; preds = %._crit_edge.thread.i1446, %.lr.ph.i1430
  %1004 = phi i32 [ %992, %.lr.ph.i1430 ], [ %1046, %._crit_edge.thread.i1446 ]
  %spec.store.select.i14511653 = phi i32 [ -1, %.lr.ph.i1430 ], [ %spec.store.select.i1451, %._crit_edge.thread.i1446 ]
  %1005 = phi ptr [ %998, %.lr.ph.i1430 ], [ %1051, %._crit_edge.thread.i1446 ]
  %1006 = phi ptr [ %997, %.lr.ph.i1430 ], [ %1050, %._crit_edge.thread.i1446 ]
  %.sroa_idx.i1432 = getelementptr i8, ptr %1006, i64 16
  %1007 = load i64, ptr %.sroa_idx.i1432, align 4
  %1008 = getelementptr i8, ptr %1006, i64 8
  %1009 = load i64, ptr %1008, align 4
  %1010 = inttoptr i64 %1009 to ptr
  %1011 = inttoptr i64 %1007 to ptr
  %hash_coef_ptr.i.i56.i1433 = getelementptr i8, ptr %1005, i64 8
  %tbl_size_ptr.i.i57.i1434 = getelementptr i8, ptr %1005, i64 16
  %offset_tbl_ptr.i.i58.i1435 = getelementptr i8, ptr %1005, i64 40
  %hash_coef.i.i59.i1436 = load i64, ptr %hash_coef_ptr.i.i56.i1433, align 4
  %tbl_size.i.i60.i1437 = load i64, ptr %tbl_size_ptr.i.i57.i1434, align 4
  %offset_tbl.i.i61.i1438 = load ptr, ptr %offset_tbl_ptr.i.i58.i1435, align 8
  %product.i.i.i62.i1439 = mul i64 %hash_coef.i.i59.i1436, 4015701072841558310
  %shifted.i.i.i63.i1440 = lshr i64 %product.i.i.i62.i1439, 32
  %xored.i.i.i64.i1441 = xor i64 %shifted.i.i.i63.i1440, %product.i.i.i62.i1439
  %hash.i.i.i65.i1442 = and i64 %xored.i.i.i64.i1441, %tbl_size.i.i60.i1437
  %offset_ptr.i.i66.i1443 = getelementptr i32, ptr %offset_tbl.i.i61.i1438, i64 %hash.i.i.i65.i1442
  %offset.i.i67.i1444 = load i32, ptr %offset_ptr.i.i66.i1443, align 4
  %1012 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1005, 0
  %1013 = insertvalue { ptr, ptr, ptr, i32 } %1012, ptr %1010, 1
  %1014 = insertvalue { ptr, ptr, ptr, i32 } %1013, ptr %1011, 2
  %1015 = insertvalue { ptr, ptr, ptr, i32 } %1014, i32 %offset.i.i67.i1444, 3
  %1016 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1005)
  %1017 = sext i32 %offset.i.i67.i1444 to i64
  %1018 = getelementptr ptr, ptr %1005, i64 %1017
  %1019 = getelementptr i8, ptr %1018, i64 64
  %1020 = load ptr, ptr %1019, align 8
  %result.i.i1445 = call ptr %1020({ ptr, ptr, ptr, i32 } %1015, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1021 = call i32 %result.i.i1445({ ptr, ptr, ptr, i32 } %1015, { ptr, ptr, ptr, i32 } %1015, ptr nonnull align 8 %2) #7
  %1022 = icmp eq i32 %1021, %988
  br i1 %1022, label %._crit_edge.i1457, label %._crit_edge.thread.i1446

._crit_edge.i1457:                                ; preds = %1003
  %1023 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1024 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1005)
  %1025 = getelementptr i8, ptr %1018, i64 48
  %1026 = load ptr, ptr %1025, align 8
  %result.i69.i1458 = call ptr %1026({ ptr, ptr, ptr, i32 } %1015, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1027 = call { ptr, i160 } %result.i69.i1458({ ptr, ptr, ptr, i32 } %1015, { ptr, ptr, ptr, i32 } %1015, ptr nonnull align 8 %2) #7
  %1028 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1029 = load ptr, ptr %11, align 8
  %1030 = call i1 %1029({ ptr, i160 } %1027, { ptr, i160 } %986) #7
  br i1 %1030, label %HashMap_find_slot_keyK_hashPtri32.exit1460.loopexit, label %._crit_edge.thread.i1446

._crit_edge.thread.i1446:                         ; preds = %._crit_edge.i1457, %1003
  %1031 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1032 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1005)
  %1033 = getelementptr i8, ptr %1018, i64 56
  %1034 = load ptr, ptr %1033, align 8
  %result.i70.i1447 = call ptr %1034({ ptr, ptr, ptr, i32 } %1015, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1035 = call { ptr, i160 } %result.i70.i1447({ ptr, ptr, ptr, i32 } %1015, { ptr, ptr, ptr, i32 } %1015, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i1448 = extractvalue { ptr, i160 } %1035, 0
  %1036 = getelementptr i8, ptr %.fca.0.extract19.i1448, i64 8
  %1037 = getelementptr i8, ptr %.fca.0.extract19.i1448, i64 16
  %1038 = getelementptr i8, ptr %.fca.0.extract19.i1448, i64 24
  %1039 = getelementptr i8, ptr %.fca.0.extract19.i1448, i64 32
  %1040 = load i64, ptr %1036, align 4
  %1041 = load i64, ptr %1037, align 4
  %1042 = load ptr, ptr %1038, align 8
  %1043 = load ptr, ptr %1039, align 8
  %result.i71.i1449 = call i1 %1042(i64 %1041, i64 %1040, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %1043) #5
  %1044 = icmp eq i32 %spec.store.select.i14511653, -1
  %or.cond.i1450 = select i1 %result.i71.i1449, i1 %1044, i1 false
  %spec.store.select.i1451 = select i1 %or.cond.i1450, i32 %1004, i32 %spec.store.select.i14511653
  %1045 = add i32 %1004, 1
  %1046 = and i32 %1045, %991
  %1047 = load ptr, ptr %12, align 8
  %1048 = sext i32 %1046 to i64
  %1049 = shl nsw i64 %1048, 5
  %1050 = getelementptr i8, ptr %1047, i64 %1049
  %1051 = load ptr, ptr %1050, align 8
  %1052 = icmp eq ptr %1051, @nil_typ
  %1053 = icmp eq ptr %1051, null
  %1054 = or i1 %1052, %1053
  br i1 %1054, label %._crit_edge105.loopexit.i1453, label %1003

._crit_edge105.loopexit.i1453:                    ; preds = %._crit_edge.thread.i1446
  %1055 = icmp eq i32 %spec.store.select.i1451, -1
  %.pre.i1456.pre = select i1 %1055, i32 %1046, i32 %spec.store.select.i1451
  br label %HashMap_find_slot_keyK_hashPtri32.exit1460

HashMap_find_slot_keyK_hashPtri32.exit1460.loopexit: ; preds = %._crit_edge.i1457
  %.pre1712 = load ptr, ptr %12, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit1460

HashMap_find_slot_keyK_hashPtri32.exit1460:       ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1460.loopexit, %.lr.ph723, %._crit_edge105.loopexit.i1453
  %1056 = phi ptr [ %1047, %._crit_edge105.loopexit.i1453 ], [ %994, %.lr.ph723 ], [ %.pre1712, %HashMap_find_slot_keyK_hashPtri32.exit1460.loopexit ]
  %1057 = phi i32 [ %.pre.i1456.pre, %._crit_edge105.loopexit.i1453 ], [ %992, %.lr.ph723 ], [ %1004, %HashMap_find_slot_keyK_hashPtri32.exit1460.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1058 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1059 = sext i32 %1057 to i64
  %1060 = shl nsw i64 %1059, 5
  %1061 = getelementptr i8, ptr %1056, i64 %1060
  %1062 = load ptr, ptr %1061, align 8
  %1063 = icmp ne ptr %1062, @nil_typ
  %1064 = icmp ne ptr %1062, null
  %.not100.i = and i1 %1063, %1064
  br i1 %.not100.i, label %1065, label %HashMap_remove_keyK.exit.thread

1065:                                             ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1460
  %1066 = getelementptr i8, ptr %1061, i64 8
  %1067 = load i64, ptr %1066, align 4
  %.sroa_idx.i1046 = getelementptr i8, ptr %1061, i64 16
  %1068 = load i64, ptr %.sroa_idx.i1046, align 4
  %1069 = inttoptr i64 %1067 to ptr
  %1070 = inttoptr i64 %1068 to ptr
  %hash_coef_ptr.i.i103.i = getelementptr i8, ptr %1062, i64 8
  %tbl_size_ptr.i.i104.i = getelementptr i8, ptr %1062, i64 16
  %offset_tbl_ptr.i.i105.i = getelementptr i8, ptr %1062, i64 40
  %hash_coef.i.i106.i = load i64, ptr %hash_coef_ptr.i.i103.i, align 4, !noalias !187
  %tbl_size.i.i107.i = load i64, ptr %tbl_size_ptr.i.i104.i, align 4, !noalias !187
  %offset_tbl.i.i108.i = load ptr, ptr %offset_tbl_ptr.i.i105.i, align 8, !noalias !187
  %product.i.i.i109.i = mul i64 %hash_coef.i.i106.i, 4015701072841558310
  %shifted.i.i.i110.i = lshr i64 %product.i.i.i109.i, 32
  %xored.i.i.i111.i = xor i64 %shifted.i.i.i110.i, %product.i.i.i109.i
  %hash.i.i.i112.i = and i64 %xored.i.i.i111.i, %tbl_size.i.i107.i
  %offset_ptr.i.i113.i = getelementptr i32, ptr %offset_tbl.i.i108.i, i64 %hash.i.i.i112.i
  %offset.i.i114.i = load i32, ptr %offset_ptr.i.i113.i, align 4, !noalias !187
  %1071 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1062, 0
  %1072 = insertvalue { ptr, ptr, ptr, i32 } %1071, ptr %1069, 1
  %1073 = insertvalue { ptr, ptr, ptr, i32 } %1072, ptr %1070, 2
  %1074 = insertvalue { ptr, ptr, ptr, i32 } %1073, i32 %offset.i.i114.i, 3
  %1075 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1076 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1062)
  %1077 = sext i32 %offset.i.i114.i to i64
  %1078 = getelementptr ptr, ptr %1062, i64 %1077
  %1079 = getelementptr i8, ptr %1078, i64 64
  %1080 = load ptr, ptr %1079, align 8
  %result.i116.i = call ptr %1080({ ptr, ptr, ptr, i32 } %1074, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1081 = call i32 %result.i116.i({ ptr, ptr, ptr, i32 } %1074, { ptr, ptr, ptr, i32 } %1074, ptr nonnull align 8 %2) #7
  %1082 = icmp eq i32 %1081, %988
  br i1 %1082, label %._crit_edge.i1047, label %HashMap_remove_keyK.exit.thread

._crit_edge.i1047:                                ; preds = %1065
  %1083 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1084 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1062)
  %1085 = getelementptr i8, ptr %1078, i64 48
  %1086 = load ptr, ptr %1085, align 8
  %result.i117.i = call ptr %1086({ ptr, ptr, ptr, i32 } %1074, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1087 = call { ptr, i160 } %result.i117.i({ ptr, ptr, ptr, i32 } %1074, { ptr, ptr, ptr, i32 } %1074, ptr nonnull align 8 %2) #7
  %1088 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1089 = load ptr, ptr %11, align 8
  %1090 = call i1 %1089({ ptr, i160 } %1087, { ptr, i160 } %986) #7
  br i1 %1090, label %1091, label %HashMap_remove_keyK.exit.thread

1091:                                             ; preds = %._crit_edge.i1047
  %1092 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1093 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1062)
  %1094 = getelementptr i8, ptr %1078, i64 56
  %1095 = load ptr, ptr %1094, align 8
  %result.i118.i = call ptr %1095({ ptr, ptr, ptr, i32 } %1074, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1096 = call { ptr, i160 } %result.i118.i({ ptr, ptr, ptr, i32 } %1074, { ptr, ptr, ptr, i32 } %1074, ptr nonnull align 8 %2) #7
  %.fca.0.extract76.i = extractvalue { ptr, i160 } %1096, 0
  %.fca.1.extract77.i = extractvalue { ptr, i160 } %1096, 1
  %1097 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1098 = load ptr, ptr %5, align 8
  %1099 = load ptr, ptr %1098, align 8
  %1100 = ptrtoint ptr %1099 to i64
  %1101 = getelementptr i8, ptr %.fca.0.extract76.i, i64 8
  %1102 = getelementptr i8, ptr %.fca.0.extract76.i, i64 16
  %1103 = getelementptr i8, ptr %.fca.0.extract76.i, i64 24
  %1104 = getelementptr i8, ptr %.fca.0.extract76.i, i64 32
  %1105 = load i64, ptr %1101, align 4
  %1106 = load i64, ptr %1102, align 4
  %1107 = load ptr, ptr %1103, align 8
  %1108 = load ptr, ptr %1104, align 8
  %1109 = load i64, ptr %1099, align 4
  %result.i120.i1048 = call i1 %1107(i64 %1106, i64 %1105, i64 %1109, i64 %1100, ptr readonly %1108) #5
  br i1 %result.i120.i1048, label %HashMap_remove_keyK.exit, label %HashMap_remove_keyK.exit.thread

HashMap_remove_keyK.exit.thread:                  ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1460, %1065, %._crit_edge.i1047, %1091
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  br label %._crit_edge.lr.ph.i1494

HashMap_remove_keyK.exit:                         ; preds = %1091
  %1110 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1111 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1062)
  %1112 = load ptr, ptr %1085, align 8
  %result.i121.i = call ptr %1112({ ptr, ptr, ptr, i32 } %1074, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1113 = call { ptr, i160 } %result.i121.i({ ptr, ptr, ptr, i32 } %1074, { ptr, ptr, ptr, i32 } %1074, ptr nonnull align 8 %2) #7
  %1114 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 16 dereferenceable(96) @Tombstone)
  %1115 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1116 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1117 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1062)
  %1118 = load ptr, ptr %1079, align 8
  %result.i125.i = call ptr %1118({ ptr, ptr, ptr, i32 } %1074, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1119 = call i32 %result.i125.i({ ptr, ptr, ptr, i32 } %1074, { ptr, ptr, ptr, i32 } %1074, ptr nonnull align 8 %2) #7
  %1120 = load ptr, ptr %989, align 8, !alias.scope !190
  %1121 = getelementptr i8, ptr %1120, i64 72
  %1122 = load ptr, ptr %1121, align 8, !alias.scope !190
  %result.i.i.i = call { i64, i64 } %1122(ptr nocapture nofree nonnull readonly %989) #5, !alias.scope !190
  %1123 = extractvalue { i64, i64 } %result.i.i.i, 0
  %1124 = extractvalue { i64, i64 } %result.i.i.i, 1
  %1125 = call i64 @llvm.umax.i64(i64 %1124, i64 8)
  %1126 = urem i64 20, %1124
  %1127 = icmp eq i64 %1126, 0
  %1128 = sub i64 %1124, %1126
  %1129 = select i1 %1127, i64 0, i64 %1128
  %1130 = add i64 %1123, 20
  %1131 = add i64 %1130, %1129
  %1132 = and i64 %1131, 7
  %1133 = icmp eq i64 %1132, 0
  %1134 = sub nuw nsw i64 40, %1132
  %1135 = select i1 %1133, i64 32, i64 %1134
  %1136 = add i64 %1135, %1131
  %1137 = urem i64 %1136, %1125
  %1138 = icmp eq i64 %1137, 0
  %1139 = sub i64 %1125, %1137
  %1140 = select i1 %1138, i64 0, i64 %1139
  %1141 = add i64 %1136, %1140
  %result.i127.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1141, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %989, ptr %result.i127.i, align 8
  %1142 = getelementptr inbounds i8, ptr %result.i127.i, i64 8
  store ptr %1098, ptr %1142, align 8
  %1143 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i127.i)
  %1144 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1145 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1062)
  %1146 = load ptr, ptr %1085, align 8
  %result.i128.i = call ptr %1146({ ptr, ptr, ptr, i32 } %1074, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1147 = call { ptr, i160 } %result.i128.i({ ptr, ptr, ptr, i32 } %1074, { ptr, ptr, ptr, i32 } %1074, ptr nonnull align 8 %2) #7
  %result.i130.i = call noalias ptr @bump_malloc_inner(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %1148 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 16 dereferenceable(96) @Tombstone)
  %1149 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1150 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1151 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1062)
  %1152 = load ptr, ptr %1079, align 8
  %result.i132.i = call ptr %1152({ ptr, ptr, ptr, i32 } %1074, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1153 = call i32 %result.i132.i({ ptr, ptr, ptr, i32 } %1074, { ptr, ptr, ptr, i32 } %1074, ptr nonnull align 8 %2) #7
  %1154 = ptrtoint ptr %result.i130.i to i64
  %.sroa.3.8.insert.ext.i = zext i64 %1154 to i160
  %1155 = load ptr, ptr %989, align 8
  %1156 = getelementptr i8, ptr %1155, i64 72
  %1157 = load ptr, ptr %1156, align 8
  %result.i.i211.i = call { i64, i64 } %1157(ptr nocapture nofree nonnull readonly %989) #5
  %1158 = extractvalue { i64, i64 } %result.i.i211.i, 1
  %1159 = urem i64 20, %1158
  %1160 = icmp eq i64 %1159, 0
  %reass.sub2411 = sub i64 %1158, %1159
  %1161 = add i64 %reass.sub2411, 20
  %1162 = select i1 %1160, i64 20, i64 %1161
  %1163 = getelementptr i8, ptr %result.i127.i, i64 %1162
  %1164 = getelementptr i8, ptr %1155, i64 64
  %1165 = load ptr, ptr %1164, align 8
  call void %1165({ ptr, i160 } %1147, ptr nocapture nofree nonnull readonly %989, ptr nocapture nofree writeonly %1163) #13
  %.sroa.3.8.insert.insert.i.i = or disjoint i160 %.sroa.3.8.insert.ext.i, 3402823669209384634633746074317682114560
  %1166 = load ptr, ptr %result.i127.i, align 8
  %1167 = load ptr, ptr %1166, align 8
  %1168 = getelementptr i8, ptr %1167, i64 72
  %1169 = load ptr, ptr %1168, align 8
  %result.i.i212.i = call { i64, i64 } %1169(ptr nocapture nofree nonnull readonly %1166) #5
  %1170 = extractvalue { i64, i64 } %result.i.i212.i, 0
  %1171 = extractvalue { i64, i64 } %result.i.i212.i, 1
  %1172 = urem i64 20, %1171
  %1173 = icmp eq i64 %1172, 0
  %1174 = sub i64 %1171, %1172
  %1175 = select i1 %1173, i64 0, i64 %1174
  %1176 = add i64 %1170, 20
  %1177 = add i64 %1176, %1175
  %1178 = and i64 %1177, 7
  %1179 = icmp eq i64 %1178, 0
  %1180 = sub nuw nsw i64 8, %1178
  %1181 = select i1 %1179, i64 0, i64 %1180
  %1182 = getelementptr i8, ptr %result.i127.i, i64 %1177
  %1183 = getelementptr i8, ptr %1182, i64 %1181
  store ptr @Tombstone, ptr %1183, align 8
  %1184 = getelementptr i8, ptr %1183, i64 8
  store i160 %.sroa.3.8.insert.insert.i.i, ptr %1184, align 4
  %1185 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @Entry) #34
  %1186 = getelementptr inbounds i8, ptr %result.i127.i, i64 16
  store i32 %1153, ptr %1186, align 8
  %1187 = load ptr, ptr %12, align 8
  %1188 = getelementptr i8, ptr %1187, i64 %1060
  store ptr @Entry, ptr %1188, align 8
  %1189 = getelementptr i8, ptr %1188, i64 8
  %1190 = ptrtoint ptr %result.i127.i to i64
  store i64 %1190, ptr %1189, align 4
  %.sroa_idx39.i = getelementptr i8, ptr %1188, i64 24
  store i32 10, ptr %.sroa_idx39.i, align 4
  %1191 = load i32, ptr %980, align 4
  %1192 = add i32 %1191, -1
  %1193 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  store i32 %1192, ptr %980, align 4
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %.not1275 = icmp eq ptr %.fca.0.extract76.i, @nil_typ
  br i1 %.not1275, label %._crit_edge.lr.ph.i1494, label %1194

1194:                                             ; preds = %HashMap_remove_keyK.exit
  %.sroa.2256.8.extract.trunc = trunc i160 %.fca.1.extract77.i to i32
  %1195 = add i32 %985, 1
  %.not = icmp eq i32 %1195, %.sroa.2256.8.extract.trunc
  br i1 %.not, label %._crit_edge6, label %._crit_edge.lr.ph.i1475

._crit_edge.lr.ph.i1475:                          ; preds = %1194
  %result.i463 = call noalias align 64 dereferenceable_or_null(46) ptr @bump_malloc_inner(i64 noundef 46, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %1196 = load <45 x i8>, ptr @gjykt_Warning_Remove_returned_wrong_value_for_key_, align 64
  store <45 x i8> %1196, ptr %result.i463, align 64
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1197 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1198 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1474 = call noalias dereferenceable_or_null(46) ptr @bump_malloc_inner(i64 noundef 46, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(45) %result.i.i1474, ptr noundef nonnull align 64 dereferenceable(45) %result.i463, i64 45, i1 false)
  %1199 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %1200 = getelementptr i8, ptr %result.i.i1474, i64 45
  store i8 0, ptr %1200, align 1
  %puts.i1068 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1474)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1201 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %1202 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %985) #17
  br label %._crit_edge6

._crit_edge6:                                     ; preds = %1194, %._crit_edge.lr.ph.i1475
  %.2362 = phi i1 [ false, %._crit_edge.lr.ph.i1475 ], [ %.0360721, %1194 ]
  %1203 = add i32 %.0354722, 1
  br label %._crit_edge5

._crit_edge.lr.ph.i1494:                          ; preds = %HashMap_remove_keyK.exit, %HashMap_remove_keyK.exit.thread
  %result.i469 = call noalias align 64 dereferenceable_or_null(38) ptr @bump_malloc_inner(i64 noundef 38, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %1204 = load <37 x i8>, ptr @yqxyt_Warning_Remove_returned_Nil_for_key_, align 64
  store <37 x i8> %1204, ptr %result.i469, align 64
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1205 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1206 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1493 = call noalias dereferenceable_or_null(38) ptr @bump_malloc_inner(i64 noundef 38, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(37) %result.i.i1493, ptr noundef nonnull align 64 dereferenceable(37) %result.i469, i64 37, i1 false)
  %1207 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %1208 = getelementptr i8, ptr %result.i.i1493, i64 37
  store i8 0, ptr %1208, align 1
  %puts.i1088 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1493)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1209 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %1210 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %985) #17
  br label %._crit_edge5

._crit_edge5:                                     ; preds = %._crit_edge6, %._crit_edge.lr.ph.i1494
  %.3 = phi i1 [ %.2362, %._crit_edge6 ], [ false, %._crit_edge.lr.ph.i1494 ]
  %.2 = phi i32 [ %1203, %._crit_edge6 ], [ %.0354722, %._crit_edge.lr.ph.i1494 ]
  %1211 = add nuw nsw i32 %.0363720, 1
  %1212 = icmp slt i32 %1211, %.0365
  br i1 %1212, label %.lr.ph723, label %._crit_edge8

._crit_edge8:                                     ; preds = %._crit_edge5, %._crit_edge4
  %.0360.lcssa = phi i1 [ true, %._crit_edge4 ], [ %.3, %._crit_edge5 ]
  %.0354.lcssa = phi i32 [ 0, %._crit_edge4 ], [ %.2, %._crit_edge5 ]
  %1213 = call i64 @clock()
  %.not370 = icmp eq i32 %.0354.lcssa, %.0365
  %1214 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %1215 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #34
  %1216 = getelementptr inbounds i8, ptr %result.i378, i64 36
  %1217 = load i32, ptr %1216, align 4
  %.not371 = icmp eq i32 %1217, 0
  %1218 = select i1 %.not371, i1 %.not370, i1 false
  %spec.select377 = select i1 %1218, i1 %.0360.lcssa, i1 false
  br i1 %978, label %1219, label %._crit_edge.lr.ph.i1559

1219:                                             ; preds = %._crit_edge8
  %1220 = load ptr, ptr %19, align 8
  %1221 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  %1222 = load i32, ptr %1220, align 1
  %.sroa.2.sroa.0.0.insert.ext.i1499 = zext i32 %1222 to i160
  %1223 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i1499, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1224 = load ptr, ptr %10, align 8
  %1225 = call i32 %1224({ ptr, i160 } %1223) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1226 = load i32, ptr %13, align 8
  %1227 = add i32 %1226, -1
  %1228 = and i32 %1227, %1225
  %1229 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1230 = load ptr, ptr %12, align 8
  %1231 = sext i32 %1228 to i64
  %1232 = shl nsw i64 %1231, 5
  %1233 = getelementptr i8, ptr %1230, i64 %1232
  %1234 = load ptr, ptr %1233, align 8
  %1235 = icmp eq ptr %1234, @nil_typ
  %1236 = icmp eq ptr %1234, null
  %1237 = or i1 %1235, %1236
  br i1 %1237, label %HashMap_find_slot_keyK_hashPtri32.exit1544, label %.lr.ph.i1514

.lr.ph.i1514:                                     ; preds = %1219
  %1238 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %1239

1239:                                             ; preds = %._crit_edge.thread.i1530, %.lr.ph.i1514
  %1240 = phi i32 [ %1228, %.lr.ph.i1514 ], [ %1282, %._crit_edge.thread.i1530 ]
  %spec.store.select.i15351659 = phi i32 [ -1, %.lr.ph.i1514 ], [ %spec.store.select.i1535, %._crit_edge.thread.i1530 ]
  %1241 = phi ptr [ %1234, %.lr.ph.i1514 ], [ %1287, %._crit_edge.thread.i1530 ]
  %1242 = phi ptr [ %1233, %.lr.ph.i1514 ], [ %1286, %._crit_edge.thread.i1530 ]
  %.sroa_idx.i1516 = getelementptr i8, ptr %1242, i64 16
  %1243 = load i64, ptr %.sroa_idx.i1516, align 4
  %1244 = getelementptr i8, ptr %1242, i64 8
  %1245 = load i64, ptr %1244, align 4
  %1246 = inttoptr i64 %1245 to ptr
  %1247 = inttoptr i64 %1243 to ptr
  %hash_coef_ptr.i.i56.i1517 = getelementptr i8, ptr %1241, i64 8
  %tbl_size_ptr.i.i57.i1518 = getelementptr i8, ptr %1241, i64 16
  %offset_tbl_ptr.i.i58.i1519 = getelementptr i8, ptr %1241, i64 40
  %hash_coef.i.i59.i1520 = load i64, ptr %hash_coef_ptr.i.i56.i1517, align 4
  %tbl_size.i.i60.i1521 = load i64, ptr %tbl_size_ptr.i.i57.i1518, align 4
  %offset_tbl.i.i61.i1522 = load ptr, ptr %offset_tbl_ptr.i.i58.i1519, align 8
  %product.i.i.i62.i1523 = mul i64 %hash_coef.i.i59.i1520, 4015701072841558310
  %shifted.i.i.i63.i1524 = lshr i64 %product.i.i.i62.i1523, 32
  %xored.i.i.i64.i1525 = xor i64 %shifted.i.i.i63.i1524, %product.i.i.i62.i1523
  %hash.i.i.i65.i1526 = and i64 %xored.i.i.i64.i1525, %tbl_size.i.i60.i1521
  %offset_ptr.i.i66.i1527 = getelementptr i32, ptr %offset_tbl.i.i61.i1522, i64 %hash.i.i.i65.i1526
  %offset.i.i67.i1528 = load i32, ptr %offset_ptr.i.i66.i1527, align 4
  %1248 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1241, 0
  %1249 = insertvalue { ptr, ptr, ptr, i32 } %1248, ptr %1246, 1
  %1250 = insertvalue { ptr, ptr, ptr, i32 } %1249, ptr %1247, 2
  %1251 = insertvalue { ptr, ptr, ptr, i32 } %1250, i32 %offset.i.i67.i1528, 3
  %1252 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1241)
  %1253 = sext i32 %offset.i.i67.i1528 to i64
  %1254 = getelementptr ptr, ptr %1241, i64 %1253
  %1255 = getelementptr i8, ptr %1254, i64 64
  %1256 = load ptr, ptr %1255, align 8
  %result.i.i1529 = call ptr %1256({ ptr, ptr, ptr, i32 } %1251, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1257 = call i32 %result.i.i1529({ ptr, ptr, ptr, i32 } %1251, { ptr, ptr, ptr, i32 } %1251, ptr nonnull align 8 %2) #7
  %1258 = icmp eq i32 %1257, %1225
  br i1 %1258, label %._crit_edge.i1541, label %._crit_edge.thread.i1530

._crit_edge.i1541:                                ; preds = %1239
  %1259 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1260 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1241)
  %1261 = getelementptr i8, ptr %1254, i64 48
  %1262 = load ptr, ptr %1261, align 8
  %result.i69.i1542 = call ptr %1262({ ptr, ptr, ptr, i32 } %1251, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1263 = call { ptr, i160 } %result.i69.i1542({ ptr, ptr, ptr, i32 } %1251, { ptr, ptr, ptr, i32 } %1251, ptr nonnull align 8 %2) #7
  %1264 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1265 = load ptr, ptr %11, align 8
  %1266 = call i1 %1265({ ptr, i160 } %1263, { ptr, i160 } %1223) #7
  br i1 %1266, label %HashMap_find_slot_keyK_hashPtri32.exit1544.loopexit, label %._crit_edge.thread.i1530

._crit_edge.thread.i1530:                         ; preds = %._crit_edge.i1541, %1239
  %1267 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1268 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1241)
  %1269 = getelementptr i8, ptr %1254, i64 56
  %1270 = load ptr, ptr %1269, align 8
  %result.i70.i1531 = call ptr %1270({ ptr, ptr, ptr, i32 } %1251, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1271 = call { ptr, i160 } %result.i70.i1531({ ptr, ptr, ptr, i32 } %1251, { ptr, ptr, ptr, i32 } %1251, ptr nonnull align 8 %2) #7
  %.fca.0.extract19.i1532 = extractvalue { ptr, i160 } %1271, 0
  %1272 = getelementptr i8, ptr %.fca.0.extract19.i1532, i64 8
  %1273 = getelementptr i8, ptr %.fca.0.extract19.i1532, i64 16
  %1274 = getelementptr i8, ptr %.fca.0.extract19.i1532, i64 24
  %1275 = getelementptr i8, ptr %.fca.0.extract19.i1532, i64 32
  %1276 = load i64, ptr %1272, align 4
  %1277 = load i64, ptr %1273, align 4
  %1278 = load ptr, ptr %1274, align 8
  %1279 = load ptr, ptr %1275, align 8
  %result.i71.i1533 = call i1 %1278(i64 %1277, i64 %1276, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %1279) #5
  %1280 = icmp eq i32 %spec.store.select.i15351659, -1
  %or.cond.i1534 = select i1 %result.i71.i1533, i1 %1280, i1 false
  %spec.store.select.i1535 = select i1 %or.cond.i1534, i32 %1240, i32 %spec.store.select.i15351659
  %1281 = add i32 %1240, 1
  %1282 = and i32 %1281, %1227
  %1283 = load ptr, ptr %12, align 8
  %1284 = sext i32 %1282 to i64
  %1285 = shl nsw i64 %1284, 5
  %1286 = getelementptr i8, ptr %1283, i64 %1285
  %1287 = load ptr, ptr %1286, align 8
  %1288 = icmp eq ptr %1287, @nil_typ
  %1289 = icmp eq ptr %1287, null
  %1290 = or i1 %1288, %1289
  br i1 %1290, label %._crit_edge105.loopexit.i1537, label %1239

._crit_edge105.loopexit.i1537:                    ; preds = %._crit_edge.thread.i1530
  %1291 = icmp eq i32 %spec.store.select.i1535, -1
  %.pre.i1540.pre = select i1 %1291, i32 %1282, i32 %spec.store.select.i1535
  br label %HashMap_find_slot_keyK_hashPtri32.exit1544

HashMap_find_slot_keyK_hashPtri32.exit1544.loopexit: ; preds = %._crit_edge.i1541
  %.pre1713 = load ptr, ptr %12, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit1544

HashMap_find_slot_keyK_hashPtri32.exit1544:       ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1544.loopexit, %1219, %._crit_edge105.loopexit.i1537
  %1292 = phi ptr [ %1283, %._crit_edge105.loopexit.i1537 ], [ %1230, %1219 ], [ %.pre1713, %HashMap_find_slot_keyK_hashPtri32.exit1544.loopexit ]
  %1293 = phi i32 [ %.pre.i1540.pre, %._crit_edge105.loopexit.i1537 ], [ %1228, %1219 ], [ %1240, %HashMap_find_slot_keyK_hashPtri32.exit1544.loopexit ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1294 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1295 = sext i32 %1293 to i64
  %1296 = shl nsw i64 %1295, 5
  %1297 = getelementptr i8, ptr %1292, i64 %1296
  %1298 = load ptr, ptr %1297, align 8
  %1299 = icmp ne ptr %1298, @nil_typ
  %1300 = icmp ne ptr %1298, null
  %.not57.i1138 = and i1 %1299, %1300
  br i1 %.not57.i1138, label %1301, label %HashMap_get_keyK.exit1166

1301:                                             ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1544
  %1302 = getelementptr i8, ptr %1297, i64 8
  %1303 = load i64, ptr %1302, align 4
  %.sroa_idx.i1142 = getelementptr i8, ptr %1297, i64 16
  %1304 = load i64, ptr %.sroa_idx.i1142, align 4
  %1305 = inttoptr i64 %1303 to ptr
  %1306 = inttoptr i64 %1304 to ptr
  %hash_coef_ptr.i.i60.i1143 = getelementptr i8, ptr %1298, i64 8
  %tbl_size_ptr.i.i61.i1144 = getelementptr i8, ptr %1298, i64 16
  %offset_tbl_ptr.i.i62.i1145 = getelementptr i8, ptr %1298, i64 40
  %hash_coef.i.i63.i1146 = load i64, ptr %hash_coef_ptr.i.i60.i1143, align 4, !noalias !193
  %tbl_size.i.i64.i1147 = load i64, ptr %tbl_size_ptr.i.i61.i1144, align 4, !noalias !193
  %offset_tbl.i.i65.i1148 = load ptr, ptr %offset_tbl_ptr.i.i62.i1145, align 8, !noalias !193
  %product.i.i.i66.i1149 = mul i64 %hash_coef.i.i63.i1146, 4015701072841558310
  %shifted.i.i.i67.i1150 = lshr i64 %product.i.i.i66.i1149, 32
  %xored.i.i.i68.i1151 = xor i64 %shifted.i.i.i67.i1150, %product.i.i.i66.i1149
  %hash.i.i.i69.i1152 = and i64 %xored.i.i.i68.i1151, %tbl_size.i.i64.i1147
  %offset_ptr.i.i70.i1153 = getelementptr i32, ptr %offset_tbl.i.i65.i1148, i64 %hash.i.i.i69.i1152
  %offset.i.i71.i1154 = load i32, ptr %offset_ptr.i.i70.i1153, align 4, !noalias !193
  %1307 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1298, 0
  %1308 = insertvalue { ptr, ptr, ptr, i32 } %1307, ptr %1305, 1
  %1309 = insertvalue { ptr, ptr, ptr, i32 } %1308, ptr %1306, 2
  %1310 = insertvalue { ptr, ptr, ptr, i32 } %1309, i32 %offset.i.i71.i1154, 3
  %1311 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1312 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1298)
  %1313 = sext i32 %offset.i.i71.i1154 to i64
  %1314 = getelementptr ptr, ptr %1298, i64 %1313
  %1315 = getelementptr i8, ptr %1314, i64 56
  %1316 = load ptr, ptr %1315, align 8
  %result.i73.i1155 = call ptr %1316({ ptr, ptr, ptr, i32 } %1310, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1317 = call { ptr, i160 } %result.i73.i1155({ ptr, ptr, ptr, i32 } %1310, { ptr, ptr, ptr, i32 } %1310, ptr nonnull align 8 %2) #7
  %.fca.0.extract51.i1156 = extractvalue { ptr, i160 } %1317, 0
  %1318 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1319 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1298)
  %1320 = getelementptr i8, ptr %1314, i64 64
  %1321 = load ptr, ptr %1320, align 8
  %result.i74.i1158 = call ptr %1321({ ptr, ptr, ptr, i32 } %1310, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1322 = call i32 %result.i74.i1158({ ptr, ptr, ptr, i32 } %1310, { ptr, ptr, ptr, i32 } %1310, ptr nonnull align 8 %2) #7
  %1323 = icmp eq i32 %1322, %1225
  br i1 %1323, label %._crit_edge.i1159, label %HashMap_get_keyK.exit1166

._crit_edge.i1159:                                ; preds = %1301
  %1324 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %1325 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1298)
  %1326 = getelementptr i8, ptr %1314, i64 48
  %1327 = load ptr, ptr %1326, align 8
  %result.i75.i1160 = call ptr %1327({ ptr, ptr, ptr, i32 } %1310, ptr nocapture nofree noundef nonnull readonly %2) #16
  %1328 = call { ptr, i160 } %result.i75.i1160({ ptr, ptr, ptr, i32 } %1310, { ptr, ptr, ptr, i32 } %1310, ptr nonnull align 8 %2) #7
  %1329 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1330 = load ptr, ptr %11, align 8
  %1331 = call i1 %1330({ ptr, i160 } %1328, { ptr, i160 } %1223) #7
  br i1 %1331, label %1332, label %HashMap_get_keyK.exit1166

1332:                                             ; preds = %._crit_edge.i1159
  %1333 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1334 = load ptr, ptr %5, align 8
  %1335 = load ptr, ptr %1334, align 8
  %1336 = ptrtoint ptr %1335 to i64
  %1337 = getelementptr i8, ptr %.fca.0.extract51.i1156, i64 8
  %1338 = getelementptr i8, ptr %.fca.0.extract51.i1156, i64 16
  %1339 = getelementptr i8, ptr %.fca.0.extract51.i1156, i64 24
  %1340 = getelementptr i8, ptr %.fca.0.extract51.i1156, i64 32
  %1341 = load i64, ptr %1337, align 4
  %1342 = load i64, ptr %1338, align 4
  %1343 = load ptr, ptr %1339, align 8
  %1344 = load ptr, ptr %1340, align 8
  %1345 = load i64, ptr %1335, align 4
  %result.i77.i1163 = call i1 %1343(i64 %1342, i64 %1341, i64 %1345, i64 %1336, ptr readonly %1344) #5
  %cond.fr.i1164 = freeze i1 %result.i77.i1163
  %spec.select.i1165 = select i1 %cond.fr.i1164, ptr %.fca.0.extract51.i1156, ptr @nil_typ
  br label %HashMap_get_keyK.exit1166

HashMap_get_keyK.exit1166:                        ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1544, %1301, %._crit_edge.i1159, %1332
  %1346 = phi ptr [ @nil_typ, %HashMap_find_slot_keyK_hashPtri32.exit1544 ], [ @nil_typ, %1301 ], [ @nil_typ, %._crit_edge.i1159 ], [ %spec.select.i1165, %1332 ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1347 = icmp eq ptr %1346, @nil_typ
  %1348 = icmp eq ptr %1346, null
  %.not374.not = or i1 %1347, %1348
  %spec.select376 = select i1 %.not374.not, i1 %spec.select377, i1 false
  br label %._crit_edge.lr.ph.i1559

._crit_edge.lr.ph.i1559:                          ; preds = %HashMap_get_keyK.exit1166, %._crit_edge8
  %.6 = phi i1 [ %spec.select377, %._crit_edge8 ], [ %spec.select376, %HashMap_get_keyK.exit1166 ]
  %result.i478 = call noalias align 16 dereferenceable_or_null(14) ptr @bump_malloc_inner(i64 noundef 14, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <13 x i8> <i8 82, i8 101, i8 109, i8 111, i8 118, i8 101, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109>, ptr %result.i478, align 16
  %1349 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #34
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1350 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1351 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1558 = call noalias dereferenceable_or_null(14) ptr @bump_malloc_inner(i64 noundef 14, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(13) %result.i.i1558, ptr noundef nonnull align 16 dereferenceable(13) %result.i478, i64 13, i1 false)
  %1352 = sub i64 %1213, %977
  %1353 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %1354 = getelementptr i8, ptr %result.i.i1558, i64 13
  store i8 0, ptr %1354, align 1
  %puts.i1186 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1558)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i97.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i97.i, align 16
  %result.i.i375.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i375.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i97.i, i64 14, i1 false)
  %puts.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i375.i)
  %1355 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0365) #17
  %result.i103.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i103.i, align 16
  %result.i.i389.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i389.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i103.i, i64 14, i1 false)
  %puts.i313.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i389.i)
  %1356 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %1352) #17
  %result.i109.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i109.i, align 4
  %result.i.i408.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i408.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i109.i, i64 3, i1 false)
  %puts.i333.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i408.i)
  br i1 %978, label %._crit_edge1.i, label %._crit_edge.lr.ph.i1578

._crit_edge1.i:                                   ; preds = %._crit_edge.lr.ph.i1559
  %1357 = icmp sgt i64 %1352, 0
  br i1 %1357, label %1358, label %._crit_edge.lr.ph.i428.i

1358:                                             ; preds = %._crit_edge1.i
  %1359 = zext nneg i32 %.0365 to i64
  %1360 = mul i64 %1352, 1000000
  %1361 = sdiv i64 %1360, %1359
  br label %._crit_edge.lr.ph.i428.i

._crit_edge.lr.ph.i428.i:                         ; preds = %1358, %._crit_edge1.i
  %.0.i = phi i64 [ %1361, %1358 ], [ 0, %._crit_edge1.i ]
  %result.i114.i = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i114.i, align 16
  %result.i.i427.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i427.i, ptr noundef nonnull align 16 dereferenceable(15) %result.i114.i, i64 15, i1 false)
  %puts.i353.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i427.i)
  %1362 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0.i) #17
  %result.i120.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i120.i, align 4
  %1363 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %result.i.i446.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i446.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i120.i, i64 3, i1 false)
  %1364 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %puts.i373.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i446.i)
  br label %._crit_edge.lr.ph.i1578

._crit_edge.lr.ph.i1578:                          ; preds = %._crit_edge.lr.ph.i1559, %._crit_edge.lr.ph.i428.i
  %result.i482 = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i482, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1365 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1366 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1577 = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i1577, ptr noundef nonnull align 32 dereferenceable(18) %result.i482, i64 18, i1 false)
  %1367 = getelementptr i8, ptr %result.i.i1577, i64 18
  store i8 0, ptr %1367, align 1
  %puts.i1206 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1577)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %. = select i1 %.6, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1368 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1369 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1596 = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <4 x i8> %., ptr %result.i.i1596, align 1
  %1370 = getelementptr i8, ptr %result.i.i1596, i64 4
  store i8 0, ptr %1370, align 1
  %puts.i1226 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1596)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %result.i497 = call noalias align 32 dereferenceable_or_null(21) ptr @bump_malloc_inner(i64 noundef 21, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <20 x i8> <i8 32, i8 32, i8 32, i8 32, i8 40, i8 73, i8 116, i8 101, i8 109, i8 115, i8 32, i8 114, i8 101, i8 109, i8 111, i8 118, i8 101, i8 100, i8 58, i8 32>, ptr %result.i497, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1371 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1372 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1615 = call noalias dereferenceable_or_null(21) ptr @bump_malloc_inner(i64 noundef 21, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(20) %result.i.i1615, ptr noundef nonnull align 32 dereferenceable(20) %result.i497, i64 20, i1 false)
  %1373 = getelementptr i8, ptr %result.i.i1615, i64 20
  store i8 0, ptr %1373, align 1
  %puts.i1246 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1615)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  %1374 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0354.lcssa) #17
  %1375 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %2)
  %1376 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %1377 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %2) #34
  %result.i.i1634 = call noalias dereferenceable_or_null(2) ptr @bump_malloc_inner(i64 noundef 2, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store i8 41, ptr %result.i.i1634, align 1
  %1378 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %1379 = getelementptr i8, ptr %result.i.i1634, i64 1
  store i8 0, ptr %1379, align 1
  %puts.i1267 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1634)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %2)
  ret void
}

define noundef i32 @main() local_unnamed_addr {
._crit_edge.lr.ph.i:
  %0 = alloca [0 x ptr], align 8
  %1 = alloca [3 x ptr], align 8
  %2 = alloca [3 x ptr], align 8
  %oldProtect.i332.i = alloca i32, align 4
  %oldProtect.i328.i = alloca i32, align 4
  %oldProtect.i287.i = alloca i32, align 4
  %oldProtect.i.i267 = alloca i32, align 4
  %.sroa.0224.sroa.0.i = alloca i8, align 8
  %3 = alloca [3 x ptr], align 8
  %oldProtect.i155.i = alloca i32, align 4
  %oldProtect.i.i147 = alloca i32, align 4
  %4 = alloca [3 x ptr], align 8
  %5 = alloca [3 x ptr], align 8
  %oldProtect.i317.i = alloca i32, align 4
  %oldProtect.i313.i = alloca i32, align 4
  %oldProtect.i272.i = alloca i32, align 4
  %oldProtect.i.i31 = alloca i32, align 4
  %.sroa.0231.sroa.0.i = alloca i8, align 8
  %6 = alloca [3 x ptr], align 8
  %oldProtect.i154.i = alloca i32, align 4
  %oldProtect.i.i = alloca i32, align 4
  tail call void @setup_landing_pad()
  %result.i = tail call noalias align 32 dereferenceable_or_null(27) ptr @bump_malloc_inner(i64 noundef 27, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <26 x i8> <i8 45, i8 45, i8 45, i8 32, i8 72, i8 97, i8 115, i8 104, i8 77, i8 97, i8 112, i8 32, i8 66, i8 101, i8 110, i8 99, i8 104, i8 109, i8 97, i8 114, i8 107, i8 115, i8 32, i8 45, i8 45, i8 45>, ptr %result.i, align 32
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %8 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i = tail call noalias dereferenceable_or_null(27) ptr @bump_malloc_inner(i64 noundef 27, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(26) %result.i.i, ptr noundef nonnull align 32 dereferenceable(26) %result.i, i64 26, i1 false)
  %9 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %puts.i = tail call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %result.i150.i = tail call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i150.i, align 8
  %10 = getelementptr inbounds i8, ptr %result.i150.i, i64 8
  store ptr @_parameterization_Ptri32, ptr %10, align 8
  %11 = getelementptr inbounds i8, ptr %result.i150.i, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %11, align 8
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i150.i) #38
  %result.i151.i = tail call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i.i)
  %result.i152.i = call i32 @VirtualProtect(ptr nofree %result.i151.i, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i.i) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i151.i, ptr noalias nofree noundef nonnull readnone @kgxtsntexh, ptr noalias nofree noundef nonnull readnone @i32_hasher) #38
  %ret.i.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i151.i) #39
  %13 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i151.i) #38
  %result.i153.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i154.i)
  %result.i155.i = call i32 @VirtualProtect(ptr nofree %result.i153.i, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i154.i) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i154.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i153.i, ptr noalias nofree noundef nonnull readnone @bljcadvgpu, ptr noalias nofree noundef nonnull readnone @i32_eq) #38
  %ret.i156.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i153.i) #39
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i153.i) #38
  %15 = getelementptr inbounds i8, ptr %result.i150.i, i64 48
  store ptr %ret.i.i, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i150.i, i64 56
  store ptr %ret.i156.i, ptr %16, align 8
  %result.i.i.i = call noalias dereferenceable_or_null(512) ptr @bump_malloc_inner(i64 noundef 512, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %17 = getelementptr inbounds i8, ptr %result.i150.i, i64 24
  store ptr %result.i.i.i, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %result.i150.i, i64 32
  store i32 16, ptr %18, align 8
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #34
  %20 = call i64 @clock()
  %21 = getelementptr inbounds i8, ptr %result.i150.i, i64 40
  %22 = getelementptr inbounds i8, ptr %result.i150.i, i64 36
  %23 = getelementptr inbounds i8, ptr %6, i64 8
  %24 = getelementptr inbounds i8, ptr %6, i64 16
  br label %._crit_edge.i

._crit_edge.i:                                    ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit.i, %._crit_edge.lr.ph.i
  %.0216.i = phi i32 [ %25, %HashMap_insert_internal_keyK_valueV_hashPtri32.exit.i ], [ 0, %._crit_edge.lr.ph.i ]
  %25 = add nuw nsw i32 %.0216.i, 1
  %.sroa.0131.0.insert.ext.i = zext nneg i32 %.0216.i to i160
  %26 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0131.0.insert.ext.i, 1
  %.sroa.0128.0.insert.ext.i = zext nneg i32 %25 to i160
  %27 = load i32, ptr %21, align 8
  %28 = load i32, ptr %18, align 8
  %29 = icmp eq i32 %28, 0
  %30 = mul i32 %27, 10
  %31 = add i32 %30, 10
  %32 = mul i32 %28, 6
  %33 = icmp sge i32 %31, %32
  %.0.i375.i = select i1 %29, i1 true, i1 %33
  br i1 %.0.i375.i, label %._crit_edge1.i377.i, label %HashMap_ensure_capacity_required_loadPtri32.exit.i

._crit_edge1.i377.i:                              ; preds = %._crit_edge.i
  %34 = shl i32 %28, 1
  %spec.select.i378.i = call i32 @llvm.smax.i32(i32 %34, i32 16)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %35 = load ptr, ptr %17, align 8
  %36 = zext nneg i32 %spec.select.i378.i to i64
  %37 = shl nuw nsw i64 %36, 5
  %result.i.i490.i = call noalias ptr @bump_malloc_inner(i64 noundef %37, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i490.i, ptr %17, align 8
  store i32 %spec.select.i378.i, ptr %18, align 8
  store i32 0, ptr %22, align 4
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #38
  store i32 0, ptr %21, align 8
  %39 = icmp sgt i32 %28, 0
  br i1 %39, label %.lr.ph.i491.i, label %HashMap_resize_new_capacityPtri32.exit.i

.lr.ph.i491.i:                                    ; preds = %._crit_edge1.i377.i, %._crit_edge.i492.i
  %.096.i.i = phi i32 [ %242, %._crit_edge.i492.i ], [ 0, %._crit_edge1.i377.i ]
  %40 = zext nneg i32 %.096.i.i to i64
  %41 = shl nuw nsw i64 %40, 5
  %42 = getelementptr i8, ptr %35, i64 %41
  %43 = load ptr, ptr %42, align 8
  %44 = icmp ne ptr %43, @nil_typ
  %45 = icmp ne ptr %43, null
  %.not40.i.i = and i1 %44, %45
  br i1 %.not40.i.i, label %46, label %._crit_edge.i492.i

46:                                               ; preds = %.lr.ph.i491.i
  %47 = getelementptr i8, ptr %42, i64 8
  %48 = load i64, ptr %47, align 4
  %.sroa_idx.i493.i = getelementptr i8, ptr %42, i64 16
  %49 = load i64, ptr %.sroa_idx.i493.i, align 4
  %50 = inttoptr i64 %48 to ptr
  %51 = inttoptr i64 %49 to ptr
  %hash_coef_ptr.i.i42.i.i = getelementptr i8, ptr %43, i64 8
  %tbl_size_ptr.i.i43.i.i = getelementptr i8, ptr %43, i64 16
  %offset_tbl_ptr.i.i44.i.i = getelementptr i8, ptr %43, i64 40
  %hash_coef.i.i45.i.i = load i64, ptr %hash_coef_ptr.i.i42.i.i, align 4, !noalias !196
  %tbl_size.i.i46.i.i = load i64, ptr %tbl_size_ptr.i.i43.i.i, align 4, !noalias !196
  %offset_tbl.i.i47.i.i = load ptr, ptr %offset_tbl_ptr.i.i44.i.i, align 8, !noalias !196
  %product.i.i.i48.i.i = mul i64 %hash_coef.i.i45.i.i, 4015701072841558310
  %shifted.i.i.i49.i.i = lshr i64 %product.i.i.i48.i.i, 32
  %xored.i.i.i50.i.i = xor i64 %shifted.i.i.i49.i.i, %product.i.i.i48.i.i
  %hash.i.i.i51.i.i = and i64 %xored.i.i.i50.i.i, %tbl_size.i.i46.i.i
  %offset_ptr.i.i52.i.i = getelementptr i32, ptr %offset_tbl.i.i47.i.i, i64 %hash.i.i.i51.i.i
  %offset.i.i53.i.i = load i32, ptr %offset_ptr.i.i52.i.i, align 4, !noalias !196
  %52 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %43, 0
  %53 = insertvalue { ptr, ptr, ptr, i32 } %52, ptr %50, 1
  %54 = insertvalue { ptr, ptr, ptr, i32 } %53, ptr %51, 2
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, i32 %offset.i.i53.i.i, 3
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %43)
  %58 = sext i32 %offset.i.i53.i.i to i64
  %59 = getelementptr ptr, ptr %43, i64 %58
  %60 = getelementptr i8, ptr %59, i64 56
  %61 = load ptr, ptr %60, align 8
  %result.i55.i.i = call ptr %61({ ptr, ptr, ptr, i32 } %55, ptr nocapture nofree noundef nonnull readonly %0) #16
  %62 = call { ptr, i160 } %result.i55.i.i({ ptr, ptr, ptr, i32 } %55, { ptr, ptr, ptr, i32 } %55, ptr nonnull align 8 %0) #7
  %.fca.0.extract29.i.i = extractvalue { ptr, i160 } %62, 0
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %64 = load ptr, ptr %10, align 8
  %65 = load ptr, ptr %64, align 8
  %66 = ptrtoint ptr %65 to i64
  %67 = getelementptr i8, ptr %.fca.0.extract29.i.i, i64 8
  %68 = getelementptr i8, ptr %.fca.0.extract29.i.i, i64 16
  %69 = getelementptr i8, ptr %.fca.0.extract29.i.i, i64 24
  %70 = getelementptr i8, ptr %.fca.0.extract29.i.i, i64 32
  %71 = load i64, ptr %67, align 4
  %72 = load i64, ptr %68, align 4
  %73 = load ptr, ptr %69, align 8
  %74 = load ptr, ptr %70, align 8
  %75 = load i64, ptr %65, align 4
  %result.i57.i.i = call i1 %73(i64 %72, i64 %71, i64 %75, i64 %66, ptr readonly %74) #5
  br i1 %result.i57.i.i, label %76, label %._crit_edge.i492.i

76:                                               ; preds = %46
  %77 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %43)
  %79 = getelementptr i8, ptr %59, i64 48
  %80 = load ptr, ptr %79, align 8
  %result.i58.i.i = call ptr %80({ ptr, ptr, ptr, i32 } %55, ptr nocapture nofree noundef nonnull readonly %0) #16
  %81 = call { ptr, i160 } %result.i58.i.i({ ptr, ptr, ptr, i32 } %55, { ptr, ptr, ptr, i32 } %55, ptr nonnull align 8 %0) #7
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %43)
  %84 = getelementptr i8, ptr %59, i64 64
  %85 = load ptr, ptr %84, align 8
  %result.i59.i.i = call ptr %85({ ptr, ptr, ptr, i32 } %55, ptr nocapture nofree noundef nonnull readonly %0) #16
  %86 = call i32 %result.i59.i.i({ ptr, ptr, ptr, i32 } %55, { ptr, ptr, ptr, i32 } %55, ptr nonnull align 8 %0) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %6)
  %87 = load ptr, ptr %result.i150.i, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %88 = load i32, ptr %18, align 8
  %89 = add i32 %88, -1
  %90 = and i32 %89, %86
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %92 = load ptr, ptr %17, align 8
  %93 = sext i32 %90 to i64
  %94 = shl nsw i64 %93, 5
  %95 = getelementptr i8, ptr %92, i64 %94
  %96 = load ptr, ptr %95, align 8
  %97 = icmp eq ptr %96, @nil_typ
  %98 = icmp eq ptr %96, null
  %99 = or i1 %97, %98
  br i1 %99, label %HashMap_find_slot_keyK_hashPtri32.exit687.i, label %.lr.ph.i663.i

.lr.ph.i663.i:                                    ; preds = %76
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %101

101:                                              ; preds = %._crit_edge.thread.i678.i, %.lr.ph.i663.i
  %102 = phi i32 [ %90, %.lr.ph.i663.i ], [ %144, %._crit_edge.thread.i678.i ]
  %spec.store.select.i683697.i = phi i32 [ -1, %.lr.ph.i663.i ], [ %spec.store.select.i683.i, %._crit_edge.thread.i678.i ]
  %103 = phi ptr [ %96, %.lr.ph.i663.i ], [ %149, %._crit_edge.thread.i678.i ]
  %104 = phi ptr [ %95, %.lr.ph.i663.i ], [ %148, %._crit_edge.thread.i678.i ]
  %.sroa_idx.i664.i = getelementptr i8, ptr %104, i64 16
  %105 = load i64, ptr %.sroa_idx.i664.i, align 4
  %106 = getelementptr i8, ptr %104, i64 8
  %107 = load i64, ptr %106, align 4
  %108 = inttoptr i64 %107 to ptr
  %109 = inttoptr i64 %105 to ptr
  %hash_coef_ptr.i.i56.i665.i = getelementptr i8, ptr %103, i64 8
  %tbl_size_ptr.i.i57.i666.i = getelementptr i8, ptr %103, i64 16
  %offset_tbl_ptr.i.i58.i667.i = getelementptr i8, ptr %103, i64 40
  %hash_coef.i.i59.i668.i = load i64, ptr %hash_coef_ptr.i.i56.i665.i, align 4
  %tbl_size.i.i60.i669.i = load i64, ptr %tbl_size_ptr.i.i57.i666.i, align 4
  %offset_tbl.i.i61.i670.i = load ptr, ptr %offset_tbl_ptr.i.i58.i667.i, align 8
  %product.i.i.i62.i671.i = mul i64 %hash_coef.i.i59.i668.i, 4015701072841558310
  %shifted.i.i.i63.i672.i = lshr i64 %product.i.i.i62.i671.i, 32
  %xored.i.i.i64.i673.i = xor i64 %shifted.i.i.i63.i672.i, %product.i.i.i62.i671.i
  %hash.i.i.i65.i674.i = and i64 %xored.i.i.i64.i673.i, %tbl_size.i.i60.i669.i
  %offset_ptr.i.i66.i675.i = getelementptr i32, ptr %offset_tbl.i.i61.i670.i, i64 %hash.i.i.i65.i674.i
  %offset.i.i67.i676.i = load i32, ptr %offset_ptr.i.i66.i675.i, align 4
  %110 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %103, 0
  %111 = insertvalue { ptr, ptr, ptr, i32 } %110, ptr %108, 1
  %112 = insertvalue { ptr, ptr, ptr, i32 } %111, ptr %109, 2
  %113 = insertvalue { ptr, ptr, ptr, i32 } %112, i32 %offset.i.i67.i676.i, 3
  %114 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %103)
  %115 = sext i32 %offset.i.i67.i676.i to i64
  %116 = getelementptr ptr, ptr %103, i64 %115
  %117 = getelementptr i8, ptr %116, i64 64
  %118 = load ptr, ptr %117, align 8
  %result.i.i677.i = call ptr %118({ ptr, ptr, ptr, i32 } %113, ptr nocapture nofree noundef nonnull readonly %0) #16
  %119 = call i32 %result.i.i677.i({ ptr, ptr, ptr, i32 } %113, { ptr, ptr, ptr, i32 } %113, ptr nonnull align 8 %0) #7
  %120 = icmp eq i32 %119, %86
  br i1 %120, label %._crit_edge.i685.i, label %._crit_edge.thread.i678.i

._crit_edge.i685.i:                               ; preds = %101
  %121 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %122 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %103)
  %123 = getelementptr i8, ptr %116, i64 48
  %124 = load ptr, ptr %123, align 8
  %result.i69.i686.i = call ptr %124({ ptr, ptr, ptr, i32 } %113, ptr nocapture nofree noundef nonnull readonly %0) #16
  %125 = call { ptr, i160 } %result.i69.i686.i({ ptr, ptr, ptr, i32 } %113, { ptr, ptr, ptr, i32 } %113, ptr nonnull align 8 %0) #7
  %126 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %127 = load ptr, ptr %16, align 8
  %128 = call i1 %127({ ptr, i160 } %125, { ptr, i160 } %81) #7
  br i1 %128, label %HashMap_find_slot_keyK_hashPtri32.exit687.loopexit.i, label %._crit_edge.thread.i678.i

._crit_edge.thread.i678.i:                        ; preds = %._crit_edge.i685.i, %101
  %129 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %130 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %103)
  %131 = getelementptr i8, ptr %116, i64 56
  %132 = load ptr, ptr %131, align 8
  %result.i70.i679.i = call ptr %132({ ptr, ptr, ptr, i32 } %113, ptr nocapture nofree noundef nonnull readonly %0) #16
  %133 = call { ptr, i160 } %result.i70.i679.i({ ptr, ptr, ptr, i32 } %113, { ptr, ptr, ptr, i32 } %113, ptr nonnull align 8 %0) #7
  %.fca.0.extract19.i680.i = extractvalue { ptr, i160 } %133, 0
  %134 = getelementptr i8, ptr %.fca.0.extract19.i680.i, i64 8
  %135 = getelementptr i8, ptr %.fca.0.extract19.i680.i, i64 16
  %136 = getelementptr i8, ptr %.fca.0.extract19.i680.i, i64 24
  %137 = getelementptr i8, ptr %.fca.0.extract19.i680.i, i64 32
  %138 = load i64, ptr %134, align 4
  %139 = load i64, ptr %135, align 4
  %140 = load ptr, ptr %136, align 8
  %141 = load ptr, ptr %137, align 8
  %result.i71.i681.i = call i1 %140(i64 %139, i64 %138, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %141) #5
  %142 = icmp eq i32 %spec.store.select.i683697.i, -1
  %or.cond.i682.i = select i1 %result.i71.i681.i, i1 %142, i1 false
  %spec.store.select.i683.i = select i1 %or.cond.i682.i, i32 %102, i32 %spec.store.select.i683697.i
  %143 = add i32 %102, 1
  %144 = and i32 %143, %89
  %145 = load ptr, ptr %17, align 8
  %146 = sext i32 %144 to i64
  %147 = shl nsw i64 %146, 5
  %148 = getelementptr i8, ptr %145, i64 %147
  %149 = load ptr, ptr %148, align 8
  %150 = icmp eq ptr %149, @nil_typ
  %151 = icmp eq ptr %149, null
  %152 = or i1 %150, %151
  br i1 %152, label %._crit_edge105.loopexit.i684.i, label %101

._crit_edge105.loopexit.i684.i:                   ; preds = %._crit_edge.thread.i678.i
  %153 = icmp eq i32 %spec.store.select.i683.i, -1
  %.pre.i.pre716.i = select i1 %153, i32 %144, i32 %spec.store.select.i683.i
  br label %HashMap_find_slot_keyK_hashPtri32.exit687.i

HashMap_find_slot_keyK_hashPtri32.exit687.loopexit.i: ; preds = %._crit_edge.i685.i
  %.pre749.i = load ptr, ptr %17, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit687.i

HashMap_find_slot_keyK_hashPtri32.exit687.i:      ; preds = %HashMap_find_slot_keyK_hashPtri32.exit687.loopexit.i, %._crit_edge105.loopexit.i684.i, %76
  %154 = phi ptr [ %145, %._crit_edge105.loopexit.i684.i ], [ %92, %76 ], [ %.pre749.i, %HashMap_find_slot_keyK_hashPtri32.exit687.loopexit.i ]
  %155 = phi i32 [ %.pre.i.pre716.i, %._crit_edge105.loopexit.i684.i ], [ %90, %76 ], [ %102, %HashMap_find_slot_keyK_hashPtri32.exit687.loopexit.i ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %156 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %157 = sext i32 %155 to i64
  %158 = shl nsw i64 %157, 5
  %159 = getelementptr i8, ptr %154, i64 %158
  %160 = load ptr, ptr %159, align 8
  %161 = getelementptr i8, ptr %159, i64 8
  %162 = load i64, ptr %161, align 4
  %.sroa_idx.i596.i = getelementptr i8, ptr %159, i64 16
  %163 = load i64, ptr %.sroa_idx.i596.i, align 4
  %164 = load ptr, ptr %10, align 8
  %165 = load ptr, ptr %87, align 8, !alias.scope !199
  %166 = getelementptr i8, ptr %165, i64 72
  %167 = load ptr, ptr %166, align 8, !alias.scope !199
  %result.i.i.i598.i = call { i64, i64 } %167(ptr nocapture nofree nonnull readonly %87) #5, !alias.scope !199
  %168 = extractvalue { i64, i64 } %result.i.i.i598.i, 0
  %169 = extractvalue { i64, i64 } %result.i.i.i598.i, 1
  %170 = call i64 @llvm.umax.i64(i64 %169, i64 8)
  %171 = urem i64 20, %169
  %172 = icmp eq i64 %171, 0
  %173 = sub i64 %169, %171
  %174 = select i1 %172, i64 0, i64 %173
  %175 = add i64 %168, 20
  %176 = add i64 %175, %174
  %177 = and i64 %176, 7
  %178 = icmp eq i64 %177, 0
  %179 = sub nuw nsw i64 40, %177
  %180 = select i1 %178, i64 32, i64 %179
  %181 = add i64 %180, %176
  %182 = urem i64 %181, %170
  %183 = icmp eq i64 %182, 0
  %184 = sub i64 %170, %182
  %185 = select i1 %183, i64 0, i64 %184
  %186 = add i64 %181, %185
  %result.i71.i599.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %186, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %87, ptr %result.i71.i599.i, align 8
  %187 = getelementptr inbounds i8, ptr %result.i71.i599.i, i64 8
  store ptr %164, ptr %187, align 8
  %188 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i599.i)
  %189 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %result.i71.i599.i, 1
  %190 = insertvalue { ptr, ptr, ptr, i32 } %189, ptr undef, 2
  %191 = insertvalue { ptr, ptr, ptr, i32 } %190, i32 10, 3
  store ptr %87, ptr %6, align 8
  store ptr %164, ptr %23, align 8
  store ptr @_parameterization_Ptri32, ptr %24, align 8
  %192 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %6)
  %193 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Entry)
  %194 = load i64, ptr %67, align 4
  %195 = load i64, ptr %68, align 4
  %196 = load ptr, ptr %69, align 8
  %197 = load ptr, ptr %70, align 8
  %result.i.i117.i.i = call i1 %196(i64 %195, i64 %194, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %197) #5
  %198 = select i1 %result.i.i117.i.i, i64 9, i64 10
  %gep.i = getelementptr [14 x ptr], ptr getelementptr inbounds (i8, ptr @Entry, i64 80), i64 0, i64 %198
  %199 = load ptr, ptr %gep.i, align 8
  call void %199({ ptr, ptr, ptr, i32 } %191, { ptr, ptr, ptr, i32 } %191, ptr nonnull align 8 dereferenceable(24) %6, { ptr, i160 } %81, { ptr, i160 } %62, i32 %86) #7
  %200 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %201 = load ptr, ptr %17, align 8
  %202 = getelementptr i8, ptr %201, i64 %158
  store ptr @Entry, ptr %202, align 8
  %203 = getelementptr i8, ptr %202, i64 8
  %204 = ptrtoint ptr %result.i71.i599.i to i64
  store i64 %204, ptr %203, align 4
  %.sroa_idx4.i600.i = getelementptr i8, ptr %202, i64 24
  store i32 10, ptr %.sroa_idx4.i600.i, align 4
  %205 = icmp eq ptr %160, @nil_typ
  %206 = icmp eq ptr %160, null
  %207 = or i1 %205, %206
  br i1 %207, label %208, label %211

208:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit687.i
  %209 = load i32, ptr %22, align 4
  %210 = add i32 %209, 1
  store i32 %210, ptr %22, align 4
  br label %._crit_edge.sink.split.i617.i

211:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit687.i
  %212 = inttoptr i64 %162 to ptr
  %213 = inttoptr i64 %163 to ptr
  %hash_coef_ptr.i.i88.i601.i = getelementptr i8, ptr %160, i64 8
  %tbl_size_ptr.i.i89.i602.i = getelementptr i8, ptr %160, i64 16
  %offset_tbl_ptr.i.i90.i603.i = getelementptr i8, ptr %160, i64 40
  %hash_coef.i.i91.i604.i = load i64, ptr %hash_coef_ptr.i.i88.i601.i, align 4, !noalias !202
  %tbl_size.i.i92.i605.i = load i64, ptr %tbl_size_ptr.i.i89.i602.i, align 4, !noalias !202
  %offset_tbl.i.i93.i606.i = load ptr, ptr %offset_tbl_ptr.i.i90.i603.i, align 8, !noalias !202
  %product.i.i.i94.i607.i = mul i64 %hash_coef.i.i91.i604.i, 4015701072841558310
  %shifted.i.i.i95.i608.i = lshr i64 %product.i.i.i94.i607.i, 32
  %xored.i.i.i96.i609.i = xor i64 %shifted.i.i.i95.i608.i, %product.i.i.i94.i607.i
  %hash.i.i.i97.i610.i = and i64 %xored.i.i.i96.i609.i, %tbl_size.i.i92.i605.i
  %offset_ptr.i.i98.i611.i = getelementptr i32, ptr %offset_tbl.i.i93.i606.i, i64 %hash.i.i.i97.i610.i
  %offset.i.i99.i612.i = load i32, ptr %offset_ptr.i.i98.i611.i, align 4, !noalias !202
  %214 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %160, 0
  %215 = insertvalue { ptr, ptr, ptr, i32 } %214, ptr %212, 1
  %216 = insertvalue { ptr, ptr, ptr, i32 } %215, ptr %213, 2
  %217 = insertvalue { ptr, ptr, ptr, i32 } %216, i32 %offset.i.i99.i612.i, 3
  %218 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %219 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %160)
  %220 = sext i32 %offset.i.i99.i612.i to i64
  %221 = getelementptr ptr, ptr %160, i64 %220
  %222 = getelementptr i8, ptr %221, i64 56
  %223 = load ptr, ptr %222, align 8
  %result.i101.i613.i = call ptr %223({ ptr, ptr, ptr, i32 } %217, ptr nocapture nofree noundef nonnull readonly %0) #16
  %224 = call { ptr, i160 } %result.i101.i613.i({ ptr, ptr, ptr, i32 } %217, { ptr, ptr, ptr, i32 } %217, ptr nonnull align 8 %0) #7
  %.fca.0.extract51.i614.i = extractvalue { ptr, i160 } %224, 0
  %225 = getelementptr i8, ptr %.fca.0.extract51.i614.i, i64 8
  %226 = getelementptr i8, ptr %.fca.0.extract51.i614.i, i64 16
  %227 = getelementptr i8, ptr %.fca.0.extract51.i614.i, i64 24
  %228 = getelementptr i8, ptr %.fca.0.extract51.i614.i, i64 32
  %229 = load i64, ptr %225, align 4
  %230 = load i64, ptr %226, align 4
  %231 = load ptr, ptr %227, align 8
  %232 = load ptr, ptr %228, align 8
  %result.i102.i615.i = call i1 %231(i64 %230, i64 %229, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %232) #5
  br i1 %result.i102.i615.i, label %._crit_edge.sink.split.i617.i, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit619.i

._crit_edge.sink.split.i617.i:                    ; preds = %211, %208
  %.sink159.i618.i = phi i64 [ 48, %208 ], [ 40, %211 ]
  %233 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %234 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i618.i
  %235 = load ptr, ptr %234, align 8
  %236 = load ptr, ptr %235, align 8
  %237 = call i32 %236(ptr nonnull %result.i150.i) #36
  %238 = add i32 %237, 1
  %239 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %240 = getelementptr i8, ptr %235, i64 8
  %241 = load ptr, ptr %240, align 8
  call void %241(ptr nonnull %result.i150.i, i32 %238) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit619.i

HashMap_insert_internal_keyK_valueV_hashPtri32.exit619.i: ; preds = %._crit_edge.sink.split.i617.i, %211
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %6)
  br label %._crit_edge.i492.i

._crit_edge.i492.i:                               ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit619.i, %46, %.lr.ph.i491.i
  %242 = add nuw nsw i32 %.096.i.i, 1
  %243 = icmp slt i32 %242, %28
  br i1 %243, label %.lr.ph.i491.i, label %HashMap_resize_new_capacityPtri32.exit.i

HashMap_resize_new_capacityPtri32.exit.i:         ; preds = %._crit_edge.i492.i, %._crit_edge1.i377.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  br label %HashMap_ensure_capacity_required_loadPtri32.exit.i

HashMap_ensure_capacity_required_loadPtri32.exit.i: ; preds = %HashMap_resize_new_capacityPtri32.exit.i, %._crit_edge.i
  %244 = load ptr, ptr %15, align 8
  %245 = call i32 %244({ ptr, i160 } %26) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %246 = load ptr, ptr %result.i150.i, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %247 = load i32, ptr %18, align 8
  %248 = add i32 %247, -1
  %249 = and i32 %248, %245
  %250 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %251 = load ptr, ptr %17, align 8
  %252 = sext i32 %249 to i64
  %253 = shl nsw i64 %252, 5
  %254 = getelementptr i8, ptr %251, i64 %253
  %255 = load ptr, ptr %254, align 8
  %256 = icmp eq ptr %255, @nil_typ
  %257 = icmp eq ptr %255, null
  %258 = or i1 %256, %257
  br i1 %258, label %HashMap_find_slot_keyK_hashPtri32.exit529.i, label %.lr.ph.i506.i

.lr.ph.i506.i:                                    ; preds = %HashMap_ensure_capacity_required_loadPtri32.exit.i
  %259 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %260

260:                                              ; preds = %._crit_edge.thread.i521.i, %.lr.ph.i506.i
  %261 = phi i32 [ %249, %.lr.ph.i506.i ], [ %303, %._crit_edge.thread.i521.i ]
  %spec.store.select.i526548.i = phi i32 [ -1, %.lr.ph.i506.i ], [ %spec.store.select.i526.i, %._crit_edge.thread.i521.i ]
  %262 = phi ptr [ %255, %.lr.ph.i506.i ], [ %308, %._crit_edge.thread.i521.i ]
  %263 = phi ptr [ %254, %.lr.ph.i506.i ], [ %307, %._crit_edge.thread.i521.i ]
  %.sroa_idx.i507.i = getelementptr i8, ptr %263, i64 16
  %264 = load i64, ptr %.sroa_idx.i507.i, align 4
  %265 = getelementptr i8, ptr %263, i64 8
  %266 = load i64, ptr %265, align 4
  %267 = inttoptr i64 %266 to ptr
  %268 = inttoptr i64 %264 to ptr
  %hash_coef_ptr.i.i56.i508.i = getelementptr i8, ptr %262, i64 8
  %tbl_size_ptr.i.i57.i509.i = getelementptr i8, ptr %262, i64 16
  %offset_tbl_ptr.i.i58.i510.i = getelementptr i8, ptr %262, i64 40
  %hash_coef.i.i59.i511.i = load i64, ptr %hash_coef_ptr.i.i56.i508.i, align 4
  %tbl_size.i.i60.i512.i = load i64, ptr %tbl_size_ptr.i.i57.i509.i, align 4
  %offset_tbl.i.i61.i513.i = load ptr, ptr %offset_tbl_ptr.i.i58.i510.i, align 8
  %product.i.i.i62.i514.i = mul i64 %hash_coef.i.i59.i511.i, 4015701072841558310
  %shifted.i.i.i63.i515.i = lshr i64 %product.i.i.i62.i514.i, 32
  %xored.i.i.i64.i516.i = xor i64 %shifted.i.i.i63.i515.i, %product.i.i.i62.i514.i
  %hash.i.i.i65.i517.i = and i64 %xored.i.i.i64.i516.i, %tbl_size.i.i60.i512.i
  %offset_ptr.i.i66.i518.i = getelementptr i32, ptr %offset_tbl.i.i61.i513.i, i64 %hash.i.i.i65.i517.i
  %offset.i.i67.i519.i = load i32, ptr %offset_ptr.i.i66.i518.i, align 4
  %269 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %262, 0
  %270 = insertvalue { ptr, ptr, ptr, i32 } %269, ptr %267, 1
  %271 = insertvalue { ptr, ptr, ptr, i32 } %270, ptr %268, 2
  %272 = insertvalue { ptr, ptr, ptr, i32 } %271, i32 %offset.i.i67.i519.i, 3
  %273 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %262)
  %274 = sext i32 %offset.i.i67.i519.i to i64
  %275 = getelementptr ptr, ptr %262, i64 %274
  %276 = getelementptr i8, ptr %275, i64 64
  %277 = load ptr, ptr %276, align 8
  %result.i.i520.i = call ptr %277({ ptr, ptr, ptr, i32 } %272, ptr nocapture nofree noundef nonnull readonly %0) #16
  %278 = call i32 %result.i.i520.i({ ptr, ptr, ptr, i32 } %272, { ptr, ptr, ptr, i32 } %272, ptr nonnull align 8 %0) #7
  %279 = icmp eq i32 %278, %245
  br i1 %279, label %._crit_edge.i528.i, label %._crit_edge.thread.i521.i

._crit_edge.i528.i:                               ; preds = %260
  %280 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %281 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %262)
  %282 = getelementptr i8, ptr %275, i64 48
  %283 = load ptr, ptr %282, align 8
  %result.i69.i.i = call ptr %283({ ptr, ptr, ptr, i32 } %272, ptr nocapture nofree noundef nonnull readonly %0) #16
  %284 = call { ptr, i160 } %result.i69.i.i({ ptr, ptr, ptr, i32 } %272, { ptr, ptr, ptr, i32 } %272, ptr nonnull align 8 %0) #7
  %285 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %286 = load ptr, ptr %16, align 8
  %287 = call i1 %286({ ptr, i160 } %284, { ptr, i160 } %26) #7
  br i1 %287, label %HashMap_find_slot_keyK_hashPtri32.exit529.loopexit.i, label %._crit_edge.thread.i521.i

._crit_edge.thread.i521.i:                        ; preds = %._crit_edge.i528.i, %260
  %288 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %289 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %262)
  %290 = getelementptr i8, ptr %275, i64 56
  %291 = load ptr, ptr %290, align 8
  %result.i70.i522.i = call ptr %291({ ptr, ptr, ptr, i32 } %272, ptr nocapture nofree noundef nonnull readonly %0) #16
  %292 = call { ptr, i160 } %result.i70.i522.i({ ptr, ptr, ptr, i32 } %272, { ptr, ptr, ptr, i32 } %272, ptr nonnull align 8 %0) #7
  %.fca.0.extract19.i523.i = extractvalue { ptr, i160 } %292, 0
  %293 = getelementptr i8, ptr %.fca.0.extract19.i523.i, i64 8
  %294 = getelementptr i8, ptr %.fca.0.extract19.i523.i, i64 16
  %295 = getelementptr i8, ptr %.fca.0.extract19.i523.i, i64 24
  %296 = getelementptr i8, ptr %.fca.0.extract19.i523.i, i64 32
  %297 = load i64, ptr %293, align 4
  %298 = load i64, ptr %294, align 4
  %299 = load ptr, ptr %295, align 8
  %300 = load ptr, ptr %296, align 8
  %result.i71.i524.i = call i1 %299(i64 %298, i64 %297, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %300) #5
  %301 = icmp eq i32 %spec.store.select.i526548.i, -1
  %or.cond.i525.i = select i1 %result.i71.i524.i, i1 %301, i1 false
  %spec.store.select.i526.i = select i1 %or.cond.i525.i, i32 %261, i32 %spec.store.select.i526548.i
  %302 = add i32 %261, 1
  %303 = and i32 %302, %248
  %304 = load ptr, ptr %17, align 8
  %305 = sext i32 %303 to i64
  %306 = shl nsw i64 %305, 5
  %307 = getelementptr i8, ptr %304, i64 %306
  %308 = load ptr, ptr %307, align 8
  %309 = icmp eq ptr %308, @nil_typ
  %310 = icmp eq ptr %308, null
  %311 = or i1 %309, %310
  br i1 %311, label %._crit_edge105.loopexit.i527.i, label %260

._crit_edge105.loopexit.i527.i:                   ; preds = %._crit_edge.thread.i521.i
  %312 = icmp eq i32 %spec.store.select.i526.i, -1
  %.pre.i.pre562.i = select i1 %312, i32 %303, i32 %spec.store.select.i526.i
  br label %HashMap_find_slot_keyK_hashPtri32.exit529.i

HashMap_find_slot_keyK_hashPtri32.exit529.loopexit.i: ; preds = %._crit_edge.i528.i
  %.pre587.i = load ptr, ptr %17, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit529.i

HashMap_find_slot_keyK_hashPtri32.exit529.i:      ; preds = %HashMap_find_slot_keyK_hashPtri32.exit529.loopexit.i, %._crit_edge105.loopexit.i527.i, %HashMap_ensure_capacity_required_loadPtri32.exit.i
  %313 = phi ptr [ %304, %._crit_edge105.loopexit.i527.i ], [ %251, %HashMap_ensure_capacity_required_loadPtri32.exit.i ], [ %.pre587.i, %HashMap_find_slot_keyK_hashPtri32.exit529.loopexit.i ]
  %314 = phi i32 [ %.pre.i.pre562.i, %._crit_edge105.loopexit.i527.i ], [ %249, %HashMap_ensure_capacity_required_loadPtri32.exit.i ], [ %261, %HashMap_find_slot_keyK_hashPtri32.exit529.loopexit.i ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %315 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %316 = sext i32 %314 to i64
  %317 = shl nsw i64 %316, 5
  %318 = getelementptr i8, ptr %313, i64 %317
  %319 = load ptr, ptr %318, align 8
  %320 = getelementptr i8, ptr %318, i64 8
  %321 = load i64, ptr %320, align 4
  %.sroa_idx.i394.i = getelementptr i8, ptr %318, i64 16
  %322 = load i64, ptr %.sroa_idx.i394.i, align 4
  %323 = load ptr, ptr %10, align 8
  %324 = load ptr, ptr %246, align 8, !alias.scope !205
  %325 = getelementptr i8, ptr %324, i64 72
  %326 = load ptr, ptr %325, align 8, !alias.scope !205
  %result.i.i.i.i = call { i64, i64 } %326(ptr nocapture nofree nonnull readonly %246) #5, !alias.scope !205
  %327 = extractvalue { i64, i64 } %result.i.i.i.i, 0
  %328 = extractvalue { i64, i64 } %result.i.i.i.i, 1
  %329 = call i64 @llvm.umax.i64(i64 %328, i64 8)
  %330 = urem i64 20, %328
  %331 = icmp eq i64 %330, 0
  %332 = sub i64 %328, %330
  %333 = select i1 %331, i64 0, i64 %332
  %334 = add i64 %327, 20
  %335 = add i64 %334, %333
  %336 = and i64 %335, 7
  %337 = icmp eq i64 %336, 0
  %338 = sub nuw nsw i64 40, %336
  %339 = select i1 %337, i64 32, i64 %338
  %340 = add i64 %339, %335
  %341 = urem i64 %340, %329
  %342 = icmp eq i64 %341, 0
  %343 = sub i64 %329, %341
  %344 = select i1 %342, i64 0, i64 %343
  %345 = add i64 %340, %344
  %result.i71.i.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %345, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %246, ptr %result.i71.i.i, align 8
  %346 = getelementptr inbounds i8, ptr %result.i71.i.i, i64 8
  store ptr %323, ptr %346, align 8
  %347 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i.i)
  %348 = load ptr, ptr %246, align 8
  %349 = getelementptr i8, ptr %348, i64 72
  %350 = load ptr, ptr %349, align 8
  %result.i.i572.i = call { i64, i64 } %350(ptr nocapture nofree nonnull readonly %246) #5
  %351 = extractvalue { i64, i64 } %result.i.i572.i, 1
  %352 = urem i64 20, %351
  %353 = icmp eq i64 %352, 0
  %reass.sub1612 = sub i64 %351, %352
  %354 = add i64 %reass.sub1612, 20
  %355 = select i1 %353, i64 20, i64 %354
  %356 = getelementptr i8, ptr %result.i71.i.i, i64 %355
  %357 = getelementptr i8, ptr %348, i64 64
  %358 = load ptr, ptr %357, align 8
  call void %358({ ptr, i160 } %26, ptr nocapture nofree nonnull readonly %246, ptr nocapture nofree writeonly %356) #13
  %359 = load ptr, ptr %result.i71.i.i, align 8
  %360 = load ptr, ptr %359, align 8
  %361 = getelementptr i8, ptr %360, i64 72
  %362 = load ptr, ptr %361, align 8
  %result.i.i573.i = call { i64, i64 } %362(ptr nocapture nofree nonnull readonly %359) #5
  %363 = extractvalue { i64, i64 } %result.i.i573.i, 0
  %364 = extractvalue { i64, i64 } %result.i.i573.i, 1
  %365 = urem i64 20, %364
  %366 = icmp eq i64 %365, 0
  %367 = sub i64 %364, %365
  %368 = select i1 %366, i64 0, i64 %367
  %369 = add i64 %363, 20
  %370 = add i64 %369, %368
  %371 = and i64 %370, 7
  %372 = icmp eq i64 %371, 0
  %373 = sub nuw nsw i64 8, %371
  %374 = select i1 %372, i64 0, i64 %373
  %375 = getelementptr i8, ptr %result.i71.i.i, i64 %370
  %376 = getelementptr i8, ptr %375, i64 %374
  store ptr @i32_typ, ptr %376, align 8
  %377 = getelementptr i8, ptr %376, i64 8
  store i160 %.sroa.0128.0.insert.ext.i, ptr %377, align 4
  %378 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @Entry) #34
  %379 = getelementptr inbounds i8, ptr %result.i71.i.i, i64 16
  store i32 %245, ptr %379, align 8
  %380 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  store ptr @Entry, ptr %318, align 8
  %381 = ptrtoint ptr %result.i71.i.i to i64
  store i64 %381, ptr %320, align 4
  %.sroa_idx4.i.i = getelementptr i8, ptr %318, i64 24
  store i32 10, ptr %.sroa_idx4.i.i, align 4
  %382 = icmp eq ptr %319, @nil_typ
  %383 = icmp eq ptr %319, null
  %384 = or i1 %382, %383
  br i1 %384, label %385, label %388

385:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit529.i
  %386 = load i32, ptr %22, align 4
  %387 = add i32 %386, 1
  store i32 %387, ptr %22, align 4
  br label %._crit_edge.sink.split.i.i

388:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit529.i
  %389 = inttoptr i64 %321 to ptr
  %390 = inttoptr i64 %322 to ptr
  %hash_coef_ptr.i.i88.i.i = getelementptr i8, ptr %319, i64 8
  %tbl_size_ptr.i.i89.i.i = getelementptr i8, ptr %319, i64 16
  %offset_tbl_ptr.i.i90.i.i = getelementptr i8, ptr %319, i64 40
  %hash_coef.i.i91.i.i = load i64, ptr %hash_coef_ptr.i.i88.i.i, align 4, !noalias !208
  %tbl_size.i.i92.i.i = load i64, ptr %tbl_size_ptr.i.i89.i.i, align 4, !noalias !208
  %offset_tbl.i.i93.i.i = load ptr, ptr %offset_tbl_ptr.i.i90.i.i, align 8, !noalias !208
  %product.i.i.i94.i.i = mul i64 %hash_coef.i.i91.i.i, 4015701072841558310
  %shifted.i.i.i95.i.i = lshr i64 %product.i.i.i94.i.i, 32
  %xored.i.i.i96.i.i = xor i64 %shifted.i.i.i95.i.i, %product.i.i.i94.i.i
  %hash.i.i.i97.i.i = and i64 %xored.i.i.i96.i.i, %tbl_size.i.i92.i.i
  %offset_ptr.i.i98.i.i = getelementptr i32, ptr %offset_tbl.i.i93.i.i, i64 %hash.i.i.i97.i.i
  %offset.i.i99.i.i = load i32, ptr %offset_ptr.i.i98.i.i, align 4, !noalias !208
  %391 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %319, 0
  %392 = insertvalue { ptr, ptr, ptr, i32 } %391, ptr %389, 1
  %393 = insertvalue { ptr, ptr, ptr, i32 } %392, ptr %390, 2
  %394 = insertvalue { ptr, ptr, ptr, i32 } %393, i32 %offset.i.i99.i.i, 3
  %395 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %396 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %319)
  %397 = sext i32 %offset.i.i99.i.i to i64
  %398 = getelementptr ptr, ptr %319, i64 %397
  %399 = getelementptr i8, ptr %398, i64 56
  %400 = load ptr, ptr %399, align 8
  %result.i101.i.i = call ptr %400({ ptr, ptr, ptr, i32 } %394, ptr nocapture nofree noundef nonnull readonly %0) #16
  %401 = call { ptr, i160 } %result.i101.i.i({ ptr, ptr, ptr, i32 } %394, { ptr, ptr, ptr, i32 } %394, ptr nonnull align 8 %0) #7
  %.fca.0.extract51.i396.i = extractvalue { ptr, i160 } %401, 0
  %402 = getelementptr i8, ptr %.fca.0.extract51.i396.i, i64 8
  %403 = getelementptr i8, ptr %.fca.0.extract51.i396.i, i64 16
  %404 = getelementptr i8, ptr %.fca.0.extract51.i396.i, i64 24
  %405 = getelementptr i8, ptr %.fca.0.extract51.i396.i, i64 32
  %406 = load i64, ptr %402, align 4
  %407 = load i64, ptr %403, align 4
  %408 = load ptr, ptr %404, align 8
  %409 = load ptr, ptr %405, align 8
  %result.i102.i.i = call i1 %408(i64 %407, i64 %406, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %409) #5
  br i1 %result.i102.i.i, label %._crit_edge.sink.split.i.i, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit.i

._crit_edge.sink.split.i.i:                       ; preds = %388, %385
  %.sink159.i.i = phi i64 [ 48, %385 ], [ 40, %388 ]
  %410 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %411 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i.i
  %412 = load ptr, ptr %411, align 8
  %413 = load ptr, ptr %412, align 8
  %414 = call i32 %413(ptr nonnull %result.i150.i) #36
  %415 = add i32 %414, 1
  %416 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %417 = getelementptr i8, ptr %412, i64 8
  %418 = load ptr, ptr %417, align 8
  call void %418(ptr nonnull %result.i150.i, i32 %415) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit.i

HashMap_insert_internal_keyK_valueV_hashPtri32.exit.i: ; preds = %._crit_edge.sink.split.i.i, %388
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %419 = icmp ult i32 %.0216.i, 999999
  br i1 %419, label %._crit_edge.i, label %._crit_edge2.i

._crit_edge2.i:                                   ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit.i
  %420 = call i64 @clock()
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %421 = load ptr, ptr %15, align 8
  %422 = call i32 %421({ ptr, i160 } { ptr @i32_typ, i160 999999 }) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %423 = load i32, ptr %18, align 8
  %424 = add i32 %423, -1
  %425 = and i32 %424, %422
  %426 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %427 = load ptr, ptr %17, align 8
  %428 = sext i32 %425 to i64
  %429 = shl nsw i64 %428, 5
  %430 = getelementptr i8, ptr %427, i64 %429
  %431 = load ptr, ptr %430, align 8
  %432 = icmp eq ptr %431, @nil_typ
  %433 = icmp eq ptr %431, null
  %434 = or i1 %432, %433
  br i1 %434, label %HashMap_find_slot_keyK_hashPtri32.exit.i, label %.lr.ph.i.i

.lr.ph.i.i:                                       ; preds = %._crit_edge2.i
  %435 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %436

436:                                              ; preds = %._crit_edge.thread.i.i, %.lr.ph.i.i
  %437 = phi i32 [ %425, %.lr.ph.i.i ], [ %479, %._crit_edge.thread.i.i ]
  %spec.store.select.i469.i = phi i32 [ -1, %.lr.ph.i.i ], [ %spec.store.select.i.i, %._crit_edge.thread.i.i ]
  %438 = phi ptr [ %431, %.lr.ph.i.i ], [ %484, %._crit_edge.thread.i.i ]
  %439 = phi ptr [ %430, %.lr.ph.i.i ], [ %483, %._crit_edge.thread.i.i ]
  %.sroa_idx.i410.i = getelementptr i8, ptr %439, i64 16
  %440 = load i64, ptr %.sroa_idx.i410.i, align 4
  %441 = getelementptr i8, ptr %439, i64 8
  %442 = load i64, ptr %441, align 4
  %443 = inttoptr i64 %442 to ptr
  %444 = inttoptr i64 %440 to ptr
  %hash_coef_ptr.i.i56.i.i = getelementptr i8, ptr %438, i64 8
  %tbl_size_ptr.i.i57.i.i = getelementptr i8, ptr %438, i64 16
  %offset_tbl_ptr.i.i58.i.i = getelementptr i8, ptr %438, i64 40
  %hash_coef.i.i59.i.i = load i64, ptr %hash_coef_ptr.i.i56.i.i, align 4
  %tbl_size.i.i60.i.i = load i64, ptr %tbl_size_ptr.i.i57.i.i, align 4
  %offset_tbl.i.i61.i.i = load ptr, ptr %offset_tbl_ptr.i.i58.i.i, align 8
  %product.i.i.i62.i.i = mul i64 %hash_coef.i.i59.i.i, 4015701072841558310
  %shifted.i.i.i63.i.i = lshr i64 %product.i.i.i62.i.i, 32
  %xored.i.i.i64.i.i = xor i64 %shifted.i.i.i63.i.i, %product.i.i.i62.i.i
  %hash.i.i.i65.i.i = and i64 %xored.i.i.i64.i.i, %tbl_size.i.i60.i.i
  %offset_ptr.i.i66.i.i = getelementptr i32, ptr %offset_tbl.i.i61.i.i, i64 %hash.i.i.i65.i.i
  %offset.i.i67.i.i = load i32, ptr %offset_ptr.i.i66.i.i, align 4
  %445 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %438, 0
  %446 = insertvalue { ptr, ptr, ptr, i32 } %445, ptr %443, 1
  %447 = insertvalue { ptr, ptr, ptr, i32 } %446, ptr %444, 2
  %448 = insertvalue { ptr, ptr, ptr, i32 } %447, i32 %offset.i.i67.i.i, 3
  %449 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %438)
  %450 = sext i32 %offset.i.i67.i.i to i64
  %451 = getelementptr ptr, ptr %438, i64 %450
  %452 = getelementptr i8, ptr %451, i64 64
  %453 = load ptr, ptr %452, align 8
  %result.i.i411.i = call ptr %453({ ptr, ptr, ptr, i32 } %448, ptr nocapture nofree noundef nonnull readonly %0) #16
  %454 = call i32 %result.i.i411.i({ ptr, ptr, ptr, i32 } %448, { ptr, ptr, ptr, i32 } %448, ptr nonnull align 8 %0) #7
  %455 = icmp eq i32 %454, %422
  br i1 %455, label %._crit_edge.i413.i, label %._crit_edge.thread.i.i

._crit_edge.i413.i:                               ; preds = %436
  %456 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %457 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %438)
  %458 = getelementptr i8, ptr %451, i64 48
  %459 = load ptr, ptr %458, align 8
  %result.i69.i414.i = call ptr %459({ ptr, ptr, ptr, i32 } %448, ptr nocapture nofree noundef nonnull readonly %0) #16
  %460 = call { ptr, i160 } %result.i69.i414.i({ ptr, ptr, ptr, i32 } %448, { ptr, ptr, ptr, i32 } %448, ptr nonnull align 8 %0) #7
  %461 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %462 = load ptr, ptr %16, align 8
  %463 = call i1 %462({ ptr, i160 } %460, { ptr, i160 } { ptr @i32_typ, i160 999999 }) #7
  br i1 %463, label %HashMap_find_slot_keyK_hashPtri32.exit.loopexit.i, label %._crit_edge.thread.i.i

._crit_edge.thread.i.i:                           ; preds = %._crit_edge.i413.i, %436
  %464 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %465 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %438)
  %466 = getelementptr i8, ptr %451, i64 56
  %467 = load ptr, ptr %466, align 8
  %result.i70.i.i = call ptr %467({ ptr, ptr, ptr, i32 } %448, ptr nocapture nofree noundef nonnull readonly %0) #16
  %468 = call { ptr, i160 } %result.i70.i.i({ ptr, ptr, ptr, i32 } %448, { ptr, ptr, ptr, i32 } %448, ptr nonnull align 8 %0) #7
  %.fca.0.extract19.i.i = extractvalue { ptr, i160 } %468, 0
  %469 = getelementptr i8, ptr %.fca.0.extract19.i.i, i64 8
  %470 = getelementptr i8, ptr %.fca.0.extract19.i.i, i64 16
  %471 = getelementptr i8, ptr %.fca.0.extract19.i.i, i64 24
  %472 = getelementptr i8, ptr %.fca.0.extract19.i.i, i64 32
  %473 = load i64, ptr %469, align 4
  %474 = load i64, ptr %470, align 4
  %475 = load ptr, ptr %471, align 8
  %476 = load ptr, ptr %472, align 8
  %result.i71.i412.i = call i1 %475(i64 %474, i64 %473, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %476) #5
  %477 = icmp eq i32 %spec.store.select.i469.i, -1
  %or.cond.i.i = select i1 %result.i71.i412.i, i1 %477, i1 false
  %spec.store.select.i.i = select i1 %or.cond.i.i, i32 %437, i32 %spec.store.select.i469.i
  %478 = add i32 %437, 1
  %479 = and i32 %478, %424
  %480 = load ptr, ptr %17, align 8
  %481 = sext i32 %479 to i64
  %482 = shl nsw i64 %481, 5
  %483 = getelementptr i8, ptr %480, i64 %482
  %484 = load ptr, ptr %483, align 8
  %485 = icmp eq ptr %484, @nil_typ
  %486 = icmp eq ptr %484, null
  %487 = or i1 %485, %486
  br i1 %487, label %._crit_edge105.loopexit.i.i, label %436

._crit_edge105.loopexit.i.i:                      ; preds = %._crit_edge.thread.i.i
  %488 = icmp eq i32 %spec.store.select.i.i, -1
  %.pre.i.pre.i = select i1 %488, i32 %479, i32 %spec.store.select.i.i
  br label %HashMap_find_slot_keyK_hashPtri32.exit.i

HashMap_find_slot_keyK_hashPtri32.exit.loopexit.i: ; preds = %._crit_edge.i413.i
  %.pre.i = load ptr, ptr %17, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit.i

HashMap_find_slot_keyK_hashPtri32.exit.i:         ; preds = %HashMap_find_slot_keyK_hashPtri32.exit.loopexit.i, %._crit_edge105.loopexit.i.i, %._crit_edge2.i
  %489 = phi ptr [ %480, %._crit_edge105.loopexit.i.i ], [ %427, %._crit_edge2.i ], [ %.pre.i, %HashMap_find_slot_keyK_hashPtri32.exit.loopexit.i ]
  %490 = phi i32 [ %.pre.i.pre.i, %._crit_edge105.loopexit.i.i ], [ %425, %._crit_edge2.i ], [ %437, %HashMap_find_slot_keyK_hashPtri32.exit.loopexit.i ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %491 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %492 = sext i32 %490 to i64
  %493 = shl nsw i64 %492, 5
  %494 = getelementptr i8, ptr %489, i64 %493
  %495 = load ptr, ptr %494, align 8
  %496 = icmp ne ptr %495, @nil_typ
  %497 = icmp ne ptr %495, null
  %.not57.i.i = and i1 %496, %497
  br i1 %.not57.i.i, label %498, label %HashMap_get_keyK.exit.thread.i

498:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit.i
  %499 = getelementptr i8, ptr %494, i64 8
  %500 = load i64, ptr %499, align 4
  %.sroa_idx.i.i = getelementptr i8, ptr %494, i64 16
  %501 = load i64, ptr %.sroa_idx.i.i, align 4
  %502 = inttoptr i64 %500 to ptr
  %503 = inttoptr i64 %501 to ptr
  %hash_coef_ptr.i.i60.i.i = getelementptr i8, ptr %495, i64 8
  %tbl_size_ptr.i.i61.i.i = getelementptr i8, ptr %495, i64 16
  %offset_tbl_ptr.i.i62.i.i = getelementptr i8, ptr %495, i64 40
  %hash_coef.i.i63.i.i = load i64, ptr %hash_coef_ptr.i.i60.i.i, align 4, !noalias !211
  %tbl_size.i.i64.i.i = load i64, ptr %tbl_size_ptr.i.i61.i.i, align 4, !noalias !211
  %offset_tbl.i.i65.i.i = load ptr, ptr %offset_tbl_ptr.i.i62.i.i, align 8, !noalias !211
  %product.i.i.i66.i.i = mul i64 %hash_coef.i.i63.i.i, 4015701072841558310
  %shifted.i.i.i67.i.i = lshr i64 %product.i.i.i66.i.i, 32
  %xored.i.i.i68.i.i = xor i64 %shifted.i.i.i67.i.i, %product.i.i.i66.i.i
  %hash.i.i.i69.i.i = and i64 %xored.i.i.i68.i.i, %tbl_size.i.i64.i.i
  %offset_ptr.i.i70.i.i = getelementptr i32, ptr %offset_tbl.i.i65.i.i, i64 %hash.i.i.i69.i.i
  %offset.i.i71.i.i = load i32, ptr %offset_ptr.i.i70.i.i, align 4, !noalias !211
  %504 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %495, 0
  %505 = insertvalue { ptr, ptr, ptr, i32 } %504, ptr %502, 1
  %506 = insertvalue { ptr, ptr, ptr, i32 } %505, ptr %503, 2
  %507 = insertvalue { ptr, ptr, ptr, i32 } %506, i32 %offset.i.i71.i.i, 3
  %508 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %509 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %495)
  %510 = sext i32 %offset.i.i71.i.i to i64
  %511 = getelementptr ptr, ptr %495, i64 %510
  %512 = getelementptr i8, ptr %511, i64 56
  %513 = load ptr, ptr %512, align 8
  %result.i73.i.i = call ptr %513({ ptr, ptr, ptr, i32 } %507, ptr nocapture nofree noundef nonnull readonly %0) #16
  %514 = call { ptr, i160 } %result.i73.i.i({ ptr, ptr, ptr, i32 } %507, { ptr, ptr, ptr, i32 } %507, ptr nonnull align 8 %0) #7
  %.fca.0.extract51.i.i = extractvalue { ptr, i160 } %514, 0
  %.fca.1.extract52.i.i = extractvalue { ptr, i160 } %514, 1
  %515 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %516 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %495)
  %517 = getelementptr i8, ptr %511, i64 64
  %518 = load ptr, ptr %517, align 8
  %result.i74.i.i = call ptr %518({ ptr, ptr, ptr, i32 } %507, ptr nocapture nofree noundef nonnull readonly %0) #16
  %519 = call i32 %result.i74.i.i({ ptr, ptr, ptr, i32 } %507, { ptr, ptr, ptr, i32 } %507, ptr nonnull align 8 %0) #7
  %520 = icmp eq i32 %519, %422
  br i1 %520, label %._crit_edge.i.i, label %HashMap_get_keyK.exit.thread.i

._crit_edge.i.i:                                  ; preds = %498
  %521 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %522 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %495)
  %523 = getelementptr i8, ptr %511, i64 48
  %524 = load ptr, ptr %523, align 8
  %result.i75.i.i = call ptr %524({ ptr, ptr, ptr, i32 } %507, ptr nocapture nofree noundef nonnull readonly %0) #16
  %525 = call { ptr, i160 } %result.i75.i.i({ ptr, ptr, ptr, i32 } %507, { ptr, ptr, ptr, i32 } %507, ptr nonnull align 8 %0) #7
  %526 = load ptr, ptr %16, align 8
  %527 = call i1 %526({ ptr, i160 } %525, { ptr, i160 } { ptr @i32_typ, i160 999999 }) #7
  br i1 %527, label %HashMap_get_keyK.exit.i, label %HashMap_get_keyK.exit.thread.i

HashMap_get_keyK.exit.thread.i:                   ; preds = %._crit_edge.i.i, %498, %HashMap_find_slot_keyK_hashPtri32.exit.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  br label %._crit_edge4.i

HashMap_get_keyK.exit.i:                          ; preds = %._crit_edge.i.i
  %528 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %529 = load ptr, ptr %10, align 8
  %530 = load ptr, ptr %529, align 8
  %531 = ptrtoint ptr %530 to i64
  %532 = getelementptr i8, ptr %.fca.0.extract51.i.i, i64 8
  %533 = getelementptr i8, ptr %.fca.0.extract51.i.i, i64 16
  %534 = getelementptr i8, ptr %.fca.0.extract51.i.i, i64 24
  %535 = getelementptr i8, ptr %.fca.0.extract51.i.i, i64 32
  %536 = load i64, ptr %532, align 4
  %537 = load i64, ptr %533, align 4
  %538 = load ptr, ptr %534, align 8
  %539 = load ptr, ptr %535, align 8
  %540 = load i64, ptr %530, align 4
  %result.i77.i.i = call i1 %538(i64 %537, i64 %536, i64 %540, i64 %531, ptr readonly %539) #5
  %cond.fr.i.i = freeze i1 %result.i77.i.i
  %spec.select.i.i = select i1 %cond.fr.i.i, ptr %.fca.0.extract51.i.i, ptr @nil_typ
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %541 = icmp ne ptr %spec.select.i.i, @nil_typ
  %542 = icmp ne ptr %spec.select.i.i, null
  %.not143.i = and i1 %541, %542
  br i1 %.not143.i, label %._crit_edge3.i, label %._crit_edge4.i

._crit_edge3.i:                                   ; preds = %HashMap_get_keyK.exit.i
  %.sroa.2.8.extract.trunc.i = trunc i160 %.fca.1.extract52.i.i to i32
  %.not147.i = icmp eq i32 %.sroa.2.8.extract.trunc.i, 1000000
  br label %._crit_edge4.i

._crit_edge4.i:                                   ; preds = %._crit_edge3.i, %HashMap_get_keyK.exit.i, %HashMap_get_keyK.exit.thread.i
  %.2.i = phi i1 [ %.not147.i, %._crit_edge3.i ], [ false, %HashMap_get_keyK.exit.i ], [ false, %HashMap_get_keyK.exit.thread.i ]
  %543 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %544 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #34
  %545 = load i32, ptr %22, align 4
  %.not148.i = icmp eq i32 %545, 1000000
  %546 = select i1 %.not148.i, i1 %.2.i, i1 false
  %547 = select i1 %546, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %result.i162.i = call noalias align 32 dereferenceable_or_null(18) ptr @bump_malloc_inner(i64 noundef 18, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <17 x i8> <i8 73, i8 110, i8 115, i8 101, i8 114, i8 116, i8 32, i8 83, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108>, ptr %result.i162.i, align 32
  %548 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #34
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %549 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %550 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i428.i = call noalias dereferenceable_or_null(18) ptr @bump_malloc_inner(i64 noundef 18, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(17) %result.i.i428.i, ptr noundef nonnull align 32 dereferenceable(17) %result.i162.i, i64 17, i1 false)
  %551 = sub i64 %420, %20
  %552 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %553 = getelementptr i8, ptr %result.i.i428.i, i64 17
  store i8 0, ptr %553, align 1
  %puts.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i428.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %result.i97.i.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i97.i.i, align 16
  %result.i.i375.i.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i375.i.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i97.i.i, i64 14, i1 false)
  %puts.i.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i375.i.i)
  %554 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 1000000) #17
  %result.i103.i.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i103.i.i, align 16
  %result.i.i389.i.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i389.i.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i103.i.i, i64 14, i1 false)
  %puts.i313.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i389.i.i)
  %555 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %551) #17
  %result.i109.i.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i109.i.i, align 4
  %result.i.i408.i.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i408.i.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i109.i.i, i64 3, i1 false)
  %puts.i333.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i408.i.i)
  %556 = icmp sgt i64 %551, 0
  br i1 %556, label %557, label %benchmark_insert_sequential.exit

557:                                              ; preds = %._crit_edge4.i
  %558 = mul i64 %551, 1000000
  %559 = sdiv i64 %558, 1000000
  br label %benchmark_insert_sequential.exit

benchmark_insert_sequential.exit:                 ; preds = %._crit_edge4.i, %557
  %.0.i.i = phi i64 [ %559, %557 ], [ 0, %._crit_edge4.i ]
  %result.i114.i.i = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i114.i.i, align 16
  %result.i.i427.i.i = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i427.i.i, ptr noundef nonnull align 16 dereferenceable(15) %result.i114.i.i, i64 15, i1 false)
  %puts.i353.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i427.i.i)
  %560 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0.i.i) #17
  %result.i120.i.i = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i120.i.i, align 4
  %result.i.i446.i.i = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i446.i.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i120.i.i, i64 3, i1 false)
  %puts.i373.i.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i446.i.i)
  %result.i166.i = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i166.i, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %561 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %562 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i443.i = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i443.i, ptr noundef nonnull align 32 dereferenceable(18) %result.i166.i, i64 18, i1 false)
  %563 = getelementptr i8, ptr %result.i.i443.i, i64 18
  store i8 0, ptr %563, align 1
  %puts.i350.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i443.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %564 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %565 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %566 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i462.i = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <4 x i8> %547, ptr %result.i.i462.i, align 1
  %567 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %568 = getelementptr i8, ptr %result.i.i462.i, i64 4
  store i8 0, ptr %568, align 1
  %puts.i370.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i462.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %.sroa.0231.sroa.0.i)
  %result.i268.i = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i268.i, align 8
  %569 = getelementptr inbounds i8, ptr %result.i268.i, i64 8
  store ptr @_parameterization_Ptri32, ptr %569, align 8
  %570 = getelementptr inbounds i8, ptr %result.i268.i, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %570, align 8
  %571 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i268.i) #38
  %result.i269.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i.i31)
  %result.i270.i = call i32 @VirtualProtect(ptr nofree %result.i269.i, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i.i31) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i.i31)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i269.i, ptr noalias nofree noundef nonnull readnone @zqowobcfpb, ptr noalias nofree noundef nonnull readnone @i32_hasher) #38
  %ret.i.i32 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i269.i) #39
  %572 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i269.i) #38
  %result.i271.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i272.i)
  %result.i273.i = call i32 @VirtualProtect(ptr nofree %result.i271.i, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i272.i) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i272.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i271.i, ptr noalias nofree noundef nonnull readnone @xnsyrjqygq, ptr noalias nofree noundef nonnull readnone @i32_eq) #38
  %ret.i274.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i271.i) #39
  %573 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i271.i) #38
  %574 = getelementptr inbounds i8, ptr %result.i268.i, i64 48
  store ptr %ret.i.i32, ptr %574, align 8
  %575 = getelementptr inbounds i8, ptr %result.i268.i, i64 56
  store ptr %ret.i274.i, ptr %575, align 8
  %result.i.i.i33 = call noalias dereferenceable_or_null(512) ptr @bump_malloc_inner(i64 noundef 512, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %576 = getelementptr inbounds i8, ptr %result.i268.i, i64 24
  store ptr %result.i.i.i33, ptr %576, align 8
  %577 = getelementptr inbounds i8, ptr %result.i268.i, i64 32
  store i32 16, ptr %577, align 8
  %result.i4.i.i = call noalias dereferenceable_or_null(4000000) ptr @bump_malloc_inner(i64 noundef 4000000, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %result.i311.i = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i311.i, align 8
  %578 = getelementptr inbounds i8, ptr %result.i311.i, i64 8
  store ptr @_parameterization_Ptri1, ptr %578, align 8
  %579 = getelementptr inbounds i8, ptr %result.i311.i, i64 16
  store ptr @_parameterization_PairPtri32._Ptri1, ptr %579, align 8
  %580 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i311.i)
  %result.i312.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i313.i)
  %result.i314.i = call i32 @VirtualProtect(ptr nofree %result.i312.i, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i313.i) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i313.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i312.i, ptr noalias nofree noundef nonnull readnone @appmrwvncp, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %ret.i315.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i312.i) #39
  %581 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i312.i)
  %result.i316.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i317.i)
  %result.i318.i = call i32 @VirtualProtect(ptr nofree %result.i316.i, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i317.i) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i317.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i316.i, ptr noalias nofree noundef nonnull readnone @rqipwqtmqq, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %ret.i319.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i316.i) #39
  %582 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i316.i)
  %583 = getelementptr inbounds i8, ptr %result.i311.i, i64 48
  store ptr %ret.i315.i, ptr %583, align 8
  %584 = getelementptr inbounds i8, ptr %result.i311.i, i64 56
  store ptr %ret.i319.i, ptr %584, align 8
  %result.i.i514.i = call noalias dereferenceable_or_null(512) ptr @bump_malloc_inner(i64 noundef 512, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %585 = getelementptr inbounds i8, ptr %result.i311.i, i64 24
  store ptr %result.i.i514.i, ptr %585, align 8
  %586 = getelementptr inbounds i8, ptr %result.i311.i, i64 32
  store i32 16, ptr %586, align 8
  %587 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %588 = getelementptr inbounds i8, ptr %result.i311.i, i64 40
  %589 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #34
  %590 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  %591 = getelementptr inbounds i8, ptr %result.i311.i, i64 36
  %592 = getelementptr inbounds i8, ptr %5, i64 8
  %593 = getelementptr inbounds i8, ptr %5, i64 16
  br label %._crit_edge.i34

._crit_edge.i34:                                  ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit.i53, %benchmark_insert_sequential.exit
  %594 = phi i32 [ 123, %benchmark_insert_sequential.exit ], [ %597, %HashMap_insert_internal_keyK_valueV_hashPtri32.exit.i53 ]
  %.0473.i = phi i32 [ -1, %benchmark_insert_sequential.exit ], [ %spec.select.i, %HashMap_insert_internal_keyK_valueV_hashPtri32.exit.i53 ]
  %.0247472.i = phi i32 [ 0, %benchmark_insert_sequential.exit ], [ %995, %HashMap_insert_internal_keyK_valueV_hashPtri32.exit.i53 ]
  %595 = mul i32 %594, 1103515245
  %596 = add i32 %595, 12345
  %597 = and i32 %596, 2147483647
  %.sroa.0241.0.insert.ext.i = zext nneg i32 %597 to i160
  %598 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0241.0.insert.ext.i, 1
  %599 = zext nneg i32 %.0247472.i to i64
  %600 = shl nuw nsw i64 %599, 2
  %601 = getelementptr i8, ptr %result.i4.i.i, i64 %600
  store i32 %597, ptr %601, align 1
  %602 = icmp eq i32 %.0247472.i, 999999
  %spec.select.i = select i1 %602, i32 %597, i32 %.0473.i
  store i1 true, ptr %.sroa.0231.sroa.0.i, align 8
  %.sroa.0231.sroa.0.i.0..sroa.0231.sroa.0.i.0..sroa.0231.sroa.0.i.0..sroa.0231.sroa.0.i.0..sroa.0231.sroa.0.i.0..sroa.0231.sroa.0.i.0..sroa.0231.sroa.0.i.0..sroa.0231.sroa.0.i.0..sroa.0231.sroa.0.i.0..sroa.0231.sroa.0.i.0..sroa.0231.sroa.0.i.0..sroa.0231.sroa.0.i.0..sroa.0231.sroa.0.i.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.0..i = load i8, ptr %.sroa.0231.sroa.0.i, align 8
  %.sroa.0231.0.insert.ext.i = zext i8 %.sroa.0231.sroa.0.i.0..sroa.0231.sroa.0.i.0..sroa.0231.sroa.0.i.0..sroa.0231.sroa.0.i.0..sroa.0231.sroa.0.i.0..sroa.0231.sroa.0.i.0..sroa.0231.sroa.0.i.0..sroa.0231.sroa.0.i.0..sroa.0231.sroa.0.i.0..sroa.0231.sroa.0.i.0..sroa.0231.sroa.0.i.0..sroa.0231.sroa.0.i.0..sroa.0231.sroa.0.i.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.sroa.0.0..sroa.0231.0..i to i160
  %603 = load i32, ptr %588, align 8
  %604 = load i32, ptr %586, align 8
  %605 = icmp eq i32 %604, 0
  %606 = mul i32 %603, 10
  %607 = add i32 %606, 10
  %608 = mul i32 %604, 6
  %609 = icmp sge i32 %607, %608
  %.0.i814.i = select i1 %605, i1 true, i1 %609
  br i1 %.0.i814.i, label %._crit_edge1.i816.i, label %HashMap_ensure_capacity_required_loadPtri32.exit.i35

._crit_edge1.i816.i:                              ; preds = %._crit_edge.i34
  %610 = shl i32 %604, 1
  %spec.select.i817.i = call i32 @llvm.smax.i32(i32 %610, i32 16)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %611 = load ptr, ptr %585, align 8
  %612 = zext nneg i32 %spec.select.i817.i to i64
  %613 = shl nuw nsw i64 %612, 5
  %result.i.i1034.i = call noalias ptr @bump_malloc_inner(i64 noundef %613, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1034.i, ptr %585, align 8
  store i32 %spec.select.i817.i, ptr %586, align 8
  store i32 0, ptr %591, align 4
  %614 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #38
  store i32 0, ptr %588, align 8
  %615 = icmp sgt i32 %604, 0
  br i1 %615, label %.lr.ph.i1035.i, label %HashMap_resize_new_capacityPtri32.exit.i125

.lr.ph.i1035.i:                                   ; preds = %._crit_edge1.i816.i, %._crit_edge.i1036.i
  %.096.i.i126 = phi i32 [ %818, %._crit_edge.i1036.i ], [ 0, %._crit_edge1.i816.i ]
  %616 = zext nneg i32 %.096.i.i126 to i64
  %617 = shl nuw nsw i64 %616, 5
  %618 = getelementptr i8, ptr %611, i64 %617
  %619 = load ptr, ptr %618, align 8
  %620 = icmp ne ptr %619, @nil_typ
  %621 = icmp ne ptr %619, null
  %.not40.i.i127 = and i1 %620, %621
  br i1 %.not40.i.i127, label %622, label %._crit_edge.i1036.i

622:                                              ; preds = %.lr.ph.i1035.i
  %623 = getelementptr i8, ptr %618, i64 8
  %624 = load i64, ptr %623, align 4
  %.sroa_idx.i1037.i = getelementptr i8, ptr %618, i64 16
  %625 = load i64, ptr %.sroa_idx.i1037.i, align 4
  %626 = inttoptr i64 %624 to ptr
  %627 = inttoptr i64 %625 to ptr
  %hash_coef_ptr.i.i42.i.i128 = getelementptr i8, ptr %619, i64 8
  %tbl_size_ptr.i.i43.i.i129 = getelementptr i8, ptr %619, i64 16
  %offset_tbl_ptr.i.i44.i.i130 = getelementptr i8, ptr %619, i64 40
  %hash_coef.i.i45.i.i131 = load i64, ptr %hash_coef_ptr.i.i42.i.i128, align 4, !noalias !214
  %tbl_size.i.i46.i.i132 = load i64, ptr %tbl_size_ptr.i.i43.i.i129, align 4, !noalias !214
  %offset_tbl.i.i47.i.i133 = load ptr, ptr %offset_tbl_ptr.i.i44.i.i130, align 8, !noalias !214
  %product.i.i.i48.i.i134 = mul i64 %hash_coef.i.i45.i.i131, 4015701072841558310
  %shifted.i.i.i49.i.i135 = lshr i64 %product.i.i.i48.i.i134, 32
  %xored.i.i.i50.i.i136 = xor i64 %shifted.i.i.i49.i.i135, %product.i.i.i48.i.i134
  %hash.i.i.i51.i.i137 = and i64 %xored.i.i.i50.i.i136, %tbl_size.i.i46.i.i132
  %offset_ptr.i.i52.i.i138 = getelementptr i32, ptr %offset_tbl.i.i47.i.i133, i64 %hash.i.i.i51.i.i137
  %offset.i.i53.i.i139 = load i32, ptr %offset_ptr.i.i52.i.i138, align 4, !noalias !214
  %628 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %619, 0
  %629 = insertvalue { ptr, ptr, ptr, i32 } %628, ptr %626, 1
  %630 = insertvalue { ptr, ptr, ptr, i32 } %629, ptr %627, 2
  %631 = insertvalue { ptr, ptr, ptr, i32 } %630, i32 %offset.i.i53.i.i139, 3
  %632 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %633 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %619)
  %634 = sext i32 %offset.i.i53.i.i139 to i64
  %635 = getelementptr ptr, ptr %619, i64 %634
  %636 = getelementptr i8, ptr %635, i64 56
  %637 = load ptr, ptr %636, align 8
  %result.i55.i.i140 = call ptr %637({ ptr, ptr, ptr, i32 } %631, ptr nocapture nofree noundef nonnull readonly %0) #16
  %638 = call { ptr, i160 } %result.i55.i.i140({ ptr, ptr, ptr, i32 } %631, { ptr, ptr, ptr, i32 } %631, ptr nonnull align 8 %0) #7
  %.fca.0.extract29.i.i141 = extractvalue { ptr, i160 } %638, 0
  %639 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %640 = load ptr, ptr %578, align 8
  %641 = load ptr, ptr %640, align 8
  %642 = ptrtoint ptr %641 to i64
  %643 = getelementptr i8, ptr %.fca.0.extract29.i.i141, i64 8
  %644 = getelementptr i8, ptr %.fca.0.extract29.i.i141, i64 16
  %645 = getelementptr i8, ptr %.fca.0.extract29.i.i141, i64 24
  %646 = getelementptr i8, ptr %.fca.0.extract29.i.i141, i64 32
  %647 = load i64, ptr %643, align 4
  %648 = load i64, ptr %644, align 4
  %649 = load ptr, ptr %645, align 8
  %650 = load ptr, ptr %646, align 8
  %651 = load i64, ptr %641, align 4
  %result.i57.i.i142 = call i1 %649(i64 %648, i64 %647, i64 %651, i64 %642, ptr readonly %650) #5
  br i1 %result.i57.i.i142, label %652, label %._crit_edge.i1036.i

652:                                              ; preds = %622
  %653 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %654 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %619)
  %655 = getelementptr i8, ptr %635, i64 48
  %656 = load ptr, ptr %655, align 8
  %result.i58.i.i143 = call ptr %656({ ptr, ptr, ptr, i32 } %631, ptr nocapture nofree noundef nonnull readonly %0) #16
  %657 = call { ptr, i160 } %result.i58.i.i143({ ptr, ptr, ptr, i32 } %631, { ptr, ptr, ptr, i32 } %631, ptr nonnull align 8 %0) #7
  %658 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %659 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %619)
  %660 = getelementptr i8, ptr %635, i64 64
  %661 = load ptr, ptr %660, align 8
  %result.i59.i.i144 = call ptr %661({ ptr, ptr, ptr, i32 } %631, ptr nocapture nofree noundef nonnull readonly %0) #16
  %662 = call i32 %result.i59.i.i144({ ptr, ptr, ptr, i32 } %631, { ptr, ptr, ptr, i32 } %631, ptr nonnull align 8 %0) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %5)
  %663 = load ptr, ptr %result.i311.i, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %664 = load i32, ptr %586, align 8
  %665 = add i32 %664, -1
  %666 = and i32 %665, %662
  %667 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %668 = load ptr, ptr %585, align 8
  %669 = sext i32 %666 to i64
  %670 = shl nsw i64 %669, 5
  %671 = getelementptr i8, ptr %668, i64 %670
  %672 = load ptr, ptr %671, align 8
  %673 = icmp eq ptr %672, @nil_typ
  %674 = icmp eq ptr %672, null
  %675 = or i1 %673, %674
  br i1 %675, label %HashMap_find_slot_keyK_hashPtri32.exit1443.i, label %.lr.ph.i1419.i

.lr.ph.i1419.i:                                   ; preds = %652
  %676 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %677

677:                                              ; preds = %._crit_edge.thread.i1434.i, %.lr.ph.i1419.i
  %678 = phi i32 [ %666, %.lr.ph.i1419.i ], [ %720, %._crit_edge.thread.i1434.i ]
  %spec.store.select.i14391505.i = phi i32 [ -1, %.lr.ph.i1419.i ], [ %spec.store.select.i1439.i, %._crit_edge.thread.i1434.i ]
  %679 = phi ptr [ %672, %.lr.ph.i1419.i ], [ %725, %._crit_edge.thread.i1434.i ]
  %680 = phi ptr [ %671, %.lr.ph.i1419.i ], [ %724, %._crit_edge.thread.i1434.i ]
  %.sroa_idx.i1420.i = getelementptr i8, ptr %680, i64 16
  %681 = load i64, ptr %.sroa_idx.i1420.i, align 4
  %682 = getelementptr i8, ptr %680, i64 8
  %683 = load i64, ptr %682, align 4
  %684 = inttoptr i64 %683 to ptr
  %685 = inttoptr i64 %681 to ptr
  %hash_coef_ptr.i.i56.i1421.i = getelementptr i8, ptr %679, i64 8
  %tbl_size_ptr.i.i57.i1422.i = getelementptr i8, ptr %679, i64 16
  %offset_tbl_ptr.i.i58.i1423.i = getelementptr i8, ptr %679, i64 40
  %hash_coef.i.i59.i1424.i = load i64, ptr %hash_coef_ptr.i.i56.i1421.i, align 4
  %tbl_size.i.i60.i1425.i = load i64, ptr %tbl_size_ptr.i.i57.i1422.i, align 4
  %offset_tbl.i.i61.i1426.i = load ptr, ptr %offset_tbl_ptr.i.i58.i1423.i, align 8
  %product.i.i.i62.i1427.i = mul i64 %hash_coef.i.i59.i1424.i, 4015701072841558310
  %shifted.i.i.i63.i1428.i = lshr i64 %product.i.i.i62.i1427.i, 32
  %xored.i.i.i64.i1429.i = xor i64 %shifted.i.i.i63.i1428.i, %product.i.i.i62.i1427.i
  %hash.i.i.i65.i1430.i = and i64 %xored.i.i.i64.i1429.i, %tbl_size.i.i60.i1425.i
  %offset_ptr.i.i66.i1431.i = getelementptr i32, ptr %offset_tbl.i.i61.i1426.i, i64 %hash.i.i.i65.i1430.i
  %offset.i.i67.i1432.i = load i32, ptr %offset_ptr.i.i66.i1431.i, align 4
  %686 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %679, 0
  %687 = insertvalue { ptr, ptr, ptr, i32 } %686, ptr %684, 1
  %688 = insertvalue { ptr, ptr, ptr, i32 } %687, ptr %685, 2
  %689 = insertvalue { ptr, ptr, ptr, i32 } %688, i32 %offset.i.i67.i1432.i, 3
  %690 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %679)
  %691 = sext i32 %offset.i.i67.i1432.i to i64
  %692 = getelementptr ptr, ptr %679, i64 %691
  %693 = getelementptr i8, ptr %692, i64 64
  %694 = load ptr, ptr %693, align 8
  %result.i.i1433.i = call ptr %694({ ptr, ptr, ptr, i32 } %689, ptr nocapture nofree noundef nonnull readonly %0) #16
  %695 = call i32 %result.i.i1433.i({ ptr, ptr, ptr, i32 } %689, { ptr, ptr, ptr, i32 } %689, ptr nonnull align 8 %0) #7
  %696 = icmp eq i32 %695, %662
  br i1 %696, label %._crit_edge.i1441.i, label %._crit_edge.thread.i1434.i

._crit_edge.i1441.i:                              ; preds = %677
  %697 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %698 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %679)
  %699 = getelementptr i8, ptr %692, i64 48
  %700 = load ptr, ptr %699, align 8
  %result.i69.i1442.i = call ptr %700({ ptr, ptr, ptr, i32 } %689, ptr nocapture nofree noundef nonnull readonly %0) #16
  %701 = call { ptr, i160 } %result.i69.i1442.i({ ptr, ptr, ptr, i32 } %689, { ptr, ptr, ptr, i32 } %689, ptr nonnull align 8 %0) #7
  %702 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %703 = load ptr, ptr %584, align 8
  %704 = call i1 %703({ ptr, i160 } %701, { ptr, i160 } %657) #7
  br i1 %704, label %HashMap_find_slot_keyK_hashPtri32.exit1443.loopexit.i, label %._crit_edge.thread.i1434.i

._crit_edge.thread.i1434.i:                       ; preds = %._crit_edge.i1441.i, %677
  %705 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %706 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %679)
  %707 = getelementptr i8, ptr %692, i64 56
  %708 = load ptr, ptr %707, align 8
  %result.i70.i1435.i = call ptr %708({ ptr, ptr, ptr, i32 } %689, ptr nocapture nofree noundef nonnull readonly %0) #16
  %709 = call { ptr, i160 } %result.i70.i1435.i({ ptr, ptr, ptr, i32 } %689, { ptr, ptr, ptr, i32 } %689, ptr nonnull align 8 %0) #7
  %.fca.0.extract19.i1436.i = extractvalue { ptr, i160 } %709, 0
  %710 = getelementptr i8, ptr %.fca.0.extract19.i1436.i, i64 8
  %711 = getelementptr i8, ptr %.fca.0.extract19.i1436.i, i64 16
  %712 = getelementptr i8, ptr %.fca.0.extract19.i1436.i, i64 24
  %713 = getelementptr i8, ptr %.fca.0.extract19.i1436.i, i64 32
  %714 = load i64, ptr %710, align 4
  %715 = load i64, ptr %711, align 4
  %716 = load ptr, ptr %712, align 8
  %717 = load ptr, ptr %713, align 8
  %result.i71.i1437.i = call i1 %716(i64 %715, i64 %714, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %717) #5
  %718 = icmp eq i32 %spec.store.select.i14391505.i, -1
  %or.cond.i1438.i = select i1 %result.i71.i1437.i, i1 %718, i1 false
  %spec.store.select.i1439.i = select i1 %or.cond.i1438.i, i32 %678, i32 %spec.store.select.i14391505.i
  %719 = add i32 %678, 1
  %720 = and i32 %719, %665
  %721 = load ptr, ptr %585, align 8
  %722 = sext i32 %720 to i64
  %723 = shl nsw i64 %722, 5
  %724 = getelementptr i8, ptr %721, i64 %723
  %725 = load ptr, ptr %724, align 8
  %726 = icmp eq ptr %725, @nil_typ
  %727 = icmp eq ptr %725, null
  %728 = or i1 %726, %727
  br i1 %728, label %._crit_edge105.loopexit.i1440.i, label %677

._crit_edge105.loopexit.i1440.i:                  ; preds = %._crit_edge.thread.i1434.i
  %729 = icmp eq i32 %spec.store.select.i1439.i, -1
  %.pre.i.pre1540.i = select i1 %729, i32 %720, i32 %spec.store.select.i1439.i
  br label %HashMap_find_slot_keyK_hashPtri32.exit1443.i

HashMap_find_slot_keyK_hashPtri32.exit1443.loopexit.i: ; preds = %._crit_edge.i1441.i
  %.pre1598.i = load ptr, ptr %585, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit1443.i

HashMap_find_slot_keyK_hashPtri32.exit1443.i:     ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1443.loopexit.i, %._crit_edge105.loopexit.i1440.i, %652
  %730 = phi ptr [ %721, %._crit_edge105.loopexit.i1440.i ], [ %668, %652 ], [ %.pre1598.i, %HashMap_find_slot_keyK_hashPtri32.exit1443.loopexit.i ]
  %731 = phi i32 [ %.pre.i.pre1540.i, %._crit_edge105.loopexit.i1440.i ], [ %666, %652 ], [ %678, %HashMap_find_slot_keyK_hashPtri32.exit1443.loopexit.i ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %732 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %733 = sext i32 %731 to i64
  %734 = shl nsw i64 %733, 5
  %735 = getelementptr i8, ptr %730, i64 %734
  %736 = load ptr, ptr %735, align 8
  %737 = getelementptr i8, ptr %735, i64 8
  %738 = load i64, ptr %737, align 4
  %.sroa_idx.i1278.i = getelementptr i8, ptr %735, i64 16
  %739 = load i64, ptr %.sroa_idx.i1278.i, align 4
  %740 = load ptr, ptr %578, align 8
  %741 = load ptr, ptr %663, align 8, !alias.scope !217
  %742 = getelementptr i8, ptr %741, i64 72
  %743 = load ptr, ptr %742, align 8, !alias.scope !217
  %result.i.i.i1280.i = call { i64, i64 } %743(ptr nocapture nofree nonnull readonly %663) #5, !alias.scope !217
  %744 = extractvalue { i64, i64 } %result.i.i.i1280.i, 0
  %745 = extractvalue { i64, i64 } %result.i.i.i1280.i, 1
  %746 = call i64 @llvm.umax.i64(i64 %745, i64 8)
  %747 = urem i64 20, %745
  %748 = icmp eq i64 %747, 0
  %749 = sub i64 %745, %747
  %750 = select i1 %748, i64 0, i64 %749
  %751 = add i64 %744, 20
  %752 = add i64 %751, %750
  %753 = and i64 %752, 7
  %754 = icmp eq i64 %753, 0
  %755 = sub nuw nsw i64 40, %753
  %756 = select i1 %754, i64 32, i64 %755
  %757 = add i64 %756, %752
  %758 = urem i64 %757, %746
  %759 = icmp eq i64 %758, 0
  %760 = sub i64 %746, %758
  %761 = select i1 %759, i64 0, i64 %760
  %762 = add i64 %757, %761
  %result.i71.i1281.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %762, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %663, ptr %result.i71.i1281.i, align 8
  %763 = getelementptr inbounds i8, ptr %result.i71.i1281.i, i64 8
  store ptr %740, ptr %763, align 8
  %764 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i1281.i)
  %765 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %result.i71.i1281.i, 1
  %766 = insertvalue { ptr, ptr, ptr, i32 } %765, ptr undef, 2
  %767 = insertvalue { ptr, ptr, ptr, i32 } %766, i32 10, 3
  store ptr %663, ptr %5, align 8
  store ptr %740, ptr %592, align 8
  store ptr @_parameterization_Ptri32, ptr %593, align 8
  %768 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %5)
  %769 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Entry)
  %770 = load i64, ptr %643, align 4
  %771 = load i64, ptr %644, align 4
  %772 = load ptr, ptr %645, align 8
  %773 = load ptr, ptr %646, align 8
  %result.i.i117.i.i145 = call i1 %772(i64 %771, i64 %770, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %773) #5
  %774 = select i1 %result.i.i117.i.i145, i64 9, i64 10
  %gep.i146 = getelementptr [14 x ptr], ptr getelementptr inbounds (i8, ptr @Entry, i64 80), i64 0, i64 %774
  %775 = load ptr, ptr %gep.i146, align 8
  call void %775({ ptr, ptr, ptr, i32 } %767, { ptr, ptr, ptr, i32 } %767, ptr nonnull align 8 dereferenceable(24) %5, { ptr, i160 } %657, { ptr, i160 } %638, i32 %662) #7
  %776 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %777 = load ptr, ptr %585, align 8
  %778 = getelementptr i8, ptr %777, i64 %734
  store ptr @Entry, ptr %778, align 8
  %779 = getelementptr i8, ptr %778, i64 8
  %780 = ptrtoint ptr %result.i71.i1281.i to i64
  store i64 %780, ptr %779, align 4
  %.sroa_idx4.i1282.i = getelementptr i8, ptr %778, i64 24
  store i32 10, ptr %.sroa_idx4.i1282.i, align 4
  %781 = icmp eq ptr %736, @nil_typ
  %782 = icmp eq ptr %736, null
  %783 = or i1 %781, %782
  br i1 %783, label %784, label %787

784:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1443.i
  %785 = load i32, ptr %591, align 4
  %786 = add i32 %785, 1
  store i32 %786, ptr %591, align 4
  br label %._crit_edge.sink.split.i1299.i

787:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1443.i
  %788 = inttoptr i64 %738 to ptr
  %789 = inttoptr i64 %739 to ptr
  %hash_coef_ptr.i.i88.i1283.i = getelementptr i8, ptr %736, i64 8
  %tbl_size_ptr.i.i89.i1284.i = getelementptr i8, ptr %736, i64 16
  %offset_tbl_ptr.i.i90.i1285.i = getelementptr i8, ptr %736, i64 40
  %hash_coef.i.i91.i1286.i = load i64, ptr %hash_coef_ptr.i.i88.i1283.i, align 4, !noalias !220
  %tbl_size.i.i92.i1287.i = load i64, ptr %tbl_size_ptr.i.i89.i1284.i, align 4, !noalias !220
  %offset_tbl.i.i93.i1288.i = load ptr, ptr %offset_tbl_ptr.i.i90.i1285.i, align 8, !noalias !220
  %product.i.i.i94.i1289.i = mul i64 %hash_coef.i.i91.i1286.i, 4015701072841558310
  %shifted.i.i.i95.i1290.i = lshr i64 %product.i.i.i94.i1289.i, 32
  %xored.i.i.i96.i1291.i = xor i64 %shifted.i.i.i95.i1290.i, %product.i.i.i94.i1289.i
  %hash.i.i.i97.i1292.i = and i64 %xored.i.i.i96.i1291.i, %tbl_size.i.i92.i1287.i
  %offset_ptr.i.i98.i1293.i = getelementptr i32, ptr %offset_tbl.i.i93.i1288.i, i64 %hash.i.i.i97.i1292.i
  %offset.i.i99.i1294.i = load i32, ptr %offset_ptr.i.i98.i1293.i, align 4, !noalias !220
  %790 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %736, 0
  %791 = insertvalue { ptr, ptr, ptr, i32 } %790, ptr %788, 1
  %792 = insertvalue { ptr, ptr, ptr, i32 } %791, ptr %789, 2
  %793 = insertvalue { ptr, ptr, ptr, i32 } %792, i32 %offset.i.i99.i1294.i, 3
  %794 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %795 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %736)
  %796 = sext i32 %offset.i.i99.i1294.i to i64
  %797 = getelementptr ptr, ptr %736, i64 %796
  %798 = getelementptr i8, ptr %797, i64 56
  %799 = load ptr, ptr %798, align 8
  %result.i101.i1295.i = call ptr %799({ ptr, ptr, ptr, i32 } %793, ptr nocapture nofree noundef nonnull readonly %0) #16
  %800 = call { ptr, i160 } %result.i101.i1295.i({ ptr, ptr, ptr, i32 } %793, { ptr, ptr, ptr, i32 } %793, ptr nonnull align 8 %0) #7
  %.fca.0.extract51.i1296.i = extractvalue { ptr, i160 } %800, 0
  %801 = getelementptr i8, ptr %.fca.0.extract51.i1296.i, i64 8
  %802 = getelementptr i8, ptr %.fca.0.extract51.i1296.i, i64 16
  %803 = getelementptr i8, ptr %.fca.0.extract51.i1296.i, i64 24
  %804 = getelementptr i8, ptr %.fca.0.extract51.i1296.i, i64 32
  %805 = load i64, ptr %801, align 4
  %806 = load i64, ptr %802, align 4
  %807 = load ptr, ptr %803, align 8
  %808 = load ptr, ptr %804, align 8
  %result.i102.i1297.i = call i1 %807(i64 %806, i64 %805, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %808) #5
  br i1 %result.i102.i1297.i, label %._crit_edge.sink.split.i1299.i, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1301.i

._crit_edge.sink.split.i1299.i:                   ; preds = %787, %784
  %.sink159.i1300.i = phi i64 [ 48, %784 ], [ 40, %787 ]
  %809 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %810 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i1300.i
  %811 = load ptr, ptr %810, align 8
  %812 = load ptr, ptr %811, align 8
  %813 = call i32 %812(ptr nonnull %result.i311.i) #36
  %814 = add i32 %813, 1
  %815 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %816 = getelementptr i8, ptr %811, i64 8
  %817 = load ptr, ptr %816, align 8
  call void %817(ptr nonnull %result.i311.i, i32 %814) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1301.i

HashMap_insert_internal_keyK_valueV_hashPtri32.exit1301.i: ; preds = %._crit_edge.sink.split.i1299.i, %787
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %5)
  br label %._crit_edge.i1036.i

._crit_edge.i1036.i:                              ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1301.i, %622, %.lr.ph.i1035.i
  %818 = add nuw nsw i32 %.096.i.i126, 1
  %819 = icmp slt i32 %818, %604
  br i1 %819, label %.lr.ph.i1035.i, label %HashMap_resize_new_capacityPtri32.exit.i125

HashMap_resize_new_capacityPtri32.exit.i125:      ; preds = %._crit_edge.i1036.i, %._crit_edge1.i816.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  br label %HashMap_ensure_capacity_required_loadPtri32.exit.i35

HashMap_ensure_capacity_required_loadPtri32.exit.i35: ; preds = %HashMap_resize_new_capacityPtri32.exit.i125, %._crit_edge.i34
  %820 = load ptr, ptr %583, align 8
  %821 = call i32 %820({ ptr, i160 } %598) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %822 = load ptr, ptr %result.i311.i, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %823 = load i32, ptr %586, align 8
  %824 = add i32 %823, -1
  %825 = and i32 %824, %821
  %826 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %827 = load ptr, ptr %585, align 8
  %828 = sext i32 %825 to i64
  %829 = shl nsw i64 %828, 5
  %830 = getelementptr i8, ptr %827, i64 %829
  %831 = load ptr, ptr %830, align 8
  %832 = icmp eq ptr %831, @nil_typ
  %833 = icmp eq ptr %831, null
  %834 = or i1 %832, %833
  br i1 %834, label %HashMap_find_slot_keyK_hashPtri32.exit1073.i, label %.lr.ph.i1050.i

.lr.ph.i1050.i:                                   ; preds = %HashMap_ensure_capacity_required_loadPtri32.exit.i35
  %835 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %836

836:                                              ; preds = %._crit_edge.thread.i1065.i, %.lr.ph.i1050.i
  %837 = phi i32 [ %825, %.lr.ph.i1050.i ], [ %879, %._crit_edge.thread.i1065.i ]
  %spec.store.select.i10701195.i = phi i32 [ -1, %.lr.ph.i1050.i ], [ %spec.store.select.i1070.i, %._crit_edge.thread.i1065.i ]
  %838 = phi ptr [ %831, %.lr.ph.i1050.i ], [ %884, %._crit_edge.thread.i1065.i ]
  %839 = phi ptr [ %830, %.lr.ph.i1050.i ], [ %883, %._crit_edge.thread.i1065.i ]
  %.sroa_idx.i1051.i = getelementptr i8, ptr %839, i64 16
  %840 = load i64, ptr %.sroa_idx.i1051.i, align 4
  %841 = getelementptr i8, ptr %839, i64 8
  %842 = load i64, ptr %841, align 4
  %843 = inttoptr i64 %842 to ptr
  %844 = inttoptr i64 %840 to ptr
  %hash_coef_ptr.i.i56.i1052.i = getelementptr i8, ptr %838, i64 8
  %tbl_size_ptr.i.i57.i1053.i = getelementptr i8, ptr %838, i64 16
  %offset_tbl_ptr.i.i58.i1054.i = getelementptr i8, ptr %838, i64 40
  %hash_coef.i.i59.i1055.i = load i64, ptr %hash_coef_ptr.i.i56.i1052.i, align 4
  %tbl_size.i.i60.i1056.i = load i64, ptr %tbl_size_ptr.i.i57.i1053.i, align 4
  %offset_tbl.i.i61.i1057.i = load ptr, ptr %offset_tbl_ptr.i.i58.i1054.i, align 8
  %product.i.i.i62.i1058.i = mul i64 %hash_coef.i.i59.i1055.i, 4015701072841558310
  %shifted.i.i.i63.i1059.i = lshr i64 %product.i.i.i62.i1058.i, 32
  %xored.i.i.i64.i1060.i = xor i64 %shifted.i.i.i63.i1059.i, %product.i.i.i62.i1058.i
  %hash.i.i.i65.i1061.i = and i64 %xored.i.i.i64.i1060.i, %tbl_size.i.i60.i1056.i
  %offset_ptr.i.i66.i1062.i = getelementptr i32, ptr %offset_tbl.i.i61.i1057.i, i64 %hash.i.i.i65.i1061.i
  %offset.i.i67.i1063.i = load i32, ptr %offset_ptr.i.i66.i1062.i, align 4
  %845 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %838, 0
  %846 = insertvalue { ptr, ptr, ptr, i32 } %845, ptr %843, 1
  %847 = insertvalue { ptr, ptr, ptr, i32 } %846, ptr %844, 2
  %848 = insertvalue { ptr, ptr, ptr, i32 } %847, i32 %offset.i.i67.i1063.i, 3
  %849 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %838)
  %850 = sext i32 %offset.i.i67.i1063.i to i64
  %851 = getelementptr ptr, ptr %838, i64 %850
  %852 = getelementptr i8, ptr %851, i64 64
  %853 = load ptr, ptr %852, align 8
  %result.i.i1064.i = call ptr %853({ ptr, ptr, ptr, i32 } %848, ptr nocapture nofree noundef nonnull readonly %0) #16
  %854 = call i32 %result.i.i1064.i({ ptr, ptr, ptr, i32 } %848, { ptr, ptr, ptr, i32 } %848, ptr nonnull align 8 %0) #7
  %855 = icmp eq i32 %854, %821
  br i1 %855, label %._crit_edge.i1072.i, label %._crit_edge.thread.i1065.i

._crit_edge.i1072.i:                              ; preds = %836
  %856 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %857 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %838)
  %858 = getelementptr i8, ptr %851, i64 48
  %859 = load ptr, ptr %858, align 8
  %result.i69.i.i124 = call ptr %859({ ptr, ptr, ptr, i32 } %848, ptr nocapture nofree noundef nonnull readonly %0) #16
  %860 = call { ptr, i160 } %result.i69.i.i124({ ptr, ptr, ptr, i32 } %848, { ptr, ptr, ptr, i32 } %848, ptr nonnull align 8 %0) #7
  %861 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %862 = load ptr, ptr %584, align 8
  %863 = call i1 %862({ ptr, i160 } %860, { ptr, i160 } %598) #7
  br i1 %863, label %HashMap_find_slot_keyK_hashPtri32.exit1073.loopexit.i, label %._crit_edge.thread.i1065.i

._crit_edge.thread.i1065.i:                       ; preds = %._crit_edge.i1072.i, %836
  %864 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %865 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %838)
  %866 = getelementptr i8, ptr %851, i64 56
  %867 = load ptr, ptr %866, align 8
  %result.i70.i1066.i = call ptr %867({ ptr, ptr, ptr, i32 } %848, ptr nocapture nofree noundef nonnull readonly %0) #16
  %868 = call { ptr, i160 } %result.i70.i1066.i({ ptr, ptr, ptr, i32 } %848, { ptr, ptr, ptr, i32 } %848, ptr nonnull align 8 %0) #7
  %.fca.0.extract19.i1067.i = extractvalue { ptr, i160 } %868, 0
  %869 = getelementptr i8, ptr %.fca.0.extract19.i1067.i, i64 8
  %870 = getelementptr i8, ptr %.fca.0.extract19.i1067.i, i64 16
  %871 = getelementptr i8, ptr %.fca.0.extract19.i1067.i, i64 24
  %872 = getelementptr i8, ptr %.fca.0.extract19.i1067.i, i64 32
  %873 = load i64, ptr %869, align 4
  %874 = load i64, ptr %870, align 4
  %875 = load ptr, ptr %871, align 8
  %876 = load ptr, ptr %872, align 8
  %result.i71.i1068.i = call i1 %875(i64 %874, i64 %873, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %876) #5
  %877 = icmp eq i32 %spec.store.select.i10701195.i, -1
  %or.cond.i1069.i = select i1 %result.i71.i1068.i, i1 %877, i1 false
  %spec.store.select.i1070.i = select i1 %or.cond.i1069.i, i32 %837, i32 %spec.store.select.i10701195.i
  %878 = add i32 %837, 1
  %879 = and i32 %878, %824
  %880 = load ptr, ptr %585, align 8
  %881 = sext i32 %879 to i64
  %882 = shl nsw i64 %881, 5
  %883 = getelementptr i8, ptr %880, i64 %882
  %884 = load ptr, ptr %883, align 8
  %885 = icmp eq ptr %884, @nil_typ
  %886 = icmp eq ptr %884, null
  %887 = or i1 %885, %886
  br i1 %887, label %._crit_edge105.loopexit.i1071.i, label %836

._crit_edge105.loopexit.i1071.i:                  ; preds = %._crit_edge.thread.i1065.i
  %888 = icmp eq i32 %spec.store.select.i1070.i, -1
  %.pre.i.pre1221.i = select i1 %888, i32 %879, i32 %spec.store.select.i1070.i
  br label %HashMap_find_slot_keyK_hashPtri32.exit1073.i

HashMap_find_slot_keyK_hashPtri32.exit1073.loopexit.i: ; preds = %._crit_edge.i1072.i
  %.pre1264.i = load ptr, ptr %585, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit1073.i

HashMap_find_slot_keyK_hashPtri32.exit1073.i:     ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1073.loopexit.i, %._crit_edge105.loopexit.i1071.i, %HashMap_ensure_capacity_required_loadPtri32.exit.i35
  %889 = phi ptr [ %880, %._crit_edge105.loopexit.i1071.i ], [ %827, %HashMap_ensure_capacity_required_loadPtri32.exit.i35 ], [ %.pre1264.i, %HashMap_find_slot_keyK_hashPtri32.exit1073.loopexit.i ]
  %890 = phi i32 [ %.pre.i.pre1221.i, %._crit_edge105.loopexit.i1071.i ], [ %825, %HashMap_ensure_capacity_required_loadPtri32.exit.i35 ], [ %837, %HashMap_find_slot_keyK_hashPtri32.exit1073.loopexit.i ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %891 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %892 = sext i32 %890 to i64
  %893 = shl nsw i64 %892, 5
  %894 = getelementptr i8, ptr %889, i64 %893
  %895 = load ptr, ptr %894, align 8
  %896 = getelementptr i8, ptr %894, i64 8
  %897 = load i64, ptr %896, align 4
  %.sroa_idx.i833.i = getelementptr i8, ptr %894, i64 16
  %898 = load i64, ptr %.sroa_idx.i833.i, align 4
  %899 = load ptr, ptr %578, align 8
  %900 = load ptr, ptr %822, align 8, !alias.scope !223
  %901 = getelementptr i8, ptr %900, i64 72
  %902 = load ptr, ptr %901, align 8, !alias.scope !223
  %result.i.i.i.i36 = call { i64, i64 } %902(ptr nocapture nofree nonnull readonly %822) #5, !alias.scope !223
  %903 = extractvalue { i64, i64 } %result.i.i.i.i36, 0
  %904 = extractvalue { i64, i64 } %result.i.i.i.i36, 1
  %905 = call i64 @llvm.umax.i64(i64 %904, i64 8)
  %906 = urem i64 20, %904
  %907 = icmp eq i64 %906, 0
  %908 = sub i64 %904, %906
  %909 = select i1 %907, i64 0, i64 %908
  %910 = add i64 %903, 20
  %911 = add i64 %910, %909
  %912 = and i64 %911, 7
  %913 = icmp eq i64 %912, 0
  %914 = sub nuw nsw i64 40, %912
  %915 = select i1 %913, i64 32, i64 %914
  %916 = add i64 %915, %911
  %917 = urem i64 %916, %905
  %918 = icmp eq i64 %917, 0
  %919 = sub i64 %905, %917
  %920 = select i1 %918, i64 0, i64 %919
  %921 = add i64 %916, %920
  %result.i71.i.i37 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %921, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %822, ptr %result.i71.i.i37, align 8
  %922 = getelementptr inbounds i8, ptr %result.i71.i.i37, i64 8
  store ptr %899, ptr %922, align 8
  %923 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i.i37)
  %924 = load ptr, ptr %822, align 8
  %925 = getelementptr i8, ptr %924, i64 72
  %926 = load ptr, ptr %925, align 8
  %result.i.i1236.i = call { i64, i64 } %926(ptr nocapture nofree nonnull readonly %822) #5
  %927 = extractvalue { i64, i64 } %result.i.i1236.i, 1
  %928 = urem i64 20, %927
  %929 = icmp eq i64 %928, 0
  %reass.sub1613 = sub i64 %927, %928
  %930 = add i64 %reass.sub1613, 20
  %931 = select i1 %929, i64 20, i64 %930
  %932 = getelementptr i8, ptr %result.i71.i.i37, i64 %931
  %933 = getelementptr i8, ptr %924, i64 64
  %934 = load ptr, ptr %933, align 8
  call void %934({ ptr, i160 } %598, ptr nocapture nofree nonnull readonly %822, ptr nocapture nofree writeonly %932) #13
  %935 = load ptr, ptr %result.i71.i.i37, align 8
  %936 = load ptr, ptr %935, align 8
  %937 = getelementptr i8, ptr %936, i64 72
  %938 = load ptr, ptr %937, align 8
  %result.i.i1237.i = call { i64, i64 } %938(ptr nocapture nofree nonnull readonly %935) #5
  %939 = extractvalue { i64, i64 } %result.i.i1237.i, 0
  %940 = extractvalue { i64, i64 } %result.i.i1237.i, 1
  %941 = urem i64 20, %940
  %942 = icmp eq i64 %941, 0
  %943 = sub i64 %940, %941
  %944 = select i1 %942, i64 0, i64 %943
  %945 = add i64 %939, 20
  %946 = add i64 %945, %944
  %947 = and i64 %946, 7
  %948 = icmp eq i64 %947, 0
  %949 = sub nuw nsw i64 8, %947
  %950 = select i1 %948, i64 0, i64 %949
  %951 = getelementptr i8, ptr %result.i71.i.i37, i64 %946
  %952 = getelementptr i8, ptr %951, i64 %950
  store ptr @bool_typ, ptr %952, align 8
  %953 = getelementptr i8, ptr %952, i64 8
  store i160 %.sroa.0231.0.insert.ext.i, ptr %953, align 4
  %954 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @Entry) #34
  %955 = getelementptr inbounds i8, ptr %result.i71.i.i37, i64 16
  store i32 %821, ptr %955, align 8
  %956 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  store ptr @Entry, ptr %894, align 8
  %957 = ptrtoint ptr %result.i71.i.i37 to i64
  store i64 %957, ptr %896, align 4
  %.sroa_idx4.i.i38 = getelementptr i8, ptr %894, i64 24
  store i32 10, ptr %.sroa_idx4.i.i38, align 4
  %958 = icmp eq ptr %895, @nil_typ
  %959 = icmp eq ptr %895, null
  %960 = or i1 %958, %959
  br i1 %960, label %961, label %964

961:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1073.i
  %962 = load i32, ptr %591, align 4
  %963 = add i32 %962, 1
  store i32 %963, ptr %591, align 4
  br label %._crit_edge.sink.split.i.i122

964:                                              ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1073.i
  %965 = inttoptr i64 %897 to ptr
  %966 = inttoptr i64 %898 to ptr
  %hash_coef_ptr.i.i88.i.i39 = getelementptr i8, ptr %895, i64 8
  %tbl_size_ptr.i.i89.i.i40 = getelementptr i8, ptr %895, i64 16
  %offset_tbl_ptr.i.i90.i.i41 = getelementptr i8, ptr %895, i64 40
  %hash_coef.i.i91.i.i42 = load i64, ptr %hash_coef_ptr.i.i88.i.i39, align 4, !noalias !226
  %tbl_size.i.i92.i.i43 = load i64, ptr %tbl_size_ptr.i.i89.i.i40, align 4, !noalias !226
  %offset_tbl.i.i93.i.i44 = load ptr, ptr %offset_tbl_ptr.i.i90.i.i41, align 8, !noalias !226
  %product.i.i.i94.i.i45 = mul i64 %hash_coef.i.i91.i.i42, 4015701072841558310
  %shifted.i.i.i95.i.i46 = lshr i64 %product.i.i.i94.i.i45, 32
  %xored.i.i.i96.i.i47 = xor i64 %shifted.i.i.i95.i.i46, %product.i.i.i94.i.i45
  %hash.i.i.i97.i.i48 = and i64 %xored.i.i.i96.i.i47, %tbl_size.i.i92.i.i43
  %offset_ptr.i.i98.i.i49 = getelementptr i32, ptr %offset_tbl.i.i93.i.i44, i64 %hash.i.i.i97.i.i48
  %offset.i.i99.i.i50 = load i32, ptr %offset_ptr.i.i98.i.i49, align 4, !noalias !226
  %967 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %895, 0
  %968 = insertvalue { ptr, ptr, ptr, i32 } %967, ptr %965, 1
  %969 = insertvalue { ptr, ptr, ptr, i32 } %968, ptr %966, 2
  %970 = insertvalue { ptr, ptr, ptr, i32 } %969, i32 %offset.i.i99.i.i50, 3
  %971 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %972 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %895)
  %973 = sext i32 %offset.i.i99.i.i50 to i64
  %974 = getelementptr ptr, ptr %895, i64 %973
  %975 = getelementptr i8, ptr %974, i64 56
  %976 = load ptr, ptr %975, align 8
  %result.i101.i.i51 = call ptr %976({ ptr, ptr, ptr, i32 } %970, ptr nocapture nofree noundef nonnull readonly %0) #16
  %977 = call { ptr, i160 } %result.i101.i.i51({ ptr, ptr, ptr, i32 } %970, { ptr, ptr, ptr, i32 } %970, ptr nonnull align 8 %0) #7
  %.fca.0.extract51.i835.i = extractvalue { ptr, i160 } %977, 0
  %978 = getelementptr i8, ptr %.fca.0.extract51.i835.i, i64 8
  %979 = getelementptr i8, ptr %.fca.0.extract51.i835.i, i64 16
  %980 = getelementptr i8, ptr %.fca.0.extract51.i835.i, i64 24
  %981 = getelementptr i8, ptr %.fca.0.extract51.i835.i, i64 32
  %982 = load i64, ptr %978, align 4
  %983 = load i64, ptr %979, align 4
  %984 = load ptr, ptr %980, align 8
  %985 = load ptr, ptr %981, align 8
  %result.i102.i.i52 = call i1 %984(i64 %983, i64 %982, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %985) #5
  br i1 %result.i102.i.i52, label %._crit_edge.sink.split.i.i122, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit.i53

._crit_edge.sink.split.i.i122:                    ; preds = %964, %961
  %.sink159.i.i123 = phi i64 [ 48, %961 ], [ 40, %964 ]
  %986 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %987 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i.i123
  %988 = load ptr, ptr %987, align 8
  %989 = load ptr, ptr %988, align 8
  %990 = call i32 %989(ptr nonnull %result.i311.i) #36
  %991 = add i32 %990, 1
  %992 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %993 = getelementptr i8, ptr %988, i64 8
  %994 = load ptr, ptr %993, align 8
  call void %994(ptr nonnull %result.i311.i, i32 %991) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit.i53

HashMap_insert_internal_keyK_valueV_hashPtri32.exit.i53: ; preds = %._crit_edge.sink.split.i.i122, %964
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %995 = add nuw nsw i32 %.0247472.i, 1
  %996 = icmp ult i32 %.0247472.i, 999999
  br i1 %996, label %._crit_edge.i34, label %._crit_edge2._crit_edge.i

._crit_edge2._crit_edge.i:                        ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit.i53
  %997 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %998 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #34
  %999 = load i32, ptr %591, align 4
  %1000 = call i64 @clock()
  %1001 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  %1002 = getelementptr inbounds i8, ptr %result.i268.i, i64 40
  %1003 = getelementptr inbounds i8, ptr %result.i268.i, i64 36
  %1004 = getelementptr inbounds i8, ptr %4, i64 8
  %1005 = getelementptr inbounds i8, ptr %4, i64 16
  br label %._crit_edge3.i54

._crit_edge3.i54:                                 ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit901.i, %._crit_edge2._crit_edge.i
  %.2249474.i = phi i32 [ %1404, %HashMap_insert_internal_keyK_valueV_hashPtri32.exit901.i ], [ 0, %._crit_edge2._crit_edge.i ]
  %1006 = zext nneg i32 %.2249474.i to i64
  %1007 = shl nuw nsw i64 %1006, 2
  %1008 = getelementptr i8, ptr %result.i4.i.i, i64 %1007
  %1009 = load i32, ptr %1008, align 1
  %.sroa.2.sroa.0.0.insert.ext.i.i = zext i32 %1009 to i160
  %1010 = add i32 %1009, 1
  %1011 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i.i, 1
  %.sroa.0211.0.insert.ext.i = zext i32 %1010 to i160
  %1012 = load i32, ptr %1002, align 8
  %1013 = load i32, ptr %577, align 8
  %1014 = icmp eq i32 %1013, 0
  %1015 = mul i32 %1012, 10
  %1016 = add i32 %1015, 10
  %1017 = mul i32 %1013, 6
  %1018 = icmp sge i32 %1016, %1017
  %.0.i850.i = select i1 %1014, i1 true, i1 %1018
  br i1 %.0.i850.i, label %._crit_edge1.i852.i, label %HashMap_ensure_capacity_required_loadPtri32.exit856.i

._crit_edge1.i852.i:                              ; preds = %._crit_edge3.i54
  %1019 = shl i32 %1013, 1
  %spec.select.i854.i = call i32 @llvm.smax.i32(i32 %1019, i32 16)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1020 = load ptr, ptr %576, align 8
  %1021 = zext nneg i32 %spec.select.i854.i to i64
  %1022 = shl nuw nsw i64 %1021, 5
  %result.i.i1101.i = call noalias ptr @bump_malloc_inner(i64 noundef %1022, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1101.i, ptr %576, align 8
  store i32 %spec.select.i854.i, ptr %577, align 8
  store i32 0, ptr %1003, align 4
  %1023 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #38
  store i32 0, ptr %1002, align 8
  %1024 = icmp sgt i32 %1013, 0
  br i1 %1024, label %.lr.ph.i1102.i, label %HashMap_resize_new_capacityPtri32.exit1128.i

.lr.ph.i1102.i:                                   ; preds = %._crit_edge1.i852.i, %._crit_edge.i1105.i
  %.096.i1103.i = phi i32 [ %1227, %._crit_edge.i1105.i ], [ 0, %._crit_edge1.i852.i ]
  %1025 = zext nneg i32 %.096.i1103.i to i64
  %1026 = shl nuw nsw i64 %1025, 5
  %1027 = getelementptr i8, ptr %1020, i64 %1026
  %1028 = load ptr, ptr %1027, align 8
  %1029 = icmp ne ptr %1028, @nil_typ
  %1030 = icmp ne ptr %1028, null
  %.not40.i1104.i = and i1 %1029, %1030
  br i1 %.not40.i1104.i, label %1031, label %._crit_edge.i1105.i

1031:                                             ; preds = %.lr.ph.i1102.i
  %1032 = getelementptr i8, ptr %1027, i64 8
  %1033 = load i64, ptr %1032, align 4
  %.sroa_idx.i1106.i = getelementptr i8, ptr %1027, i64 16
  %1034 = load i64, ptr %.sroa_idx.i1106.i, align 4
  %1035 = inttoptr i64 %1033 to ptr
  %1036 = inttoptr i64 %1034 to ptr
  %hash_coef_ptr.i.i42.i1107.i = getelementptr i8, ptr %1028, i64 8
  %tbl_size_ptr.i.i43.i1108.i = getelementptr i8, ptr %1028, i64 16
  %offset_tbl_ptr.i.i44.i1109.i = getelementptr i8, ptr %1028, i64 40
  %hash_coef.i.i45.i1110.i = load i64, ptr %hash_coef_ptr.i.i42.i1107.i, align 4, !noalias !229
  %tbl_size.i.i46.i1111.i = load i64, ptr %tbl_size_ptr.i.i43.i1108.i, align 4, !noalias !229
  %offset_tbl.i.i47.i1112.i = load ptr, ptr %offset_tbl_ptr.i.i44.i1109.i, align 8, !noalias !229
  %product.i.i.i48.i1113.i = mul i64 %hash_coef.i.i45.i1110.i, 4015701072841558310
  %shifted.i.i.i49.i1114.i = lshr i64 %product.i.i.i48.i1113.i, 32
  %xored.i.i.i50.i1115.i = xor i64 %shifted.i.i.i49.i1114.i, %product.i.i.i48.i1113.i
  %hash.i.i.i51.i1116.i = and i64 %xored.i.i.i50.i1115.i, %tbl_size.i.i46.i1111.i
  %offset_ptr.i.i52.i1117.i = getelementptr i32, ptr %offset_tbl.i.i47.i1112.i, i64 %hash.i.i.i51.i1116.i
  %offset.i.i53.i1118.i = load i32, ptr %offset_ptr.i.i52.i1117.i, align 4, !noalias !229
  %1037 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1028, 0
  %1038 = insertvalue { ptr, ptr, ptr, i32 } %1037, ptr %1035, 1
  %1039 = insertvalue { ptr, ptr, ptr, i32 } %1038, ptr %1036, 2
  %1040 = insertvalue { ptr, ptr, ptr, i32 } %1039, i32 %offset.i.i53.i1118.i, 3
  %1041 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1042 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1028)
  %1043 = sext i32 %offset.i.i53.i1118.i to i64
  %1044 = getelementptr ptr, ptr %1028, i64 %1043
  %1045 = getelementptr i8, ptr %1044, i64 56
  %1046 = load ptr, ptr %1045, align 8
  %result.i55.i1119.i = call ptr %1046({ ptr, ptr, ptr, i32 } %1040, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1047 = call { ptr, i160 } %result.i55.i1119.i({ ptr, ptr, ptr, i32 } %1040, { ptr, ptr, ptr, i32 } %1040, ptr nonnull align 8 %0) #7
  %.fca.0.extract29.i1120.i = extractvalue { ptr, i160 } %1047, 0
  %1048 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1049 = load ptr, ptr %569, align 8
  %1050 = load ptr, ptr %1049, align 8
  %1051 = ptrtoint ptr %1050 to i64
  %1052 = getelementptr i8, ptr %.fca.0.extract29.i1120.i, i64 8
  %1053 = getelementptr i8, ptr %.fca.0.extract29.i1120.i, i64 16
  %1054 = getelementptr i8, ptr %.fca.0.extract29.i1120.i, i64 24
  %1055 = getelementptr i8, ptr %.fca.0.extract29.i1120.i, i64 32
  %1056 = load i64, ptr %1052, align 4
  %1057 = load i64, ptr %1053, align 4
  %1058 = load ptr, ptr %1054, align 8
  %1059 = load ptr, ptr %1055, align 8
  %1060 = load i64, ptr %1050, align 4
  %result.i57.i1122.i = call i1 %1058(i64 %1057, i64 %1056, i64 %1060, i64 %1051, ptr readonly %1059) #5
  br i1 %result.i57.i1122.i, label %1061, label %._crit_edge.i1105.i

1061:                                             ; preds = %1031
  %1062 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1063 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1028)
  %1064 = getelementptr i8, ptr %1044, i64 48
  %1065 = load ptr, ptr %1064, align 8
  %result.i58.i1123.i = call ptr %1065({ ptr, ptr, ptr, i32 } %1040, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1066 = call { ptr, i160 } %result.i58.i1123.i({ ptr, ptr, ptr, i32 } %1040, { ptr, ptr, ptr, i32 } %1040, ptr nonnull align 8 %0) #7
  %1067 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1068 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1028)
  %1069 = getelementptr i8, ptr %1044, i64 64
  %1070 = load ptr, ptr %1069, align 8
  %result.i59.i1125.i = call ptr %1070({ ptr, ptr, ptr, i32 } %1040, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1071 = call i32 %result.i59.i1125.i({ ptr, ptr, ptr, i32 } %1040, { ptr, ptr, ptr, i32 } %1040, ptr nonnull align 8 %0) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %4)
  %1072 = load ptr, ptr %result.i268.i, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1073 = load i32, ptr %577, align 8
  %1074 = add i32 %1073, -1
  %1075 = and i32 %1074, %1071
  %1076 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1077 = load ptr, ptr %576, align 8
  %1078 = sext i32 %1075 to i64
  %1079 = shl nsw i64 %1078, 5
  %1080 = getelementptr i8, ptr %1077, i64 %1079
  %1081 = load ptr, ptr %1080, align 8
  %1082 = icmp eq ptr %1081, @nil_typ
  %1083 = icmp eq ptr %1081, null
  %1084 = or i1 %1082, %1083
  br i1 %1084, label %HashMap_find_slot_keyK_hashPtri32.exit1488.i, label %.lr.ph.i1458.i

.lr.ph.i1458.i:                                   ; preds = %1061
  %1085 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %1086

1086:                                             ; preds = %._crit_edge.thread.i1474.i, %.lr.ph.i1458.i
  %1087 = phi i32 [ %1075, %.lr.ph.i1458.i ], [ %1129, %._crit_edge.thread.i1474.i ]
  %spec.store.select.i14791511.i = phi i32 [ -1, %.lr.ph.i1458.i ], [ %spec.store.select.i1479.i, %._crit_edge.thread.i1474.i ]
  %1088 = phi ptr [ %1081, %.lr.ph.i1458.i ], [ %1134, %._crit_edge.thread.i1474.i ]
  %1089 = phi ptr [ %1080, %.lr.ph.i1458.i ], [ %1133, %._crit_edge.thread.i1474.i ]
  %.sroa_idx.i1460.i = getelementptr i8, ptr %1089, i64 16
  %1090 = load i64, ptr %.sroa_idx.i1460.i, align 4
  %1091 = getelementptr i8, ptr %1089, i64 8
  %1092 = load i64, ptr %1091, align 4
  %1093 = inttoptr i64 %1092 to ptr
  %1094 = inttoptr i64 %1090 to ptr
  %hash_coef_ptr.i.i56.i1461.i = getelementptr i8, ptr %1088, i64 8
  %tbl_size_ptr.i.i57.i1462.i = getelementptr i8, ptr %1088, i64 16
  %offset_tbl_ptr.i.i58.i1463.i = getelementptr i8, ptr %1088, i64 40
  %hash_coef.i.i59.i1464.i = load i64, ptr %hash_coef_ptr.i.i56.i1461.i, align 4
  %tbl_size.i.i60.i1465.i = load i64, ptr %tbl_size_ptr.i.i57.i1462.i, align 4
  %offset_tbl.i.i61.i1466.i = load ptr, ptr %offset_tbl_ptr.i.i58.i1463.i, align 8
  %product.i.i.i62.i1467.i = mul i64 %hash_coef.i.i59.i1464.i, 4015701072841558310
  %shifted.i.i.i63.i1468.i = lshr i64 %product.i.i.i62.i1467.i, 32
  %xored.i.i.i64.i1469.i = xor i64 %shifted.i.i.i63.i1468.i, %product.i.i.i62.i1467.i
  %hash.i.i.i65.i1470.i = and i64 %xored.i.i.i64.i1469.i, %tbl_size.i.i60.i1465.i
  %offset_ptr.i.i66.i1471.i = getelementptr i32, ptr %offset_tbl.i.i61.i1466.i, i64 %hash.i.i.i65.i1470.i
  %offset.i.i67.i1472.i = load i32, ptr %offset_ptr.i.i66.i1471.i, align 4
  %1095 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1088, 0
  %1096 = insertvalue { ptr, ptr, ptr, i32 } %1095, ptr %1093, 1
  %1097 = insertvalue { ptr, ptr, ptr, i32 } %1096, ptr %1094, 2
  %1098 = insertvalue { ptr, ptr, ptr, i32 } %1097, i32 %offset.i.i67.i1472.i, 3
  %1099 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1088)
  %1100 = sext i32 %offset.i.i67.i1472.i to i64
  %1101 = getelementptr ptr, ptr %1088, i64 %1100
  %1102 = getelementptr i8, ptr %1101, i64 64
  %1103 = load ptr, ptr %1102, align 8
  %result.i.i1473.i = call ptr %1103({ ptr, ptr, ptr, i32 } %1098, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1104 = call i32 %result.i.i1473.i({ ptr, ptr, ptr, i32 } %1098, { ptr, ptr, ptr, i32 } %1098, ptr nonnull align 8 %0) #7
  %1105 = icmp eq i32 %1104, %1071
  br i1 %1105, label %._crit_edge.i1485.i, label %._crit_edge.thread.i1474.i

._crit_edge.i1485.i:                              ; preds = %1086
  %1106 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1107 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1088)
  %1108 = getelementptr i8, ptr %1101, i64 48
  %1109 = load ptr, ptr %1108, align 8
  %result.i69.i1486.i = call ptr %1109({ ptr, ptr, ptr, i32 } %1098, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1110 = call { ptr, i160 } %result.i69.i1486.i({ ptr, ptr, ptr, i32 } %1098, { ptr, ptr, ptr, i32 } %1098, ptr nonnull align 8 %0) #7
  %1111 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1112 = load ptr, ptr %575, align 8
  %1113 = call i1 %1112({ ptr, i160 } %1110, { ptr, i160 } %1066) #7
  br i1 %1113, label %HashMap_find_slot_keyK_hashPtri32.exit1488.loopexit.i, label %._crit_edge.thread.i1474.i

._crit_edge.thread.i1474.i:                       ; preds = %._crit_edge.i1485.i, %1086
  %1114 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1115 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1088)
  %1116 = getelementptr i8, ptr %1101, i64 56
  %1117 = load ptr, ptr %1116, align 8
  %result.i70.i1475.i = call ptr %1117({ ptr, ptr, ptr, i32 } %1098, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1118 = call { ptr, i160 } %result.i70.i1475.i({ ptr, ptr, ptr, i32 } %1098, { ptr, ptr, ptr, i32 } %1098, ptr nonnull align 8 %0) #7
  %.fca.0.extract19.i1476.i = extractvalue { ptr, i160 } %1118, 0
  %1119 = getelementptr i8, ptr %.fca.0.extract19.i1476.i, i64 8
  %1120 = getelementptr i8, ptr %.fca.0.extract19.i1476.i, i64 16
  %1121 = getelementptr i8, ptr %.fca.0.extract19.i1476.i, i64 24
  %1122 = getelementptr i8, ptr %.fca.0.extract19.i1476.i, i64 32
  %1123 = load i64, ptr %1119, align 4
  %1124 = load i64, ptr %1120, align 4
  %1125 = load ptr, ptr %1121, align 8
  %1126 = load ptr, ptr %1122, align 8
  %result.i71.i1477.i = call i1 %1125(i64 %1124, i64 %1123, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %1126) #5
  %1127 = icmp eq i32 %spec.store.select.i14791511.i, -1
  %or.cond.i1478.i = select i1 %result.i71.i1477.i, i1 %1127, i1 false
  %spec.store.select.i1479.i = select i1 %or.cond.i1478.i, i32 %1087, i32 %spec.store.select.i14791511.i
  %1128 = add i32 %1087, 1
  %1129 = and i32 %1128, %1074
  %1130 = load ptr, ptr %576, align 8
  %1131 = sext i32 %1129 to i64
  %1132 = shl nsw i64 %1131, 5
  %1133 = getelementptr i8, ptr %1130, i64 %1132
  %1134 = load ptr, ptr %1133, align 8
  %1135 = icmp eq ptr %1134, @nil_typ
  %1136 = icmp eq ptr %1134, null
  %1137 = or i1 %1135, %1136
  br i1 %1137, label %._crit_edge105.loopexit.i1481.i, label %1086

._crit_edge105.loopexit.i1481.i:                  ; preds = %._crit_edge.thread.i1474.i
  %1138 = icmp eq i32 %spec.store.select.i1479.i, -1
  %.pre.i1484.pre.i = select i1 %1138, i32 %1129, i32 %spec.store.select.i1479.i
  br label %HashMap_find_slot_keyK_hashPtri32.exit1488.i

HashMap_find_slot_keyK_hashPtri32.exit1488.loopexit.i: ; preds = %._crit_edge.i1485.i
  %.pre1599.i = load ptr, ptr %576, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit1488.i

HashMap_find_slot_keyK_hashPtri32.exit1488.i:     ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1488.loopexit.i, %._crit_edge105.loopexit.i1481.i, %1061
  %1139 = phi ptr [ %1130, %._crit_edge105.loopexit.i1481.i ], [ %1077, %1061 ], [ %.pre1599.i, %HashMap_find_slot_keyK_hashPtri32.exit1488.loopexit.i ]
  %1140 = phi i32 [ %.pre.i1484.pre.i, %._crit_edge105.loopexit.i1481.i ], [ %1075, %1061 ], [ %1087, %HashMap_find_slot_keyK_hashPtri32.exit1488.loopexit.i ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %1141 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1142 = sext i32 %1140 to i64
  %1143 = shl nsw i64 %1142, 5
  %1144 = getelementptr i8, ptr %1139, i64 %1143
  %1145 = load ptr, ptr %1144, align 8
  %1146 = getelementptr i8, ptr %1144, i64 8
  %1147 = load i64, ptr %1146, align 4
  %.sroa_idx.i1321.i = getelementptr i8, ptr %1144, i64 16
  %1148 = load i64, ptr %.sroa_idx.i1321.i, align 4
  %1149 = load ptr, ptr %569, align 8
  %1150 = load ptr, ptr %1072, align 8, !alias.scope !232
  %1151 = getelementptr i8, ptr %1150, i64 72
  %1152 = load ptr, ptr %1151, align 8, !alias.scope !232
  %result.i.i.i1323.i = call { i64, i64 } %1152(ptr nocapture nofree nonnull readonly %1072) #5, !alias.scope !232
  %1153 = extractvalue { i64, i64 } %result.i.i.i1323.i, 0
  %1154 = extractvalue { i64, i64 } %result.i.i.i1323.i, 1
  %1155 = call i64 @llvm.umax.i64(i64 %1154, i64 8)
  %1156 = urem i64 20, %1154
  %1157 = icmp eq i64 %1156, 0
  %1158 = sub i64 %1154, %1156
  %1159 = select i1 %1157, i64 0, i64 %1158
  %1160 = add i64 %1153, 20
  %1161 = add i64 %1160, %1159
  %1162 = and i64 %1161, 7
  %1163 = icmp eq i64 %1162, 0
  %1164 = sub nuw nsw i64 40, %1162
  %1165 = select i1 %1163, i64 32, i64 %1164
  %1166 = add i64 %1165, %1161
  %1167 = urem i64 %1166, %1155
  %1168 = icmp eq i64 %1167, 0
  %1169 = sub i64 %1155, %1167
  %1170 = select i1 %1168, i64 0, i64 %1169
  %1171 = add i64 %1166, %1170
  %result.i71.i1324.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1171, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %1072, ptr %result.i71.i1324.i, align 8
  %1172 = getelementptr inbounds i8, ptr %result.i71.i1324.i, i64 8
  store ptr %1149, ptr %1172, align 8
  %1173 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i1324.i)
  %1174 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %result.i71.i1324.i, 1
  %1175 = insertvalue { ptr, ptr, ptr, i32 } %1174, ptr undef, 2
  %1176 = insertvalue { ptr, ptr, ptr, i32 } %1175, i32 10, 3
  store ptr %1072, ptr %4, align 8
  store ptr %1149, ptr %1004, align 8
  store ptr @_parameterization_Ptri32, ptr %1005, align 8
  %1177 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %4)
  %1178 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Entry)
  %1179 = load i64, ptr %1052, align 4
  %1180 = load i64, ptr %1053, align 4
  %1181 = load ptr, ptr %1054, align 8
  %1182 = load ptr, ptr %1055, align 8
  %result.i.i117.i1325.i = call i1 %1181(i64 %1180, i64 %1179, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %1182) #5
  %1183 = select i1 %result.i.i117.i1325.i, i64 9, i64 10
  %gep1359.i = getelementptr [14 x ptr], ptr getelementptr inbounds (i8, ptr @Entry, i64 80), i64 0, i64 %1183
  %1184 = load ptr, ptr %gep1359.i, align 8
  call void %1184({ ptr, ptr, ptr, i32 } %1176, { ptr, ptr, ptr, i32 } %1176, ptr nonnull align 8 dereferenceable(24) %4, { ptr, i160 } %1066, { ptr, i160 } %1047, i32 %1071) #7
  %1185 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1186 = load ptr, ptr %576, align 8
  %1187 = getelementptr i8, ptr %1186, i64 %1143
  store ptr @Entry, ptr %1187, align 8
  %1188 = getelementptr i8, ptr %1187, i64 8
  %1189 = ptrtoint ptr %result.i71.i1324.i to i64
  store i64 %1189, ptr %1188, align 4
  %.sroa_idx4.i1327.i = getelementptr i8, ptr %1187, i64 24
  store i32 10, ptr %.sroa_idx4.i1327.i, align 4
  %1190 = icmp eq ptr %1145, @nil_typ
  %1191 = icmp eq ptr %1145, null
  %1192 = or i1 %1190, %1191
  br i1 %1192, label %1193, label %1196

1193:                                             ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1488.i
  %1194 = load i32, ptr %1003, align 4
  %1195 = add i32 %1194, 1
  store i32 %1195, ptr %1003, align 4
  br label %._crit_edge.sink.split.i1344.i

1196:                                             ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1488.i
  %1197 = inttoptr i64 %1147 to ptr
  %1198 = inttoptr i64 %1148 to ptr
  %hash_coef_ptr.i.i88.i1328.i = getelementptr i8, ptr %1145, i64 8
  %tbl_size_ptr.i.i89.i1329.i = getelementptr i8, ptr %1145, i64 16
  %offset_tbl_ptr.i.i90.i1330.i = getelementptr i8, ptr %1145, i64 40
  %hash_coef.i.i91.i1331.i = load i64, ptr %hash_coef_ptr.i.i88.i1328.i, align 4, !noalias !235
  %tbl_size.i.i92.i1332.i = load i64, ptr %tbl_size_ptr.i.i89.i1329.i, align 4, !noalias !235
  %offset_tbl.i.i93.i1333.i = load ptr, ptr %offset_tbl_ptr.i.i90.i1330.i, align 8, !noalias !235
  %product.i.i.i94.i1334.i = mul i64 %hash_coef.i.i91.i1331.i, 4015701072841558310
  %shifted.i.i.i95.i1335.i = lshr i64 %product.i.i.i94.i1334.i, 32
  %xored.i.i.i96.i1336.i = xor i64 %shifted.i.i.i95.i1335.i, %product.i.i.i94.i1334.i
  %hash.i.i.i97.i1337.i = and i64 %xored.i.i.i96.i1336.i, %tbl_size.i.i92.i1332.i
  %offset_ptr.i.i98.i1338.i = getelementptr i32, ptr %offset_tbl.i.i93.i1333.i, i64 %hash.i.i.i97.i1337.i
  %offset.i.i99.i1339.i = load i32, ptr %offset_ptr.i.i98.i1338.i, align 4, !noalias !235
  %1199 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1145, 0
  %1200 = insertvalue { ptr, ptr, ptr, i32 } %1199, ptr %1197, 1
  %1201 = insertvalue { ptr, ptr, ptr, i32 } %1200, ptr %1198, 2
  %1202 = insertvalue { ptr, ptr, ptr, i32 } %1201, i32 %offset.i.i99.i1339.i, 3
  %1203 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1204 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1145)
  %1205 = sext i32 %offset.i.i99.i1339.i to i64
  %1206 = getelementptr ptr, ptr %1145, i64 %1205
  %1207 = getelementptr i8, ptr %1206, i64 56
  %1208 = load ptr, ptr %1207, align 8
  %result.i101.i1340.i = call ptr %1208({ ptr, ptr, ptr, i32 } %1202, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1209 = call { ptr, i160 } %result.i101.i1340.i({ ptr, ptr, ptr, i32 } %1202, { ptr, ptr, ptr, i32 } %1202, ptr nonnull align 8 %0) #7
  %.fca.0.extract51.i1341.i = extractvalue { ptr, i160 } %1209, 0
  %1210 = getelementptr i8, ptr %.fca.0.extract51.i1341.i, i64 8
  %1211 = getelementptr i8, ptr %.fca.0.extract51.i1341.i, i64 16
  %1212 = getelementptr i8, ptr %.fca.0.extract51.i1341.i, i64 24
  %1213 = getelementptr i8, ptr %.fca.0.extract51.i1341.i, i64 32
  %1214 = load i64, ptr %1210, align 4
  %1215 = load i64, ptr %1211, align 4
  %1216 = load ptr, ptr %1212, align 8
  %1217 = load ptr, ptr %1213, align 8
  %result.i102.i1342.i = call i1 %1216(i64 %1215, i64 %1214, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %1217) #5
  br i1 %result.i102.i1342.i, label %._crit_edge.sink.split.i1344.i, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1346.i

._crit_edge.sink.split.i1344.i:                   ; preds = %1196, %1193
  %.sink159.i1345.i = phi i64 [ 48, %1193 ], [ 40, %1196 ]
  %1218 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1219 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i1345.i
  %1220 = load ptr, ptr %1219, align 8
  %1221 = load ptr, ptr %1220, align 8
  %1222 = call i32 %1221(ptr nonnull %result.i268.i) #36
  %1223 = add i32 %1222, 1
  %1224 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1225 = getelementptr i8, ptr %1220, i64 8
  %1226 = load ptr, ptr %1225, align 8
  call void %1226(ptr nonnull %result.i268.i, i32 %1223) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1346.i

HashMap_insert_internal_keyK_valueV_hashPtri32.exit1346.i: ; preds = %._crit_edge.sink.split.i1344.i, %1196
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %4)
  br label %._crit_edge.i1105.i

._crit_edge.i1105.i:                              ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1346.i, %1031, %.lr.ph.i1102.i
  %1227 = add nuw nsw i32 %.096.i1103.i, 1
  %1228 = icmp slt i32 %1227, %1013
  br i1 %1228, label %.lr.ph.i1102.i, label %HashMap_resize_new_capacityPtri32.exit1128.i

HashMap_resize_new_capacityPtri32.exit1128.i:     ; preds = %._crit_edge.i1105.i, %._crit_edge1.i852.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  br label %HashMap_ensure_capacity_required_loadPtri32.exit856.i

HashMap_ensure_capacity_required_loadPtri32.exit856.i: ; preds = %HashMap_resize_new_capacityPtri32.exit1128.i, %._crit_edge3.i54
  %1229 = load ptr, ptr %574, align 8
  %1230 = call i32 %1229({ ptr, i160 } %1011) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1231 = load ptr, ptr %result.i268.i, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1232 = load i32, ptr %577, align 8
  %1233 = add i32 %1232, -1
  %1234 = and i32 %1233, %1230
  %1235 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1236 = load ptr, ptr %576, align 8
  %1237 = sext i32 %1234 to i64
  %1238 = shl nsw i64 %1237, 5
  %1239 = getelementptr i8, ptr %1236, i64 %1238
  %1240 = load ptr, ptr %1239, align 8
  %1241 = icmp eq ptr %1240, @nil_typ
  %1242 = icmp eq ptr %1240, null
  %1243 = or i1 %1241, %1242
  br i1 %1243, label %HashMap_find_slot_keyK_hashPtri32.exit1173.i, label %.lr.ph.i1143.i

.lr.ph.i1143.i:                                   ; preds = %HashMap_ensure_capacity_required_loadPtri32.exit856.i
  %1244 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %1245

1245:                                             ; preds = %._crit_edge.thread.i1159.i, %.lr.ph.i1143.i
  %1246 = phi i32 [ %1234, %.lr.ph.i1143.i ], [ %1288, %._crit_edge.thread.i1159.i ]
  %spec.store.select.i11641201.i = phi i32 [ -1, %.lr.ph.i1143.i ], [ %spec.store.select.i1164.i, %._crit_edge.thread.i1159.i ]
  %1247 = phi ptr [ %1240, %.lr.ph.i1143.i ], [ %1293, %._crit_edge.thread.i1159.i ]
  %1248 = phi ptr [ %1239, %.lr.ph.i1143.i ], [ %1292, %._crit_edge.thread.i1159.i ]
  %.sroa_idx.i1145.i = getelementptr i8, ptr %1248, i64 16
  %1249 = load i64, ptr %.sroa_idx.i1145.i, align 4
  %1250 = getelementptr i8, ptr %1248, i64 8
  %1251 = load i64, ptr %1250, align 4
  %1252 = inttoptr i64 %1251 to ptr
  %1253 = inttoptr i64 %1249 to ptr
  %hash_coef_ptr.i.i56.i1146.i = getelementptr i8, ptr %1247, i64 8
  %tbl_size_ptr.i.i57.i1147.i = getelementptr i8, ptr %1247, i64 16
  %offset_tbl_ptr.i.i58.i1148.i = getelementptr i8, ptr %1247, i64 40
  %hash_coef.i.i59.i1149.i = load i64, ptr %hash_coef_ptr.i.i56.i1146.i, align 4
  %tbl_size.i.i60.i1150.i = load i64, ptr %tbl_size_ptr.i.i57.i1147.i, align 4
  %offset_tbl.i.i61.i1151.i = load ptr, ptr %offset_tbl_ptr.i.i58.i1148.i, align 8
  %product.i.i.i62.i1152.i = mul i64 %hash_coef.i.i59.i1149.i, 4015701072841558310
  %shifted.i.i.i63.i1153.i = lshr i64 %product.i.i.i62.i1152.i, 32
  %xored.i.i.i64.i1154.i = xor i64 %shifted.i.i.i63.i1153.i, %product.i.i.i62.i1152.i
  %hash.i.i.i65.i1155.i = and i64 %xored.i.i.i64.i1154.i, %tbl_size.i.i60.i1150.i
  %offset_ptr.i.i66.i1156.i = getelementptr i32, ptr %offset_tbl.i.i61.i1151.i, i64 %hash.i.i.i65.i1155.i
  %offset.i.i67.i1157.i = load i32, ptr %offset_ptr.i.i66.i1156.i, align 4
  %1254 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1247, 0
  %1255 = insertvalue { ptr, ptr, ptr, i32 } %1254, ptr %1252, 1
  %1256 = insertvalue { ptr, ptr, ptr, i32 } %1255, ptr %1253, 2
  %1257 = insertvalue { ptr, ptr, ptr, i32 } %1256, i32 %offset.i.i67.i1157.i, 3
  %1258 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1247)
  %1259 = sext i32 %offset.i.i67.i1157.i to i64
  %1260 = getelementptr ptr, ptr %1247, i64 %1259
  %1261 = getelementptr i8, ptr %1260, i64 64
  %1262 = load ptr, ptr %1261, align 8
  %result.i.i1158.i = call ptr %1262({ ptr, ptr, ptr, i32 } %1257, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1263 = call i32 %result.i.i1158.i({ ptr, ptr, ptr, i32 } %1257, { ptr, ptr, ptr, i32 } %1257, ptr nonnull align 8 %0) #7
  %1264 = icmp eq i32 %1263, %1230
  br i1 %1264, label %._crit_edge.i1170.i, label %._crit_edge.thread.i1159.i

._crit_edge.i1170.i:                              ; preds = %1245
  %1265 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1266 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1247)
  %1267 = getelementptr i8, ptr %1260, i64 48
  %1268 = load ptr, ptr %1267, align 8
  %result.i69.i1171.i = call ptr %1268({ ptr, ptr, ptr, i32 } %1257, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1269 = call { ptr, i160 } %result.i69.i1171.i({ ptr, ptr, ptr, i32 } %1257, { ptr, ptr, ptr, i32 } %1257, ptr nonnull align 8 %0) #7
  %1270 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1271 = load ptr, ptr %575, align 8
  %1272 = call i1 %1271({ ptr, i160 } %1269, { ptr, i160 } %1011) #7
  br i1 %1272, label %HashMap_find_slot_keyK_hashPtri32.exit1173.loopexit.i, label %._crit_edge.thread.i1159.i

._crit_edge.thread.i1159.i:                       ; preds = %._crit_edge.i1170.i, %1245
  %1273 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1274 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1247)
  %1275 = getelementptr i8, ptr %1260, i64 56
  %1276 = load ptr, ptr %1275, align 8
  %result.i70.i1160.i = call ptr %1276({ ptr, ptr, ptr, i32 } %1257, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1277 = call { ptr, i160 } %result.i70.i1160.i({ ptr, ptr, ptr, i32 } %1257, { ptr, ptr, ptr, i32 } %1257, ptr nonnull align 8 %0) #7
  %.fca.0.extract19.i1161.i = extractvalue { ptr, i160 } %1277, 0
  %1278 = getelementptr i8, ptr %.fca.0.extract19.i1161.i, i64 8
  %1279 = getelementptr i8, ptr %.fca.0.extract19.i1161.i, i64 16
  %1280 = getelementptr i8, ptr %.fca.0.extract19.i1161.i, i64 24
  %1281 = getelementptr i8, ptr %.fca.0.extract19.i1161.i, i64 32
  %1282 = load i64, ptr %1278, align 4
  %1283 = load i64, ptr %1279, align 4
  %1284 = load ptr, ptr %1280, align 8
  %1285 = load ptr, ptr %1281, align 8
  %result.i71.i1162.i = call i1 %1284(i64 %1283, i64 %1282, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %1285) #5
  %1286 = icmp eq i32 %spec.store.select.i11641201.i, -1
  %or.cond.i1163.i = select i1 %result.i71.i1162.i, i1 %1286, i1 false
  %spec.store.select.i1164.i = select i1 %or.cond.i1163.i, i32 %1246, i32 %spec.store.select.i11641201.i
  %1287 = add i32 %1246, 1
  %1288 = and i32 %1287, %1233
  %1289 = load ptr, ptr %576, align 8
  %1290 = sext i32 %1288 to i64
  %1291 = shl nsw i64 %1290, 5
  %1292 = getelementptr i8, ptr %1289, i64 %1291
  %1293 = load ptr, ptr %1292, align 8
  %1294 = icmp eq ptr %1293, @nil_typ
  %1295 = icmp eq ptr %1293, null
  %1296 = or i1 %1294, %1295
  br i1 %1296, label %._crit_edge105.loopexit.i1166.i, label %1245

._crit_edge105.loopexit.i1166.i:                  ; preds = %._crit_edge.thread.i1159.i
  %1297 = icmp eq i32 %spec.store.select.i1164.i, -1
  %.pre.i1169.pre.i = select i1 %1297, i32 %1288, i32 %spec.store.select.i1164.i
  br label %HashMap_find_slot_keyK_hashPtri32.exit1173.i

HashMap_find_slot_keyK_hashPtri32.exit1173.loopexit.i: ; preds = %._crit_edge.i1170.i
  %.pre1265.i = load ptr, ptr %576, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit1173.i

HashMap_find_slot_keyK_hashPtri32.exit1173.i:     ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1173.loopexit.i, %._crit_edge105.loopexit.i1166.i, %HashMap_ensure_capacity_required_loadPtri32.exit856.i
  %1298 = phi ptr [ %1289, %._crit_edge105.loopexit.i1166.i ], [ %1236, %HashMap_ensure_capacity_required_loadPtri32.exit856.i ], [ %.pre1265.i, %HashMap_find_slot_keyK_hashPtri32.exit1173.loopexit.i ]
  %1299 = phi i32 [ %.pre.i1169.pre.i, %._crit_edge105.loopexit.i1166.i ], [ %1234, %HashMap_ensure_capacity_required_loadPtri32.exit856.i ], [ %1246, %HashMap_find_slot_keyK_hashPtri32.exit1173.loopexit.i ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %1300 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1301 = sext i32 %1299 to i64
  %1302 = shl nsw i64 %1301, 5
  %1303 = getelementptr i8, ptr %1298, i64 %1302
  %1304 = load ptr, ptr %1303, align 8
  %1305 = getelementptr i8, ptr %1303, i64 8
  %1306 = load i64, ptr %1305, align 4
  %.sroa_idx.i876.i = getelementptr i8, ptr %1303, i64 16
  %1307 = load i64, ptr %.sroa_idx.i876.i, align 4
  %1308 = load ptr, ptr %569, align 8
  %1309 = load ptr, ptr %1231, align 8, !alias.scope !238
  %1310 = getelementptr i8, ptr %1309, i64 72
  %1311 = load ptr, ptr %1310, align 8, !alias.scope !238
  %result.i.i.i878.i = call { i64, i64 } %1311(ptr nocapture nofree nonnull readonly %1231) #5, !alias.scope !238
  %1312 = extractvalue { i64, i64 } %result.i.i.i878.i, 0
  %1313 = extractvalue { i64, i64 } %result.i.i.i878.i, 1
  %1314 = call i64 @llvm.umax.i64(i64 %1313, i64 8)
  %1315 = urem i64 20, %1313
  %1316 = icmp eq i64 %1315, 0
  %1317 = sub i64 %1313, %1315
  %1318 = select i1 %1316, i64 0, i64 %1317
  %1319 = add i64 %1312, 20
  %1320 = add i64 %1319, %1318
  %1321 = and i64 %1320, 7
  %1322 = icmp eq i64 %1321, 0
  %1323 = sub nuw nsw i64 40, %1321
  %1324 = select i1 %1322, i64 32, i64 %1323
  %1325 = add i64 %1324, %1320
  %1326 = urem i64 %1325, %1314
  %1327 = icmp eq i64 %1326, 0
  %1328 = sub i64 %1314, %1326
  %1329 = select i1 %1327, i64 0, i64 %1328
  %1330 = add i64 %1325, %1329
  %result.i71.i879.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1330, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %1231, ptr %result.i71.i879.i, align 8
  %1331 = getelementptr inbounds i8, ptr %result.i71.i879.i, i64 8
  store ptr %1308, ptr %1331, align 8
  %1332 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i879.i)
  %1333 = load ptr, ptr %1231, align 8
  %1334 = getelementptr i8, ptr %1333, i64 72
  %1335 = load ptr, ptr %1334, align 8
  %result.i.i1240.i = call { i64, i64 } %1335(ptr nocapture nofree nonnull readonly %1231) #5
  %1336 = extractvalue { i64, i64 } %result.i.i1240.i, 1
  %1337 = urem i64 20, %1336
  %1338 = icmp eq i64 %1337, 0
  %reass.sub1614 = sub i64 %1336, %1337
  %1339 = add i64 %reass.sub1614, 20
  %1340 = select i1 %1338, i64 20, i64 %1339
  %1341 = getelementptr i8, ptr %result.i71.i879.i, i64 %1340
  %1342 = getelementptr i8, ptr %1333, i64 64
  %1343 = load ptr, ptr %1342, align 8
  call void %1343({ ptr, i160 } %1011, ptr nocapture nofree nonnull readonly %1231, ptr nocapture nofree writeonly %1341) #13
  %1344 = load ptr, ptr %result.i71.i879.i, align 8
  %1345 = load ptr, ptr %1344, align 8
  %1346 = getelementptr i8, ptr %1345, i64 72
  %1347 = load ptr, ptr %1346, align 8
  %result.i.i1242.i = call { i64, i64 } %1347(ptr nocapture nofree nonnull readonly %1344) #5
  %1348 = extractvalue { i64, i64 } %result.i.i1242.i, 0
  %1349 = extractvalue { i64, i64 } %result.i.i1242.i, 1
  %1350 = urem i64 20, %1349
  %1351 = icmp eq i64 %1350, 0
  %1352 = sub i64 %1349, %1350
  %1353 = select i1 %1351, i64 0, i64 %1352
  %1354 = add i64 %1348, 20
  %1355 = add i64 %1354, %1353
  %1356 = and i64 %1355, 7
  %1357 = icmp eq i64 %1356, 0
  %1358 = sub nuw nsw i64 8, %1356
  %1359 = select i1 %1357, i64 0, i64 %1358
  %1360 = getelementptr i8, ptr %result.i71.i879.i, i64 %1355
  %1361 = getelementptr i8, ptr %1360, i64 %1359
  store ptr @i32_typ, ptr %1361, align 8
  %1362 = getelementptr i8, ptr %1361, i64 8
  store i160 %.sroa.0211.0.insert.ext.i, ptr %1362, align 4
  %1363 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @Entry) #34
  %1364 = getelementptr inbounds i8, ptr %result.i71.i879.i, i64 16
  store i32 %1230, ptr %1364, align 8
  %1365 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  store ptr @Entry, ptr %1303, align 8
  %1366 = ptrtoint ptr %result.i71.i879.i to i64
  store i64 %1366, ptr %1305, align 4
  %.sroa_idx4.i882.i = getelementptr i8, ptr %1303, i64 24
  store i32 10, ptr %.sroa_idx4.i882.i, align 4
  %1367 = icmp eq ptr %1304, @nil_typ
  %1368 = icmp eq ptr %1304, null
  %1369 = or i1 %1367, %1368
  br i1 %1369, label %1370, label %1373

1370:                                             ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1173.i
  %1371 = load i32, ptr %1003, align 4
  %1372 = add i32 %1371, 1
  store i32 %1372, ptr %1003, align 4
  br label %._crit_edge.sink.split.i899.i

1373:                                             ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1173.i
  %1374 = inttoptr i64 %1306 to ptr
  %1375 = inttoptr i64 %1307 to ptr
  %hash_coef_ptr.i.i88.i883.i = getelementptr i8, ptr %1304, i64 8
  %tbl_size_ptr.i.i89.i884.i = getelementptr i8, ptr %1304, i64 16
  %offset_tbl_ptr.i.i90.i885.i = getelementptr i8, ptr %1304, i64 40
  %hash_coef.i.i91.i886.i = load i64, ptr %hash_coef_ptr.i.i88.i883.i, align 4, !noalias !241
  %tbl_size.i.i92.i887.i = load i64, ptr %tbl_size_ptr.i.i89.i884.i, align 4, !noalias !241
  %offset_tbl.i.i93.i888.i = load ptr, ptr %offset_tbl_ptr.i.i90.i885.i, align 8, !noalias !241
  %product.i.i.i94.i889.i = mul i64 %hash_coef.i.i91.i886.i, 4015701072841558310
  %shifted.i.i.i95.i890.i = lshr i64 %product.i.i.i94.i889.i, 32
  %xored.i.i.i96.i891.i = xor i64 %shifted.i.i.i95.i890.i, %product.i.i.i94.i889.i
  %hash.i.i.i97.i892.i = and i64 %xored.i.i.i96.i891.i, %tbl_size.i.i92.i887.i
  %offset_ptr.i.i98.i893.i = getelementptr i32, ptr %offset_tbl.i.i93.i888.i, i64 %hash.i.i.i97.i892.i
  %offset.i.i99.i894.i = load i32, ptr %offset_ptr.i.i98.i893.i, align 4, !noalias !241
  %1376 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1304, 0
  %1377 = insertvalue { ptr, ptr, ptr, i32 } %1376, ptr %1374, 1
  %1378 = insertvalue { ptr, ptr, ptr, i32 } %1377, ptr %1375, 2
  %1379 = insertvalue { ptr, ptr, ptr, i32 } %1378, i32 %offset.i.i99.i894.i, 3
  %1380 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1381 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1304)
  %1382 = sext i32 %offset.i.i99.i894.i to i64
  %1383 = getelementptr ptr, ptr %1304, i64 %1382
  %1384 = getelementptr i8, ptr %1383, i64 56
  %1385 = load ptr, ptr %1384, align 8
  %result.i101.i895.i = call ptr %1385({ ptr, ptr, ptr, i32 } %1379, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1386 = call { ptr, i160 } %result.i101.i895.i({ ptr, ptr, ptr, i32 } %1379, { ptr, ptr, ptr, i32 } %1379, ptr nonnull align 8 %0) #7
  %.fca.0.extract51.i896.i = extractvalue { ptr, i160 } %1386, 0
  %1387 = getelementptr i8, ptr %.fca.0.extract51.i896.i, i64 8
  %1388 = getelementptr i8, ptr %.fca.0.extract51.i896.i, i64 16
  %1389 = getelementptr i8, ptr %.fca.0.extract51.i896.i, i64 24
  %1390 = getelementptr i8, ptr %.fca.0.extract51.i896.i, i64 32
  %1391 = load i64, ptr %1387, align 4
  %1392 = load i64, ptr %1388, align 4
  %1393 = load ptr, ptr %1389, align 8
  %1394 = load ptr, ptr %1390, align 8
  %result.i102.i897.i = call i1 %1393(i64 %1392, i64 %1391, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %1394) #5
  br i1 %result.i102.i897.i, label %._crit_edge.sink.split.i899.i, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit901.i

._crit_edge.sink.split.i899.i:                    ; preds = %1373, %1370
  %.sink159.i900.i = phi i64 [ 48, %1370 ], [ 40, %1373 ]
  %1395 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1396 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i900.i
  %1397 = load ptr, ptr %1396, align 8
  %1398 = load ptr, ptr %1397, align 8
  %1399 = call i32 %1398(ptr nonnull %result.i268.i) #36
  %1400 = add i32 %1399, 1
  %1401 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1402 = getelementptr i8, ptr %1397, i64 8
  %1403 = load ptr, ptr %1402, align 8
  call void %1403(ptr nonnull %result.i268.i, i32 %1400) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit901.i

HashMap_insert_internal_keyK_valueV_hashPtri32.exit901.i: ; preds = %._crit_edge.sink.split.i899.i, %1373
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %1404 = add nuw nsw i32 %.2249474.i, 1
  %1405 = icmp ult i32 %.2249474.i, 999999
  br i1 %1405, label %._crit_edge3.i54, label %._crit_edge5.i

._crit_edge5.i:                                   ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit901.i
  %1406 = call i64 @clock()
  %.sroa.0202.0.insert.ext.i = zext i32 %spec.select.i to i160
  %1407 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0202.0.insert.ext.i, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1408 = load ptr, ptr %574, align 8
  %1409 = call i32 %1408({ ptr, i160 } %1407) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1410 = load i32, ptr %577, align 8
  %1411 = add i32 %1410, -1
  %1412 = and i32 %1411, %1409
  %1413 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1414 = load ptr, ptr %576, align 8
  %1415 = sext i32 %1412 to i64
  %1416 = shl nsw i64 %1415, 5
  %1417 = getelementptr i8, ptr %1414, i64 %1416
  %1418 = load ptr, ptr %1417, align 8
  %1419 = icmp eq ptr %1418, @nil_typ
  %1420 = icmp eq ptr %1418, null
  %1421 = or i1 %1419, %1420
  br i1 %1421, label %HashMap_find_slot_keyK_hashPtri32.exit.i76, label %.lr.ph.i.i56

.lr.ph.i.i56:                                     ; preds = %._crit_edge5.i
  %1422 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %1423

1423:                                             ; preds = %._crit_edge.thread.i.i69, %.lr.ph.i.i56
  %1424 = phi i32 [ %1412, %.lr.ph.i.i56 ], [ %1466, %._crit_edge.thread.i.i69 ]
  %spec.store.select.i1013.i = phi i32 [ -1, %.lr.ph.i.i56 ], [ %spec.store.select.i.i73, %._crit_edge.thread.i.i69 ]
  %1425 = phi ptr [ %1418, %.lr.ph.i.i56 ], [ %1471, %._crit_edge.thread.i.i69 ]
  %1426 = phi ptr [ %1417, %.lr.ph.i.i56 ], [ %1470, %._crit_edge.thread.i.i69 ]
  %.sroa_idx.i914.i = getelementptr i8, ptr %1426, i64 16
  %1427 = load i64, ptr %.sroa_idx.i914.i, align 4
  %1428 = getelementptr i8, ptr %1426, i64 8
  %1429 = load i64, ptr %1428, align 4
  %1430 = inttoptr i64 %1429 to ptr
  %1431 = inttoptr i64 %1427 to ptr
  %hash_coef_ptr.i.i56.i.i57 = getelementptr i8, ptr %1425, i64 8
  %tbl_size_ptr.i.i57.i.i58 = getelementptr i8, ptr %1425, i64 16
  %offset_tbl_ptr.i.i58.i.i59 = getelementptr i8, ptr %1425, i64 40
  %hash_coef.i.i59.i.i60 = load i64, ptr %hash_coef_ptr.i.i56.i.i57, align 4
  %tbl_size.i.i60.i.i61 = load i64, ptr %tbl_size_ptr.i.i57.i.i58, align 4
  %offset_tbl.i.i61.i.i62 = load ptr, ptr %offset_tbl_ptr.i.i58.i.i59, align 8
  %product.i.i.i62.i.i63 = mul i64 %hash_coef.i.i59.i.i60, 4015701072841558310
  %shifted.i.i.i63.i.i64 = lshr i64 %product.i.i.i62.i.i63, 32
  %xored.i.i.i64.i.i65 = xor i64 %shifted.i.i.i63.i.i64, %product.i.i.i62.i.i63
  %hash.i.i.i65.i.i66 = and i64 %xored.i.i.i64.i.i65, %tbl_size.i.i60.i.i61
  %offset_ptr.i.i66.i.i67 = getelementptr i32, ptr %offset_tbl.i.i61.i.i62, i64 %hash.i.i.i65.i.i66
  %offset.i.i67.i.i68 = load i32, ptr %offset_ptr.i.i66.i.i67, align 4
  %1432 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1425, 0
  %1433 = insertvalue { ptr, ptr, ptr, i32 } %1432, ptr %1430, 1
  %1434 = insertvalue { ptr, ptr, ptr, i32 } %1433, ptr %1431, 2
  %1435 = insertvalue { ptr, ptr, ptr, i32 } %1434, i32 %offset.i.i67.i.i68, 3
  %1436 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1425)
  %1437 = sext i32 %offset.i.i67.i.i68 to i64
  %1438 = getelementptr ptr, ptr %1425, i64 %1437
  %1439 = getelementptr i8, ptr %1438, i64 64
  %1440 = load ptr, ptr %1439, align 8
  %result.i.i915.i = call ptr %1440({ ptr, ptr, ptr, i32 } %1435, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1441 = call i32 %result.i.i915.i({ ptr, ptr, ptr, i32 } %1435, { ptr, ptr, ptr, i32 } %1435, ptr nonnull align 8 %0) #7
  %1442 = icmp eq i32 %1441, %1409
  br i1 %1442, label %._crit_edge.i917.i, label %._crit_edge.thread.i.i69

._crit_edge.i917.i:                               ; preds = %1423
  %1443 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1444 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1425)
  %1445 = getelementptr i8, ptr %1438, i64 48
  %1446 = load ptr, ptr %1445, align 8
  %result.i69.i918.i = call ptr %1446({ ptr, ptr, ptr, i32 } %1435, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1447 = call { ptr, i160 } %result.i69.i918.i({ ptr, ptr, ptr, i32 } %1435, { ptr, ptr, ptr, i32 } %1435, ptr nonnull align 8 %0) #7
  %1448 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1449 = load ptr, ptr %575, align 8
  %1450 = call i1 %1449({ ptr, i160 } %1447, { ptr, i160 } %1407) #7
  br i1 %1450, label %HashMap_find_slot_keyK_hashPtri32.exit.loopexit.i120, label %._crit_edge.thread.i.i69

._crit_edge.thread.i.i69:                         ; preds = %._crit_edge.i917.i, %1423
  %1451 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1452 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1425)
  %1453 = getelementptr i8, ptr %1438, i64 56
  %1454 = load ptr, ptr %1453, align 8
  %result.i70.i.i70 = call ptr %1454({ ptr, ptr, ptr, i32 } %1435, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1455 = call { ptr, i160 } %result.i70.i.i70({ ptr, ptr, ptr, i32 } %1435, { ptr, ptr, ptr, i32 } %1435, ptr nonnull align 8 %0) #7
  %.fca.0.extract19.i.i71 = extractvalue { ptr, i160 } %1455, 0
  %1456 = getelementptr i8, ptr %.fca.0.extract19.i.i71, i64 8
  %1457 = getelementptr i8, ptr %.fca.0.extract19.i.i71, i64 16
  %1458 = getelementptr i8, ptr %.fca.0.extract19.i.i71, i64 24
  %1459 = getelementptr i8, ptr %.fca.0.extract19.i.i71, i64 32
  %1460 = load i64, ptr %1456, align 4
  %1461 = load i64, ptr %1457, align 4
  %1462 = load ptr, ptr %1458, align 8
  %1463 = load ptr, ptr %1459, align 8
  %result.i71.i916.i = call i1 %1462(i64 %1461, i64 %1460, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %1463) #5
  %1464 = icmp eq i32 %spec.store.select.i1013.i, -1
  %or.cond.i.i72 = select i1 %result.i71.i916.i, i1 %1464, i1 false
  %spec.store.select.i.i73 = select i1 %or.cond.i.i72, i32 %1424, i32 %spec.store.select.i1013.i
  %1465 = add i32 %1424, 1
  %1466 = and i32 %1465, %1411
  %1467 = load ptr, ptr %576, align 8
  %1468 = sext i32 %1466 to i64
  %1469 = shl nsw i64 %1468, 5
  %1470 = getelementptr i8, ptr %1467, i64 %1469
  %1471 = load ptr, ptr %1470, align 8
  %1472 = icmp eq ptr %1471, @nil_typ
  %1473 = icmp eq ptr %1471, null
  %1474 = or i1 %1472, %1473
  br i1 %1474, label %._crit_edge105.loopexit.i.i74, label %1423

._crit_edge105.loopexit.i.i74:                    ; preds = %._crit_edge.thread.i.i69
  %1475 = icmp eq i32 %spec.store.select.i.i73, -1
  %.pre.i.pre.i75 = select i1 %1475, i32 %1466, i32 %spec.store.select.i.i73
  br label %HashMap_find_slot_keyK_hashPtri32.exit.i76

HashMap_find_slot_keyK_hashPtri32.exit.loopexit.i120: ; preds = %._crit_edge.i917.i
  %.pre.i121 = load ptr, ptr %576, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit.i76

HashMap_find_slot_keyK_hashPtri32.exit.i76:       ; preds = %HashMap_find_slot_keyK_hashPtri32.exit.loopexit.i120, %._crit_edge105.loopexit.i.i74, %._crit_edge5.i
  %1476 = phi ptr [ %1467, %._crit_edge105.loopexit.i.i74 ], [ %1414, %._crit_edge5.i ], [ %.pre.i121, %HashMap_find_slot_keyK_hashPtri32.exit.loopexit.i120 ]
  %1477 = phi i32 [ %.pre.i.pre.i75, %._crit_edge105.loopexit.i.i74 ], [ %1412, %._crit_edge5.i ], [ %1424, %HashMap_find_slot_keyK_hashPtri32.exit.loopexit.i120 ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %1478 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1479 = sext i32 %1477 to i64
  %1480 = shl nsw i64 %1479, 5
  %1481 = getelementptr i8, ptr %1476, i64 %1480
  %1482 = load ptr, ptr %1481, align 8
  %1483 = icmp ne ptr %1482, @nil_typ
  %1484 = icmp ne ptr %1482, null
  %.not57.i.i77 = and i1 %1483, %1484
  br i1 %.not57.i.i77, label %1485, label %HashMap_get_keyK.exit.thread.i78

1485:                                             ; preds = %HashMap_find_slot_keyK_hashPtri32.exit.i76
  %1486 = getelementptr i8, ptr %1481, i64 8
  %1487 = load i64, ptr %1486, align 4
  %.sroa_idx.i.i96 = getelementptr i8, ptr %1481, i64 16
  %1488 = load i64, ptr %.sroa_idx.i.i96, align 4
  %1489 = inttoptr i64 %1487 to ptr
  %1490 = inttoptr i64 %1488 to ptr
  %hash_coef_ptr.i.i60.i.i97 = getelementptr i8, ptr %1482, i64 8
  %tbl_size_ptr.i.i61.i.i98 = getelementptr i8, ptr %1482, i64 16
  %offset_tbl_ptr.i.i62.i.i99 = getelementptr i8, ptr %1482, i64 40
  %hash_coef.i.i63.i.i100 = load i64, ptr %hash_coef_ptr.i.i60.i.i97, align 4, !noalias !244
  %tbl_size.i.i64.i.i101 = load i64, ptr %tbl_size_ptr.i.i61.i.i98, align 4, !noalias !244
  %offset_tbl.i.i65.i.i102 = load ptr, ptr %offset_tbl_ptr.i.i62.i.i99, align 8, !noalias !244
  %product.i.i.i66.i.i103 = mul i64 %hash_coef.i.i63.i.i100, 4015701072841558310
  %shifted.i.i.i67.i.i104 = lshr i64 %product.i.i.i66.i.i103, 32
  %xored.i.i.i68.i.i105 = xor i64 %shifted.i.i.i67.i.i104, %product.i.i.i66.i.i103
  %hash.i.i.i69.i.i106 = and i64 %xored.i.i.i68.i.i105, %tbl_size.i.i64.i.i101
  %offset_ptr.i.i70.i.i107 = getelementptr i32, ptr %offset_tbl.i.i65.i.i102, i64 %hash.i.i.i69.i.i106
  %offset.i.i71.i.i108 = load i32, ptr %offset_ptr.i.i70.i.i107, align 4, !noalias !244
  %1491 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1482, 0
  %1492 = insertvalue { ptr, ptr, ptr, i32 } %1491, ptr %1489, 1
  %1493 = insertvalue { ptr, ptr, ptr, i32 } %1492, ptr %1490, 2
  %1494 = insertvalue { ptr, ptr, ptr, i32 } %1493, i32 %offset.i.i71.i.i108, 3
  %1495 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1496 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1482)
  %1497 = sext i32 %offset.i.i71.i.i108 to i64
  %1498 = getelementptr ptr, ptr %1482, i64 %1497
  %1499 = getelementptr i8, ptr %1498, i64 56
  %1500 = load ptr, ptr %1499, align 8
  %result.i73.i.i109 = call ptr %1500({ ptr, ptr, ptr, i32 } %1494, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1501 = call { ptr, i160 } %result.i73.i.i109({ ptr, ptr, ptr, i32 } %1494, { ptr, ptr, ptr, i32 } %1494, ptr nonnull align 8 %0) #7
  %.fca.0.extract51.i.i110 = extractvalue { ptr, i160 } %1501, 0
  %.fca.1.extract52.i.i111 = extractvalue { ptr, i160 } %1501, 1
  %1502 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1503 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1482)
  %1504 = getelementptr i8, ptr %1498, i64 64
  %1505 = load ptr, ptr %1504, align 8
  %result.i74.i.i112 = call ptr %1505({ ptr, ptr, ptr, i32 } %1494, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1506 = call i32 %result.i74.i.i112({ ptr, ptr, ptr, i32 } %1494, { ptr, ptr, ptr, i32 } %1494, ptr nonnull align 8 %0) #7
  %1507 = icmp eq i32 %1506, %1409
  br i1 %1507, label %._crit_edge.i.i113, label %HashMap_get_keyK.exit.thread.i78

._crit_edge.i.i113:                               ; preds = %1485
  %1508 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1509 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1482)
  %1510 = getelementptr i8, ptr %1498, i64 48
  %1511 = load ptr, ptr %1510, align 8
  %result.i75.i.i114 = call ptr %1511({ ptr, ptr, ptr, i32 } %1494, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1512 = call { ptr, i160 } %result.i75.i.i114({ ptr, ptr, ptr, i32 } %1494, { ptr, ptr, ptr, i32 } %1494, ptr nonnull align 8 %0) #7
  %1513 = load ptr, ptr %575, align 8
  %1514 = call i1 %1513({ ptr, i160 } %1512, { ptr, i160 } %1407) #7
  br i1 %1514, label %HashMap_get_keyK.exit.i115, label %HashMap_get_keyK.exit.thread.i78

HashMap_get_keyK.exit.thread.i78:                 ; preds = %._crit_edge.i.i113, %1485, %HashMap_find_slot_keyK_hashPtri32.exit.i76
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  br label %._crit_edge7.i

HashMap_get_keyK.exit.i115:                       ; preds = %._crit_edge.i.i113
  %1515 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1516 = load ptr, ptr %569, align 8
  %1517 = load ptr, ptr %1516, align 8
  %1518 = ptrtoint ptr %1517 to i64
  %1519 = getelementptr i8, ptr %.fca.0.extract51.i.i110, i64 8
  %1520 = getelementptr i8, ptr %.fca.0.extract51.i.i110, i64 16
  %1521 = getelementptr i8, ptr %.fca.0.extract51.i.i110, i64 24
  %1522 = getelementptr i8, ptr %.fca.0.extract51.i.i110, i64 32
  %1523 = load i64, ptr %1519, align 4
  %1524 = load i64, ptr %1520, align 4
  %1525 = load ptr, ptr %1521, align 8
  %1526 = load ptr, ptr %1522, align 8
  %1527 = load i64, ptr %1517, align 4
  %result.i77.i.i116 = call i1 %1525(i64 %1524, i64 %1523, i64 %1527, i64 %1518, ptr readonly %1526) #5
  %cond.fr.i.i117 = freeze i1 %result.i77.i.i116
  %spec.select.i.i118 = select i1 %cond.fr.i.i117, ptr %.fca.0.extract51.i.i110, ptr @nil_typ
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %1528 = icmp ne ptr %spec.select.i.i118, @nil_typ
  %1529 = icmp ne ptr %spec.select.i.i118, null
  %.not260.i = and i1 %1528, %1529
  br i1 %.not260.i, label %._crit_edge6.i, label %._crit_edge7.i

._crit_edge6.i:                                   ; preds = %HashMap_get_keyK.exit.i115
  %.sroa.2.8.extract.trunc.i119 = trunc i160 %.fca.1.extract52.i.i111 to i32
  %1530 = add i32 %spec.select.i, 1
  %.not264.i = icmp eq i32 %1530, %.sroa.2.8.extract.trunc.i119
  br label %._crit_edge7.i

._crit_edge7.i:                                   ; preds = %._crit_edge6.i, %HashMap_get_keyK.exit.i115, %HashMap_get_keyK.exit.thread.i78
  %.2252.i = phi i1 [ %.not264.i, %._crit_edge6.i ], [ false, %HashMap_get_keyK.exit.i115 ], [ false, %HashMap_get_keyK.exit.thread.i78 ]
  %1531 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %1532 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #34
  %1533 = load i32, ptr %1003, align 4
  %.not265.i = icmp eq i32 %1533, %999
  %1534 = select i1 %.not265.i, i1 %.2252.i, i1 false
  %1535 = select i1 %1534, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %result.i344.i = call noalias align 16 dereferenceable_or_null(14) ptr @bump_malloc_inner(i64 noundef 14, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <13 x i8> <i8 73, i8 110, i8 115, i8 101, i8 114, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109>, ptr %result.i344.i, align 16
  %1536 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #34
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1537 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %1538 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i932.i = call noalias dereferenceable_or_null(14) ptr @bump_malloc_inner(i64 noundef 14, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(13) %result.i.i932.i, ptr noundef nonnull align 16 dereferenceable(13) %result.i344.i, i64 13, i1 false)
  %1539 = sub i64 %1406, %1000
  %1540 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %1541 = getelementptr i8, ptr %result.i.i932.i, i64 13
  store i8 0, ptr %1541, align 1
  %puts.i.i79 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i932.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %result.i97.i.i80 = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i97.i.i80, align 16
  %result.i.i375.i.i81 = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i375.i.i81, ptr noundef nonnull align 16 dereferenceable(14) %result.i97.i.i80, i64 14, i1 false)
  %puts.i.i.i82 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i375.i.i81)
  %1542 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 1000000) #17
  %result.i103.i.i83 = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i103.i.i83, align 16
  %result.i.i389.i.i84 = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i389.i.i84, ptr noundef nonnull align 16 dereferenceable(14) %result.i103.i.i83, i64 14, i1 false)
  %puts.i313.i.i85 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i389.i.i84)
  %1543 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %1539) #17
  %result.i109.i.i86 = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i109.i.i86, align 4
  %result.i.i408.i.i87 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i408.i.i87, ptr noundef nonnull align 4 dereferenceable(3) %result.i109.i.i86, i64 3, i1 false)
  %puts.i333.i.i88 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i408.i.i87)
  %1544 = icmp sgt i64 %1539, 0
  br i1 %1544, label %1545, label %benchmark_insert_random.exit

1545:                                             ; preds = %._crit_edge7.i
  %1546 = mul i64 %1539, 1000000
  %1547 = sdiv i64 %1546, 1000000
  br label %benchmark_insert_random.exit

benchmark_insert_random.exit:                     ; preds = %._crit_edge7.i, %1545
  %.0.i.i89 = phi i64 [ %1547, %1545 ], [ 0, %._crit_edge7.i ]
  %result.i114.i.i90 = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i114.i.i90, align 16
  %result.i.i427.i.i91 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i427.i.i91, ptr noundef nonnull align 16 dereferenceable(15) %result.i114.i.i90, i64 15, i1 false)
  %puts.i353.i.i92 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i427.i.i91)
  %1548 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0.i.i89) #17
  %result.i120.i.i93 = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i120.i.i93, align 4
  %result.i.i446.i.i94 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i446.i.i94, ptr noundef nonnull align 4 dereferenceable(3) %result.i120.i.i93, i64 3, i1 false)
  %puts.i373.i.i95 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i446.i.i94)
  %result.i348.i = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i348.i, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1549 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %1550 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i947.i = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i947.i, ptr noundef nonnull align 32 dereferenceable(18) %result.i348.i, i64 18, i1 false)
  %1551 = getelementptr i8, ptr %result.i.i947.i, i64 18
  store i8 0, ptr %1551, align 1
  %puts.i748.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i947.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1552 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %1553 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i966.i = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <4 x i8> %1535, ptr %result.i.i966.i, align 1
  %1554 = getelementptr i8, ptr %result.i.i966.i, i64 4
  store i8 0, ptr %1554, align 1
  %puts.i768.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i966.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %result.i363.i = call noalias align 32 dereferenceable_or_null(28) ptr @bump_malloc_inner(i64 noundef 28, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <27 x i8> <i8 32, i8 32, i8 32, i8 32, i8 40, i8 69, i8 120, i8 112, i8 101, i8 99, i8 116, i8 101, i8 100, i8 32, i8 117, i8 110, i8 105, i8 113, i8 117, i8 101, i8 32, i8 115, i8 105, i8 122, i8 101, i8 58, i8 32>, ptr %result.i363.i, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1555 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %1556 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i985.i = call noalias dereferenceable_or_null(28) ptr @bump_malloc_inner(i64 noundef 28, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(27) %result.i.i985.i, ptr noundef nonnull align 32 dereferenceable(27) %result.i363.i, i64 27, i1 false)
  %1557 = getelementptr i8, ptr %result.i.i985.i, i64 27
  store i8 0, ptr %1557, align 1
  %puts.i788.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i985.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %1558 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %999) #17
  %1559 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1560 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %1561 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i1004.i = call noalias dereferenceable_or_null(2) ptr @bump_malloc_inner(i64 noundef 2, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store i8 41, ptr %result.i.i1004.i, align 1
  %1562 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %1563 = getelementptr i8, ptr %result.i.i1004.i, i64 1
  store i8 0, ptr %1563, align 1
  %puts.i808.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1004.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %.sroa.0231.sroa.0.i)
  %result.i151.i148 = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i151.i148, align 8
  %1564 = getelementptr inbounds i8, ptr %result.i151.i148, i64 8
  store ptr @_parameterization_Ptri32, ptr %1564, align 8
  %1565 = getelementptr inbounds i8, ptr %result.i151.i148, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %1565, align 8
  %1566 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i151.i148) #38
  %result.i152.i149 = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i.i147)
  %result.i153.i150 = call i32 @VirtualProtect(ptr nofree %result.i152.i149, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i.i147) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i.i147)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i152.i149, ptr noalias nofree noundef nonnull readnone @ogzjpsiwda, ptr noalias nofree noundef nonnull readnone @i32_hasher) #38
  %ret.i.i151 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i152.i149) #39
  %1567 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i152.i149) #38
  %result.i154.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i155.i)
  %result.i156.i = call i32 @VirtualProtect(ptr nofree %result.i154.i, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i155.i) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i155.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i154.i, ptr noalias nofree noundef nonnull readnone @qqpnfjadrc, ptr noalias nofree noundef nonnull readnone @i32_eq) #38
  %ret.i157.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i154.i) #39
  %1568 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i154.i) #38
  %1569 = getelementptr inbounds i8, ptr %result.i151.i148, i64 48
  store ptr %ret.i.i151, ptr %1569, align 8
  %1570 = getelementptr inbounds i8, ptr %result.i151.i148, i64 56
  store ptr %ret.i157.i, ptr %1570, align 8
  %result.i.i271.i = call noalias dereferenceable_or_null(512) ptr @bump_malloc_inner(i64 noundef 512, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %1571 = getelementptr inbounds i8, ptr %result.i151.i148, i64 24
  store ptr %result.i.i271.i, ptr %1571, align 8
  %1572 = getelementptr inbounds i8, ptr %result.i151.i148, i64 32
  store i32 16, ptr %1572, align 8
  %1573 = getelementptr inbounds i8, ptr %result.i151.i148, i64 40
  %1574 = getelementptr inbounds i8, ptr %result.i151.i148, i64 36
  %1575 = getelementptr inbounds i8, ptr %3, i64 8
  %1576 = getelementptr inbounds i8, ptr %3, i64 16
  br label %._crit_edge.i152

._crit_edge.i152thread-pre-split:                 ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit.i172
  %.pr = load i32, ptr %1572, align 8
  %.pre = load i32, ptr %1573, align 8
  br label %._crit_edge.i152

._crit_edge.i152:                                 ; preds = %._crit_edge.i152thread-pre-split, %benchmark_insert_random.exit
  %1577 = phi i32 [ %.pre, %._crit_edge.i152thread-pre-split ], [ 0, %benchmark_insert_random.exit ]
  %1578 = phi i32 [ %.pr, %._crit_edge.i152thread-pre-split ], [ 16, %benchmark_insert_random.exit ]
  %.0258.i = phi i32 [ %1579, %._crit_edge.i152thread-pre-split ], [ 0, %benchmark_insert_random.exit ]
  %1579 = add nuw nsw i32 %.0258.i, 1
  %.sroa.0132.0.insert.ext.i = zext nneg i32 %.0258.i to i160
  %1580 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0132.0.insert.ext.i, 1
  %.sroa.0129.0.insert.ext.i = zext nneg i32 %1579 to i160
  %1581 = icmp eq i32 %1578, 0
  %1582 = mul i32 %1577, 10
  %1583 = add i32 %1582, 10
  %1584 = mul i32 %1578, 6
  %1585 = icmp sge i32 %1583, %1584
  %.0.i437.i = select i1 %1581, i1 true, i1 %1585
  br i1 %.0.i437.i, label %._crit_edge1.i439.i, label %HashMap_ensure_capacity_required_loadPtri32.exit.i153

._crit_edge1.i439.i:                              ; preds = %._crit_edge.i152
  %1586 = shl i32 %1578, 1
  %spec.select.i440.i = call i32 @llvm.smax.i32(i32 %1586, i32 16)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1587 = load ptr, ptr %1571, align 8
  %1588 = zext nneg i32 %spec.select.i440.i to i64
  %1589 = shl nuw nsw i64 %1588, 5
  %result.i.i.i244 = call noalias ptr @bump_malloc_inner(i64 noundef %1589, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i.i244, ptr %1571, align 8
  store i32 %spec.select.i440.i, ptr %1572, align 8
  store i32 0, ptr %1574, align 4
  %1590 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #38
  store i32 0, ptr %1573, align 8
  %1591 = icmp sgt i32 %1578, 0
  br i1 %1591, label %.lr.ph.i576.i, label %HashMap_resize_new_capacityPtri32.exit.i245

.lr.ph.i576.i:                                    ; preds = %._crit_edge1.i439.i, %._crit_edge.i577.i
  %.096.i.i246 = phi i32 [ %1794, %._crit_edge.i577.i ], [ 0, %._crit_edge1.i439.i ]
  %1592 = zext nneg i32 %.096.i.i246 to i64
  %1593 = shl nuw nsw i64 %1592, 5
  %1594 = getelementptr i8, ptr %1587, i64 %1593
  %1595 = load ptr, ptr %1594, align 8
  %1596 = icmp ne ptr %1595, @nil_typ
  %1597 = icmp ne ptr %1595, null
  %.not40.i.i247 = and i1 %1596, %1597
  br i1 %.not40.i.i247, label %1598, label %._crit_edge.i577.i

1598:                                             ; preds = %.lr.ph.i576.i
  %1599 = getelementptr i8, ptr %1594, i64 8
  %1600 = load i64, ptr %1599, align 4
  %.sroa_idx.i578.i = getelementptr i8, ptr %1594, i64 16
  %1601 = load i64, ptr %.sroa_idx.i578.i, align 4
  %1602 = inttoptr i64 %1600 to ptr
  %1603 = inttoptr i64 %1601 to ptr
  %hash_coef_ptr.i.i42.i.i248 = getelementptr i8, ptr %1595, i64 8
  %tbl_size_ptr.i.i43.i.i249 = getelementptr i8, ptr %1595, i64 16
  %offset_tbl_ptr.i.i44.i.i250 = getelementptr i8, ptr %1595, i64 40
  %hash_coef.i.i45.i.i251 = load i64, ptr %hash_coef_ptr.i.i42.i.i248, align 4, !noalias !247
  %tbl_size.i.i46.i.i252 = load i64, ptr %tbl_size_ptr.i.i43.i.i249, align 4, !noalias !247
  %offset_tbl.i.i47.i.i253 = load ptr, ptr %offset_tbl_ptr.i.i44.i.i250, align 8, !noalias !247
  %product.i.i.i48.i.i254 = mul i64 %hash_coef.i.i45.i.i251, 4015701072841558310
  %shifted.i.i.i49.i.i255 = lshr i64 %product.i.i.i48.i.i254, 32
  %xored.i.i.i50.i.i256 = xor i64 %shifted.i.i.i49.i.i255, %product.i.i.i48.i.i254
  %hash.i.i.i51.i.i257 = and i64 %xored.i.i.i50.i.i256, %tbl_size.i.i46.i.i252
  %offset_ptr.i.i52.i.i258 = getelementptr i32, ptr %offset_tbl.i.i47.i.i253, i64 %hash.i.i.i51.i.i257
  %offset.i.i53.i.i259 = load i32, ptr %offset_ptr.i.i52.i.i258, align 4, !noalias !247
  %1604 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1595, 0
  %1605 = insertvalue { ptr, ptr, ptr, i32 } %1604, ptr %1602, 1
  %1606 = insertvalue { ptr, ptr, ptr, i32 } %1605, ptr %1603, 2
  %1607 = insertvalue { ptr, ptr, ptr, i32 } %1606, i32 %offset.i.i53.i.i259, 3
  %1608 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1609 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1595)
  %1610 = sext i32 %offset.i.i53.i.i259 to i64
  %1611 = getelementptr ptr, ptr %1595, i64 %1610
  %1612 = getelementptr i8, ptr %1611, i64 56
  %1613 = load ptr, ptr %1612, align 8
  %result.i55.i.i260 = call ptr %1613({ ptr, ptr, ptr, i32 } %1607, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1614 = call { ptr, i160 } %result.i55.i.i260({ ptr, ptr, ptr, i32 } %1607, { ptr, ptr, ptr, i32 } %1607, ptr nonnull align 8 %0) #7
  %.fca.0.extract29.i.i261 = extractvalue { ptr, i160 } %1614, 0
  %1615 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1616 = load ptr, ptr %1564, align 8
  %1617 = load ptr, ptr %1616, align 8
  %1618 = ptrtoint ptr %1617 to i64
  %1619 = getelementptr i8, ptr %.fca.0.extract29.i.i261, i64 8
  %1620 = getelementptr i8, ptr %.fca.0.extract29.i.i261, i64 16
  %1621 = getelementptr i8, ptr %.fca.0.extract29.i.i261, i64 24
  %1622 = getelementptr i8, ptr %.fca.0.extract29.i.i261, i64 32
  %1623 = load i64, ptr %1619, align 4
  %1624 = load i64, ptr %1620, align 4
  %1625 = load ptr, ptr %1621, align 8
  %1626 = load ptr, ptr %1622, align 8
  %1627 = load i64, ptr %1617, align 4
  %result.i57.i.i262 = call i1 %1625(i64 %1624, i64 %1623, i64 %1627, i64 %1618, ptr readonly %1626) #5
  br i1 %result.i57.i.i262, label %1628, label %._crit_edge.i577.i

1628:                                             ; preds = %1598
  %1629 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1630 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1595)
  %1631 = getelementptr i8, ptr %1611, i64 48
  %1632 = load ptr, ptr %1631, align 8
  %result.i58.i.i263 = call ptr %1632({ ptr, ptr, ptr, i32 } %1607, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1633 = call { ptr, i160 } %result.i58.i.i263({ ptr, ptr, ptr, i32 } %1607, { ptr, ptr, ptr, i32 } %1607, ptr nonnull align 8 %0) #7
  %1634 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1635 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %1595)
  %1636 = getelementptr i8, ptr %1611, i64 64
  %1637 = load ptr, ptr %1636, align 8
  %result.i59.i.i264 = call ptr %1637({ ptr, ptr, ptr, i32 } %1607, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1638 = call i32 %result.i59.i.i264({ ptr, ptr, ptr, i32 } %1607, { ptr, ptr, ptr, i32 } %1607, ptr nonnull align 8 %0) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %3)
  %1639 = load ptr, ptr %result.i151.i148, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1640 = load i32, ptr %1572, align 8
  %1641 = add i32 %1640, -1
  %1642 = and i32 %1641, %1638
  %1643 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1644 = load ptr, ptr %1571, align 8
  %1645 = sext i32 %1642 to i64
  %1646 = shl nsw i64 %1645, 5
  %1647 = getelementptr i8, ptr %1644, i64 %1646
  %1648 = load ptr, ptr %1647, align 8
  %1649 = icmp eq ptr %1648, @nil_typ
  %1650 = icmp eq ptr %1648, null
  %1651 = or i1 %1649, %1650
  br i1 %1651, label %HashMap_find_slot_keyK_hashPtri32.exit784.i, label %.lr.ph.i760.i

.lr.ph.i760.i:                                    ; preds = %1628
  %1652 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %1653

1653:                                             ; preds = %._crit_edge.thread.i775.i, %.lr.ph.i760.i
  %1654 = phi i32 [ %1642, %.lr.ph.i760.i ], [ %1696, %._crit_edge.thread.i775.i ]
  %spec.store.select.i780795.i = phi i32 [ -1, %.lr.ph.i760.i ], [ %spec.store.select.i780.i, %._crit_edge.thread.i775.i ]
  %1655 = phi ptr [ %1648, %.lr.ph.i760.i ], [ %1701, %._crit_edge.thread.i775.i ]
  %1656 = phi ptr [ %1647, %.lr.ph.i760.i ], [ %1700, %._crit_edge.thread.i775.i ]
  %.sroa_idx.i761.i = getelementptr i8, ptr %1656, i64 16
  %1657 = load i64, ptr %.sroa_idx.i761.i, align 4
  %1658 = getelementptr i8, ptr %1656, i64 8
  %1659 = load i64, ptr %1658, align 4
  %1660 = inttoptr i64 %1659 to ptr
  %1661 = inttoptr i64 %1657 to ptr
  %hash_coef_ptr.i.i56.i762.i = getelementptr i8, ptr %1655, i64 8
  %tbl_size_ptr.i.i57.i763.i = getelementptr i8, ptr %1655, i64 16
  %offset_tbl_ptr.i.i58.i764.i = getelementptr i8, ptr %1655, i64 40
  %hash_coef.i.i59.i765.i = load i64, ptr %hash_coef_ptr.i.i56.i762.i, align 4
  %tbl_size.i.i60.i766.i = load i64, ptr %tbl_size_ptr.i.i57.i763.i, align 4
  %offset_tbl.i.i61.i767.i = load ptr, ptr %offset_tbl_ptr.i.i58.i764.i, align 8
  %product.i.i.i62.i768.i = mul i64 %hash_coef.i.i59.i765.i, 4015701072841558310
  %shifted.i.i.i63.i769.i = lshr i64 %product.i.i.i62.i768.i, 32
  %xored.i.i.i64.i770.i = xor i64 %shifted.i.i.i63.i769.i, %product.i.i.i62.i768.i
  %hash.i.i.i65.i771.i = and i64 %xored.i.i.i64.i770.i, %tbl_size.i.i60.i766.i
  %offset_ptr.i.i66.i772.i = getelementptr i32, ptr %offset_tbl.i.i61.i767.i, i64 %hash.i.i.i65.i771.i
  %offset.i.i67.i773.i = load i32, ptr %offset_ptr.i.i66.i772.i, align 4
  %1662 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1655, 0
  %1663 = insertvalue { ptr, ptr, ptr, i32 } %1662, ptr %1660, 1
  %1664 = insertvalue { ptr, ptr, ptr, i32 } %1663, ptr %1661, 2
  %1665 = insertvalue { ptr, ptr, ptr, i32 } %1664, i32 %offset.i.i67.i773.i, 3
  %1666 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1655)
  %1667 = sext i32 %offset.i.i67.i773.i to i64
  %1668 = getelementptr ptr, ptr %1655, i64 %1667
  %1669 = getelementptr i8, ptr %1668, i64 64
  %1670 = load ptr, ptr %1669, align 8
  %result.i.i774.i = call ptr %1670({ ptr, ptr, ptr, i32 } %1665, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1671 = call i32 %result.i.i774.i({ ptr, ptr, ptr, i32 } %1665, { ptr, ptr, ptr, i32 } %1665, ptr nonnull align 8 %0) #7
  %1672 = icmp eq i32 %1671, %1638
  br i1 %1672, label %._crit_edge.i782.i, label %._crit_edge.thread.i775.i

._crit_edge.i782.i:                               ; preds = %1653
  %1673 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1674 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1655)
  %1675 = getelementptr i8, ptr %1668, i64 48
  %1676 = load ptr, ptr %1675, align 8
  %result.i69.i783.i = call ptr %1676({ ptr, ptr, ptr, i32 } %1665, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1677 = call { ptr, i160 } %result.i69.i783.i({ ptr, ptr, ptr, i32 } %1665, { ptr, ptr, ptr, i32 } %1665, ptr nonnull align 8 %0) #7
  %1678 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1679 = load ptr, ptr %1570, align 8
  %1680 = call i1 %1679({ ptr, i160 } %1677, { ptr, i160 } %1633) #7
  br i1 %1680, label %HashMap_find_slot_keyK_hashPtri32.exit784.loopexit.i, label %._crit_edge.thread.i775.i

._crit_edge.thread.i775.i:                        ; preds = %._crit_edge.i782.i, %1653
  %1681 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1682 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1655)
  %1683 = getelementptr i8, ptr %1668, i64 56
  %1684 = load ptr, ptr %1683, align 8
  %result.i70.i776.i = call ptr %1684({ ptr, ptr, ptr, i32 } %1665, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1685 = call { ptr, i160 } %result.i70.i776.i({ ptr, ptr, ptr, i32 } %1665, { ptr, ptr, ptr, i32 } %1665, ptr nonnull align 8 %0) #7
  %.fca.0.extract19.i777.i = extractvalue { ptr, i160 } %1685, 0
  %1686 = getelementptr i8, ptr %.fca.0.extract19.i777.i, i64 8
  %1687 = getelementptr i8, ptr %.fca.0.extract19.i777.i, i64 16
  %1688 = getelementptr i8, ptr %.fca.0.extract19.i777.i, i64 24
  %1689 = getelementptr i8, ptr %.fca.0.extract19.i777.i, i64 32
  %1690 = load i64, ptr %1686, align 4
  %1691 = load i64, ptr %1687, align 4
  %1692 = load ptr, ptr %1688, align 8
  %1693 = load ptr, ptr %1689, align 8
  %result.i71.i778.i = call i1 %1692(i64 %1691, i64 %1690, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %1693) #5
  %1694 = icmp eq i32 %spec.store.select.i780795.i, -1
  %or.cond.i779.i = select i1 %result.i71.i778.i, i1 %1694, i1 false
  %spec.store.select.i780.i = select i1 %or.cond.i779.i, i32 %1654, i32 %spec.store.select.i780795.i
  %1695 = add i32 %1654, 1
  %1696 = and i32 %1695, %1641
  %1697 = load ptr, ptr %1571, align 8
  %1698 = sext i32 %1696 to i64
  %1699 = shl nsw i64 %1698, 5
  %1700 = getelementptr i8, ptr %1697, i64 %1699
  %1701 = load ptr, ptr %1700, align 8
  %1702 = icmp eq ptr %1701, @nil_typ
  %1703 = icmp eq ptr %1701, null
  %1704 = or i1 %1702, %1703
  br i1 %1704, label %._crit_edge105.loopexit.i781.i, label %1653

._crit_edge105.loopexit.i781.i:                   ; preds = %._crit_edge.thread.i775.i
  %1705 = icmp eq i32 %spec.store.select.i780.i, -1
  %.pre.i.pre815.i = select i1 %1705, i32 %1696, i32 %spec.store.select.i780.i
  br label %HashMap_find_slot_keyK_hashPtri32.exit784.i

HashMap_find_slot_keyK_hashPtri32.exit784.loopexit.i: ; preds = %._crit_edge.i782.i
  %.pre851.i = load ptr, ptr %1571, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit784.i

HashMap_find_slot_keyK_hashPtri32.exit784.i:      ; preds = %HashMap_find_slot_keyK_hashPtri32.exit784.loopexit.i, %._crit_edge105.loopexit.i781.i, %1628
  %1706 = phi ptr [ %1697, %._crit_edge105.loopexit.i781.i ], [ %1644, %1628 ], [ %.pre851.i, %HashMap_find_slot_keyK_hashPtri32.exit784.loopexit.i ]
  %1707 = phi i32 [ %.pre.i.pre815.i, %._crit_edge105.loopexit.i781.i ], [ %1642, %1628 ], [ %1654, %HashMap_find_slot_keyK_hashPtri32.exit784.loopexit.i ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %1708 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1709 = sext i32 %1707 to i64
  %1710 = shl nsw i64 %1709, 5
  %1711 = getelementptr i8, ptr %1706, i64 %1710
  %1712 = load ptr, ptr %1711, align 8
  %1713 = getelementptr i8, ptr %1711, i64 8
  %1714 = load i64, ptr %1713, align 4
  %.sroa_idx.i687.i = getelementptr i8, ptr %1711, i64 16
  %1715 = load i64, ptr %.sroa_idx.i687.i, align 4
  %1716 = load ptr, ptr %1564, align 8
  %1717 = load ptr, ptr %1639, align 8, !alias.scope !250
  %1718 = getelementptr i8, ptr %1717, i64 72
  %1719 = load ptr, ptr %1718, align 8, !alias.scope !250
  %result.i.i.i689.i = call { i64, i64 } %1719(ptr nocapture nofree nonnull readonly %1639) #5, !alias.scope !250
  %1720 = extractvalue { i64, i64 } %result.i.i.i689.i, 0
  %1721 = extractvalue { i64, i64 } %result.i.i.i689.i, 1
  %1722 = call i64 @llvm.umax.i64(i64 %1721, i64 8)
  %1723 = urem i64 20, %1721
  %1724 = icmp eq i64 %1723, 0
  %1725 = sub i64 %1721, %1723
  %1726 = select i1 %1724, i64 0, i64 %1725
  %1727 = add i64 %1720, 20
  %1728 = add i64 %1727, %1726
  %1729 = and i64 %1728, 7
  %1730 = icmp eq i64 %1729, 0
  %1731 = sub nuw nsw i64 40, %1729
  %1732 = select i1 %1730, i64 32, i64 %1731
  %1733 = add i64 %1732, %1728
  %1734 = urem i64 %1733, %1722
  %1735 = icmp eq i64 %1734, 0
  %1736 = sub i64 %1722, %1734
  %1737 = select i1 %1735, i64 0, i64 %1736
  %1738 = add i64 %1733, %1737
  %result.i71.i690.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1738, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %1639, ptr %result.i71.i690.i, align 8
  %1739 = getelementptr inbounds i8, ptr %result.i71.i690.i, i64 8
  store ptr %1716, ptr %1739, align 8
  %1740 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i690.i)
  %1741 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %result.i71.i690.i, 1
  %1742 = insertvalue { ptr, ptr, ptr, i32 } %1741, ptr undef, 2
  %1743 = insertvalue { ptr, ptr, ptr, i32 } %1742, i32 10, 3
  store ptr %1639, ptr %3, align 8
  store ptr %1716, ptr %1575, align 8
  store ptr @_parameterization_Ptri32, ptr %1576, align 8
  %1744 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %3)
  %1745 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Entry)
  %1746 = load i64, ptr %1619, align 4
  %1747 = load i64, ptr %1620, align 4
  %1748 = load ptr, ptr %1621, align 8
  %1749 = load ptr, ptr %1622, align 8
  %result.i.i117.i.i265 = call i1 %1748(i64 %1747, i64 %1746, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %1749) #5
  %1750 = select i1 %result.i.i117.i.i265, i64 9, i64 10
  %gep.i266 = getelementptr [14 x ptr], ptr getelementptr inbounds (i8, ptr @Entry, i64 80), i64 0, i64 %1750
  %1751 = load ptr, ptr %gep.i266, align 8
  call void %1751({ ptr, ptr, ptr, i32 } %1743, { ptr, ptr, ptr, i32 } %1743, ptr nonnull align 8 dereferenceable(24) %3, { ptr, i160 } %1633, { ptr, i160 } %1614, i32 %1638) #7
  %1752 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1753 = load ptr, ptr %1571, align 8
  %1754 = getelementptr i8, ptr %1753, i64 %1710
  store ptr @Entry, ptr %1754, align 8
  %1755 = getelementptr i8, ptr %1754, i64 8
  %1756 = ptrtoint ptr %result.i71.i690.i to i64
  store i64 %1756, ptr %1755, align 4
  %.sroa_idx4.i691.i = getelementptr i8, ptr %1754, i64 24
  store i32 10, ptr %.sroa_idx4.i691.i, align 4
  %1757 = icmp eq ptr %1712, @nil_typ
  %1758 = icmp eq ptr %1712, null
  %1759 = or i1 %1757, %1758
  br i1 %1759, label %1760, label %1763

1760:                                             ; preds = %HashMap_find_slot_keyK_hashPtri32.exit784.i
  %1761 = load i32, ptr %1574, align 4
  %1762 = add i32 %1761, 1
  store i32 %1762, ptr %1574, align 4
  br label %._crit_edge.sink.split.i708.i

1763:                                             ; preds = %HashMap_find_slot_keyK_hashPtri32.exit784.i
  %1764 = inttoptr i64 %1714 to ptr
  %1765 = inttoptr i64 %1715 to ptr
  %hash_coef_ptr.i.i88.i692.i = getelementptr i8, ptr %1712, i64 8
  %tbl_size_ptr.i.i89.i693.i = getelementptr i8, ptr %1712, i64 16
  %offset_tbl_ptr.i.i90.i694.i = getelementptr i8, ptr %1712, i64 40
  %hash_coef.i.i91.i695.i = load i64, ptr %hash_coef_ptr.i.i88.i692.i, align 4, !noalias !253
  %tbl_size.i.i92.i696.i = load i64, ptr %tbl_size_ptr.i.i89.i693.i, align 4, !noalias !253
  %offset_tbl.i.i93.i697.i = load ptr, ptr %offset_tbl_ptr.i.i90.i694.i, align 8, !noalias !253
  %product.i.i.i94.i698.i = mul i64 %hash_coef.i.i91.i695.i, 4015701072841558310
  %shifted.i.i.i95.i699.i = lshr i64 %product.i.i.i94.i698.i, 32
  %xored.i.i.i96.i700.i = xor i64 %shifted.i.i.i95.i699.i, %product.i.i.i94.i698.i
  %hash.i.i.i97.i701.i = and i64 %xored.i.i.i96.i700.i, %tbl_size.i.i92.i696.i
  %offset_ptr.i.i98.i702.i = getelementptr i32, ptr %offset_tbl.i.i93.i697.i, i64 %hash.i.i.i97.i701.i
  %offset.i.i99.i703.i = load i32, ptr %offset_ptr.i.i98.i702.i, align 4, !noalias !253
  %1766 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1712, 0
  %1767 = insertvalue { ptr, ptr, ptr, i32 } %1766, ptr %1764, 1
  %1768 = insertvalue { ptr, ptr, ptr, i32 } %1767, ptr %1765, 2
  %1769 = insertvalue { ptr, ptr, ptr, i32 } %1768, i32 %offset.i.i99.i703.i, 3
  %1770 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1771 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1712)
  %1772 = sext i32 %offset.i.i99.i703.i to i64
  %1773 = getelementptr ptr, ptr %1712, i64 %1772
  %1774 = getelementptr i8, ptr %1773, i64 56
  %1775 = load ptr, ptr %1774, align 8
  %result.i101.i704.i = call ptr %1775({ ptr, ptr, ptr, i32 } %1769, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1776 = call { ptr, i160 } %result.i101.i704.i({ ptr, ptr, ptr, i32 } %1769, { ptr, ptr, ptr, i32 } %1769, ptr nonnull align 8 %0) #7
  %.fca.0.extract51.i705.i = extractvalue { ptr, i160 } %1776, 0
  %1777 = getelementptr i8, ptr %.fca.0.extract51.i705.i, i64 8
  %1778 = getelementptr i8, ptr %.fca.0.extract51.i705.i, i64 16
  %1779 = getelementptr i8, ptr %.fca.0.extract51.i705.i, i64 24
  %1780 = getelementptr i8, ptr %.fca.0.extract51.i705.i, i64 32
  %1781 = load i64, ptr %1777, align 4
  %1782 = load i64, ptr %1778, align 4
  %1783 = load ptr, ptr %1779, align 8
  %1784 = load ptr, ptr %1780, align 8
  %result.i102.i706.i = call i1 %1783(i64 %1782, i64 %1781, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %1784) #5
  br i1 %result.i102.i706.i, label %._crit_edge.sink.split.i708.i, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit710.i

._crit_edge.sink.split.i708.i:                    ; preds = %1763, %1760
  %.sink159.i709.i = phi i64 [ 48, %1760 ], [ 40, %1763 ]
  %1785 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1786 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i709.i
  %1787 = load ptr, ptr %1786, align 8
  %1788 = load ptr, ptr %1787, align 8
  %1789 = call i32 %1788(ptr nonnull %result.i151.i148) #36
  %1790 = add i32 %1789, 1
  %1791 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1792 = getelementptr i8, ptr %1787, i64 8
  %1793 = load ptr, ptr %1792, align 8
  call void %1793(ptr nonnull %result.i151.i148, i32 %1790) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit710.i

HashMap_insert_internal_keyK_valueV_hashPtri32.exit710.i: ; preds = %._crit_edge.sink.split.i708.i, %1763
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %3)
  br label %._crit_edge.i577.i

._crit_edge.i577.i:                               ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit710.i, %1598, %.lr.ph.i576.i
  %1794 = add nuw nsw i32 %.096.i.i246, 1
  %1795 = icmp slt i32 %1794, %1578
  br i1 %1795, label %.lr.ph.i576.i, label %HashMap_resize_new_capacityPtri32.exit.i245

HashMap_resize_new_capacityPtri32.exit.i245:      ; preds = %._crit_edge.i577.i, %._crit_edge1.i439.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  br label %HashMap_ensure_capacity_required_loadPtri32.exit.i153

HashMap_ensure_capacity_required_loadPtri32.exit.i153: ; preds = %HashMap_resize_new_capacityPtri32.exit.i245, %._crit_edge.i152
  %1796 = load ptr, ptr %1569, align 8
  %1797 = call i32 %1796({ ptr, i160 } %1580) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1798 = load ptr, ptr %result.i151.i148, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1799 = load i32, ptr %1572, align 8
  %1800 = add i32 %1799, -1
  %1801 = and i32 %1800, %1797
  %1802 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1803 = load ptr, ptr %1571, align 8
  %1804 = sext i32 %1801 to i64
  %1805 = shl nsw i64 %1804, 5
  %1806 = getelementptr i8, ptr %1803, i64 %1805
  %1807 = load ptr, ptr %1806, align 8
  %1808 = icmp eq ptr %1807, @nil_typ
  %1809 = icmp eq ptr %1807, null
  %1810 = or i1 %1808, %1809
  br i1 %1810, label %HashMap_find_slot_keyK_hashPtri32.exit614.i, label %.lr.ph.i591.i

.lr.ph.i591.i:                                    ; preds = %HashMap_ensure_capacity_required_loadPtri32.exit.i153
  %1811 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %1812

1812:                                             ; preds = %._crit_edge.thread.i606.i, %.lr.ph.i591.i
  %1813 = phi i32 [ %1801, %.lr.ph.i591.i ], [ %1855, %._crit_edge.thread.i606.i ]
  %spec.store.select.i611634.i = phi i32 [ -1, %.lr.ph.i591.i ], [ %spec.store.select.i611.i, %._crit_edge.thread.i606.i ]
  %1814 = phi ptr [ %1807, %.lr.ph.i591.i ], [ %1860, %._crit_edge.thread.i606.i ]
  %1815 = phi ptr [ %1806, %.lr.ph.i591.i ], [ %1859, %._crit_edge.thread.i606.i ]
  %.sroa_idx.i592.i = getelementptr i8, ptr %1815, i64 16
  %1816 = load i64, ptr %.sroa_idx.i592.i, align 4
  %1817 = getelementptr i8, ptr %1815, i64 8
  %1818 = load i64, ptr %1817, align 4
  %1819 = inttoptr i64 %1818 to ptr
  %1820 = inttoptr i64 %1816 to ptr
  %hash_coef_ptr.i.i56.i593.i = getelementptr i8, ptr %1814, i64 8
  %tbl_size_ptr.i.i57.i594.i = getelementptr i8, ptr %1814, i64 16
  %offset_tbl_ptr.i.i58.i595.i = getelementptr i8, ptr %1814, i64 40
  %hash_coef.i.i59.i596.i = load i64, ptr %hash_coef_ptr.i.i56.i593.i, align 4
  %tbl_size.i.i60.i597.i = load i64, ptr %tbl_size_ptr.i.i57.i594.i, align 4
  %offset_tbl.i.i61.i598.i = load ptr, ptr %offset_tbl_ptr.i.i58.i595.i, align 8
  %product.i.i.i62.i599.i = mul i64 %hash_coef.i.i59.i596.i, 4015701072841558310
  %shifted.i.i.i63.i600.i = lshr i64 %product.i.i.i62.i599.i, 32
  %xored.i.i.i64.i601.i = xor i64 %shifted.i.i.i63.i600.i, %product.i.i.i62.i599.i
  %hash.i.i.i65.i602.i = and i64 %xored.i.i.i64.i601.i, %tbl_size.i.i60.i597.i
  %offset_ptr.i.i66.i603.i = getelementptr i32, ptr %offset_tbl.i.i61.i598.i, i64 %hash.i.i.i65.i602.i
  %offset.i.i67.i604.i = load i32, ptr %offset_ptr.i.i66.i603.i, align 4
  %1821 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1814, 0
  %1822 = insertvalue { ptr, ptr, ptr, i32 } %1821, ptr %1819, 1
  %1823 = insertvalue { ptr, ptr, ptr, i32 } %1822, ptr %1820, 2
  %1824 = insertvalue { ptr, ptr, ptr, i32 } %1823, i32 %offset.i.i67.i604.i, 3
  %1825 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1814)
  %1826 = sext i32 %offset.i.i67.i604.i to i64
  %1827 = getelementptr ptr, ptr %1814, i64 %1826
  %1828 = getelementptr i8, ptr %1827, i64 64
  %1829 = load ptr, ptr %1828, align 8
  %result.i.i605.i = call ptr %1829({ ptr, ptr, ptr, i32 } %1824, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1830 = call i32 %result.i.i605.i({ ptr, ptr, ptr, i32 } %1824, { ptr, ptr, ptr, i32 } %1824, ptr nonnull align 8 %0) #7
  %1831 = icmp eq i32 %1830, %1797
  br i1 %1831, label %._crit_edge.i613.i, label %._crit_edge.thread.i606.i

._crit_edge.i613.i:                               ; preds = %1812
  %1832 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1833 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1814)
  %1834 = getelementptr i8, ptr %1827, i64 48
  %1835 = load ptr, ptr %1834, align 8
  %result.i69.i.i243 = call ptr %1835({ ptr, ptr, ptr, i32 } %1824, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1836 = call { ptr, i160 } %result.i69.i.i243({ ptr, ptr, ptr, i32 } %1824, { ptr, ptr, ptr, i32 } %1824, ptr nonnull align 8 %0) #7
  %1837 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1838 = load ptr, ptr %1570, align 8
  %1839 = call i1 %1838({ ptr, i160 } %1836, { ptr, i160 } %1580) #7
  br i1 %1839, label %HashMap_find_slot_keyK_hashPtri32.exit614.loopexit.i, label %._crit_edge.thread.i606.i

._crit_edge.thread.i606.i:                        ; preds = %._crit_edge.i613.i, %1812
  %1840 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1841 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1814)
  %1842 = getelementptr i8, ptr %1827, i64 56
  %1843 = load ptr, ptr %1842, align 8
  %result.i70.i607.i = call ptr %1843({ ptr, ptr, ptr, i32 } %1824, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1844 = call { ptr, i160 } %result.i70.i607.i({ ptr, ptr, ptr, i32 } %1824, { ptr, ptr, ptr, i32 } %1824, ptr nonnull align 8 %0) #7
  %.fca.0.extract19.i608.i = extractvalue { ptr, i160 } %1844, 0
  %1845 = getelementptr i8, ptr %.fca.0.extract19.i608.i, i64 8
  %1846 = getelementptr i8, ptr %.fca.0.extract19.i608.i, i64 16
  %1847 = getelementptr i8, ptr %.fca.0.extract19.i608.i, i64 24
  %1848 = getelementptr i8, ptr %.fca.0.extract19.i608.i, i64 32
  %1849 = load i64, ptr %1845, align 4
  %1850 = load i64, ptr %1846, align 4
  %1851 = load ptr, ptr %1847, align 8
  %1852 = load ptr, ptr %1848, align 8
  %result.i71.i609.i = call i1 %1851(i64 %1850, i64 %1849, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %1852) #5
  %1853 = icmp eq i32 %spec.store.select.i611634.i, -1
  %or.cond.i610.i = select i1 %result.i71.i609.i, i1 %1853, i1 false
  %spec.store.select.i611.i = select i1 %or.cond.i610.i, i32 %1813, i32 %spec.store.select.i611634.i
  %1854 = add i32 %1813, 1
  %1855 = and i32 %1854, %1800
  %1856 = load ptr, ptr %1571, align 8
  %1857 = sext i32 %1855 to i64
  %1858 = shl nsw i64 %1857, 5
  %1859 = getelementptr i8, ptr %1856, i64 %1858
  %1860 = load ptr, ptr %1859, align 8
  %1861 = icmp eq ptr %1860, @nil_typ
  %1862 = icmp eq ptr %1860, null
  %1863 = or i1 %1861, %1862
  br i1 %1863, label %._crit_edge105.loopexit.i612.i, label %1812

._crit_edge105.loopexit.i612.i:                   ; preds = %._crit_edge.thread.i606.i
  %1864 = icmp eq i32 %spec.store.select.i611.i, -1
  %.pre.i.pre649.i = select i1 %1864, i32 %1855, i32 %spec.store.select.i611.i
  br label %HashMap_find_slot_keyK_hashPtri32.exit614.i

HashMap_find_slot_keyK_hashPtri32.exit614.loopexit.i: ; preds = %._crit_edge.i613.i
  %.pre677.i = load ptr, ptr %1571, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit614.i

HashMap_find_slot_keyK_hashPtri32.exit614.i:      ; preds = %HashMap_find_slot_keyK_hashPtri32.exit614.loopexit.i, %._crit_edge105.loopexit.i612.i, %HashMap_ensure_capacity_required_loadPtri32.exit.i153
  %1865 = phi ptr [ %1856, %._crit_edge105.loopexit.i612.i ], [ %1803, %HashMap_ensure_capacity_required_loadPtri32.exit.i153 ], [ %.pre677.i, %HashMap_find_slot_keyK_hashPtri32.exit614.loopexit.i ]
  %1866 = phi i32 [ %.pre.i.pre649.i, %._crit_edge105.loopexit.i612.i ], [ %1801, %HashMap_ensure_capacity_required_loadPtri32.exit.i153 ], [ %1813, %HashMap_find_slot_keyK_hashPtri32.exit614.loopexit.i ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %1867 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1868 = sext i32 %1866 to i64
  %1869 = shl nsw i64 %1868, 5
  %1870 = getelementptr i8, ptr %1865, i64 %1869
  %1871 = load ptr, ptr %1870, align 8
  %1872 = getelementptr i8, ptr %1870, i64 8
  %1873 = load i64, ptr %1872, align 4
  %.sroa_idx.i455.i = getelementptr i8, ptr %1870, i64 16
  %1874 = load i64, ptr %.sroa_idx.i455.i, align 4
  %1875 = load ptr, ptr %1564, align 8
  %1876 = load ptr, ptr %1798, align 8, !alias.scope !256
  %1877 = getelementptr i8, ptr %1876, i64 72
  %1878 = load ptr, ptr %1877, align 8, !alias.scope !256
  %result.i.i.i.i154 = call { i64, i64 } %1878(ptr nocapture nofree nonnull readonly %1798) #5, !alias.scope !256
  %1879 = extractvalue { i64, i64 } %result.i.i.i.i154, 0
  %1880 = extractvalue { i64, i64 } %result.i.i.i.i154, 1
  %1881 = call i64 @llvm.umax.i64(i64 %1880, i64 8)
  %1882 = urem i64 20, %1880
  %1883 = icmp eq i64 %1882, 0
  %1884 = sub i64 %1880, %1882
  %1885 = select i1 %1883, i64 0, i64 %1884
  %1886 = add i64 %1879, 20
  %1887 = add i64 %1886, %1885
  %1888 = and i64 %1887, 7
  %1889 = icmp eq i64 %1888, 0
  %1890 = sub nuw nsw i64 40, %1888
  %1891 = select i1 %1889, i64 32, i64 %1890
  %1892 = add i64 %1891, %1887
  %1893 = urem i64 %1892, %1881
  %1894 = icmp eq i64 %1893, 0
  %1895 = sub i64 %1881, %1893
  %1896 = select i1 %1894, i64 0, i64 %1895
  %1897 = add i64 %1892, %1896
  %result.i71.i.i155 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %1897, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %1798, ptr %result.i71.i.i155, align 8
  %1898 = getelementptr inbounds i8, ptr %result.i71.i.i155, i64 8
  store ptr %1875, ptr %1898, align 8
  %1899 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i.i155)
  %1900 = load ptr, ptr %1798, align 8
  %1901 = getelementptr i8, ptr %1900, i64 72
  %1902 = load ptr, ptr %1901, align 8
  %result.i.i660.i = call { i64, i64 } %1902(ptr nocapture nofree nonnull readonly %1798) #5
  %1903 = extractvalue { i64, i64 } %result.i.i660.i, 1
  %1904 = urem i64 20, %1903
  %1905 = icmp eq i64 %1904, 0
  %reass.sub1615 = sub i64 %1903, %1904
  %1906 = add i64 %reass.sub1615, 20
  %1907 = select i1 %1905, i64 20, i64 %1906
  %1908 = getelementptr i8, ptr %result.i71.i.i155, i64 %1907
  %1909 = getelementptr i8, ptr %1900, i64 64
  %1910 = load ptr, ptr %1909, align 8
  call void %1910({ ptr, i160 } %1580, ptr nocapture nofree nonnull readonly %1798, ptr nocapture nofree writeonly %1908) #13
  %1911 = load ptr, ptr %result.i71.i.i155, align 8
  %1912 = load ptr, ptr %1911, align 8
  %1913 = getelementptr i8, ptr %1912, i64 72
  %1914 = load ptr, ptr %1913, align 8
  %result.i.i661.i = call { i64, i64 } %1914(ptr nocapture nofree nonnull readonly %1911) #5
  %1915 = extractvalue { i64, i64 } %result.i.i661.i, 0
  %1916 = extractvalue { i64, i64 } %result.i.i661.i, 1
  %1917 = urem i64 20, %1916
  %1918 = icmp eq i64 %1917, 0
  %1919 = sub i64 %1916, %1917
  %1920 = select i1 %1918, i64 0, i64 %1919
  %1921 = add i64 %1915, 20
  %1922 = add i64 %1921, %1920
  %1923 = and i64 %1922, 7
  %1924 = icmp eq i64 %1923, 0
  %1925 = sub nuw nsw i64 8, %1923
  %1926 = select i1 %1924, i64 0, i64 %1925
  %1927 = getelementptr i8, ptr %result.i71.i.i155, i64 %1922
  %1928 = getelementptr i8, ptr %1927, i64 %1926
  store ptr @i32_typ, ptr %1928, align 8
  %1929 = getelementptr i8, ptr %1928, i64 8
  store i160 %.sroa.0129.0.insert.ext.i, ptr %1929, align 4
  %1930 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @Entry) #34
  %1931 = getelementptr inbounds i8, ptr %result.i71.i.i155, i64 16
  store i32 %1797, ptr %1931, align 8
  %1932 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  store ptr @Entry, ptr %1870, align 8
  %1933 = ptrtoint ptr %result.i71.i.i155 to i64
  store i64 %1933, ptr %1872, align 4
  %.sroa_idx4.i.i157 = getelementptr i8, ptr %1870, i64 24
  store i32 10, ptr %.sroa_idx4.i.i157, align 4
  %1934 = icmp eq ptr %1871, @nil_typ
  %1935 = icmp eq ptr %1871, null
  %1936 = or i1 %1934, %1935
  br i1 %1936, label %1937, label %1940

1937:                                             ; preds = %HashMap_find_slot_keyK_hashPtri32.exit614.i
  %1938 = load i32, ptr %1574, align 4
  %1939 = add i32 %1938, 1
  store i32 %1939, ptr %1574, align 4
  br label %._crit_edge.sink.split.i.i241

1940:                                             ; preds = %HashMap_find_slot_keyK_hashPtri32.exit614.i
  %1941 = inttoptr i64 %1873 to ptr
  %1942 = inttoptr i64 %1874 to ptr
  %hash_coef_ptr.i.i88.i.i158 = getelementptr i8, ptr %1871, i64 8
  %tbl_size_ptr.i.i89.i.i159 = getelementptr i8, ptr %1871, i64 16
  %offset_tbl_ptr.i.i90.i.i160 = getelementptr i8, ptr %1871, i64 40
  %hash_coef.i.i91.i.i161 = load i64, ptr %hash_coef_ptr.i.i88.i.i158, align 4, !noalias !259
  %tbl_size.i.i92.i.i162 = load i64, ptr %tbl_size_ptr.i.i89.i.i159, align 4, !noalias !259
  %offset_tbl.i.i93.i.i163 = load ptr, ptr %offset_tbl_ptr.i.i90.i.i160, align 8, !noalias !259
  %product.i.i.i94.i.i164 = mul i64 %hash_coef.i.i91.i.i161, 4015701072841558310
  %shifted.i.i.i95.i.i165 = lshr i64 %product.i.i.i94.i.i164, 32
  %xored.i.i.i96.i.i166 = xor i64 %shifted.i.i.i95.i.i165, %product.i.i.i94.i.i164
  %hash.i.i.i97.i.i167 = and i64 %xored.i.i.i96.i.i166, %tbl_size.i.i92.i.i162
  %offset_ptr.i.i98.i.i168 = getelementptr i32, ptr %offset_tbl.i.i93.i.i163, i64 %hash.i.i.i97.i.i167
  %offset.i.i99.i.i169 = load i32, ptr %offset_ptr.i.i98.i.i168, align 4, !noalias !259
  %1943 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1871, 0
  %1944 = insertvalue { ptr, ptr, ptr, i32 } %1943, ptr %1941, 1
  %1945 = insertvalue { ptr, ptr, ptr, i32 } %1944, ptr %1942, 2
  %1946 = insertvalue { ptr, ptr, ptr, i32 } %1945, i32 %offset.i.i99.i.i169, 3
  %1947 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %1948 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1871)
  %1949 = sext i32 %offset.i.i99.i.i169 to i64
  %1950 = getelementptr ptr, ptr %1871, i64 %1949
  %1951 = getelementptr i8, ptr %1950, i64 56
  %1952 = load ptr, ptr %1951, align 8
  %result.i101.i.i170 = call ptr %1952({ ptr, ptr, ptr, i32 } %1946, ptr nocapture nofree noundef nonnull readonly %0) #16
  %1953 = call { ptr, i160 } %result.i101.i.i170({ ptr, ptr, ptr, i32 } %1946, { ptr, ptr, ptr, i32 } %1946, ptr nonnull align 8 %0) #7
  %.fca.0.extract51.i457.i = extractvalue { ptr, i160 } %1953, 0
  %1954 = getelementptr i8, ptr %.fca.0.extract51.i457.i, i64 8
  %1955 = getelementptr i8, ptr %.fca.0.extract51.i457.i, i64 16
  %1956 = getelementptr i8, ptr %.fca.0.extract51.i457.i, i64 24
  %1957 = getelementptr i8, ptr %.fca.0.extract51.i457.i, i64 32
  %1958 = load i64, ptr %1954, align 4
  %1959 = load i64, ptr %1955, align 4
  %1960 = load ptr, ptr %1956, align 8
  %1961 = load ptr, ptr %1957, align 8
  %result.i102.i.i171 = call i1 %1960(i64 %1959, i64 %1958, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %1961) #5
  br i1 %result.i102.i.i171, label %._crit_edge.sink.split.i.i241, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit.i172

._crit_edge.sink.split.i.i241:                    ; preds = %1940, %1937
  %.sink159.i.i242 = phi i64 [ 48, %1937 ], [ 40, %1940 ]
  %1962 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1963 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i.i242
  %1964 = load ptr, ptr %1963, align 8
  %1965 = load ptr, ptr %1964, align 8
  %1966 = call i32 %1965(ptr nonnull %result.i151.i148) #36
  %1967 = add i32 %1966, 1
  %1968 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1969 = getelementptr i8, ptr %1964, i64 8
  %1970 = load ptr, ptr %1969, align 8
  call void %1970(ptr nonnull %result.i151.i148, i32 %1967) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit.i172

HashMap_insert_internal_keyK_valueV_hashPtri32.exit.i172: ; preds = %._crit_edge.sink.split.i.i241, %1940
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %1971 = icmp ult i32 %.0258.i, 999999
  br i1 %1971, label %._crit_edge.i152thread-pre-split, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit.i172
  %1972 = call i64 @clock()
  br label %1973

1973:                                             ; preds = %._crit_edge2.i197, %.lr.ph.i
  %.2262.i = phi i32 [ 0, %.lr.ph.i ], [ %2108, %._crit_edge2.i197 ]
  %.0141261.i = phi i64 [ 0, %.lr.ph.i ], [ %.2143.i, %._crit_edge2.i197 ]
  %.0144260.i = phi i1 [ true, %.lr.ph.i ], [ %.2146.i, %._crit_edge2.i197 ]
  %.sroa.0117.0.insert.ext.i = zext nneg i32 %.2262.i to i160
  %1974 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0117.0.insert.ext.i, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1975 = load ptr, ptr %1569, align 8
  %1976 = call i32 %1975({ ptr, i160 } %1974) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %1977 = load i32, ptr %1572, align 8
  %1978 = add i32 %1977, -1
  %1979 = and i32 %1978, %1976
  %1980 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %1981 = load ptr, ptr %1571, align 8
  %1982 = sext i32 %1979 to i64
  %1983 = shl nsw i64 %1982, 5
  %1984 = getelementptr i8, ptr %1981, i64 %1983
  %1985 = load ptr, ptr %1984, align 8
  %1986 = icmp eq ptr %1985, @nil_typ
  %1987 = icmp eq ptr %1985, null
  %1988 = or i1 %1986, %1987
  br i1 %1988, label %HashMap_find_slot_keyK_hashPtri32.exit.i193, label %.lr.ph.i.i173

.lr.ph.i.i173:                                    ; preds = %1973
  %1989 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %1990

1990:                                             ; preds = %._crit_edge.thread.i.i186, %.lr.ph.i.i173
  %1991 = phi i32 [ %1979, %.lr.ph.i.i173 ], [ %2033, %._crit_edge.thread.i.i186 ]
  %spec.store.select.i550.i = phi i32 [ -1, %.lr.ph.i.i173 ], [ %spec.store.select.i.i190, %._crit_edge.thread.i.i186 ]
  %1992 = phi ptr [ %1985, %.lr.ph.i.i173 ], [ %2038, %._crit_edge.thread.i.i186 ]
  %1993 = phi ptr [ %1984, %.lr.ph.i.i173 ], [ %2037, %._crit_edge.thread.i.i186 ]
  %.sroa_idx.i471.i = getelementptr i8, ptr %1993, i64 16
  %1994 = load i64, ptr %.sroa_idx.i471.i, align 4
  %1995 = getelementptr i8, ptr %1993, i64 8
  %1996 = load i64, ptr %1995, align 4
  %1997 = inttoptr i64 %1996 to ptr
  %1998 = inttoptr i64 %1994 to ptr
  %hash_coef_ptr.i.i56.i.i174 = getelementptr i8, ptr %1992, i64 8
  %tbl_size_ptr.i.i57.i.i175 = getelementptr i8, ptr %1992, i64 16
  %offset_tbl_ptr.i.i58.i.i176 = getelementptr i8, ptr %1992, i64 40
  %hash_coef.i.i59.i.i177 = load i64, ptr %hash_coef_ptr.i.i56.i.i174, align 4
  %tbl_size.i.i60.i.i178 = load i64, ptr %tbl_size_ptr.i.i57.i.i175, align 4
  %offset_tbl.i.i61.i.i179 = load ptr, ptr %offset_tbl_ptr.i.i58.i.i176, align 8
  %product.i.i.i62.i.i180 = mul i64 %hash_coef.i.i59.i.i177, 4015701072841558310
  %shifted.i.i.i63.i.i181 = lshr i64 %product.i.i.i62.i.i180, 32
  %xored.i.i.i64.i.i182 = xor i64 %shifted.i.i.i63.i.i181, %product.i.i.i62.i.i180
  %hash.i.i.i65.i.i183 = and i64 %xored.i.i.i64.i.i182, %tbl_size.i.i60.i.i178
  %offset_ptr.i.i66.i.i184 = getelementptr i32, ptr %offset_tbl.i.i61.i.i179, i64 %hash.i.i.i65.i.i183
  %offset.i.i67.i.i185 = load i32, ptr %offset_ptr.i.i66.i.i184, align 4
  %1999 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %1992, 0
  %2000 = insertvalue { ptr, ptr, ptr, i32 } %1999, ptr %1997, 1
  %2001 = insertvalue { ptr, ptr, ptr, i32 } %2000, ptr %1998, 2
  %2002 = insertvalue { ptr, ptr, ptr, i32 } %2001, i32 %offset.i.i67.i.i185, 3
  %2003 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1992)
  %2004 = sext i32 %offset.i.i67.i.i185 to i64
  %2005 = getelementptr ptr, ptr %1992, i64 %2004
  %2006 = getelementptr i8, ptr %2005, i64 64
  %2007 = load ptr, ptr %2006, align 8
  %result.i.i472.i = call ptr %2007({ ptr, ptr, ptr, i32 } %2002, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2008 = call i32 %result.i.i472.i({ ptr, ptr, ptr, i32 } %2002, { ptr, ptr, ptr, i32 } %2002, ptr nonnull align 8 %0) #7
  %2009 = icmp eq i32 %2008, %1976
  br i1 %2009, label %._crit_edge.i474.i, label %._crit_edge.thread.i.i186

._crit_edge.i474.i:                               ; preds = %1990
  %2010 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2011 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1992)
  %2012 = getelementptr i8, ptr %2005, i64 48
  %2013 = load ptr, ptr %2012, align 8
  %result.i69.i475.i = call ptr %2013({ ptr, ptr, ptr, i32 } %2002, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2014 = call { ptr, i160 } %result.i69.i475.i({ ptr, ptr, ptr, i32 } %2002, { ptr, ptr, ptr, i32 } %2002, ptr nonnull align 8 %0) #7
  %2015 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2016 = load ptr, ptr %1570, align 8
  %2017 = call i1 %2016({ ptr, i160 } %2014, { ptr, i160 } %1974) #7
  br i1 %2017, label %HashMap_find_slot_keyK_hashPtri32.exit.loopexit.i239, label %._crit_edge.thread.i.i186

._crit_edge.thread.i.i186:                        ; preds = %._crit_edge.i474.i, %1990
  %2018 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2019 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %1992)
  %2020 = getelementptr i8, ptr %2005, i64 56
  %2021 = load ptr, ptr %2020, align 8
  %result.i70.i.i187 = call ptr %2021({ ptr, ptr, ptr, i32 } %2002, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2022 = call { ptr, i160 } %result.i70.i.i187({ ptr, ptr, ptr, i32 } %2002, { ptr, ptr, ptr, i32 } %2002, ptr nonnull align 8 %0) #7
  %.fca.0.extract19.i.i188 = extractvalue { ptr, i160 } %2022, 0
  %2023 = getelementptr i8, ptr %.fca.0.extract19.i.i188, i64 8
  %2024 = getelementptr i8, ptr %.fca.0.extract19.i.i188, i64 16
  %2025 = getelementptr i8, ptr %.fca.0.extract19.i.i188, i64 24
  %2026 = getelementptr i8, ptr %.fca.0.extract19.i.i188, i64 32
  %2027 = load i64, ptr %2023, align 4
  %2028 = load i64, ptr %2024, align 4
  %2029 = load ptr, ptr %2025, align 8
  %2030 = load ptr, ptr %2026, align 8
  %result.i71.i473.i = call i1 %2029(i64 %2028, i64 %2027, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %2030) #5
  %2031 = icmp eq i32 %spec.store.select.i550.i, -1
  %or.cond.i.i189 = select i1 %result.i71.i473.i, i1 %2031, i1 false
  %spec.store.select.i.i190 = select i1 %or.cond.i.i189, i32 %1991, i32 %spec.store.select.i550.i
  %2032 = add i32 %1991, 1
  %2033 = and i32 %2032, %1978
  %2034 = load ptr, ptr %1571, align 8
  %2035 = sext i32 %2033 to i64
  %2036 = shl nsw i64 %2035, 5
  %2037 = getelementptr i8, ptr %2034, i64 %2036
  %2038 = load ptr, ptr %2037, align 8
  %2039 = icmp eq ptr %2038, @nil_typ
  %2040 = icmp eq ptr %2038, null
  %2041 = or i1 %2039, %2040
  br i1 %2041, label %._crit_edge105.loopexit.i.i191, label %1990

._crit_edge105.loopexit.i.i191:                   ; preds = %._crit_edge.thread.i.i186
  %2042 = icmp eq i32 %spec.store.select.i.i190, -1
  %.pre.i.pre.i192 = select i1 %2042, i32 %2033, i32 %spec.store.select.i.i190
  br label %HashMap_find_slot_keyK_hashPtri32.exit.i193

HashMap_find_slot_keyK_hashPtri32.exit.loopexit.i239: ; preds = %._crit_edge.i474.i
  %.pre.i240 = load ptr, ptr %1571, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit.i193

HashMap_find_slot_keyK_hashPtri32.exit.i193:      ; preds = %HashMap_find_slot_keyK_hashPtri32.exit.loopexit.i239, %._crit_edge105.loopexit.i.i191, %1973
  %2043 = phi ptr [ %2034, %._crit_edge105.loopexit.i.i191 ], [ %1981, %1973 ], [ %.pre.i240, %HashMap_find_slot_keyK_hashPtri32.exit.loopexit.i239 ]
  %2044 = phi i32 [ %.pre.i.pre.i192, %._crit_edge105.loopexit.i.i191 ], [ %1979, %1973 ], [ %1991, %HashMap_find_slot_keyK_hashPtri32.exit.loopexit.i239 ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %2045 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2046 = sext i32 %2044 to i64
  %2047 = shl nsw i64 %2046, 5
  %2048 = getelementptr i8, ptr %2043, i64 %2047
  %2049 = load ptr, ptr %2048, align 8
  %2050 = icmp ne ptr %2049, @nil_typ
  %2051 = icmp ne ptr %2049, null
  %.not57.i.i194 = and i1 %2050, %2051
  br i1 %.not57.i.i194, label %2052, label %HashMap_get_keyK.exit.thread.i195

2052:                                             ; preds = %HashMap_find_slot_keyK_hashPtri32.exit.i193
  %2053 = getelementptr i8, ptr %2048, i64 8
  %2054 = load i64, ptr %2053, align 4
  %.sroa_idx.i.i215 = getelementptr i8, ptr %2048, i64 16
  %2055 = load i64, ptr %.sroa_idx.i.i215, align 4
  %2056 = inttoptr i64 %2054 to ptr
  %2057 = inttoptr i64 %2055 to ptr
  %hash_coef_ptr.i.i60.i.i216 = getelementptr i8, ptr %2049, i64 8
  %tbl_size_ptr.i.i61.i.i217 = getelementptr i8, ptr %2049, i64 16
  %offset_tbl_ptr.i.i62.i.i218 = getelementptr i8, ptr %2049, i64 40
  %hash_coef.i.i63.i.i219 = load i64, ptr %hash_coef_ptr.i.i60.i.i216, align 4, !noalias !262
  %tbl_size.i.i64.i.i220 = load i64, ptr %tbl_size_ptr.i.i61.i.i217, align 4, !noalias !262
  %offset_tbl.i.i65.i.i221 = load ptr, ptr %offset_tbl_ptr.i.i62.i.i218, align 8, !noalias !262
  %product.i.i.i66.i.i222 = mul i64 %hash_coef.i.i63.i.i219, 4015701072841558310
  %shifted.i.i.i67.i.i223 = lshr i64 %product.i.i.i66.i.i222, 32
  %xored.i.i.i68.i.i224 = xor i64 %shifted.i.i.i67.i.i223, %product.i.i.i66.i.i222
  %hash.i.i.i69.i.i225 = and i64 %xored.i.i.i68.i.i224, %tbl_size.i.i64.i.i220
  %offset_ptr.i.i70.i.i226 = getelementptr i32, ptr %offset_tbl.i.i65.i.i221, i64 %hash.i.i.i69.i.i225
  %offset.i.i71.i.i227 = load i32, ptr %offset_ptr.i.i70.i.i226, align 4, !noalias !262
  %2058 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2049, 0
  %2059 = insertvalue { ptr, ptr, ptr, i32 } %2058, ptr %2056, 1
  %2060 = insertvalue { ptr, ptr, ptr, i32 } %2059, ptr %2057, 2
  %2061 = insertvalue { ptr, ptr, ptr, i32 } %2060, i32 %offset.i.i71.i.i227, 3
  %2062 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2063 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %2049)
  %2064 = sext i32 %offset.i.i71.i.i227 to i64
  %2065 = getelementptr ptr, ptr %2049, i64 %2064
  %2066 = getelementptr i8, ptr %2065, i64 56
  %2067 = load ptr, ptr %2066, align 8
  %result.i73.i.i228 = call ptr %2067({ ptr, ptr, ptr, i32 } %2061, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2068 = call { ptr, i160 } %result.i73.i.i228({ ptr, ptr, ptr, i32 } %2061, { ptr, ptr, ptr, i32 } %2061, ptr nonnull align 8 %0) #7
  %.fca.0.extract51.i.i229 = extractvalue { ptr, i160 } %2068, 0
  %.fca.1.extract52.i.i230 = extractvalue { ptr, i160 } %2068, 1
  %2069 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2070 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %2049)
  %2071 = getelementptr i8, ptr %2065, i64 64
  %2072 = load ptr, ptr %2071, align 8
  %result.i74.i.i231 = call ptr %2072({ ptr, ptr, ptr, i32 } %2061, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2073 = call i32 %result.i74.i.i231({ ptr, ptr, ptr, i32 } %2061, { ptr, ptr, ptr, i32 } %2061, ptr nonnull align 8 %0) #7
  %2074 = icmp eq i32 %2073, %1976
  br i1 %2074, label %._crit_edge.i.i232, label %HashMap_get_keyK.exit.thread.i195

._crit_edge.i.i232:                               ; preds = %2052
  %2075 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2076 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %2049)
  %2077 = getelementptr i8, ptr %2065, i64 48
  %2078 = load ptr, ptr %2077, align 8
  %result.i75.i.i233 = call ptr %2078({ ptr, ptr, ptr, i32 } %2061, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2079 = call { ptr, i160 } %result.i75.i.i233({ ptr, ptr, ptr, i32 } %2061, { ptr, ptr, ptr, i32 } %2061, ptr nonnull align 8 %0) #7
  %2080 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2081 = load ptr, ptr %1570, align 8
  %2082 = call i1 %2081({ ptr, i160 } %2079, { ptr, i160 } %1974) #7
  br i1 %2082, label %HashMap_get_keyK.exit.i234, label %HashMap_get_keyK.exit.thread.i195

HashMap_get_keyK.exit.thread.i195:                ; preds = %._crit_edge.i.i232, %2052, %HashMap_find_slot_keyK_hashPtri32.exit.i193
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  br label %._crit_edge.lr.ph.i.i

HashMap_get_keyK.exit.i234:                       ; preds = %._crit_edge.i.i232
  %2083 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2084 = load ptr, ptr %1564, align 8
  %2085 = load ptr, ptr %2084, align 8
  %2086 = ptrtoint ptr %2085 to i64
  %2087 = getelementptr i8, ptr %.fca.0.extract51.i.i229, i64 8
  %2088 = getelementptr i8, ptr %.fca.0.extract51.i.i229, i64 16
  %2089 = getelementptr i8, ptr %.fca.0.extract51.i.i229, i64 24
  %2090 = getelementptr i8, ptr %.fca.0.extract51.i.i229, i64 32
  %2091 = load i64, ptr %2087, align 4
  %2092 = load i64, ptr %2088, align 4
  %2093 = load ptr, ptr %2089, align 8
  %2094 = load ptr, ptr %2090, align 8
  %2095 = load i64, ptr %2085, align 4
  %result.i77.i.i235 = call i1 %2093(i64 %2092, i64 %2091, i64 %2095, i64 %2086, ptr readonly %2094) #5
  %cond.fr.i.i236 = freeze i1 %result.i77.i.i235
  %spec.select.i.i237 = select i1 %cond.fr.i.i236, ptr %.fca.0.extract51.i.i229, ptr @nil_typ
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %2096 = icmp ne ptr %spec.select.i.i237, @nil_typ
  %2097 = icmp ne ptr %spec.select.i.i237, null
  %.not150.i = and i1 %2096, %2097
  br i1 %.not150.i, label %2098, label %._crit_edge.lr.ph.i.i

2098:                                             ; preds = %HashMap_get_keyK.exit.i234
  %.sroa.2.8.extract.trunc.i238 = trunc i160 %.fca.1.extract52.i.i230 to i32
  %2099 = sext i32 %.sroa.2.8.extract.trunc.i238 to i64
  %2100 = add i64 %.0141261.i, %2099
  br label %._crit_edge2.i197

._crit_edge.lr.ph.i.i:                            ; preds = %HashMap_get_keyK.exit.i234, %HashMap_get_keyK.exit.thread.i195
  %result.i161.i = call noalias align 64 dereferenceable_or_null(56) ptr @bump_malloc_inner(i64 noundef 56, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %2101 = load <55 x i8>, ptr @mbvap_Error_Nil_returned_during_sequential_hit_test_for_key_, align 64
  store <55 x i8> %2101, ptr %result.i161.i, align 64
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2102 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %2103 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i489.i = call noalias dereferenceable_or_null(56) ptr @bump_malloc_inner(i64 noundef 56, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(55) %result.i.i489.i, ptr noundef nonnull align 64 dereferenceable(55) %result.i161.i, i64 55, i1 false)
  %2104 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %2105 = getelementptr i8, ptr %result.i.i489.i, i64 55
  store i8 0, ptr %2105, align 1
  %puts.i.i196 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i489.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %2106 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %2107 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.2262.i) #17
  br label %._crit_edge2.i197

._crit_edge2.i197:                                ; preds = %._crit_edge.lr.ph.i.i, %2098
  %.2146.i = phi i1 [ %.0144260.i, %2098 ], [ false, %._crit_edge.lr.ph.i.i ]
  %.2143.i = phi i64 [ %2100, %2098 ], [ %.0141261.i, %._crit_edge.lr.ph.i.i ]
  %2108 = add nuw nsw i32 %.2262.i, 1
  %2109 = icmp ult i32 %.2262.i, 999999
  br i1 %2109, label %1973, label %._crit_edge.lr.ph.i505.i

._crit_edge.lr.ph.i505.i:                         ; preds = %._crit_edge2.i197
  %2110 = call i64 @clock()
  %result.i167.i = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <18 x i8> <i8 71, i8 101, i8 116, i8 32, i8 83, i8 101, i8 113, i8 117, i8 101, i8 110, i8 116, i8 105, i8 97, i8 108, i8 32, i8 72, i8 105, i8 116>, ptr %result.i167.i, align 32
  %2111 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #34
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2112 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %2113 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i504.i = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i504.i, ptr noundef nonnull align 32 dereferenceable(18) %result.i167.i, i64 18, i1 false)
  %2114 = sub i64 %2110, %1972
  %2115 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %2116 = getelementptr i8, ptr %result.i.i504.i, i64 18
  store i8 0, ptr %2116, align 1
  %puts.i391.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i504.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %result.i97.i.i198 = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i97.i.i198, align 16
  %result.i.i375.i.i199 = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i375.i.i199, ptr noundef nonnull align 16 dereferenceable(14) %result.i97.i.i198, i64 14, i1 false)
  %puts.i.i.i200 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i375.i.i199)
  %2117 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 1000000) #17
  %result.i103.i.i201 = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i103.i.i201, align 16
  %result.i.i389.i.i202 = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i389.i.i202, ptr noundef nonnull align 16 dereferenceable(14) %result.i103.i.i201, i64 14, i1 false)
  %puts.i313.i.i203 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i389.i.i202)
  %2118 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %2114) #17
  %result.i109.i.i204 = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i109.i.i204, align 4
  %result.i.i408.i.i205 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i408.i.i205, ptr noundef nonnull align 4 dereferenceable(3) %result.i109.i.i204, i64 3, i1 false)
  %puts.i333.i.i206 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i408.i.i205)
  %2119 = icmp sgt i64 %2114, 0
  br i1 %2119, label %2120, label %benchmark_get_sequential_hit.exit

2120:                                             ; preds = %._crit_edge.lr.ph.i505.i
  %2121 = mul i64 %2114, 1000000
  %2122 = sdiv i64 %2121, 1000000
  br label %benchmark_get_sequential_hit.exit

benchmark_get_sequential_hit.exit:                ; preds = %._crit_edge.lr.ph.i505.i, %2120
  %.0.i.i207 = phi i64 [ %2122, %2120 ], [ 0, %._crit_edge.lr.ph.i505.i ]
  %result.i114.i.i208 = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i114.i.i208, align 16
  %result.i.i427.i.i209 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i427.i.i209, ptr noundef nonnull align 16 dereferenceable(15) %result.i114.i.i208, i64 15, i1 false)
  %puts.i353.i.i210 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i427.i.i209)
  %2123 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0.i.i207) #17
  %result.i120.i.i211 = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i120.i.i211, align 4
  %result.i.i446.i.i212 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i446.i.i212, ptr noundef nonnull align 4 dereferenceable(3) %result.i120.i.i211, i64 3, i1 false)
  %puts.i373.i.i213 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i446.i.i212)
  %.not.i = icmp eq i64 %.2143.i, 500000500000
  %result.i171.i = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i171.i, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2124 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %2125 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i523.i = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i523.i, ptr noundef nonnull align 32 dereferenceable(18) %result.i171.i, i64 18, i1 false)
  %spec.select.i214 = select i1 %.not.i, i1 %.2146.i, i1 false
  %2126 = getelementptr i8, ptr %result.i.i523.i, i64 18
  store i8 0, ptr %2126, align 1
  %puts.i411.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i523.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %..i = select i1 %spec.select.i214, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %2127 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2128 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %2129 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i542.i = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <4 x i8> %..i, ptr %result.i.i542.i, align 1
  %2130 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %2131 = getelementptr i8, ptr %result.i.i542.i, i64 4
  store i8 0, ptr %2131, align 1
  %puts.i431.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i542.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %.sroa.0224.sroa.0.i)
  %result.i283.i = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i283.i, align 8
  %2132 = getelementptr inbounds i8, ptr %result.i283.i, i64 8
  store ptr @_parameterization_Ptri32, ptr %2132, align 8
  %2133 = getelementptr inbounds i8, ptr %result.i283.i, i64 16
  store ptr @_parameterization_PairPtri32._Ptri32, ptr %2133, align 8
  %2134 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i283.i) #38
  %result.i284.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i.i267)
  %result.i285.i = call i32 @VirtualProtect(ptr nofree %result.i284.i, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i.i267) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i.i267)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i284.i, ptr noalias nofree noundef nonnull readnone @gfgpcwhvzl, ptr noalias nofree noundef nonnull readnone @i32_hasher) #38
  %ret.i.i268 = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i284.i) #39
  %2135 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i284.i) #38
  %result.i286.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i287.i)
  %result.i288.i = call i32 @VirtualProtect(ptr nofree %result.i286.i, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i287.i) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i287.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i286.i, ptr noalias nofree noundef nonnull readnone @ehsipluukj, ptr noalias nofree noundef nonnull readnone @i32_eq) #38
  %ret.i289.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i286.i) #39
  %2136 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i286.i) #38
  %2137 = getelementptr inbounds i8, ptr %result.i283.i, i64 48
  store ptr %ret.i.i268, ptr %2137, align 8
  %2138 = getelementptr inbounds i8, ptr %result.i283.i, i64 56
  store ptr %ret.i289.i, ptr %2138, align 8
  %result.i.i541.i = call noalias dereferenceable_or_null(512) ptr @bump_malloc_inner(i64 noundef 512, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %2139 = getelementptr inbounds i8, ptr %result.i283.i, i64 24
  store ptr %result.i.i541.i, ptr %2139, align 8
  %2140 = getelementptr inbounds i8, ptr %result.i283.i, i64 32
  store i32 16, ptr %2140, align 8
  %result.i4.i.i269 = call noalias dereferenceable_or_null(4000000) ptr @bump_malloc_inner(i64 noundef 4000000, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %2141 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #34
  %result.i326.i = call noalias nonnull align 8 dereferenceable(64) ptr @bump_malloc_inner(i64 noundef 64, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr @_parameterization_Ptri32, ptr %result.i326.i, align 8
  %2142 = getelementptr inbounds i8, ptr %result.i326.i, i64 8
  store ptr @_parameterization_Ptri1, ptr %2142, align 8
  %2143 = getelementptr inbounds i8, ptr %result.i326.i, i64 16
  store ptr @_parameterization_PairPtri32._Ptri1, ptr %2143, align 8
  %2144 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i326.i)
  %result.i327.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i328.i)
  %result.i329.i = call i32 @VirtualProtect(ptr nofree %result.i327.i, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i328.i) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i328.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i327.i, ptr noalias nofree noundef nonnull readnone @njmyxpctxz, ptr noalias nofree noundef nonnull readnone @i32_hasher)
  %ret.i330.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i327.i) #39
  %2145 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i327.i)
  %result.i331.i = call noalias dereferenceable_or_null(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %oldProtect.i332.i)
  %result.i333.i = call i32 @VirtualProtect(ptr nofree %result.i331.i, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect.i332.i) #25
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %oldProtect.i332.i)
  call void @llvm.init.trampoline(ptr nocapture nofree writeonly %result.i331.i, ptr noalias nofree noundef nonnull readnone @egzihtnwnj, ptr noalias nofree noundef nonnull readnone @i32_eq)
  %ret.i334.i = call ptr @llvm.adjust.trampoline(ptr nofree readonly %result.i331.i) #39
  %2146 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree %result.i331.i)
  %2147 = getelementptr inbounds i8, ptr %result.i326.i, i64 48
  store ptr %ret.i330.i, ptr %2147, align 8
  %2148 = getelementptr inbounds i8, ptr %result.i326.i, i64 56
  store ptr %ret.i334.i, ptr %2148, align 8
  %result.i.i581.i = call noalias dereferenceable_or_null(512) ptr @bump_malloc_inner(i64 noundef 512, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %2149 = getelementptr inbounds i8, ptr %result.i326.i, i64 24
  store ptr %result.i.i581.i, ptr %2149, align 8
  %2150 = getelementptr inbounds i8, ptr %result.i326.i, i64 32
  store i32 16, ptr %2150, align 8
  %2151 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %2152 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @PRNG) #34
  %2153 = getelementptr inbounds i8, ptr %result.i283.i, i64 40
  %2154 = getelementptr inbounds i8, ptr %result.i326.i, i64 40
  %2155 = getelementptr inbounds i8, ptr %result.i283.i, i64 36
  %2156 = getelementptr inbounds i8, ptr %result.i326.i, i64 36
  %2157 = getelementptr inbounds i8, ptr %2, i64 8
  %2158 = getelementptr inbounds i8, ptr %2, i64 16
  %2159 = getelementptr inbounds i8, ptr %1, i64 8
  %2160 = getelementptr inbounds i8, ptr %1, i64 16
  br label %2161

2161:                                             ; preds = %._crit_edge1.i, %benchmark_get_sequential_hit.exit
  %2162 = phi i32 [ 456, %benchmark_get_sequential_hit.exit ], [ %2165, %._crit_edge1.i ]
  %.0264529.i = phi i32 [ 0, %benchmark_get_sequential_hit.exit ], [ %3083, %._crit_edge1.i ]
  %.0266528.i = phi i32 [ 0, %benchmark_get_sequential_hit.exit ], [ %.2268.i, %._crit_edge1.i ]
  %.0275527.i = phi i64 [ 0, %benchmark_get_sequential_hit.exit ], [ %.2277.i, %._crit_edge1.i ]
  %2163 = mul i32 %2162, 1103515245
  %2164 = add i32 %2163, 12345
  %2165 = and i32 %2164, 2147483647
  %.sroa.0252.0.insert.ext.i = zext nneg i32 %2165 to i160
  %2166 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.0252.0.insert.ext.i, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2167 = load ptr, ptr %2147, align 8
  %2168 = call i32 %2167({ ptr, i160 } %2166) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2169 = load i32, ptr %2150, align 8
  %2170 = add i32 %2169, -1
  %2171 = and i32 %2170, %2168
  %2172 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2173 = load ptr, ptr %2149, align 8
  %2174 = sext i32 %2171 to i64
  %2175 = shl nsw i64 %2174, 5
  %2176 = getelementptr i8, ptr %2173, i64 %2175
  %2177 = load ptr, ptr %2176, align 8
  %2178 = icmp eq ptr %2177, @nil_typ
  %2179 = icmp eq ptr %2177, null
  %2180 = or i1 %2178, %2179
  br i1 %2180, label %HashMap_find_slot_keyK_hashPtri32.exit.i293, label %.lr.ph.i.i271

.lr.ph.i.i271:                                    ; preds = %2161
  %2181 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %2182

2182:                                             ; preds = %._crit_edge.thread.i.i285, %.lr.ph.i.i271
  %2183 = phi i32 [ %2171, %.lr.ph.i.i271 ], [ %2225, %._crit_edge.thread.i.i285 ]
  %spec.store.select.i1193.i = phi i32 [ -1, %.lr.ph.i.i271 ], [ %spec.store.select.i.i290, %._crit_edge.thread.i.i285 ]
  %2184 = phi ptr [ %2177, %.lr.ph.i.i271 ], [ %2230, %._crit_edge.thread.i.i285 ]
  %2185 = phi ptr [ %2176, %.lr.ph.i.i271 ], [ %2229, %._crit_edge.thread.i.i285 ]
  %.sroa_idx.i929.i = getelementptr i8, ptr %2185, i64 16
  %2186 = load i64, ptr %.sroa_idx.i929.i, align 4
  %2187 = getelementptr i8, ptr %2185, i64 8
  %2188 = load i64, ptr %2187, align 4
  %2189 = inttoptr i64 %2188 to ptr
  %2190 = inttoptr i64 %2186 to ptr
  %hash_coef_ptr.i.i56.i.i272 = getelementptr i8, ptr %2184, i64 8
  %tbl_size_ptr.i.i57.i.i273 = getelementptr i8, ptr %2184, i64 16
  %offset_tbl_ptr.i.i58.i.i274 = getelementptr i8, ptr %2184, i64 40
  %hash_coef.i.i59.i.i275 = load i64, ptr %hash_coef_ptr.i.i56.i.i272, align 4
  %tbl_size.i.i60.i.i276 = load i64, ptr %tbl_size_ptr.i.i57.i.i273, align 4
  %offset_tbl.i.i61.i.i277 = load ptr, ptr %offset_tbl_ptr.i.i58.i.i274, align 8
  %product.i.i.i62.i.i278 = mul i64 %hash_coef.i.i59.i.i275, 4015701072841558310
  %shifted.i.i.i63.i.i279 = lshr i64 %product.i.i.i62.i.i278, 32
  %xored.i.i.i64.i.i280 = xor i64 %shifted.i.i.i63.i.i279, %product.i.i.i62.i.i278
  %hash.i.i.i65.i.i281 = and i64 %xored.i.i.i64.i.i280, %tbl_size.i.i60.i.i276
  %offset_ptr.i.i66.i.i282 = getelementptr i32, ptr %offset_tbl.i.i61.i.i277, i64 %hash.i.i.i65.i.i281
  %offset.i.i67.i.i283 = load i32, ptr %offset_ptr.i.i66.i.i282, align 4
  %2191 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2184, 0
  %2192 = insertvalue { ptr, ptr, ptr, i32 } %2191, ptr %2189, 1
  %2193 = insertvalue { ptr, ptr, ptr, i32 } %2192, ptr %2190, 2
  %2194 = insertvalue { ptr, ptr, ptr, i32 } %2193, i32 %offset.i.i67.i.i283, 3
  %2195 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %2184)
  %2196 = sext i32 %offset.i.i67.i.i283 to i64
  %2197 = getelementptr ptr, ptr %2184, i64 %2196
  %2198 = getelementptr i8, ptr %2197, i64 64
  %2199 = load ptr, ptr %2198, align 8
  %result.i.i.i284 = call ptr %2199({ ptr, ptr, ptr, i32 } %2194, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2200 = call i32 %result.i.i.i284({ ptr, ptr, ptr, i32 } %2194, { ptr, ptr, ptr, i32 } %2194, ptr nonnull align 8 %0) #7
  %2201 = icmp eq i32 %2200, %2168
  br i1 %2201, label %._crit_edge.i930.i, label %._crit_edge.thread.i.i285

._crit_edge.i930.i:                               ; preds = %2182
  %2202 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2203 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %2184)
  %2204 = getelementptr i8, ptr %2197, i64 48
  %2205 = load ptr, ptr %2204, align 8
  %result.i69.i.i387 = call ptr %2205({ ptr, ptr, ptr, i32 } %2194, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2206 = call { ptr, i160 } %result.i69.i.i387({ ptr, ptr, ptr, i32 } %2194, { ptr, ptr, ptr, i32 } %2194, ptr nonnull align 8 %0) #7
  %2207 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2208 = load ptr, ptr %2148, align 8
  %2209 = call i1 %2208({ ptr, i160 } %2206, { ptr, i160 } %2166) #7
  br i1 %2209, label %HashMap_find_slot_keyK_hashPtri32.exit.loopexit.i388, label %._crit_edge.thread.i.i285

._crit_edge.thread.i.i285:                        ; preds = %._crit_edge.i930.i, %2182
  %2210 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2211 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %2184)
  %2212 = getelementptr i8, ptr %2197, i64 56
  %2213 = load ptr, ptr %2212, align 8
  %result.i70.i.i286 = call ptr %2213({ ptr, ptr, ptr, i32 } %2194, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2214 = call { ptr, i160 } %result.i70.i.i286({ ptr, ptr, ptr, i32 } %2194, { ptr, ptr, ptr, i32 } %2194, ptr nonnull align 8 %0) #7
  %.fca.0.extract19.i.i287 = extractvalue { ptr, i160 } %2214, 0
  %2215 = getelementptr i8, ptr %.fca.0.extract19.i.i287, i64 8
  %2216 = getelementptr i8, ptr %.fca.0.extract19.i.i287, i64 16
  %2217 = getelementptr i8, ptr %.fca.0.extract19.i.i287, i64 24
  %2218 = getelementptr i8, ptr %.fca.0.extract19.i.i287, i64 32
  %2219 = load i64, ptr %2215, align 4
  %2220 = load i64, ptr %2216, align 4
  %2221 = load ptr, ptr %2217, align 8
  %2222 = load ptr, ptr %2218, align 8
  %result.i71.i.i288 = call i1 %2221(i64 %2220, i64 %2219, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %2222) #5
  %2223 = icmp eq i32 %spec.store.select.i1193.i, -1
  %or.cond.i.i289 = select i1 %result.i71.i.i288, i1 %2223, i1 false
  %spec.store.select.i.i290 = select i1 %or.cond.i.i289, i32 %2183, i32 %spec.store.select.i1193.i
  %2224 = add i32 %2183, 1
  %2225 = and i32 %2224, %2170
  %2226 = load ptr, ptr %2149, align 8
  %2227 = sext i32 %2225 to i64
  %2228 = shl nsw i64 %2227, 5
  %2229 = getelementptr i8, ptr %2226, i64 %2228
  %2230 = load ptr, ptr %2229, align 8
  %2231 = icmp eq ptr %2230, @nil_typ
  %2232 = icmp eq ptr %2230, null
  %2233 = or i1 %2231, %2232
  br i1 %2233, label %._crit_edge105.loopexit.i.i291, label %2182

._crit_edge105.loopexit.i.i291:                   ; preds = %._crit_edge.thread.i.i285
  %2234 = icmp eq i32 %spec.store.select.i.i290, -1
  %.pre.i.pre.i292 = select i1 %2234, i32 %2225, i32 %spec.store.select.i.i290
  br label %HashMap_find_slot_keyK_hashPtri32.exit.i293

HashMap_find_slot_keyK_hashPtri32.exit.loopexit.i388: ; preds = %._crit_edge.i930.i
  %.pre.i389 = load ptr, ptr %2149, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit.i293

HashMap_find_slot_keyK_hashPtri32.exit.i293:      ; preds = %HashMap_find_slot_keyK_hashPtri32.exit.loopexit.i388, %._crit_edge105.loopexit.i.i291, %2161
  %2235 = phi ptr [ %2226, %._crit_edge105.loopexit.i.i291 ], [ %2173, %2161 ], [ %.pre.i389, %HashMap_find_slot_keyK_hashPtri32.exit.loopexit.i388 ]
  %2236 = phi i32 [ %.pre.i.pre.i292, %._crit_edge105.loopexit.i.i291 ], [ %2171, %2161 ], [ %2183, %HashMap_find_slot_keyK_hashPtri32.exit.loopexit.i388 ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %2237 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2238 = sext i32 %2236 to i64
  %2239 = shl nsw i64 %2238, 5
  %2240 = getelementptr i8, ptr %2235, i64 %2239
  %2241 = load ptr, ptr %2240, align 8
  %2242 = icmp ne ptr %2241, @nil_typ
  %2243 = icmp ne ptr %2241, null
  %.not57.i.i294 = and i1 %2242, %2243
  br i1 %.not57.i.i294, label %2244, label %HashMap_get_keyK.exit.thread.i295

2244:                                             ; preds = %HashMap_find_slot_keyK_hashPtri32.exit.i293
  %2245 = getelementptr i8, ptr %2240, i64 8
  %2246 = load i64, ptr %2245, align 4
  %.sroa_idx.i.i365 = getelementptr i8, ptr %2240, i64 16
  %2247 = load i64, ptr %.sroa_idx.i.i365, align 4
  %2248 = inttoptr i64 %2246 to ptr
  %2249 = inttoptr i64 %2247 to ptr
  %hash_coef_ptr.i.i60.i.i366 = getelementptr i8, ptr %2241, i64 8
  %tbl_size_ptr.i.i61.i.i367 = getelementptr i8, ptr %2241, i64 16
  %offset_tbl_ptr.i.i62.i.i368 = getelementptr i8, ptr %2241, i64 40
  %hash_coef.i.i63.i.i369 = load i64, ptr %hash_coef_ptr.i.i60.i.i366, align 4, !noalias !265
  %tbl_size.i.i64.i.i370 = load i64, ptr %tbl_size_ptr.i.i61.i.i367, align 4, !noalias !265
  %offset_tbl.i.i65.i.i371 = load ptr, ptr %offset_tbl_ptr.i.i62.i.i368, align 8, !noalias !265
  %product.i.i.i66.i.i372 = mul i64 %hash_coef.i.i63.i.i369, 4015701072841558310
  %shifted.i.i.i67.i.i373 = lshr i64 %product.i.i.i66.i.i372, 32
  %xored.i.i.i68.i.i374 = xor i64 %shifted.i.i.i67.i.i373, %product.i.i.i66.i.i372
  %hash.i.i.i69.i.i375 = and i64 %xored.i.i.i68.i.i374, %tbl_size.i.i64.i.i370
  %offset_ptr.i.i70.i.i376 = getelementptr i32, ptr %offset_tbl.i.i65.i.i371, i64 %hash.i.i.i69.i.i375
  %offset.i.i71.i.i377 = load i32, ptr %offset_ptr.i.i70.i.i376, align 4, !noalias !265
  %2250 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2241, 0
  %2251 = insertvalue { ptr, ptr, ptr, i32 } %2250, ptr %2248, 1
  %2252 = insertvalue { ptr, ptr, ptr, i32 } %2251, ptr %2249, 2
  %2253 = insertvalue { ptr, ptr, ptr, i32 } %2252, i32 %offset.i.i71.i.i377, 3
  %2254 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2255 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %2241)
  %2256 = sext i32 %offset.i.i71.i.i377 to i64
  %2257 = getelementptr ptr, ptr %2241, i64 %2256
  %2258 = getelementptr i8, ptr %2257, i64 56
  %2259 = load ptr, ptr %2258, align 8
  %result.i73.i.i378 = call ptr %2259({ ptr, ptr, ptr, i32 } %2253, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2260 = call { ptr, i160 } %result.i73.i.i378({ ptr, ptr, ptr, i32 } %2253, { ptr, ptr, ptr, i32 } %2253, ptr nonnull align 8 %0) #7
  %.fca.0.extract51.i.i379 = extractvalue { ptr, i160 } %2260, 0
  %2261 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2262 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %2241)
  %2263 = getelementptr i8, ptr %2257, i64 64
  %2264 = load ptr, ptr %2263, align 8
  %result.i74.i.i380 = call ptr %2264({ ptr, ptr, ptr, i32 } %2253, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2265 = call i32 %result.i74.i.i380({ ptr, ptr, ptr, i32 } %2253, { ptr, ptr, ptr, i32 } %2253, ptr nonnull align 8 %0) #7
  %2266 = icmp eq i32 %2265, %2168
  br i1 %2266, label %._crit_edge.i.i381, label %HashMap_get_keyK.exit.thread.i295

._crit_edge.i.i381:                               ; preds = %2244
  %2267 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2268 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %2241)
  %2269 = getelementptr i8, ptr %2257, i64 48
  %2270 = load ptr, ptr %2269, align 8
  %result.i75.i.i382 = call ptr %2270({ ptr, ptr, ptr, i32 } %2253, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2271 = call { ptr, i160 } %result.i75.i.i382({ ptr, ptr, ptr, i32 } %2253, { ptr, ptr, ptr, i32 } %2253, ptr nonnull align 8 %0) #7
  %2272 = load ptr, ptr %2148, align 8
  %2273 = call i1 %2272({ ptr, i160 } %2271, { ptr, i160 } %2166) #7
  br i1 %2273, label %HashMap_get_keyK.exit.i383, label %HashMap_get_keyK.exit.thread.i295

HashMap_get_keyK.exit.thread.i295:                ; preds = %._crit_edge.i.i381, %2244, %HashMap_find_slot_keyK_hashPtri32.exit.i293
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  br label %2290

HashMap_get_keyK.exit.i383:                       ; preds = %._crit_edge.i.i381
  %2274 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2275 = load ptr, ptr %2142, align 8
  %2276 = load ptr, ptr %2275, align 8
  %2277 = ptrtoint ptr %2276 to i64
  %2278 = getelementptr i8, ptr %.fca.0.extract51.i.i379, i64 8
  %2279 = getelementptr i8, ptr %.fca.0.extract51.i.i379, i64 16
  %2280 = getelementptr i8, ptr %.fca.0.extract51.i.i379, i64 24
  %2281 = getelementptr i8, ptr %.fca.0.extract51.i.i379, i64 32
  %2282 = load i64, ptr %2278, align 4
  %2283 = load i64, ptr %2279, align 4
  %2284 = load ptr, ptr %2280, align 8
  %2285 = load ptr, ptr %2281, align 8
  %2286 = load i64, ptr %2276, align 4
  %result.i77.i.i384 = call i1 %2284(i64 %2283, i64 %2282, i64 %2286, i64 %2277, ptr readonly %2285) #5
  %cond.fr.i.i385 = freeze i1 %result.i77.i.i384
  %spec.select.i.i386 = select i1 %cond.fr.i.i385, ptr %.fca.0.extract51.i.i379, ptr @nil_typ
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %2287 = icmp eq ptr %spec.select.i.i386, @nil_typ
  %2288 = icmp eq ptr %spec.select.i.i386, null
  %2289 = or i1 %2287, %2288
  br i1 %2289, label %2290, label %._crit_edge1.i

2290:                                             ; preds = %HashMap_get_keyK.exit.i383, %HashMap_get_keyK.exit.thread.i295
  %2291 = add nuw i32 %2165, 1
  %.sroa.0234.0.insert.ext.i = zext i32 %2291 to i160
  %2292 = load i32, ptr %2153, align 8
  %2293 = load i32, ptr %2140, align 8
  %2294 = icmp eq i32 %2293, 0
  %2295 = mul i32 %2292, 10
  %2296 = add i32 %2295, 10
  %2297 = mul i32 %2293, 6
  %2298 = icmp sge i32 %2296, %2297
  %.0.i943.i = select i1 %2294, i1 true, i1 %2298
  br i1 %.0.i943.i, label %._crit_edge1.i945.i, label %HashMap_ensure_capacity_required_loadPtri32.exit.i296

._crit_edge1.i945.i:                              ; preds = %2290
  %2299 = shl i32 %2293, 1
  %spec.select.i946.i = call i32 @llvm.smax.i32(i32 %2299, i32 16)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2300 = load ptr, ptr %2139, align 8
  %2301 = zext nneg i32 %spec.select.i946.i to i64
  %2302 = shl nuw nsw i64 %2301, 5
  %result.i.i1243.i = call noalias ptr @bump_malloc_inner(i64 noundef %2302, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1243.i, ptr %2139, align 8
  store i32 %spec.select.i946.i, ptr %2140, align 8
  store i32 0, ptr %2155, align 4
  %2303 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #38
  store i32 0, ptr %2153, align 8
  %2304 = icmp sgt i32 %2293, 0
  br i1 %2304, label %.lr.ph.i1244.i, label %HashMap_resize_new_capacityPtri32.exit.i343

.lr.ph.i1244.i:                                   ; preds = %._crit_edge1.i945.i, %._crit_edge.i1245.i
  %.096.i.i344 = phi i32 [ %2507, %._crit_edge.i1245.i ], [ 0, %._crit_edge1.i945.i ]
  %2305 = zext nneg i32 %.096.i.i344 to i64
  %2306 = shl nuw nsw i64 %2305, 5
  %2307 = getelementptr i8, ptr %2300, i64 %2306
  %2308 = load ptr, ptr %2307, align 8
  %2309 = icmp ne ptr %2308, @nil_typ
  %2310 = icmp ne ptr %2308, null
  %.not40.i.i345 = and i1 %2309, %2310
  br i1 %.not40.i.i345, label %2311, label %._crit_edge.i1245.i

2311:                                             ; preds = %.lr.ph.i1244.i
  %2312 = getelementptr i8, ptr %2307, i64 8
  %2313 = load i64, ptr %2312, align 4
  %.sroa_idx.i1246.i = getelementptr i8, ptr %2307, i64 16
  %2314 = load i64, ptr %.sroa_idx.i1246.i, align 4
  %2315 = inttoptr i64 %2313 to ptr
  %2316 = inttoptr i64 %2314 to ptr
  %hash_coef_ptr.i.i42.i.i346 = getelementptr i8, ptr %2308, i64 8
  %tbl_size_ptr.i.i43.i.i347 = getelementptr i8, ptr %2308, i64 16
  %offset_tbl_ptr.i.i44.i.i348 = getelementptr i8, ptr %2308, i64 40
  %hash_coef.i.i45.i.i349 = load i64, ptr %hash_coef_ptr.i.i42.i.i346, align 4, !noalias !268
  %tbl_size.i.i46.i.i350 = load i64, ptr %tbl_size_ptr.i.i43.i.i347, align 4, !noalias !268
  %offset_tbl.i.i47.i.i351 = load ptr, ptr %offset_tbl_ptr.i.i44.i.i348, align 8, !noalias !268
  %product.i.i.i48.i.i352 = mul i64 %hash_coef.i.i45.i.i349, 4015701072841558310
  %shifted.i.i.i49.i.i353 = lshr i64 %product.i.i.i48.i.i352, 32
  %xored.i.i.i50.i.i354 = xor i64 %shifted.i.i.i49.i.i353, %product.i.i.i48.i.i352
  %hash.i.i.i51.i.i355 = and i64 %xored.i.i.i50.i.i354, %tbl_size.i.i46.i.i350
  %offset_ptr.i.i52.i.i356 = getelementptr i32, ptr %offset_tbl.i.i47.i.i351, i64 %hash.i.i.i51.i.i355
  %offset.i.i53.i.i357 = load i32, ptr %offset_ptr.i.i52.i.i356, align 4, !noalias !268
  %2317 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2308, 0
  %2318 = insertvalue { ptr, ptr, ptr, i32 } %2317, ptr %2315, 1
  %2319 = insertvalue { ptr, ptr, ptr, i32 } %2318, ptr %2316, 2
  %2320 = insertvalue { ptr, ptr, ptr, i32 } %2319, i32 %offset.i.i53.i.i357, 3
  %2321 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2322 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %2308)
  %2323 = sext i32 %offset.i.i53.i.i357 to i64
  %2324 = getelementptr ptr, ptr %2308, i64 %2323
  %2325 = getelementptr i8, ptr %2324, i64 56
  %2326 = load ptr, ptr %2325, align 8
  %result.i55.i.i358 = call ptr %2326({ ptr, ptr, ptr, i32 } %2320, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2327 = call { ptr, i160 } %result.i55.i.i358({ ptr, ptr, ptr, i32 } %2320, { ptr, ptr, ptr, i32 } %2320, ptr nonnull align 8 %0) #7
  %.fca.0.extract29.i.i359 = extractvalue { ptr, i160 } %2327, 0
  %2328 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2329 = load ptr, ptr %2132, align 8
  %2330 = load ptr, ptr %2329, align 8
  %2331 = ptrtoint ptr %2330 to i64
  %2332 = getelementptr i8, ptr %.fca.0.extract29.i.i359, i64 8
  %2333 = getelementptr i8, ptr %.fca.0.extract29.i.i359, i64 16
  %2334 = getelementptr i8, ptr %.fca.0.extract29.i.i359, i64 24
  %2335 = getelementptr i8, ptr %.fca.0.extract29.i.i359, i64 32
  %2336 = load i64, ptr %2332, align 4
  %2337 = load i64, ptr %2333, align 4
  %2338 = load ptr, ptr %2334, align 8
  %2339 = load ptr, ptr %2335, align 8
  %2340 = load i64, ptr %2330, align 4
  %result.i57.i.i360 = call i1 %2338(i64 %2337, i64 %2336, i64 %2340, i64 %2331, ptr readonly %2339) #5
  br i1 %result.i57.i.i360, label %2341, label %._crit_edge.i1245.i

2341:                                             ; preds = %2311
  %2342 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2343 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %2308)
  %2344 = getelementptr i8, ptr %2324, i64 48
  %2345 = load ptr, ptr %2344, align 8
  %result.i58.i.i361 = call ptr %2345({ ptr, ptr, ptr, i32 } %2320, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2346 = call { ptr, i160 } %result.i58.i.i361({ ptr, ptr, ptr, i32 } %2320, { ptr, ptr, ptr, i32 } %2320, ptr nonnull align 8 %0) #7
  %2347 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2348 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %2308)
  %2349 = getelementptr i8, ptr %2324, i64 64
  %2350 = load ptr, ptr %2349, align 8
  %result.i59.i.i362 = call ptr %2350({ ptr, ptr, ptr, i32 } %2320, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2351 = call i32 %result.i59.i.i362({ ptr, ptr, ptr, i32 } %2320, { ptr, ptr, ptr, i32 } %2320, ptr nonnull align 8 %0) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %2)
  %2352 = load ptr, ptr %result.i283.i, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2353 = load i32, ptr %2140, align 8
  %2354 = add i32 %2353, -1
  %2355 = and i32 %2354, %2351
  %2356 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2357 = load ptr, ptr %2139, align 8
  %2358 = sext i32 %2355 to i64
  %2359 = shl nsw i64 %2358, 5
  %2360 = getelementptr i8, ptr %2357, i64 %2359
  %2361 = load ptr, ptr %2360, align 8
  %2362 = icmp eq ptr %2361, @nil_typ
  %2363 = icmp eq ptr %2361, null
  %2364 = or i1 %2362, %2363
  br i1 %2364, label %HashMap_find_slot_keyK_hashPtri32.exit1701.i, label %.lr.ph.i1677.i

.lr.ph.i1677.i:                                   ; preds = %2341
  %2365 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %2366

2366:                                             ; preds = %._crit_edge.thread.i1692.i, %.lr.ph.i1677.i
  %2367 = phi i32 [ %2355, %.lr.ph.i1677.i ], [ %2409, %._crit_edge.thread.i1692.i ]
  %spec.store.select.i16971767.i = phi i32 [ -1, %.lr.ph.i1677.i ], [ %spec.store.select.i1697.i, %._crit_edge.thread.i1692.i ]
  %2368 = phi ptr [ %2361, %.lr.ph.i1677.i ], [ %2414, %._crit_edge.thread.i1692.i ]
  %2369 = phi ptr [ %2360, %.lr.ph.i1677.i ], [ %2413, %._crit_edge.thread.i1692.i ]
  %.sroa_idx.i1678.i = getelementptr i8, ptr %2369, i64 16
  %2370 = load i64, ptr %.sroa_idx.i1678.i, align 4
  %2371 = getelementptr i8, ptr %2369, i64 8
  %2372 = load i64, ptr %2371, align 4
  %2373 = inttoptr i64 %2372 to ptr
  %2374 = inttoptr i64 %2370 to ptr
  %hash_coef_ptr.i.i56.i1679.i = getelementptr i8, ptr %2368, i64 8
  %tbl_size_ptr.i.i57.i1680.i = getelementptr i8, ptr %2368, i64 16
  %offset_tbl_ptr.i.i58.i1681.i = getelementptr i8, ptr %2368, i64 40
  %hash_coef.i.i59.i1682.i = load i64, ptr %hash_coef_ptr.i.i56.i1679.i, align 4
  %tbl_size.i.i60.i1683.i = load i64, ptr %tbl_size_ptr.i.i57.i1680.i, align 4
  %offset_tbl.i.i61.i1684.i = load ptr, ptr %offset_tbl_ptr.i.i58.i1681.i, align 8
  %product.i.i.i62.i1685.i = mul i64 %hash_coef.i.i59.i1682.i, 4015701072841558310
  %shifted.i.i.i63.i1686.i = lshr i64 %product.i.i.i62.i1685.i, 32
  %xored.i.i.i64.i1687.i = xor i64 %shifted.i.i.i63.i1686.i, %product.i.i.i62.i1685.i
  %hash.i.i.i65.i1688.i = and i64 %xored.i.i.i64.i1687.i, %tbl_size.i.i60.i1683.i
  %offset_ptr.i.i66.i1689.i = getelementptr i32, ptr %offset_tbl.i.i61.i1684.i, i64 %hash.i.i.i65.i1688.i
  %offset.i.i67.i1690.i = load i32, ptr %offset_ptr.i.i66.i1689.i, align 4
  %2375 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2368, 0
  %2376 = insertvalue { ptr, ptr, ptr, i32 } %2375, ptr %2373, 1
  %2377 = insertvalue { ptr, ptr, ptr, i32 } %2376, ptr %2374, 2
  %2378 = insertvalue { ptr, ptr, ptr, i32 } %2377, i32 %offset.i.i67.i1690.i, 3
  %2379 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %2368)
  %2380 = sext i32 %offset.i.i67.i1690.i to i64
  %2381 = getelementptr ptr, ptr %2368, i64 %2380
  %2382 = getelementptr i8, ptr %2381, i64 64
  %2383 = load ptr, ptr %2382, align 8
  %result.i.i1691.i = call ptr %2383({ ptr, ptr, ptr, i32 } %2378, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2384 = call i32 %result.i.i1691.i({ ptr, ptr, ptr, i32 } %2378, { ptr, ptr, ptr, i32 } %2378, ptr nonnull align 8 %0) #7
  %2385 = icmp eq i32 %2384, %2351
  br i1 %2385, label %._crit_edge.i1699.i, label %._crit_edge.thread.i1692.i

._crit_edge.i1699.i:                              ; preds = %2366
  %2386 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2387 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %2368)
  %2388 = getelementptr i8, ptr %2381, i64 48
  %2389 = load ptr, ptr %2388, align 8
  %result.i69.i1700.i = call ptr %2389({ ptr, ptr, ptr, i32 } %2378, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2390 = call { ptr, i160 } %result.i69.i1700.i({ ptr, ptr, ptr, i32 } %2378, { ptr, ptr, ptr, i32 } %2378, ptr nonnull align 8 %0) #7
  %2391 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2392 = load ptr, ptr %2138, align 8
  %2393 = call i1 %2392({ ptr, i160 } %2390, { ptr, i160 } %2346) #7
  br i1 %2393, label %HashMap_find_slot_keyK_hashPtri32.exit1701.loopexit.i, label %._crit_edge.thread.i1692.i

._crit_edge.thread.i1692.i:                       ; preds = %._crit_edge.i1699.i, %2366
  %2394 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2395 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %2368)
  %2396 = getelementptr i8, ptr %2381, i64 56
  %2397 = load ptr, ptr %2396, align 8
  %result.i70.i1693.i = call ptr %2397({ ptr, ptr, ptr, i32 } %2378, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2398 = call { ptr, i160 } %result.i70.i1693.i({ ptr, ptr, ptr, i32 } %2378, { ptr, ptr, ptr, i32 } %2378, ptr nonnull align 8 %0) #7
  %.fca.0.extract19.i1694.i = extractvalue { ptr, i160 } %2398, 0
  %2399 = getelementptr i8, ptr %.fca.0.extract19.i1694.i, i64 8
  %2400 = getelementptr i8, ptr %.fca.0.extract19.i1694.i, i64 16
  %2401 = getelementptr i8, ptr %.fca.0.extract19.i1694.i, i64 24
  %2402 = getelementptr i8, ptr %.fca.0.extract19.i1694.i, i64 32
  %2403 = load i64, ptr %2399, align 4
  %2404 = load i64, ptr %2400, align 4
  %2405 = load ptr, ptr %2401, align 8
  %2406 = load ptr, ptr %2402, align 8
  %result.i71.i1695.i = call i1 %2405(i64 %2404, i64 %2403, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %2406) #5
  %2407 = icmp eq i32 %spec.store.select.i16971767.i, -1
  %or.cond.i1696.i = select i1 %result.i71.i1695.i, i1 %2407, i1 false
  %spec.store.select.i1697.i = select i1 %or.cond.i1696.i, i32 %2367, i32 %spec.store.select.i16971767.i
  %2408 = add i32 %2367, 1
  %2409 = and i32 %2408, %2354
  %2410 = load ptr, ptr %2139, align 8
  %2411 = sext i32 %2409 to i64
  %2412 = shl nsw i64 %2411, 5
  %2413 = getelementptr i8, ptr %2410, i64 %2412
  %2414 = load ptr, ptr %2413, align 8
  %2415 = icmp eq ptr %2414, @nil_typ
  %2416 = icmp eq ptr %2414, null
  %2417 = or i1 %2415, %2416
  br i1 %2417, label %._crit_edge105.loopexit.i1698.i, label %2366

._crit_edge105.loopexit.i1698.i:                  ; preds = %._crit_edge.thread.i1692.i
  %2418 = icmp eq i32 %spec.store.select.i1697.i, -1
  %.pre.i.pre1806.i = select i1 %2418, i32 %2409, i32 %spec.store.select.i1697.i
  br label %HashMap_find_slot_keyK_hashPtri32.exit1701.i

HashMap_find_slot_keyK_hashPtri32.exit1701.loopexit.i: ; preds = %._crit_edge.i1699.i
  %.pre1876.i = load ptr, ptr %2139, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit1701.i

HashMap_find_slot_keyK_hashPtri32.exit1701.i:     ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1701.loopexit.i, %._crit_edge105.loopexit.i1698.i, %2341
  %2419 = phi ptr [ %2410, %._crit_edge105.loopexit.i1698.i ], [ %2357, %2341 ], [ %.pre1876.i, %HashMap_find_slot_keyK_hashPtri32.exit1701.loopexit.i ]
  %2420 = phi i32 [ %.pre.i.pre1806.i, %._crit_edge105.loopexit.i1698.i ], [ %2355, %2341 ], [ %2367, %HashMap_find_slot_keyK_hashPtri32.exit1701.loopexit.i ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %2421 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2422 = sext i32 %2420 to i64
  %2423 = shl nsw i64 %2422, 5
  %2424 = getelementptr i8, ptr %2419, i64 %2423
  %2425 = load ptr, ptr %2424, align 8
  %2426 = getelementptr i8, ptr %2424, i64 8
  %2427 = load i64, ptr %2426, align 4
  %.sroa_idx.i1512.i = getelementptr i8, ptr %2424, i64 16
  %2428 = load i64, ptr %.sroa_idx.i1512.i, align 4
  %2429 = load ptr, ptr %2132, align 8
  %2430 = load ptr, ptr %2352, align 8, !alias.scope !271
  %2431 = getelementptr i8, ptr %2430, i64 72
  %2432 = load ptr, ptr %2431, align 8, !alias.scope !271
  %result.i.i.i1514.i = call { i64, i64 } %2432(ptr nocapture nofree nonnull readonly %2352) #5, !alias.scope !271
  %2433 = extractvalue { i64, i64 } %result.i.i.i1514.i, 0
  %2434 = extractvalue { i64, i64 } %result.i.i.i1514.i, 1
  %2435 = call i64 @llvm.umax.i64(i64 %2434, i64 8)
  %2436 = urem i64 20, %2434
  %2437 = icmp eq i64 %2436, 0
  %2438 = sub i64 %2434, %2436
  %2439 = select i1 %2437, i64 0, i64 %2438
  %2440 = add i64 %2433, 20
  %2441 = add i64 %2440, %2439
  %2442 = and i64 %2441, 7
  %2443 = icmp eq i64 %2442, 0
  %2444 = sub nuw nsw i64 40, %2442
  %2445 = select i1 %2443, i64 32, i64 %2444
  %2446 = add i64 %2445, %2441
  %2447 = urem i64 %2446, %2435
  %2448 = icmp eq i64 %2447, 0
  %2449 = sub i64 %2435, %2447
  %2450 = select i1 %2448, i64 0, i64 %2449
  %2451 = add i64 %2446, %2450
  %result.i71.i1515.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %2451, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %2352, ptr %result.i71.i1515.i, align 8
  %2452 = getelementptr inbounds i8, ptr %result.i71.i1515.i, i64 8
  store ptr %2429, ptr %2452, align 8
  %2453 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i1515.i)
  %2454 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %result.i71.i1515.i, 1
  %2455 = insertvalue { ptr, ptr, ptr, i32 } %2454, ptr undef, 2
  %2456 = insertvalue { ptr, ptr, ptr, i32 } %2455, i32 10, 3
  store ptr %2352, ptr %2, align 8
  store ptr %2429, ptr %2157, align 8
  store ptr @_parameterization_Ptri32, ptr %2158, align 8
  %2457 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %2)
  %2458 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Entry)
  %2459 = load i64, ptr %2332, align 4
  %2460 = load i64, ptr %2333, align 4
  %2461 = load ptr, ptr %2334, align 8
  %2462 = load ptr, ptr %2335, align 8
  %result.i.i117.i.i363 = call i1 %2461(i64 %2460, i64 %2459, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %2462) #5
  %2463 = select i1 %result.i.i117.i.i363, i64 9, i64 10
  %gep.i364 = getelementptr [14 x ptr], ptr getelementptr inbounds (i8, ptr @Entry, i64 80), i64 0, i64 %2463
  %2464 = load ptr, ptr %gep.i364, align 8
  call void %2464({ ptr, ptr, ptr, i32 } %2456, { ptr, ptr, ptr, i32 } %2456, ptr nonnull align 8 dereferenceable(24) %2, { ptr, i160 } %2346, { ptr, i160 } %2327, i32 %2351) #7
  %2465 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2466 = load ptr, ptr %2139, align 8
  %2467 = getelementptr i8, ptr %2466, i64 %2423
  store ptr @Entry, ptr %2467, align 8
  %2468 = getelementptr i8, ptr %2467, i64 8
  %2469 = ptrtoint ptr %result.i71.i1515.i to i64
  store i64 %2469, ptr %2468, align 4
  %.sroa_idx4.i1516.i = getelementptr i8, ptr %2467, i64 24
  store i32 10, ptr %.sroa_idx4.i1516.i, align 4
  %2470 = icmp eq ptr %2425, @nil_typ
  %2471 = icmp eq ptr %2425, null
  %2472 = or i1 %2470, %2471
  br i1 %2472, label %2473, label %2476

2473:                                             ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1701.i
  %2474 = load i32, ptr %2155, align 4
  %2475 = add i32 %2474, 1
  store i32 %2475, ptr %2155, align 4
  br label %._crit_edge.sink.split.i1533.i

2476:                                             ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1701.i
  %2477 = inttoptr i64 %2427 to ptr
  %2478 = inttoptr i64 %2428 to ptr
  %hash_coef_ptr.i.i88.i1517.i = getelementptr i8, ptr %2425, i64 8
  %tbl_size_ptr.i.i89.i1518.i = getelementptr i8, ptr %2425, i64 16
  %offset_tbl_ptr.i.i90.i1519.i = getelementptr i8, ptr %2425, i64 40
  %hash_coef.i.i91.i1520.i = load i64, ptr %hash_coef_ptr.i.i88.i1517.i, align 4, !noalias !274
  %tbl_size.i.i92.i1521.i = load i64, ptr %tbl_size_ptr.i.i89.i1518.i, align 4, !noalias !274
  %offset_tbl.i.i93.i1522.i = load ptr, ptr %offset_tbl_ptr.i.i90.i1519.i, align 8, !noalias !274
  %product.i.i.i94.i1523.i = mul i64 %hash_coef.i.i91.i1520.i, 4015701072841558310
  %shifted.i.i.i95.i1524.i = lshr i64 %product.i.i.i94.i1523.i, 32
  %xored.i.i.i96.i1525.i = xor i64 %shifted.i.i.i95.i1524.i, %product.i.i.i94.i1523.i
  %hash.i.i.i97.i1526.i = and i64 %xored.i.i.i96.i1525.i, %tbl_size.i.i92.i1521.i
  %offset_ptr.i.i98.i1527.i = getelementptr i32, ptr %offset_tbl.i.i93.i1522.i, i64 %hash.i.i.i97.i1526.i
  %offset.i.i99.i1528.i = load i32, ptr %offset_ptr.i.i98.i1527.i, align 4, !noalias !274
  %2479 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2425, 0
  %2480 = insertvalue { ptr, ptr, ptr, i32 } %2479, ptr %2477, 1
  %2481 = insertvalue { ptr, ptr, ptr, i32 } %2480, ptr %2478, 2
  %2482 = insertvalue { ptr, ptr, ptr, i32 } %2481, i32 %offset.i.i99.i1528.i, 3
  %2483 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2484 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %2425)
  %2485 = sext i32 %offset.i.i99.i1528.i to i64
  %2486 = getelementptr ptr, ptr %2425, i64 %2485
  %2487 = getelementptr i8, ptr %2486, i64 56
  %2488 = load ptr, ptr %2487, align 8
  %result.i101.i1529.i = call ptr %2488({ ptr, ptr, ptr, i32 } %2482, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2489 = call { ptr, i160 } %result.i101.i1529.i({ ptr, ptr, ptr, i32 } %2482, { ptr, ptr, ptr, i32 } %2482, ptr nonnull align 8 %0) #7
  %.fca.0.extract51.i1530.i = extractvalue { ptr, i160 } %2489, 0
  %2490 = getelementptr i8, ptr %.fca.0.extract51.i1530.i, i64 8
  %2491 = getelementptr i8, ptr %.fca.0.extract51.i1530.i, i64 16
  %2492 = getelementptr i8, ptr %.fca.0.extract51.i1530.i, i64 24
  %2493 = getelementptr i8, ptr %.fca.0.extract51.i1530.i, i64 32
  %2494 = load i64, ptr %2490, align 4
  %2495 = load i64, ptr %2491, align 4
  %2496 = load ptr, ptr %2492, align 8
  %2497 = load ptr, ptr %2493, align 8
  %result.i102.i1531.i = call i1 %2496(i64 %2495, i64 %2494, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %2497) #5
  br i1 %result.i102.i1531.i, label %._crit_edge.sink.split.i1533.i, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1535.i

._crit_edge.sink.split.i1533.i:                   ; preds = %2476, %2473
  %.sink159.i1534.i = phi i64 [ 48, %2473 ], [ 40, %2476 ]
  %2498 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2499 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i1534.i
  %2500 = load ptr, ptr %2499, align 8
  %2501 = load ptr, ptr %2500, align 8
  %2502 = call i32 %2501(ptr nonnull %result.i283.i) #36
  %2503 = add i32 %2502, 1
  %2504 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2505 = getelementptr i8, ptr %2500, i64 8
  %2506 = load ptr, ptr %2505, align 8
  call void %2506(ptr nonnull %result.i283.i, i32 %2503) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1535.i

HashMap_insert_internal_keyK_valueV_hashPtri32.exit1535.i: ; preds = %._crit_edge.sink.split.i1533.i, %2476
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %2)
  br label %._crit_edge.i1245.i

._crit_edge.i1245.i:                              ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1535.i, %2311, %.lr.ph.i1244.i
  %2507 = add nuw nsw i32 %.096.i.i344, 1
  %2508 = icmp slt i32 %2507, %2293
  br i1 %2508, label %.lr.ph.i1244.i, label %HashMap_resize_new_capacityPtri32.exit.i343

HashMap_resize_new_capacityPtri32.exit.i343:      ; preds = %._crit_edge.i1245.i, %._crit_edge1.i945.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  br label %HashMap_ensure_capacity_required_loadPtri32.exit.i296

HashMap_ensure_capacity_required_loadPtri32.exit.i296: ; preds = %HashMap_resize_new_capacityPtri32.exit.i343, %2290
  %2509 = load ptr, ptr %2137, align 8
  %2510 = call i32 %2509({ ptr, i160 } %2166) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2511 = load ptr, ptr %result.i283.i, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2512 = load i32, ptr %2140, align 8
  %2513 = add i32 %2512, -1
  %2514 = and i32 %2513, %2510
  %2515 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2516 = load ptr, ptr %2139, align 8
  %2517 = sext i32 %2514 to i64
  %2518 = shl nsw i64 %2517, 5
  %2519 = getelementptr i8, ptr %2516, i64 %2518
  %2520 = load ptr, ptr %2519, align 8
  %2521 = icmp eq ptr %2520, @nil_typ
  %2522 = icmp eq ptr %2520, null
  %2523 = or i1 %2521, %2522
  br i1 %2523, label %HashMap_find_slot_keyK_hashPtri32.exit1283.i, label %.lr.ph.i1259.i

.lr.ph.i1259.i:                                   ; preds = %HashMap_ensure_capacity_required_loadPtri32.exit.i296
  %2524 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %2525

2525:                                             ; preds = %._crit_edge.thread.i1274.i, %.lr.ph.i1259.i
  %2526 = phi i32 [ %2514, %.lr.ph.i1259.i ], [ %2568, %._crit_edge.thread.i1274.i ]
  %spec.store.select.i12791409.i = phi i32 [ -1, %.lr.ph.i1259.i ], [ %spec.store.select.i1279.i, %._crit_edge.thread.i1274.i ]
  %2527 = phi ptr [ %2520, %.lr.ph.i1259.i ], [ %2573, %._crit_edge.thread.i1274.i ]
  %2528 = phi ptr [ %2519, %.lr.ph.i1259.i ], [ %2572, %._crit_edge.thread.i1274.i ]
  %.sroa_idx.i1260.i = getelementptr i8, ptr %2528, i64 16
  %2529 = load i64, ptr %.sroa_idx.i1260.i, align 4
  %2530 = getelementptr i8, ptr %2528, i64 8
  %2531 = load i64, ptr %2530, align 4
  %2532 = inttoptr i64 %2531 to ptr
  %2533 = inttoptr i64 %2529 to ptr
  %hash_coef_ptr.i.i56.i1261.i = getelementptr i8, ptr %2527, i64 8
  %tbl_size_ptr.i.i57.i1262.i = getelementptr i8, ptr %2527, i64 16
  %offset_tbl_ptr.i.i58.i1263.i = getelementptr i8, ptr %2527, i64 40
  %hash_coef.i.i59.i1264.i = load i64, ptr %hash_coef_ptr.i.i56.i1261.i, align 4
  %tbl_size.i.i60.i1265.i = load i64, ptr %tbl_size_ptr.i.i57.i1262.i, align 4
  %offset_tbl.i.i61.i1266.i = load ptr, ptr %offset_tbl_ptr.i.i58.i1263.i, align 8
  %product.i.i.i62.i1267.i = mul i64 %hash_coef.i.i59.i1264.i, 4015701072841558310
  %shifted.i.i.i63.i1268.i = lshr i64 %product.i.i.i62.i1267.i, 32
  %xored.i.i.i64.i1269.i = xor i64 %shifted.i.i.i63.i1268.i, %product.i.i.i62.i1267.i
  %hash.i.i.i65.i1270.i = and i64 %xored.i.i.i64.i1269.i, %tbl_size.i.i60.i1265.i
  %offset_ptr.i.i66.i1271.i = getelementptr i32, ptr %offset_tbl.i.i61.i1266.i, i64 %hash.i.i.i65.i1270.i
  %offset.i.i67.i1272.i = load i32, ptr %offset_ptr.i.i66.i1271.i, align 4
  %2534 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2527, 0
  %2535 = insertvalue { ptr, ptr, ptr, i32 } %2534, ptr %2532, 1
  %2536 = insertvalue { ptr, ptr, ptr, i32 } %2535, ptr %2533, 2
  %2537 = insertvalue { ptr, ptr, ptr, i32 } %2536, i32 %offset.i.i67.i1272.i, 3
  %2538 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %2527)
  %2539 = sext i32 %offset.i.i67.i1272.i to i64
  %2540 = getelementptr ptr, ptr %2527, i64 %2539
  %2541 = getelementptr i8, ptr %2540, i64 64
  %2542 = load ptr, ptr %2541, align 8
  %result.i.i1273.i = call ptr %2542({ ptr, ptr, ptr, i32 } %2537, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2543 = call i32 %result.i.i1273.i({ ptr, ptr, ptr, i32 } %2537, { ptr, ptr, ptr, i32 } %2537, ptr nonnull align 8 %0) #7
  %2544 = icmp eq i32 %2543, %2510
  br i1 %2544, label %._crit_edge.i1281.i, label %._crit_edge.thread.i1274.i

._crit_edge.i1281.i:                              ; preds = %2525
  %2545 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2546 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %2527)
  %2547 = getelementptr i8, ptr %2540, i64 48
  %2548 = load ptr, ptr %2547, align 8
  %result.i69.i1282.i = call ptr %2548({ ptr, ptr, ptr, i32 } %2537, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2549 = call { ptr, i160 } %result.i69.i1282.i({ ptr, ptr, ptr, i32 } %2537, { ptr, ptr, ptr, i32 } %2537, ptr nonnull align 8 %0) #7
  %2550 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2551 = load ptr, ptr %2138, align 8
  %2552 = call i1 %2551({ ptr, i160 } %2549, { ptr, i160 } %2166) #7
  br i1 %2552, label %HashMap_find_slot_keyK_hashPtri32.exit1283.loopexit.i, label %._crit_edge.thread.i1274.i

._crit_edge.thread.i1274.i:                       ; preds = %._crit_edge.i1281.i, %2525
  %2553 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2554 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %2527)
  %2555 = getelementptr i8, ptr %2540, i64 56
  %2556 = load ptr, ptr %2555, align 8
  %result.i70.i1275.i = call ptr %2556({ ptr, ptr, ptr, i32 } %2537, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2557 = call { ptr, i160 } %result.i70.i1275.i({ ptr, ptr, ptr, i32 } %2537, { ptr, ptr, ptr, i32 } %2537, ptr nonnull align 8 %0) #7
  %.fca.0.extract19.i1276.i = extractvalue { ptr, i160 } %2557, 0
  %2558 = getelementptr i8, ptr %.fca.0.extract19.i1276.i, i64 8
  %2559 = getelementptr i8, ptr %.fca.0.extract19.i1276.i, i64 16
  %2560 = getelementptr i8, ptr %.fca.0.extract19.i1276.i, i64 24
  %2561 = getelementptr i8, ptr %.fca.0.extract19.i1276.i, i64 32
  %2562 = load i64, ptr %2558, align 4
  %2563 = load i64, ptr %2559, align 4
  %2564 = load ptr, ptr %2560, align 8
  %2565 = load ptr, ptr %2561, align 8
  %result.i71.i1277.i = call i1 %2564(i64 %2563, i64 %2562, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %2565) #5
  %2566 = icmp eq i32 %spec.store.select.i12791409.i, -1
  %or.cond.i1278.i = select i1 %result.i71.i1277.i, i1 %2566, i1 false
  %spec.store.select.i1279.i = select i1 %or.cond.i1278.i, i32 %2526, i32 %spec.store.select.i12791409.i
  %2567 = add i32 %2526, 1
  %2568 = and i32 %2567, %2513
  %2569 = load ptr, ptr %2139, align 8
  %2570 = sext i32 %2568 to i64
  %2571 = shl nsw i64 %2570, 5
  %2572 = getelementptr i8, ptr %2569, i64 %2571
  %2573 = load ptr, ptr %2572, align 8
  %2574 = icmp eq ptr %2573, @nil_typ
  %2575 = icmp eq ptr %2573, null
  %2576 = or i1 %2574, %2575
  br i1 %2576, label %._crit_edge105.loopexit.i1280.i, label %2525

._crit_edge105.loopexit.i1280.i:                  ; preds = %._crit_edge.thread.i1274.i
  %2577 = icmp eq i32 %spec.store.select.i1279.i, -1
  %.pre.i.pre1439.i = select i1 %2577, i32 %2568, i32 %spec.store.select.i1279.i
  br label %HashMap_find_slot_keyK_hashPtri32.exit1283.i

HashMap_find_slot_keyK_hashPtri32.exit1283.loopexit.i: ; preds = %._crit_edge.i1281.i
  %.pre1494.i = load ptr, ptr %2139, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit1283.i

HashMap_find_slot_keyK_hashPtri32.exit1283.i:     ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1283.loopexit.i, %._crit_edge105.loopexit.i1280.i, %HashMap_ensure_capacity_required_loadPtri32.exit.i296
  %2578 = phi ptr [ %2569, %._crit_edge105.loopexit.i1280.i ], [ %2516, %HashMap_ensure_capacity_required_loadPtri32.exit.i296 ], [ %.pre1494.i, %HashMap_find_slot_keyK_hashPtri32.exit1283.loopexit.i ]
  %2579 = phi i32 [ %.pre.i.pre1439.i, %._crit_edge105.loopexit.i1280.i ], [ %2514, %HashMap_ensure_capacity_required_loadPtri32.exit.i296 ], [ %2526, %HashMap_find_slot_keyK_hashPtri32.exit1283.loopexit.i ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %2580 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2581 = sext i32 %2579 to i64
  %2582 = shl nsw i64 %2581, 5
  %2583 = getelementptr i8, ptr %2578, i64 %2582
  %2584 = load ptr, ptr %2583, align 8
  %2585 = getelementptr i8, ptr %2583, i64 8
  %2586 = load i64, ptr %2585, align 4
  %.sroa_idx.i962.i = getelementptr i8, ptr %2583, i64 16
  %2587 = load i64, ptr %.sroa_idx.i962.i, align 4
  %2588 = load ptr, ptr %2132, align 8
  %2589 = load ptr, ptr %2511, align 8, !alias.scope !277
  %2590 = getelementptr i8, ptr %2589, i64 72
  %2591 = load ptr, ptr %2590, align 8, !alias.scope !277
  %result.i.i.i.i297 = call { i64, i64 } %2591(ptr nocapture nofree nonnull readonly %2511) #5, !alias.scope !277
  %2592 = extractvalue { i64, i64 } %result.i.i.i.i297, 0
  %2593 = extractvalue { i64, i64 } %result.i.i.i.i297, 1
  %2594 = call i64 @llvm.umax.i64(i64 %2593, i64 8)
  %2595 = urem i64 20, %2593
  %2596 = icmp eq i64 %2595, 0
  %2597 = sub i64 %2593, %2595
  %2598 = select i1 %2596, i64 0, i64 %2597
  %2599 = add i64 %2592, 20
  %2600 = add i64 %2599, %2598
  %2601 = and i64 %2600, 7
  %2602 = icmp eq i64 %2601, 0
  %2603 = sub nuw nsw i64 40, %2601
  %2604 = select i1 %2602, i64 32, i64 %2603
  %2605 = add i64 %2604, %2600
  %2606 = urem i64 %2605, %2594
  %2607 = icmp eq i64 %2606, 0
  %2608 = sub i64 %2594, %2606
  %2609 = select i1 %2607, i64 0, i64 %2608
  %2610 = add i64 %2605, %2609
  %result.i71.i964.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %2610, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %2511, ptr %result.i71.i964.i, align 8
  %2611 = getelementptr inbounds i8, ptr %result.i71.i964.i, i64 8
  store ptr %2588, ptr %2611, align 8
  %2612 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i964.i)
  %2613 = load ptr, ptr %2511, align 8
  %2614 = getelementptr i8, ptr %2613, i64 72
  %2615 = load ptr, ptr %2614, align 8
  %result.i.i1458.i = call { i64, i64 } %2615(ptr nocapture nofree nonnull readonly %2511) #5
  %2616 = extractvalue { i64, i64 } %result.i.i1458.i, 1
  %2617 = urem i64 20, %2616
  %2618 = icmp eq i64 %2617, 0
  %reass.sub1616 = sub i64 %2616, %2617
  %2619 = add i64 %reass.sub1616, 20
  %2620 = select i1 %2618, i64 20, i64 %2619
  %2621 = getelementptr i8, ptr %result.i71.i964.i, i64 %2620
  %2622 = getelementptr i8, ptr %2613, i64 64
  %2623 = load ptr, ptr %2622, align 8
  call void %2623({ ptr, i160 } %2166, ptr nocapture nofree nonnull readonly %2511, ptr nocapture nofree writeonly %2621) #13
  %2624 = load ptr, ptr %result.i71.i964.i, align 8
  %2625 = load ptr, ptr %2624, align 8
  %2626 = getelementptr i8, ptr %2625, i64 72
  %2627 = load ptr, ptr %2626, align 8
  %result.i.i1459.i = call { i64, i64 } %2627(ptr nocapture nofree nonnull readonly %2624) #5
  %2628 = extractvalue { i64, i64 } %result.i.i1459.i, 0
  %2629 = extractvalue { i64, i64 } %result.i.i1459.i, 1
  %2630 = urem i64 20, %2629
  %2631 = icmp eq i64 %2630, 0
  %2632 = sub i64 %2629, %2630
  %2633 = select i1 %2631, i64 0, i64 %2632
  %2634 = add i64 %2628, 20
  %2635 = add i64 %2634, %2633
  %2636 = and i64 %2635, 7
  %2637 = icmp eq i64 %2636, 0
  %2638 = sub nuw nsw i64 8, %2636
  %2639 = select i1 %2637, i64 0, i64 %2638
  %2640 = getelementptr i8, ptr %result.i71.i964.i, i64 %2635
  %2641 = getelementptr i8, ptr %2640, i64 %2639
  store ptr @i32_typ, ptr %2641, align 8
  %2642 = getelementptr i8, ptr %2641, i64 8
  store i160 %.sroa.0234.0.insert.ext.i, ptr %2642, align 4
  %2643 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @Entry) #34
  %2644 = getelementptr inbounds i8, ptr %result.i71.i964.i, i64 16
  store i32 %2510, ptr %2644, align 8
  %2645 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  store ptr @Entry, ptr %2583, align 8
  %2646 = ptrtoint ptr %result.i71.i964.i to i64
  store i64 %2646, ptr %2585, align 4
  %.sroa_idx4.i.i298 = getelementptr i8, ptr %2583, i64 24
  store i32 10, ptr %.sroa_idx4.i.i298, align 4
  %2647 = icmp eq ptr %2584, @nil_typ
  %2648 = icmp eq ptr %2584, null
  %2649 = or i1 %2647, %2648
  br i1 %2649, label %2650, label %2653

2650:                                             ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1283.i
  %2651 = load i32, ptr %2155, align 4
  %2652 = add i32 %2651, 1
  store i32 %2652, ptr %2155, align 4
  br label %._crit_edge.sink.split.i.i341

2653:                                             ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1283.i
  %2654 = inttoptr i64 %2586 to ptr
  %2655 = inttoptr i64 %2587 to ptr
  %hash_coef_ptr.i.i88.i.i299 = getelementptr i8, ptr %2584, i64 8
  %tbl_size_ptr.i.i89.i.i300 = getelementptr i8, ptr %2584, i64 16
  %offset_tbl_ptr.i.i90.i.i301 = getelementptr i8, ptr %2584, i64 40
  %hash_coef.i.i91.i.i302 = load i64, ptr %hash_coef_ptr.i.i88.i.i299, align 4, !noalias !280
  %tbl_size.i.i92.i.i303 = load i64, ptr %tbl_size_ptr.i.i89.i.i300, align 4, !noalias !280
  %offset_tbl.i.i93.i.i304 = load ptr, ptr %offset_tbl_ptr.i.i90.i.i301, align 8, !noalias !280
  %product.i.i.i94.i.i305 = mul i64 %hash_coef.i.i91.i.i302, 4015701072841558310
  %shifted.i.i.i95.i.i306 = lshr i64 %product.i.i.i94.i.i305, 32
  %xored.i.i.i96.i.i307 = xor i64 %shifted.i.i.i95.i.i306, %product.i.i.i94.i.i305
  %hash.i.i.i97.i.i308 = and i64 %xored.i.i.i96.i.i307, %tbl_size.i.i92.i.i303
  %offset_ptr.i.i98.i.i309 = getelementptr i32, ptr %offset_tbl.i.i93.i.i304, i64 %hash.i.i.i97.i.i308
  %offset.i.i99.i.i310 = load i32, ptr %offset_ptr.i.i98.i.i309, align 4, !noalias !280
  %2656 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2584, 0
  %2657 = insertvalue { ptr, ptr, ptr, i32 } %2656, ptr %2654, 1
  %2658 = insertvalue { ptr, ptr, ptr, i32 } %2657, ptr %2655, 2
  %2659 = insertvalue { ptr, ptr, ptr, i32 } %2658, i32 %offset.i.i99.i.i310, 3
  %2660 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2661 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %2584)
  %2662 = sext i32 %offset.i.i99.i.i310 to i64
  %2663 = getelementptr ptr, ptr %2584, i64 %2662
  %2664 = getelementptr i8, ptr %2663, i64 56
  %2665 = load ptr, ptr %2664, align 8
  %result.i101.i.i311 = call ptr %2665({ ptr, ptr, ptr, i32 } %2659, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2666 = call { ptr, i160 } %result.i101.i.i311({ ptr, ptr, ptr, i32 } %2659, { ptr, ptr, ptr, i32 } %2659, ptr nonnull align 8 %0) #7
  %.fca.0.extract51.i966.i = extractvalue { ptr, i160 } %2666, 0
  %2667 = getelementptr i8, ptr %.fca.0.extract51.i966.i, i64 8
  %2668 = getelementptr i8, ptr %.fca.0.extract51.i966.i, i64 16
  %2669 = getelementptr i8, ptr %.fca.0.extract51.i966.i, i64 24
  %2670 = getelementptr i8, ptr %.fca.0.extract51.i966.i, i64 32
  %2671 = load i64, ptr %2667, align 4
  %2672 = load i64, ptr %2668, align 4
  %2673 = load ptr, ptr %2669, align 8
  %2674 = load ptr, ptr %2670, align 8
  %result.i102.i.i312 = call i1 %2673(i64 %2672, i64 %2671, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %2674) #5
  br i1 %result.i102.i.i312, label %._crit_edge.sink.split.i.i341, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit.i313

._crit_edge.sink.split.i.i341:                    ; preds = %2653, %2650
  %.sink159.i.i342 = phi i64 [ 48, %2650 ], [ 40, %2653 ]
  %2675 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2676 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i.i342
  %2677 = load ptr, ptr %2676, align 8
  %2678 = load ptr, ptr %2677, align 8
  %2679 = call i32 %2678(ptr nonnull %result.i283.i) #36
  %2680 = add i32 %2679, 1
  %2681 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2682 = getelementptr i8, ptr %2677, i64 8
  %2683 = load ptr, ptr %2682, align 8
  call void %2683(ptr nonnull %result.i283.i, i32 %2680) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit.i313

HashMap_insert_internal_keyK_valueV_hashPtri32.exit.i313: ; preds = %._crit_edge.sink.split.i.i341, %2653
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %2684 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  %2685 = sext i32 %.0266528.i to i64
  %2686 = shl nsw i64 %2685, 2
  %2687 = getelementptr i8, ptr %result.i4.i.i269, i64 %2686
  store i32 %2165, ptr %2687, align 1
  store i1 true, ptr %.sroa.0224.sroa.0.i, align 8
  %.sroa.0224.sroa.0.i.0..sroa.0224.sroa.0.i.0..sroa.0224.sroa.0.i.0..sroa.0224.sroa.0.i.0..sroa.0224.sroa.0.i.0..sroa.0224.sroa.0.i.0..sroa.0224.sroa.0.i.0..sroa.0224.sroa.0.i.0..sroa.0224.sroa.0.i.0..sroa.0224.sroa.0.i.0..sroa.0224.sroa.0.i.0..sroa.0224.sroa.0.i.0..sroa.0224.sroa.0.i.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.0..i = load i8, ptr %.sroa.0224.sroa.0.i, align 8
  %.sroa.0224.0.insert.ext.i = zext i8 %.sroa.0224.sroa.0.i.0..sroa.0224.sroa.0.i.0..sroa.0224.sroa.0.i.0..sroa.0224.sroa.0.i.0..sroa.0224.sroa.0.i.0..sroa.0224.sroa.0.i.0..sroa.0224.sroa.0.i.0..sroa.0224.sroa.0.i.0..sroa.0224.sroa.0.i.0..sroa.0224.sroa.0.i.0..sroa.0224.sroa.0.i.0..sroa.0224.sroa.0.i.0..sroa.0224.sroa.0.i.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.sroa.0.0..sroa.0224.0..i to i160
  %2688 = load i32, ptr %2154, align 8
  %2689 = load i32, ptr %2150, align 8
  %2690 = icmp eq i32 %2689, 0
  %2691 = mul i32 %2688, 10
  %2692 = add i32 %2691, 10
  %2693 = mul i32 %2689, 6
  %2694 = icmp sge i32 %2692, %2693
  %.0.i982.i = select i1 %2690, i1 true, i1 %2694
  br i1 %.0.i982.i, label %._crit_edge1.i984.i, label %HashMap_ensure_capacity_required_loadPtri32.exit988.i

._crit_edge1.i984.i:                              ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit.i313
  %2695 = shl i32 %2689, 1
  %spec.select.i986.i = call i32 @llvm.smax.i32(i32 %2695, i32 16)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2696 = load ptr, ptr %2149, align 8
  %2697 = zext nneg i32 %spec.select.i986.i to i64
  %2698 = shl nuw nsw i64 %2697, 5
  %result.i.i1311.i = call noalias ptr @bump_malloc_inner(i64 noundef %2698, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i1311.i, ptr %2149, align 8
  store i32 %spec.select.i986.i, ptr %2150, align 8
  store i32 0, ptr %2156, align 4
  %2699 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap) #38
  store i32 0, ptr %2154, align 8
  %2700 = icmp sgt i32 %2689, 0
  br i1 %2700, label %.lr.ph.i1312.i, label %HashMap_resize_new_capacityPtri32.exit1338.i

.lr.ph.i1312.i:                                   ; preds = %._crit_edge1.i984.i, %._crit_edge.i1315.i
  %.096.i1313.i = phi i32 [ %2903, %._crit_edge.i1315.i ], [ 0, %._crit_edge1.i984.i ]
  %2701 = zext nneg i32 %.096.i1313.i to i64
  %2702 = shl nuw nsw i64 %2701, 5
  %2703 = getelementptr i8, ptr %2696, i64 %2702
  %2704 = load ptr, ptr %2703, align 8
  %2705 = icmp ne ptr %2704, @nil_typ
  %2706 = icmp ne ptr %2704, null
  %.not40.i1314.i = and i1 %2705, %2706
  br i1 %.not40.i1314.i, label %2707, label %._crit_edge.i1315.i

2707:                                             ; preds = %.lr.ph.i1312.i
  %2708 = getelementptr i8, ptr %2703, i64 8
  %2709 = load i64, ptr %2708, align 4
  %.sroa_idx.i1316.i = getelementptr i8, ptr %2703, i64 16
  %2710 = load i64, ptr %.sroa_idx.i1316.i, align 4
  %2711 = inttoptr i64 %2709 to ptr
  %2712 = inttoptr i64 %2710 to ptr
  %hash_coef_ptr.i.i42.i1317.i = getelementptr i8, ptr %2704, i64 8
  %tbl_size_ptr.i.i43.i1318.i = getelementptr i8, ptr %2704, i64 16
  %offset_tbl_ptr.i.i44.i1319.i = getelementptr i8, ptr %2704, i64 40
  %hash_coef.i.i45.i1320.i = load i64, ptr %hash_coef_ptr.i.i42.i1317.i, align 4, !noalias !283
  %tbl_size.i.i46.i1321.i = load i64, ptr %tbl_size_ptr.i.i43.i1318.i, align 4, !noalias !283
  %offset_tbl.i.i47.i1322.i = load ptr, ptr %offset_tbl_ptr.i.i44.i1319.i, align 8, !noalias !283
  %product.i.i.i48.i1323.i = mul i64 %hash_coef.i.i45.i1320.i, 4015701072841558310
  %shifted.i.i.i49.i1324.i = lshr i64 %product.i.i.i48.i1323.i, 32
  %xored.i.i.i50.i1325.i = xor i64 %shifted.i.i.i49.i1324.i, %product.i.i.i48.i1323.i
  %hash.i.i.i51.i1326.i = and i64 %xored.i.i.i50.i1325.i, %tbl_size.i.i46.i1321.i
  %offset_ptr.i.i52.i1327.i = getelementptr i32, ptr %offset_tbl.i.i47.i1322.i, i64 %hash.i.i.i51.i1326.i
  %offset.i.i53.i1328.i = load i32, ptr %offset_ptr.i.i52.i1327.i, align 4, !noalias !283
  %2713 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2704, 0
  %2714 = insertvalue { ptr, ptr, ptr, i32 } %2713, ptr %2711, 1
  %2715 = insertvalue { ptr, ptr, ptr, i32 } %2714, ptr %2712, 2
  %2716 = insertvalue { ptr, ptr, ptr, i32 } %2715, i32 %offset.i.i53.i1328.i, 3
  %2717 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2718 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %2704)
  %2719 = sext i32 %offset.i.i53.i1328.i to i64
  %2720 = getelementptr ptr, ptr %2704, i64 %2719
  %2721 = getelementptr i8, ptr %2720, i64 56
  %2722 = load ptr, ptr %2721, align 8
  %result.i55.i1329.i = call ptr %2722({ ptr, ptr, ptr, i32 } %2716, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2723 = call { ptr, i160 } %result.i55.i1329.i({ ptr, ptr, ptr, i32 } %2716, { ptr, ptr, ptr, i32 } %2716, ptr nonnull align 8 %0) #7
  %.fca.0.extract29.i1330.i = extractvalue { ptr, i160 } %2723, 0
  %2724 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2725 = load ptr, ptr %2142, align 8
  %2726 = load ptr, ptr %2725, align 8
  %2727 = ptrtoint ptr %2726 to i64
  %2728 = getelementptr i8, ptr %.fca.0.extract29.i1330.i, i64 8
  %2729 = getelementptr i8, ptr %.fca.0.extract29.i1330.i, i64 16
  %2730 = getelementptr i8, ptr %.fca.0.extract29.i1330.i, i64 24
  %2731 = getelementptr i8, ptr %.fca.0.extract29.i1330.i, i64 32
  %2732 = load i64, ptr %2728, align 4
  %2733 = load i64, ptr %2729, align 4
  %2734 = load ptr, ptr %2730, align 8
  %2735 = load ptr, ptr %2731, align 8
  %2736 = load i64, ptr %2726, align 4
  %result.i57.i1332.i = call i1 %2734(i64 %2733, i64 %2732, i64 %2736, i64 %2727, ptr readonly %2735) #5
  br i1 %result.i57.i1332.i, label %2737, label %._crit_edge.i1315.i

2737:                                             ; preds = %2707
  %2738 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2739 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %2704)
  %2740 = getelementptr i8, ptr %2720, i64 48
  %2741 = load ptr, ptr %2740, align 8
  %result.i58.i1333.i = call ptr %2741({ ptr, ptr, ptr, i32 } %2716, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2742 = call { ptr, i160 } %result.i58.i1333.i({ ptr, ptr, ptr, i32 } %2716, { ptr, ptr, ptr, i32 } %2716, ptr nonnull align 8 %0) #7
  %2743 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2744 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %2704)
  %2745 = getelementptr i8, ptr %2720, i64 64
  %2746 = load ptr, ptr %2745, align 8
  %result.i59.i1335.i = call ptr %2746({ ptr, ptr, ptr, i32 } %2716, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2747 = call i32 %result.i59.i1335.i({ ptr, ptr, ptr, i32 } %2716, { ptr, ptr, ptr, i32 } %2716, ptr nonnull align 8 %0) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %1)
  %2748 = load ptr, ptr %result.i326.i, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2749 = load i32, ptr %2150, align 8
  %2750 = add i32 %2749, -1
  %2751 = and i32 %2750, %2747
  %2752 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2753 = load ptr, ptr %2149, align 8
  %2754 = sext i32 %2751 to i64
  %2755 = shl nsw i64 %2754, 5
  %2756 = getelementptr i8, ptr %2753, i64 %2755
  %2757 = load ptr, ptr %2756, align 8
  %2758 = icmp eq ptr %2757, @nil_typ
  %2759 = icmp eq ptr %2757, null
  %2760 = or i1 %2758, %2759
  br i1 %2760, label %HashMap_find_slot_keyK_hashPtri32.exit1746.i, label %.lr.ph.i1716.i

.lr.ph.i1716.i:                                   ; preds = %2737
  %2761 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %2762

2762:                                             ; preds = %._crit_edge.thread.i1732.i, %.lr.ph.i1716.i
  %2763 = phi i32 [ %2751, %.lr.ph.i1716.i ], [ %2805, %._crit_edge.thread.i1732.i ]
  %spec.store.select.i17371773.i = phi i32 [ -1, %.lr.ph.i1716.i ], [ %spec.store.select.i1737.i, %._crit_edge.thread.i1732.i ]
  %2764 = phi ptr [ %2757, %.lr.ph.i1716.i ], [ %2810, %._crit_edge.thread.i1732.i ]
  %2765 = phi ptr [ %2756, %.lr.ph.i1716.i ], [ %2809, %._crit_edge.thread.i1732.i ]
  %.sroa_idx.i1718.i = getelementptr i8, ptr %2765, i64 16
  %2766 = load i64, ptr %.sroa_idx.i1718.i, align 4
  %2767 = getelementptr i8, ptr %2765, i64 8
  %2768 = load i64, ptr %2767, align 4
  %2769 = inttoptr i64 %2768 to ptr
  %2770 = inttoptr i64 %2766 to ptr
  %hash_coef_ptr.i.i56.i1719.i = getelementptr i8, ptr %2764, i64 8
  %tbl_size_ptr.i.i57.i1720.i = getelementptr i8, ptr %2764, i64 16
  %offset_tbl_ptr.i.i58.i1721.i = getelementptr i8, ptr %2764, i64 40
  %hash_coef.i.i59.i1722.i = load i64, ptr %hash_coef_ptr.i.i56.i1719.i, align 4
  %tbl_size.i.i60.i1723.i = load i64, ptr %tbl_size_ptr.i.i57.i1720.i, align 4
  %offset_tbl.i.i61.i1724.i = load ptr, ptr %offset_tbl_ptr.i.i58.i1721.i, align 8
  %product.i.i.i62.i1725.i = mul i64 %hash_coef.i.i59.i1722.i, 4015701072841558310
  %shifted.i.i.i63.i1726.i = lshr i64 %product.i.i.i62.i1725.i, 32
  %xored.i.i.i64.i1727.i = xor i64 %shifted.i.i.i63.i1726.i, %product.i.i.i62.i1725.i
  %hash.i.i.i65.i1728.i = and i64 %xored.i.i.i64.i1727.i, %tbl_size.i.i60.i1723.i
  %offset_ptr.i.i66.i1729.i = getelementptr i32, ptr %offset_tbl.i.i61.i1724.i, i64 %hash.i.i.i65.i1728.i
  %offset.i.i67.i1730.i = load i32, ptr %offset_ptr.i.i66.i1729.i, align 4
  %2771 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2764, 0
  %2772 = insertvalue { ptr, ptr, ptr, i32 } %2771, ptr %2769, 1
  %2773 = insertvalue { ptr, ptr, ptr, i32 } %2772, ptr %2770, 2
  %2774 = insertvalue { ptr, ptr, ptr, i32 } %2773, i32 %offset.i.i67.i1730.i, 3
  %2775 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %2764)
  %2776 = sext i32 %offset.i.i67.i1730.i to i64
  %2777 = getelementptr ptr, ptr %2764, i64 %2776
  %2778 = getelementptr i8, ptr %2777, i64 64
  %2779 = load ptr, ptr %2778, align 8
  %result.i.i1731.i = call ptr %2779({ ptr, ptr, ptr, i32 } %2774, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2780 = call i32 %result.i.i1731.i({ ptr, ptr, ptr, i32 } %2774, { ptr, ptr, ptr, i32 } %2774, ptr nonnull align 8 %0) #7
  %2781 = icmp eq i32 %2780, %2747
  br i1 %2781, label %._crit_edge.i1743.i, label %._crit_edge.thread.i1732.i

._crit_edge.i1743.i:                              ; preds = %2762
  %2782 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2783 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %2764)
  %2784 = getelementptr i8, ptr %2777, i64 48
  %2785 = load ptr, ptr %2784, align 8
  %result.i69.i1744.i = call ptr %2785({ ptr, ptr, ptr, i32 } %2774, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2786 = call { ptr, i160 } %result.i69.i1744.i({ ptr, ptr, ptr, i32 } %2774, { ptr, ptr, ptr, i32 } %2774, ptr nonnull align 8 %0) #7
  %2787 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2788 = load ptr, ptr %2148, align 8
  %2789 = call i1 %2788({ ptr, i160 } %2786, { ptr, i160 } %2742) #7
  br i1 %2789, label %HashMap_find_slot_keyK_hashPtri32.exit1746.loopexit.i, label %._crit_edge.thread.i1732.i

._crit_edge.thread.i1732.i:                       ; preds = %._crit_edge.i1743.i, %2762
  %2790 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2791 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %2764)
  %2792 = getelementptr i8, ptr %2777, i64 56
  %2793 = load ptr, ptr %2792, align 8
  %result.i70.i1733.i = call ptr %2793({ ptr, ptr, ptr, i32 } %2774, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2794 = call { ptr, i160 } %result.i70.i1733.i({ ptr, ptr, ptr, i32 } %2774, { ptr, ptr, ptr, i32 } %2774, ptr nonnull align 8 %0) #7
  %.fca.0.extract19.i1734.i = extractvalue { ptr, i160 } %2794, 0
  %2795 = getelementptr i8, ptr %.fca.0.extract19.i1734.i, i64 8
  %2796 = getelementptr i8, ptr %.fca.0.extract19.i1734.i, i64 16
  %2797 = getelementptr i8, ptr %.fca.0.extract19.i1734.i, i64 24
  %2798 = getelementptr i8, ptr %.fca.0.extract19.i1734.i, i64 32
  %2799 = load i64, ptr %2795, align 4
  %2800 = load i64, ptr %2796, align 4
  %2801 = load ptr, ptr %2797, align 8
  %2802 = load ptr, ptr %2798, align 8
  %result.i71.i1735.i = call i1 %2801(i64 %2800, i64 %2799, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %2802) #5
  %2803 = icmp eq i32 %spec.store.select.i17371773.i, -1
  %or.cond.i1736.i = select i1 %result.i71.i1735.i, i1 %2803, i1 false
  %spec.store.select.i1737.i = select i1 %or.cond.i1736.i, i32 %2763, i32 %spec.store.select.i17371773.i
  %2804 = add i32 %2763, 1
  %2805 = and i32 %2804, %2750
  %2806 = load ptr, ptr %2149, align 8
  %2807 = sext i32 %2805 to i64
  %2808 = shl nsw i64 %2807, 5
  %2809 = getelementptr i8, ptr %2806, i64 %2808
  %2810 = load ptr, ptr %2809, align 8
  %2811 = icmp eq ptr %2810, @nil_typ
  %2812 = icmp eq ptr %2810, null
  %2813 = or i1 %2811, %2812
  br i1 %2813, label %._crit_edge105.loopexit.i1739.i, label %2762

._crit_edge105.loopexit.i1739.i:                  ; preds = %._crit_edge.thread.i1732.i
  %2814 = icmp eq i32 %spec.store.select.i1737.i, -1
  %.pre.i1742.pre.i = select i1 %2814, i32 %2805, i32 %spec.store.select.i1737.i
  br label %HashMap_find_slot_keyK_hashPtri32.exit1746.i

HashMap_find_slot_keyK_hashPtri32.exit1746.loopexit.i: ; preds = %._crit_edge.i1743.i
  %.pre1877.i = load ptr, ptr %2149, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit1746.i

HashMap_find_slot_keyK_hashPtri32.exit1746.i:     ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1746.loopexit.i, %._crit_edge105.loopexit.i1739.i, %2737
  %2815 = phi ptr [ %2806, %._crit_edge105.loopexit.i1739.i ], [ %2753, %2737 ], [ %.pre1877.i, %HashMap_find_slot_keyK_hashPtri32.exit1746.loopexit.i ]
  %2816 = phi i32 [ %.pre.i1742.pre.i, %._crit_edge105.loopexit.i1739.i ], [ %2751, %2737 ], [ %2763, %HashMap_find_slot_keyK_hashPtri32.exit1746.loopexit.i ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %2817 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2818 = sext i32 %2816 to i64
  %2819 = shl nsw i64 %2818, 5
  %2820 = getelementptr i8, ptr %2815, i64 %2819
  %2821 = load ptr, ptr %2820, align 8
  %2822 = getelementptr i8, ptr %2820, i64 8
  %2823 = load i64, ptr %2822, align 4
  %.sroa_idx.i1555.i = getelementptr i8, ptr %2820, i64 16
  %2824 = load i64, ptr %.sroa_idx.i1555.i, align 4
  %2825 = load ptr, ptr %2142, align 8
  %2826 = load ptr, ptr %2748, align 8, !alias.scope !286
  %2827 = getelementptr i8, ptr %2826, i64 72
  %2828 = load ptr, ptr %2827, align 8, !alias.scope !286
  %result.i.i.i1557.i = call { i64, i64 } %2828(ptr nocapture nofree nonnull readonly %2748) #5, !alias.scope !286
  %2829 = extractvalue { i64, i64 } %result.i.i.i1557.i, 0
  %2830 = extractvalue { i64, i64 } %result.i.i.i1557.i, 1
  %2831 = call i64 @llvm.umax.i64(i64 %2830, i64 8)
  %2832 = urem i64 20, %2830
  %2833 = icmp eq i64 %2832, 0
  %2834 = sub i64 %2830, %2832
  %2835 = select i1 %2833, i64 0, i64 %2834
  %2836 = add i64 %2829, 20
  %2837 = add i64 %2836, %2835
  %2838 = and i64 %2837, 7
  %2839 = icmp eq i64 %2838, 0
  %2840 = sub nuw nsw i64 40, %2838
  %2841 = select i1 %2839, i64 32, i64 %2840
  %2842 = add i64 %2841, %2837
  %2843 = urem i64 %2842, %2831
  %2844 = icmp eq i64 %2843, 0
  %2845 = sub i64 %2831, %2843
  %2846 = select i1 %2844, i64 0, i64 %2845
  %2847 = add i64 %2842, %2846
  %result.i71.i1558.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %2847, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %2748, ptr %result.i71.i1558.i, align 8
  %2848 = getelementptr inbounds i8, ptr %result.i71.i1558.i, i64 8
  store ptr %2825, ptr %2848, align 8
  %2849 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i1558.i)
  %2850 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %result.i71.i1558.i, 1
  %2851 = insertvalue { ptr, ptr, ptr, i32 } %2850, ptr undef, 2
  %2852 = insertvalue { ptr, ptr, ptr, i32 } %2851, i32 10, 3
  store ptr %2748, ptr %1, align 8
  store ptr %2825, ptr %2159, align 8
  store ptr @_parameterization_Ptri32, ptr %2160, align 8
  %2853 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1)
  %2854 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Entry)
  %2855 = load i64, ptr %2728, align 4
  %2856 = load i64, ptr %2729, align 4
  %2857 = load ptr, ptr %2730, align 8
  %2858 = load ptr, ptr %2731, align 8
  %result.i.i117.i1559.i = call i1 %2857(i64 %2856, i64 %2855, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %2858) #5
  %2859 = select i1 %result.i.i117.i1559.i, i64 9, i64 10
  %gep1597.i = getelementptr [14 x ptr], ptr getelementptr inbounds (i8, ptr @Entry, i64 80), i64 0, i64 %2859
  %2860 = load ptr, ptr %gep1597.i, align 8
  call void %2860({ ptr, ptr, ptr, i32 } %2852, { ptr, ptr, ptr, i32 } %2852, ptr nonnull align 8 dereferenceable(24) %1, { ptr, i160 } %2742, { ptr, i160 } %2723, i32 %2747) #7
  %2861 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2862 = load ptr, ptr %2149, align 8
  %2863 = getelementptr i8, ptr %2862, i64 %2819
  store ptr @Entry, ptr %2863, align 8
  %2864 = getelementptr i8, ptr %2863, i64 8
  %2865 = ptrtoint ptr %result.i71.i1558.i to i64
  store i64 %2865, ptr %2864, align 4
  %.sroa_idx4.i1561.i = getelementptr i8, ptr %2863, i64 24
  store i32 10, ptr %.sroa_idx4.i1561.i, align 4
  %2866 = icmp eq ptr %2821, @nil_typ
  %2867 = icmp eq ptr %2821, null
  %2868 = or i1 %2866, %2867
  br i1 %2868, label %2869, label %2872

2869:                                             ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1746.i
  %2870 = load i32, ptr %2156, align 4
  %2871 = add i32 %2870, 1
  store i32 %2871, ptr %2156, align 4
  br label %._crit_edge.sink.split.i1578.i

2872:                                             ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1746.i
  %2873 = inttoptr i64 %2823 to ptr
  %2874 = inttoptr i64 %2824 to ptr
  %hash_coef_ptr.i.i88.i1562.i = getelementptr i8, ptr %2821, i64 8
  %tbl_size_ptr.i.i89.i1563.i = getelementptr i8, ptr %2821, i64 16
  %offset_tbl_ptr.i.i90.i1564.i = getelementptr i8, ptr %2821, i64 40
  %hash_coef.i.i91.i1565.i = load i64, ptr %hash_coef_ptr.i.i88.i1562.i, align 4, !noalias !289
  %tbl_size.i.i92.i1566.i = load i64, ptr %tbl_size_ptr.i.i89.i1563.i, align 4, !noalias !289
  %offset_tbl.i.i93.i1567.i = load ptr, ptr %offset_tbl_ptr.i.i90.i1564.i, align 8, !noalias !289
  %product.i.i.i94.i1568.i = mul i64 %hash_coef.i.i91.i1565.i, 4015701072841558310
  %shifted.i.i.i95.i1569.i = lshr i64 %product.i.i.i94.i1568.i, 32
  %xored.i.i.i96.i1570.i = xor i64 %shifted.i.i.i95.i1569.i, %product.i.i.i94.i1568.i
  %hash.i.i.i97.i1571.i = and i64 %xored.i.i.i96.i1570.i, %tbl_size.i.i92.i1566.i
  %offset_ptr.i.i98.i1572.i = getelementptr i32, ptr %offset_tbl.i.i93.i1567.i, i64 %hash.i.i.i97.i1571.i
  %offset.i.i99.i1573.i = load i32, ptr %offset_ptr.i.i98.i1572.i, align 4, !noalias !289
  %2875 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2821, 0
  %2876 = insertvalue { ptr, ptr, ptr, i32 } %2875, ptr %2873, 1
  %2877 = insertvalue { ptr, ptr, ptr, i32 } %2876, ptr %2874, 2
  %2878 = insertvalue { ptr, ptr, ptr, i32 } %2877, i32 %offset.i.i99.i1573.i, 3
  %2879 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2880 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %2821)
  %2881 = sext i32 %offset.i.i99.i1573.i to i64
  %2882 = getelementptr ptr, ptr %2821, i64 %2881
  %2883 = getelementptr i8, ptr %2882, i64 56
  %2884 = load ptr, ptr %2883, align 8
  %result.i101.i1574.i = call ptr %2884({ ptr, ptr, ptr, i32 } %2878, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2885 = call { ptr, i160 } %result.i101.i1574.i({ ptr, ptr, ptr, i32 } %2878, { ptr, ptr, ptr, i32 } %2878, ptr nonnull align 8 %0) #7
  %.fca.0.extract51.i1575.i = extractvalue { ptr, i160 } %2885, 0
  %2886 = getelementptr i8, ptr %.fca.0.extract51.i1575.i, i64 8
  %2887 = getelementptr i8, ptr %.fca.0.extract51.i1575.i, i64 16
  %2888 = getelementptr i8, ptr %.fca.0.extract51.i1575.i, i64 24
  %2889 = getelementptr i8, ptr %.fca.0.extract51.i1575.i, i64 32
  %2890 = load i64, ptr %2886, align 4
  %2891 = load i64, ptr %2887, align 4
  %2892 = load ptr, ptr %2888, align 8
  %2893 = load ptr, ptr %2889, align 8
  %result.i102.i1576.i = call i1 %2892(i64 %2891, i64 %2890, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %2893) #5
  br i1 %result.i102.i1576.i, label %._crit_edge.sink.split.i1578.i, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1580.i

._crit_edge.sink.split.i1578.i:                   ; preds = %2872, %2869
  %.sink159.i1579.i = phi i64 [ 48, %2869 ], [ 40, %2872 ]
  %2894 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2895 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i1579.i
  %2896 = load ptr, ptr %2895, align 8
  %2897 = load ptr, ptr %2896, align 8
  %2898 = call i32 %2897(ptr nonnull %result.i326.i) #36
  %2899 = add i32 %2898, 1
  %2900 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2901 = getelementptr i8, ptr %2896, i64 8
  %2902 = load ptr, ptr %2901, align 8
  call void %2902(ptr nonnull %result.i326.i, i32 %2899) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1580.i

HashMap_insert_internal_keyK_valueV_hashPtri32.exit1580.i: ; preds = %._crit_edge.sink.split.i1578.i, %2872
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %1)
  br label %._crit_edge.i1315.i

._crit_edge.i1315.i:                              ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1580.i, %2707, %.lr.ph.i1312.i
  %2903 = add nuw nsw i32 %.096.i1313.i, 1
  %2904 = icmp slt i32 %2903, %2689
  br i1 %2904, label %.lr.ph.i1312.i, label %HashMap_resize_new_capacityPtri32.exit1338.i

HashMap_resize_new_capacityPtri32.exit1338.i:     ; preds = %._crit_edge.i1315.i, %._crit_edge1.i984.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  br label %HashMap_ensure_capacity_required_loadPtri32.exit988.i

HashMap_ensure_capacity_required_loadPtri32.exit988.i: ; preds = %HashMap_resize_new_capacityPtri32.exit1338.i, %HashMap_insert_internal_keyK_valueV_hashPtri32.exit.i313
  %2905 = load ptr, ptr %2147, align 8
  %2906 = call i32 %2905({ ptr, i160 } %2166) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2907 = load ptr, ptr %result.i326.i, align 8
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %2908 = load i32, ptr %2150, align 8
  %2909 = add i32 %2908, -1
  %2910 = and i32 %2909, %2906
  %2911 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2912 = load ptr, ptr %2149, align 8
  %2913 = sext i32 %2910 to i64
  %2914 = shl nsw i64 %2913, 5
  %2915 = getelementptr i8, ptr %2912, i64 %2914
  %2916 = load ptr, ptr %2915, align 8
  %2917 = icmp eq ptr %2916, @nil_typ
  %2918 = icmp eq ptr %2916, null
  %2919 = or i1 %2917, %2918
  br i1 %2919, label %HashMap_find_slot_keyK_hashPtri32.exit1383.i, label %.lr.ph.i1353.i

.lr.ph.i1353.i:                                   ; preds = %HashMap_ensure_capacity_required_loadPtri32.exit988.i
  %2920 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %2921

2921:                                             ; preds = %._crit_edge.thread.i1369.i, %.lr.ph.i1353.i
  %2922 = phi i32 [ %2910, %.lr.ph.i1353.i ], [ %2964, %._crit_edge.thread.i1369.i ]
  %spec.store.select.i13741415.i = phi i32 [ -1, %.lr.ph.i1353.i ], [ %spec.store.select.i1374.i, %._crit_edge.thread.i1369.i ]
  %2923 = phi ptr [ %2916, %.lr.ph.i1353.i ], [ %2969, %._crit_edge.thread.i1369.i ]
  %2924 = phi ptr [ %2915, %.lr.ph.i1353.i ], [ %2968, %._crit_edge.thread.i1369.i ]
  %.sroa_idx.i1355.i = getelementptr i8, ptr %2924, i64 16
  %2925 = load i64, ptr %.sroa_idx.i1355.i, align 4
  %2926 = getelementptr i8, ptr %2924, i64 8
  %2927 = load i64, ptr %2926, align 4
  %2928 = inttoptr i64 %2927 to ptr
  %2929 = inttoptr i64 %2925 to ptr
  %hash_coef_ptr.i.i56.i1356.i = getelementptr i8, ptr %2923, i64 8
  %tbl_size_ptr.i.i57.i1357.i = getelementptr i8, ptr %2923, i64 16
  %offset_tbl_ptr.i.i58.i1358.i = getelementptr i8, ptr %2923, i64 40
  %hash_coef.i.i59.i1359.i = load i64, ptr %hash_coef_ptr.i.i56.i1356.i, align 4
  %tbl_size.i.i60.i1360.i = load i64, ptr %tbl_size_ptr.i.i57.i1357.i, align 4
  %offset_tbl.i.i61.i1361.i = load ptr, ptr %offset_tbl_ptr.i.i58.i1358.i, align 8
  %product.i.i.i62.i1362.i = mul i64 %hash_coef.i.i59.i1359.i, 4015701072841558310
  %shifted.i.i.i63.i1363.i = lshr i64 %product.i.i.i62.i1362.i, 32
  %xored.i.i.i64.i1364.i = xor i64 %shifted.i.i.i63.i1363.i, %product.i.i.i62.i1362.i
  %hash.i.i.i65.i1365.i = and i64 %xored.i.i.i64.i1364.i, %tbl_size.i.i60.i1360.i
  %offset_ptr.i.i66.i1366.i = getelementptr i32, ptr %offset_tbl.i.i61.i1361.i, i64 %hash.i.i.i65.i1365.i
  %offset.i.i67.i1367.i = load i32, ptr %offset_ptr.i.i66.i1366.i, align 4
  %2930 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2923, 0
  %2931 = insertvalue { ptr, ptr, ptr, i32 } %2930, ptr %2928, 1
  %2932 = insertvalue { ptr, ptr, ptr, i32 } %2931, ptr %2929, 2
  %2933 = insertvalue { ptr, ptr, ptr, i32 } %2932, i32 %offset.i.i67.i1367.i, 3
  %2934 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %2923)
  %2935 = sext i32 %offset.i.i67.i1367.i to i64
  %2936 = getelementptr ptr, ptr %2923, i64 %2935
  %2937 = getelementptr i8, ptr %2936, i64 64
  %2938 = load ptr, ptr %2937, align 8
  %result.i.i1368.i = call ptr %2938({ ptr, ptr, ptr, i32 } %2933, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2939 = call i32 %result.i.i1368.i({ ptr, ptr, ptr, i32 } %2933, { ptr, ptr, ptr, i32 } %2933, ptr nonnull align 8 %0) #7
  %2940 = icmp eq i32 %2939, %2906
  br i1 %2940, label %._crit_edge.i1380.i, label %._crit_edge.thread.i1369.i

._crit_edge.i1380.i:                              ; preds = %2921
  %2941 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2942 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %2923)
  %2943 = getelementptr i8, ptr %2936, i64 48
  %2944 = load ptr, ptr %2943, align 8
  %result.i69.i1381.i = call ptr %2944({ ptr, ptr, ptr, i32 } %2933, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2945 = call { ptr, i160 } %result.i69.i1381.i({ ptr, ptr, ptr, i32 } %2933, { ptr, ptr, ptr, i32 } %2933, ptr nonnull align 8 %0) #7
  %2946 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2947 = load ptr, ptr %2148, align 8
  %2948 = call i1 %2947({ ptr, i160 } %2945, { ptr, i160 } %2166) #7
  br i1 %2948, label %HashMap_find_slot_keyK_hashPtri32.exit1383.loopexit.i, label %._crit_edge.thread.i1369.i

._crit_edge.thread.i1369.i:                       ; preds = %._crit_edge.i1380.i, %2921
  %2949 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %2950 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %2923)
  %2951 = getelementptr i8, ptr %2936, i64 56
  %2952 = load ptr, ptr %2951, align 8
  %result.i70.i1370.i = call ptr %2952({ ptr, ptr, ptr, i32 } %2933, ptr nocapture nofree noundef nonnull readonly %0) #16
  %2953 = call { ptr, i160 } %result.i70.i1370.i({ ptr, ptr, ptr, i32 } %2933, { ptr, ptr, ptr, i32 } %2933, ptr nonnull align 8 %0) #7
  %.fca.0.extract19.i1371.i = extractvalue { ptr, i160 } %2953, 0
  %2954 = getelementptr i8, ptr %.fca.0.extract19.i1371.i, i64 8
  %2955 = getelementptr i8, ptr %.fca.0.extract19.i1371.i, i64 16
  %2956 = getelementptr i8, ptr %.fca.0.extract19.i1371.i, i64 24
  %2957 = getelementptr i8, ptr %.fca.0.extract19.i1371.i, i64 32
  %2958 = load i64, ptr %2954, align 4
  %2959 = load i64, ptr %2955, align 4
  %2960 = load ptr, ptr %2956, align 8
  %2961 = load ptr, ptr %2957, align 8
  %result.i71.i1372.i = call i1 %2960(i64 %2959, i64 %2958, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %2961) #5
  %2962 = icmp eq i32 %spec.store.select.i13741415.i, -1
  %or.cond.i1373.i = select i1 %result.i71.i1372.i, i1 %2962, i1 false
  %spec.store.select.i1374.i = select i1 %or.cond.i1373.i, i32 %2922, i32 %spec.store.select.i13741415.i
  %2963 = add i32 %2922, 1
  %2964 = and i32 %2963, %2909
  %2965 = load ptr, ptr %2149, align 8
  %2966 = sext i32 %2964 to i64
  %2967 = shl nsw i64 %2966, 5
  %2968 = getelementptr i8, ptr %2965, i64 %2967
  %2969 = load ptr, ptr %2968, align 8
  %2970 = icmp eq ptr %2969, @nil_typ
  %2971 = icmp eq ptr %2969, null
  %2972 = or i1 %2970, %2971
  br i1 %2972, label %._crit_edge105.loopexit.i1376.i, label %2921

._crit_edge105.loopexit.i1376.i:                  ; preds = %._crit_edge.thread.i1369.i
  %2973 = icmp eq i32 %spec.store.select.i1374.i, -1
  %.pre.i1379.pre.i = select i1 %2973, i32 %2964, i32 %spec.store.select.i1374.i
  br label %HashMap_find_slot_keyK_hashPtri32.exit1383.i

HashMap_find_slot_keyK_hashPtri32.exit1383.loopexit.i: ; preds = %._crit_edge.i1380.i
  %.pre1495.i = load ptr, ptr %2149, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit1383.i

HashMap_find_slot_keyK_hashPtri32.exit1383.i:     ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1383.loopexit.i, %._crit_edge105.loopexit.i1376.i, %HashMap_ensure_capacity_required_loadPtri32.exit988.i
  %2974 = phi ptr [ %2965, %._crit_edge105.loopexit.i1376.i ], [ %2912, %HashMap_ensure_capacity_required_loadPtri32.exit988.i ], [ %.pre1495.i, %HashMap_find_slot_keyK_hashPtri32.exit1383.loopexit.i ]
  %2975 = phi i32 [ %.pre.i1379.pre.i, %._crit_edge105.loopexit.i1376.i ], [ %2910, %HashMap_ensure_capacity_required_loadPtri32.exit988.i ], [ %2922, %HashMap_find_slot_keyK_hashPtri32.exit1383.loopexit.i ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %2976 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %2977 = sext i32 %2975 to i64
  %2978 = shl nsw i64 %2977, 5
  %2979 = getelementptr i8, ptr %2974, i64 %2978
  %2980 = load ptr, ptr %2979, align 8
  %2981 = getelementptr i8, ptr %2979, i64 8
  %2982 = load i64, ptr %2981, align 4
  %.sroa_idx.i1008.i = getelementptr i8, ptr %2979, i64 16
  %2983 = load i64, ptr %.sroa_idx.i1008.i, align 4
  %2984 = load ptr, ptr %2142, align 8
  %2985 = load ptr, ptr %2907, align 8, !alias.scope !292
  %2986 = getelementptr i8, ptr %2985, i64 72
  %2987 = load ptr, ptr %2986, align 8, !alias.scope !292
  %result.i.i.i1010.i = call { i64, i64 } %2987(ptr nocapture nofree nonnull readonly %2907) #5, !alias.scope !292
  %2988 = extractvalue { i64, i64 } %result.i.i.i1010.i, 0
  %2989 = extractvalue { i64, i64 } %result.i.i.i1010.i, 1
  %2990 = call i64 @llvm.umax.i64(i64 %2989, i64 8)
  %2991 = urem i64 20, %2989
  %2992 = icmp eq i64 %2991, 0
  %2993 = sub i64 %2989, %2991
  %2994 = select i1 %2992, i64 0, i64 %2993
  %2995 = add i64 %2988, 20
  %2996 = add i64 %2995, %2994
  %2997 = and i64 %2996, 7
  %2998 = icmp eq i64 %2997, 0
  %2999 = sub nuw nsw i64 40, %2997
  %3000 = select i1 %2998, i64 32, i64 %2999
  %3001 = add i64 %3000, %2996
  %3002 = urem i64 %3001, %2990
  %3003 = icmp eq i64 %3002, 0
  %3004 = sub i64 %2990, %3002
  %3005 = select i1 %3003, i64 0, i64 %3004
  %3006 = add i64 %3001, %3005
  %result.i71.i1011.i = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %3006, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %2907, ptr %result.i71.i1011.i, align 8
  %3007 = getelementptr inbounds i8, ptr %result.i71.i1011.i, i64 8
  store ptr %2984, ptr %3007, align 8
  %3008 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71.i1011.i)
  %3009 = load ptr, ptr %2907, align 8
  %3010 = getelementptr i8, ptr %3009, i64 72
  %3011 = load ptr, ptr %3010, align 8
  %result.i.i1462.i = call { i64, i64 } %3011(ptr nocapture nofree nonnull readonly %2907) #5
  %3012 = extractvalue { i64, i64 } %result.i.i1462.i, 1
  %3013 = urem i64 20, %3012
  %3014 = icmp eq i64 %3013, 0
  %reass.sub = sub i64 %3012, %3013
  %3015 = add i64 %reass.sub, 20
  %3016 = select i1 %3014, i64 20, i64 %3015
  %3017 = getelementptr i8, ptr %result.i71.i1011.i, i64 %3016
  %3018 = getelementptr i8, ptr %3009, i64 64
  %3019 = load ptr, ptr %3018, align 8
  call void %3019({ ptr, i160 } %2166, ptr nocapture nofree nonnull readonly %2907, ptr nocapture nofree writeonly %3017) #13
  %3020 = load ptr, ptr %result.i71.i1011.i, align 8
  %3021 = load ptr, ptr %3020, align 8
  %3022 = getelementptr i8, ptr %3021, i64 72
  %3023 = load ptr, ptr %3022, align 8
  %result.i.i1464.i = call { i64, i64 } %3023(ptr nocapture nofree nonnull readonly %3020) #5
  %3024 = extractvalue { i64, i64 } %result.i.i1464.i, 0
  %3025 = extractvalue { i64, i64 } %result.i.i1464.i, 1
  %3026 = urem i64 20, %3025
  %3027 = icmp eq i64 %3026, 0
  %3028 = sub i64 %3025, %3026
  %3029 = select i1 %3027, i64 0, i64 %3028
  %3030 = add i64 %3024, 20
  %3031 = add i64 %3030, %3029
  %3032 = and i64 %3031, 7
  %3033 = icmp eq i64 %3032, 0
  %3034 = sub nuw nsw i64 8, %3032
  %3035 = select i1 %3033, i64 0, i64 %3034
  %3036 = getelementptr i8, ptr %result.i71.i1011.i, i64 %3031
  %3037 = getelementptr i8, ptr %3036, i64 %3035
  store ptr @bool_typ, ptr %3037, align 8
  %3038 = getelementptr i8, ptr %3037, i64 8
  store i160 %.sroa.0224.0.insert.ext.i, ptr %3038, align 4
  %3039 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @Entry) #34
  %3040 = getelementptr inbounds i8, ptr %result.i71.i1011.i, i64 16
  store i32 %2906, ptr %3040, align 8
  %3041 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  store ptr @Entry, ptr %2979, align 8
  %3042 = ptrtoint ptr %result.i71.i1011.i to i64
  store i64 %3042, ptr %2981, align 4
  %.sroa_idx4.i1014.i = getelementptr i8, ptr %2979, i64 24
  store i32 10, ptr %.sroa_idx4.i1014.i, align 4
  %3043 = icmp eq ptr %2980, @nil_typ
  %3044 = icmp eq ptr %2980, null
  %3045 = or i1 %3043, %3044
  br i1 %3045, label %3046, label %3049

3046:                                             ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1383.i
  %3047 = load i32, ptr %2156, align 4
  %3048 = add i32 %3047, 1
  store i32 %3048, ptr %2156, align 4
  br label %._crit_edge.sink.split.i1031.i

3049:                                             ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1383.i
  %3050 = inttoptr i64 %2982 to ptr
  %3051 = inttoptr i64 %2983 to ptr
  %hash_coef_ptr.i.i88.i1015.i = getelementptr i8, ptr %2980, i64 8
  %tbl_size_ptr.i.i89.i1016.i = getelementptr i8, ptr %2980, i64 16
  %offset_tbl_ptr.i.i90.i1017.i = getelementptr i8, ptr %2980, i64 40
  %hash_coef.i.i91.i1018.i = load i64, ptr %hash_coef_ptr.i.i88.i1015.i, align 4, !noalias !295
  %tbl_size.i.i92.i1019.i = load i64, ptr %tbl_size_ptr.i.i89.i1016.i, align 4, !noalias !295
  %offset_tbl.i.i93.i1020.i = load ptr, ptr %offset_tbl_ptr.i.i90.i1017.i, align 8, !noalias !295
  %product.i.i.i94.i1021.i = mul i64 %hash_coef.i.i91.i1018.i, 4015701072841558310
  %shifted.i.i.i95.i1022.i = lshr i64 %product.i.i.i94.i1021.i, 32
  %xored.i.i.i96.i1023.i = xor i64 %shifted.i.i.i95.i1022.i, %product.i.i.i94.i1021.i
  %hash.i.i.i97.i1024.i = and i64 %xored.i.i.i96.i1023.i, %tbl_size.i.i92.i1019.i
  %offset_ptr.i.i98.i1025.i = getelementptr i32, ptr %offset_tbl.i.i93.i1020.i, i64 %hash.i.i.i97.i1024.i
  %offset.i.i99.i1026.i = load i32, ptr %offset_ptr.i.i98.i1025.i, align 4, !noalias !295
  %3052 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2980, 0
  %3053 = insertvalue { ptr, ptr, ptr, i32 } %3052, ptr %3050, 1
  %3054 = insertvalue { ptr, ptr, ptr, i32 } %3053, ptr %3051, 2
  %3055 = insertvalue { ptr, ptr, ptr, i32 } %3054, i32 %offset.i.i99.i1026.i, 3
  %3056 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %3057 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %2980)
  %3058 = sext i32 %offset.i.i99.i1026.i to i64
  %3059 = getelementptr ptr, ptr %2980, i64 %3058
  %3060 = getelementptr i8, ptr %3059, i64 56
  %3061 = load ptr, ptr %3060, align 8
  %result.i101.i1027.i = call ptr %3061({ ptr, ptr, ptr, i32 } %3055, ptr nocapture nofree noundef nonnull readonly %0) #16
  %3062 = call { ptr, i160 } %result.i101.i1027.i({ ptr, ptr, ptr, i32 } %3055, { ptr, ptr, ptr, i32 } %3055, ptr nonnull align 8 %0) #7
  %.fca.0.extract51.i1028.i = extractvalue { ptr, i160 } %3062, 0
  %3063 = getelementptr i8, ptr %.fca.0.extract51.i1028.i, i64 8
  %3064 = getelementptr i8, ptr %.fca.0.extract51.i1028.i, i64 16
  %3065 = getelementptr i8, ptr %.fca.0.extract51.i1028.i, i64 24
  %3066 = getelementptr i8, ptr %.fca.0.extract51.i1028.i, i64 32
  %3067 = load i64, ptr %3063, align 4
  %3068 = load i64, ptr %3064, align 4
  %3069 = load ptr, ptr %3065, align 8
  %3070 = load ptr, ptr %3066, align 8
  %result.i102.i1029.i = call i1 %3069(i64 %3068, i64 %3067, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %3070) #5
  br i1 %result.i102.i1029.i, label %._crit_edge.sink.split.i1031.i, label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1033.i

._crit_edge.sink.split.i1031.i:                   ; preds = %3049, %3046
  %.sink159.i1032.i = phi i64 [ 48, %3046 ], [ 40, %3049 ]
  %3071 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %3072 = getelementptr i8, ptr getelementptr inbounds (i8, ptr @HashMap, i64 80), i64 %.sink159.i1032.i
  %3073 = load ptr, ptr %3072, align 8
  %3074 = load ptr, ptr %3073, align 8
  %3075 = call i32 %3074(ptr nonnull %result.i326.i) #36
  %3076 = add i32 %3075, 1
  %3077 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %3078 = getelementptr i8, ptr %3073, i64 8
  %3079 = load ptr, ptr %3078, align 8
  call void %3079(ptr nonnull %result.i326.i, i32 %3076) #35
  br label %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1033.i

HashMap_insert_internal_keyK_valueV_hashPtri32.exit1033.i: ; preds = %._crit_edge.sink.split.i1031.i, %3049
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %3080 = sext i32 %2291 to i64
  %3081 = add i64 %.0275527.i, %3080
  %3082 = add nsw i32 %.0266528.i, 1
  br label %._crit_edge1.i

._crit_edge1.i:                                   ; preds = %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1033.i, %HashMap_get_keyK.exit.i383
  %.2277.i = phi i64 [ %3081, %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1033.i ], [ %.0275527.i, %HashMap_get_keyK.exit.i383 ]
  %.2268.i = phi i32 [ %3082, %HashMap_insert_internal_keyK_valueV_hashPtri32.exit1033.i ], [ %.0266528.i, %HashMap_get_keyK.exit.i383 ]
  %3083 = add nuw nsw i32 %.0264529.i, 1
  %3084 = icmp slt i32 %.2268.i, 1000000
  %3085 = icmp ult i32 %.0264529.i, 9999999
  %spec.select.i315 = select i1 %3084, i1 %3085, i1 false
  br i1 %spec.select.i315, label %2161, label %._crit_edge3._crit_edge.i

._crit_edge3._crit_edge.i:                        ; preds = %._crit_edge1.i
  br i1 %3084, label %._crit_edge4.i316, label %._crit_edge4.i316.thread

._crit_edge4.i316.thread:                         ; preds = %._crit_edge3._crit_edge.i
  %3086 = call i64 @clock()
  br label %.lr.ph535.preheader.i

._crit_edge4.i316:                                ; preds = %._crit_edge3._crit_edge.i
  %result.i355.i = call noalias align 32 dereferenceable_or_null(30) ptr @bump_malloc_inner(i64 noundef 30, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <29 x i8> <i8 87, i8 97, i8 114, i8 110, i8 105, i8 110, i8 103, i8 58, i8 32, i8 67, i8 111, i8 117, i8 108, i8 100, i8 32, i8 111, i8 110, i8 108, i8 121, i8 32, i8 103, i8 101, i8 110, i8 101, i8 114, i8 97, i8 116, i8 101, i8 32>, ptr %result.i355.i, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %3087 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %3088 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i1047.i = call noalias dereferenceable_or_null(30) ptr @bump_malloc_inner(i64 noundef 30, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(29) %result.i.i1047.i, ptr noundef nonnull align 32 dereferenceable(29) %result.i355.i, i64 29, i1 false)
  %3089 = getelementptr i8, ptr %result.i.i1047.i, i64 29
  store i8 0, ptr %3089, align 1
  %puts.i.i340 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1047.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %3090 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.2268.i) #17
  %result.i361.i = call noalias align 64 dereferenceable_or_null(34) ptr @bump_malloc_inner(i64 noundef 34, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %3091 = load <33 x i8>, ptr @uyexo__unique_keys_for_random_hit_test, align 64
  store <33 x i8> %3091, ptr %result.i361.i, align 64
  %3092 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %3093 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %3094 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i1062.i = call noalias dereferenceable_or_null(34) ptr @bump_malloc_inner(i64 noundef 34, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(33) %result.i.i1062.i, ptr noundef nonnull align 64 dereferenceable(33) %result.i361.i, i64 33, i1 false)
  %3095 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %3096 = getelementptr i8, ptr %result.i.i1062.i, i64 33
  store i8 0, ptr %3096, align 1
  %puts.i780.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1062.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %3097 = call i64 @clock()
  %3098 = icmp sgt i32 %.2268.i, 0
  br i1 %3098, label %.lr.ph535.preheader.i, label %._crit_edge.lr.ph.i1146.i

.lr.ph535.preheader.i:                            ; preds = %._crit_edge4.i316.thread, %._crit_edge4.i316
  %3099 = phi i64 [ %3086, %._crit_edge4.i316.thread ], [ %3097, %._crit_edge4.i316 ]
  %.0274.i412 = phi i32 [ 1000000, %._crit_edge4.i316.thread ], [ %.2268.i, %._crit_edge4.i316 ]
  %3100 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  br label %.lr.ph535.i

.lr.ph535.i:                                      ; preds = %._crit_edge5.i336, %.lr.ph535.preheader.i
  %.0263534.i = phi i64 [ %.2.i337, %._crit_edge5.i336 ], [ 0, %.lr.ph535.preheader.i ]
  %.0269533.i = phi i1 [ %.2271.i, %._crit_edge5.i336 ], [ true, %.lr.ph535.preheader.i ]
  %.0272532.i = phi i32 [ %3239, %._crit_edge5.i336 ], [ 0, %.lr.ph535.preheader.i ]
  %3101 = zext nneg i32 %.0272532.i to i64
  %3102 = shl nuw nsw i64 %3101, 2
  %3103 = getelementptr i8, ptr %result.i4.i.i269, i64 %3102
  %3104 = load i32, ptr %3103, align 1
  %.sroa.2.sroa.0.0.insert.ext.i.i335 = zext i32 %3104 to i160
  %3105 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext.i.i335, 1
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %3106 = load ptr, ptr %2137, align 8
  %3107 = call i32 %3106({ ptr, i160 } %3105) #7
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %3108 = load i32, ptr %2140, align 8
  %3109 = add i32 %3108, -1
  %3110 = and i32 %3109, %3107
  %3111 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %3112 = load ptr, ptr %2139, align 8
  %3113 = sext i32 %3110 to i64
  %3114 = shl nsw i64 %3113, 5
  %3115 = getelementptr i8, ptr %3112, i64 %3114
  %3116 = load ptr, ptr %3115, align 8
  %3117 = icmp eq ptr %3116, @nil_typ
  %3118 = icmp eq ptr %3116, null
  %3119 = or i1 %3117, %3118
  br i1 %3119, label %HashMap_find_slot_keyK_hashPtri32.exit1112.i, label %.lr.ph.i1082.i

.lr.ph.i1082.i:                                   ; preds = %.lr.ph535.i
  %3120 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  br label %3121

3121:                                             ; preds = %._crit_edge.thread.i1098.i, %.lr.ph.i1082.i
  %3122 = phi i32 [ %3110, %.lr.ph.i1082.i ], [ %3164, %._crit_edge.thread.i1098.i ]
  %spec.store.select.i11031200.i = phi i32 [ -1, %.lr.ph.i1082.i ], [ %spec.store.select.i1103.i, %._crit_edge.thread.i1098.i ]
  %3123 = phi ptr [ %3116, %.lr.ph.i1082.i ], [ %3169, %._crit_edge.thread.i1098.i ]
  %3124 = phi ptr [ %3115, %.lr.ph.i1082.i ], [ %3168, %._crit_edge.thread.i1098.i ]
  %.sroa_idx.i1084.i = getelementptr i8, ptr %3124, i64 16
  %3125 = load i64, ptr %.sroa_idx.i1084.i, align 4
  %3126 = getelementptr i8, ptr %3124, i64 8
  %3127 = load i64, ptr %3126, align 4
  %3128 = inttoptr i64 %3127 to ptr
  %3129 = inttoptr i64 %3125 to ptr
  %hash_coef_ptr.i.i56.i1085.i = getelementptr i8, ptr %3123, i64 8
  %tbl_size_ptr.i.i57.i1086.i = getelementptr i8, ptr %3123, i64 16
  %offset_tbl_ptr.i.i58.i1087.i = getelementptr i8, ptr %3123, i64 40
  %hash_coef.i.i59.i1088.i = load i64, ptr %hash_coef_ptr.i.i56.i1085.i, align 4
  %tbl_size.i.i60.i1089.i = load i64, ptr %tbl_size_ptr.i.i57.i1086.i, align 4
  %offset_tbl.i.i61.i1090.i = load ptr, ptr %offset_tbl_ptr.i.i58.i1087.i, align 8
  %product.i.i.i62.i1091.i = mul i64 %hash_coef.i.i59.i1088.i, 4015701072841558310
  %shifted.i.i.i63.i1092.i = lshr i64 %product.i.i.i62.i1091.i, 32
  %xored.i.i.i64.i1093.i = xor i64 %shifted.i.i.i63.i1092.i, %product.i.i.i62.i1091.i
  %hash.i.i.i65.i1094.i = and i64 %xored.i.i.i64.i1093.i, %tbl_size.i.i60.i1089.i
  %offset_ptr.i.i66.i1095.i = getelementptr i32, ptr %offset_tbl.i.i61.i1090.i, i64 %hash.i.i.i65.i1094.i
  %offset.i.i67.i1096.i = load i32, ptr %offset_ptr.i.i66.i1095.i, align 4
  %3130 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3123, 0
  %3131 = insertvalue { ptr, ptr, ptr, i32 } %3130, ptr %3128, 1
  %3132 = insertvalue { ptr, ptr, ptr, i32 } %3131, ptr %3129, 2
  %3133 = insertvalue { ptr, ptr, ptr, i32 } %3132, i32 %offset.i.i67.i1096.i, 3
  %3134 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %3123)
  %3135 = sext i32 %offset.i.i67.i1096.i to i64
  %3136 = getelementptr ptr, ptr %3123, i64 %3135
  %3137 = getelementptr i8, ptr %3136, i64 64
  %3138 = load ptr, ptr %3137, align 8
  %result.i.i1097.i = call ptr %3138({ ptr, ptr, ptr, i32 } %3133, ptr nocapture nofree noundef nonnull readonly %0) #16
  %3139 = call i32 %result.i.i1097.i({ ptr, ptr, ptr, i32 } %3133, { ptr, ptr, ptr, i32 } %3133, ptr nonnull align 8 %0) #7
  %3140 = icmp eq i32 %3139, %3107
  br i1 %3140, label %._crit_edge.i1109.i, label %._crit_edge.thread.i1098.i

._crit_edge.i1109.i:                              ; preds = %3121
  %3141 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %3142 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %3123)
  %3143 = getelementptr i8, ptr %3136, i64 48
  %3144 = load ptr, ptr %3143, align 8
  %result.i69.i1110.i = call ptr %3144({ ptr, ptr, ptr, i32 } %3133, ptr nocapture nofree noundef nonnull readonly %0) #16
  %3145 = call { ptr, i160 } %result.i69.i1110.i({ ptr, ptr, ptr, i32 } %3133, { ptr, ptr, ptr, i32 } %3133, ptr nonnull align 8 %0) #7
  %3146 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %3147 = load ptr, ptr %2138, align 8
  %3148 = call i1 %3147({ ptr, i160 } %3145, { ptr, i160 } %3105) #7
  br i1 %3148, label %HashMap_find_slot_keyK_hashPtri32.exit1112.loopexit.i, label %._crit_edge.thread.i1098.i

._crit_edge.thread.i1098.i:                       ; preds = %._crit_edge.i1109.i, %3121
  %3149 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %3150 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %3123)
  %3151 = getelementptr i8, ptr %3136, i64 56
  %3152 = load ptr, ptr %3151, align 8
  %result.i70.i1099.i = call ptr %3152({ ptr, ptr, ptr, i32 } %3133, ptr nocapture nofree noundef nonnull readonly %0) #16
  %3153 = call { ptr, i160 } %result.i70.i1099.i({ ptr, ptr, ptr, i32 } %3133, { ptr, ptr, ptr, i32 } %3133, ptr nonnull align 8 %0) #7
  %.fca.0.extract19.i1100.i = extractvalue { ptr, i160 } %3153, 0
  %3154 = getelementptr i8, ptr %.fca.0.extract19.i1100.i, i64 8
  %3155 = getelementptr i8, ptr %.fca.0.extract19.i1100.i, i64 16
  %3156 = getelementptr i8, ptr %.fca.0.extract19.i1100.i, i64 24
  %3157 = getelementptr i8, ptr %.fca.0.extract19.i1100.i, i64 32
  %3158 = load i64, ptr %3154, align 4
  %3159 = load i64, ptr %3155, align 4
  %3160 = load ptr, ptr %3156, align 8
  %3161 = load ptr, ptr %3157, align 8
  %result.i71.i1101.i = call i1 %3160(i64 %3159, i64 %3158, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %3161) #5
  %3162 = icmp eq i32 %spec.store.select.i11031200.i, -1
  %or.cond.i1102.i = select i1 %result.i71.i1101.i, i1 %3162, i1 false
  %spec.store.select.i1103.i = select i1 %or.cond.i1102.i, i32 %3122, i32 %spec.store.select.i11031200.i
  %3163 = add i32 %3122, 1
  %3164 = and i32 %3163, %3109
  %3165 = load ptr, ptr %2139, align 8
  %3166 = sext i32 %3164 to i64
  %3167 = shl nsw i64 %3166, 5
  %3168 = getelementptr i8, ptr %3165, i64 %3167
  %3169 = load ptr, ptr %3168, align 8
  %3170 = icmp eq ptr %3169, @nil_typ
  %3171 = icmp eq ptr %3169, null
  %3172 = or i1 %3170, %3171
  br i1 %3172, label %._crit_edge105.loopexit.i1105.i, label %3121

._crit_edge105.loopexit.i1105.i:                  ; preds = %._crit_edge.thread.i1098.i
  %3173 = icmp eq i32 %spec.store.select.i1103.i, -1
  %.pre.i1108.pre.i = select i1 %3173, i32 %3164, i32 %spec.store.select.i1103.i
  br label %HashMap_find_slot_keyK_hashPtri32.exit1112.i

HashMap_find_slot_keyK_hashPtri32.exit1112.loopexit.i: ; preds = %._crit_edge.i1109.i
  %.pre1235.i = load ptr, ptr %2139, align 8
  br label %HashMap_find_slot_keyK_hashPtri32.exit1112.i

HashMap_find_slot_keyK_hashPtri32.exit1112.i:     ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1112.loopexit.i, %._crit_edge105.loopexit.i1105.i, %.lr.ph535.i
  %3174 = phi ptr [ %3165, %._crit_edge105.loopexit.i1105.i ], [ %3112, %.lr.ph535.i ], [ %.pre1235.i, %HashMap_find_slot_keyK_hashPtri32.exit1112.loopexit.i ]
  %3175 = phi i32 [ %.pre.i1108.pre.i, %._crit_edge105.loopexit.i1105.i ], [ %3110, %.lr.ph535.i ], [ %3122, %HashMap_find_slot_keyK_hashPtri32.exit1112.loopexit.i ]
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %3176 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %3177 = sext i32 %3175 to i64
  %3178 = shl nsw i64 %3177, 5
  %3179 = getelementptr i8, ptr %3174, i64 %3178
  %3180 = load ptr, ptr %3179, align 8
  %3181 = icmp ne ptr %3180, @nil_typ
  %3182 = icmp ne ptr %3180, null
  %.not57.i813.i = and i1 %3181, %3182
  br i1 %.not57.i813.i, label %3183, label %HashMap_get_keyK.exit841.thread.i

3183:                                             ; preds = %HashMap_find_slot_keyK_hashPtri32.exit1112.i
  %3184 = getelementptr i8, ptr %3179, i64 8
  %3185 = load i64, ptr %3184, align 4
  %.sroa_idx.i817.i = getelementptr i8, ptr %3179, i64 16
  %3186 = load i64, ptr %.sroa_idx.i817.i, align 4
  %3187 = inttoptr i64 %3185 to ptr
  %3188 = inttoptr i64 %3186 to ptr
  %hash_coef_ptr.i.i60.i818.i = getelementptr i8, ptr %3180, i64 8
  %tbl_size_ptr.i.i61.i819.i = getelementptr i8, ptr %3180, i64 16
  %offset_tbl_ptr.i.i62.i820.i = getelementptr i8, ptr %3180, i64 40
  %hash_coef.i.i63.i821.i = load i64, ptr %hash_coef_ptr.i.i60.i818.i, align 4, !noalias !298
  %tbl_size.i.i64.i822.i = load i64, ptr %tbl_size_ptr.i.i61.i819.i, align 4, !noalias !298
  %offset_tbl.i.i65.i823.i = load ptr, ptr %offset_tbl_ptr.i.i62.i820.i, align 8, !noalias !298
  %product.i.i.i66.i824.i = mul i64 %hash_coef.i.i63.i821.i, 4015701072841558310
  %shifted.i.i.i67.i825.i = lshr i64 %product.i.i.i66.i824.i, 32
  %xored.i.i.i68.i826.i = xor i64 %shifted.i.i.i67.i825.i, %product.i.i.i66.i824.i
  %hash.i.i.i69.i827.i = and i64 %xored.i.i.i68.i826.i, %tbl_size.i.i64.i822.i
  %offset_ptr.i.i70.i828.i = getelementptr i32, ptr %offset_tbl.i.i65.i823.i, i64 %hash.i.i.i69.i827.i
  %offset.i.i71.i829.i = load i32, ptr %offset_ptr.i.i70.i828.i, align 4, !noalias !298
  %3189 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3180, 0
  %3190 = insertvalue { ptr, ptr, ptr, i32 } %3189, ptr %3187, 1
  %3191 = insertvalue { ptr, ptr, ptr, i32 } %3190, ptr %3188, 2
  %3192 = insertvalue { ptr, ptr, ptr, i32 } %3191, i32 %offset.i.i71.i829.i, 3
  %3193 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %3194 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %3180)
  %3195 = sext i32 %offset.i.i71.i829.i to i64
  %3196 = getelementptr ptr, ptr %3180, i64 %3195
  %3197 = getelementptr i8, ptr %3196, i64 56
  %3198 = load ptr, ptr %3197, align 8
  %result.i73.i830.i = call ptr %3198({ ptr, ptr, ptr, i32 } %3192, ptr nocapture nofree noundef nonnull readonly %0) #16
  %3199 = call { ptr, i160 } %result.i73.i830.i({ ptr, ptr, ptr, i32 } %3192, { ptr, ptr, ptr, i32 } %3192, ptr nonnull align 8 %0) #7
  %.fca.0.extract51.i831.i = extractvalue { ptr, i160 } %3199, 0
  %.fca.1.extract52.i832.i = extractvalue { ptr, i160 } %3199, 1
  %3200 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %3201 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %3180)
  %3202 = getelementptr i8, ptr %3196, i64 64
  %3203 = load ptr, ptr %3202, align 8
  %result.i74.i833.i = call ptr %3203({ ptr, ptr, ptr, i32 } %3192, ptr nocapture nofree noundef nonnull readonly %0) #16
  %3204 = call i32 %result.i74.i833.i({ ptr, ptr, ptr, i32 } %3192, { ptr, ptr, ptr, i32 } %3192, ptr nonnull align 8 %0) #7
  %3205 = icmp eq i32 %3204, %3107
  br i1 %3205, label %._crit_edge.i834.i, label %HashMap_get_keyK.exit841.thread.i

._crit_edge.i834.i:                               ; preds = %3183
  %3206 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0)
  %3207 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %3180)
  %3208 = getelementptr i8, ptr %3196, i64 48
  %3209 = load ptr, ptr %3208, align 8
  %result.i75.i835.i = call ptr %3209({ ptr, ptr, ptr, i32 } %3192, ptr nocapture nofree noundef nonnull readonly %0) #16
  %3210 = call { ptr, i160 } %result.i75.i835.i({ ptr, ptr, ptr, i32 } %3192, { ptr, ptr, ptr, i32 } %3192, ptr nonnull align 8 %0) #7
  %3211 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %3212 = load ptr, ptr %2138, align 8
  %3213 = call i1 %3212({ ptr, i160 } %3210, { ptr, i160 } %3105) #7
  br i1 %3213, label %HashMap_get_keyK.exit841.i, label %HashMap_get_keyK.exit841.thread.i

HashMap_get_keyK.exit841.thread.i:                ; preds = %._crit_edge.i834.i, %3183, %HashMap_find_slot_keyK_hashPtri32.exit1112.i
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  br label %._crit_edge.lr.ph.i1127.i

HashMap_get_keyK.exit841.i:                       ; preds = %._crit_edge.i834.i
  %3214 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull @HashMap)
  %3215 = load ptr, ptr %2132, align 8
  %3216 = load ptr, ptr %3215, align 8
  %3217 = ptrtoint ptr %3216 to i64
  %3218 = getelementptr i8, ptr %.fca.0.extract51.i831.i, i64 8
  %3219 = getelementptr i8, ptr %.fca.0.extract51.i831.i, i64 16
  %3220 = getelementptr i8, ptr %.fca.0.extract51.i831.i, i64 24
  %3221 = getelementptr i8, ptr %.fca.0.extract51.i831.i, i64 32
  %3222 = load i64, ptr %3218, align 4
  %3223 = load i64, ptr %3219, align 4
  %3224 = load ptr, ptr %3220, align 8
  %3225 = load ptr, ptr %3221, align 8
  %3226 = load i64, ptr %3216, align 4
  %result.i77.i838.i = call i1 %3224(i64 %3223, i64 %3222, i64 %3226, i64 %3217, ptr readonly %3225) #5
  %cond.fr.i839.i = freeze i1 %result.i77.i838.i
  %spec.select.i840.i = select i1 %cond.fr.i839.i, ptr %.fca.0.extract51.i831.i, ptr @nil_typ
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %3227 = icmp ne ptr %spec.select.i840.i, @nil_typ
  %3228 = icmp ne ptr %spec.select.i840.i, null
  %.not281.i = and i1 %3227, %3228
  br i1 %.not281.i, label %3229, label %._crit_edge.lr.ph.i1127.i

3229:                                             ; preds = %HashMap_get_keyK.exit841.i
  %.sroa.2.8.extract.trunc.i338 = trunc i160 %.fca.1.extract52.i832.i to i32
  %3230 = sext i32 %.sroa.2.8.extract.trunc.i338 to i64
  %3231 = add i64 %.0263534.i, %3230
  br label %._crit_edge5.i336

._crit_edge.lr.ph.i1127.i:                        ; preds = %HashMap_get_keyK.exit841.i, %HashMap_get_keyK.exit841.thread.i
  %result.i368.i = call noalias align 64 dereferenceable_or_null(52) ptr @bump_malloc_inner(i64 noundef 52, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %3232 = load <51 x i8>, ptr @umtrl_Error_Nil_returned_during_random_hit_test_for_key_, align 64
  store <51 x i8> %3232, ptr %result.i368.i, align 64
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %3233 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %3234 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i1126.i = call noalias dereferenceable_or_null(52) ptr @bump_malloc_inner(i64 noundef 52, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(51) %result.i.i1126.i, ptr noundef nonnull align 64 dereferenceable(51) %result.i368.i, i64 51, i1 false)
  %3235 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %3236 = getelementptr i8, ptr %result.i.i1126.i, i64 51
  store i8 0, ptr %3236, align 1
  %puts.i861.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1126.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %3237 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %3238 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %3104) #17
  br label %._crit_edge5.i336

._crit_edge5.i336:                                ; preds = %._crit_edge.lr.ph.i1127.i, %3229
  %.2271.i = phi i1 [ %.0269533.i, %3229 ], [ false, %._crit_edge.lr.ph.i1127.i ]
  %.2.i337 = phi i64 [ %3231, %3229 ], [ %.0263534.i, %._crit_edge.lr.ph.i1127.i ]
  %3239 = add nuw nsw i32 %.0272532.i, 1
  %3240 = icmp ult i32 %3239, %.0274.i412
  br i1 %3240, label %.lr.ph535.i, label %._crit_edge.lr.ph.i1146.i

._crit_edge.lr.ph.i1146.i:                        ; preds = %._crit_edge5.i336, %._crit_edge4.i316
  %3241 = phi i1 [ false, %._crit_edge4.i316 ], [ true, %._crit_edge5.i336 ]
  %3242 = phi i64 [ %3097, %._crit_edge4.i316 ], [ %3099, %._crit_edge5.i336 ]
  %.0274.i411 = phi i32 [ %.2268.i, %._crit_edge4.i316 ], [ %.0274.i412, %._crit_edge5.i336 ]
  %.0269.lcssa.i = phi i1 [ true, %._crit_edge4.i316 ], [ %.2271.i, %._crit_edge5.i336 ]
  %.0263.lcssa.i = phi i64 [ 0, %._crit_edge4.i316 ], [ %.2.i337, %._crit_edge5.i336 ]
  %3243 = call i64 @clock()
  %result.i374.i = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 71, i8 101, i8 116, i8 32, i8 82, i8 97, i8 110, i8 100, i8 111, i8 109, i8 32, i8 72, i8 105, i8 116>, ptr %result.i374.i, align 16
  %3244 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO) #34
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %3245 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %3246 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i1145.i = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i1145.i, ptr noundef nonnull align 16 dereferenceable(14) %result.i374.i, i64 14, i1 false)
  %3247 = sub i64 %3243, %3242
  %3248 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %3249 = getelementptr i8, ptr %result.i.i1145.i, i64 14
  store i8 0, ptr %3249, align 1
  %puts.i881.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1145.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %result.i97.i.i317 = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 79, i8 112, i8 101, i8 114, i8 97, i8 116, i8 105, i8 111, i8 110, i8 115, i8 58, i8 32>, ptr %result.i97.i.i317, align 16
  %result.i.i375.i.i318 = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i375.i.i318, ptr noundef nonnull align 16 dereferenceable(14) %result.i97.i.i317, i64 14, i1 false)
  %puts.i.i.i319 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i375.i.i318)
  %3250 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.0274.i411) #17
  %result.i103.i.i320 = call noalias align 16 dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <14 x i8> <i8 32, i8 32, i8 84, i8 111, i8 116, i8 97, i8 108, i8 32, i8 84, i8 105, i8 109, i8 101, i8 58, i8 32>, ptr %result.i103.i.i320, align 16
  %result.i.i389.i.i321 = call noalias dereferenceable_or_null(15) ptr @bump_malloc_inner(i64 noundef 15, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(14) %result.i.i389.i.i321, ptr noundef nonnull align 16 dereferenceable(14) %result.i103.i.i320, i64 14, i1 false)
  %puts.i313.i.i322 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i389.i.i321)
  %3251 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %3247) #17
  %result.i109.i.i323 = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 109, i8 115>, ptr %result.i109.i.i323, align 4
  %result.i.i408.i.i324 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i408.i.i324, ptr noundef nonnull align 4 dereferenceable(3) %result.i109.i.i323, i64 3, i1 false)
  %puts.i333.i.i325 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i408.i.i324)
  br i1 %3241, label %._crit_edge1.i.i, label %._crit_edge.lr.ph.i1320

._crit_edge1.i.i:                                 ; preds = %._crit_edge.lr.ph.i1146.i
  %3252 = icmp sgt i64 %3247, 0
  br i1 %3252, label %3253, label %._crit_edge.lr.ph.i428.i.i

3253:                                             ; preds = %._crit_edge1.i.i
  %3254 = zext nneg i32 %.0274.i411 to i64
  %3255 = mul i64 %3247, 1000000
  %3256 = sdiv i64 %3255, %3254
  br label %._crit_edge.lr.ph.i428.i.i

._crit_edge.lr.ph.i428.i.i:                       ; preds = %3253, %._crit_edge1.i.i
  %.0.i.i328 = phi i64 [ %3256, %3253 ], [ 0, %._crit_edge1.i.i ]
  %result.i114.i.i329 = call noalias align 16 dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <15 x i8> <i8 32, i8 32, i8 84, i8 105, i8 109, i8 101, i8 47, i8 79, i8 112, i8 58, i8 32, i8 32, i8 32, i8 32, i8 126>, ptr %result.i114.i.i329, align 16
  %result.i.i427.i.i330 = call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(15) %result.i.i427.i.i330, ptr noundef nonnull align 16 dereferenceable(15) %result.i114.i.i329, i64 15, i1 false)
  %puts.i353.i.i331 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i427.i.i330)
  %3257 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.0.i.i328) #17
  %result.i120.i.i332 = call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 32, i8 110, i8 115>, ptr %result.i120.i.i332, align 4
  %3258 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  %result.i.i446.i.i333 = call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i446.i.i333, ptr noundef nonnull align 4 dereferenceable(3) %result.i120.i.i332, i64 3, i1 false)
  %3259 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %puts.i373.i.i334 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i446.i.i333)
  br label %._crit_edge.lr.ph.i1320

._crit_edge.lr.ph.i1320:                          ; preds = %._crit_edge.lr.ph.i1146.i, %._crit_edge.lr.ph.i428.i.i
  %.not.i326 = icmp eq i64 %.0263.lcssa.i, %.2277.i
  %result.i378.i = call noalias align 32 dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <18 x i8> <i8 32, i8 32, i8 32, i8 32, i8 86, i8 101, i8 114, i8 105, i8 102, i8 105, i8 99, i8 97, i8 116, i8 105, i8 111, i8 110, i8 58, i8 32>, ptr %result.i378.i, align 32
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %3260 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %3261 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i1164.i = call noalias dereferenceable_or_null(19) ptr @bump_malloc_inner(i64 noundef 19, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(18) %result.i.i1164.i, ptr noundef nonnull align 32 dereferenceable(18) %result.i378.i, i64 18, i1 false)
  %spec.select282.i = select i1 %.not.i326, i1 %.0269.lcssa.i, i1 false
  %3262 = getelementptr i8, ptr %result.i.i1164.i, i64 18
  store i8 0, ptr %3262, align 1
  %puts.i901.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1164.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  %..i327 = select i1 %spec.select282.i, <4 x i8> <i8 80, i8 65, i8 83, i8 83>, <4 x i8> <i8 70, i8 65, i8 73, i8 76>
  %3263 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %3264 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %3265 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i1183.i = call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <4 x i8> %..i327, ptr %result.i.i1183.i, align 1
  %3266 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %3267 = getelementptr i8, ptr %result.i.i1183.i, i64 4
  store i8 0, ptr %3267, align 1
  %puts.i921.i = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1183.i)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %.sroa.0224.sroa.0.i)
  call void @benchmark_get_random_miss(i32 noundef 1000000)
  call void @benchmark_remove_random(i32 noundef 1000000)
  %result.i390 = call noalias align 32 dereferenceable_or_null(28) ptr @bump_malloc_inner(i64 noundef 28, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <27 x i8> <i8 45, i8 45, i8 45, i8 32, i8 66, i8 101, i8 110, i8 99, i8 104, i8 109, i8 97, i8 114, i8 107, i8 115, i8 32, i8 67, i8 111, i8 109, i8 112, i8 108, i8 101, i8 116, i8 101, i8 32, i8 45, i8 45, i8 45>, ptr %result.i390, align 32
  %3268 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull align 16 dereferenceable(160) @IO)
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %0)
  %3269 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %0) #34
  %3270 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %0) #34
  %result.i.i1319 = call noalias dereferenceable_or_null(28) ptr @bump_malloc_inner(i64 noundef 28, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(27) %result.i.i1319, ptr noundef nonnull align 32 dereferenceable(27) %result.i390, i64 27, i1 false)
  %3271 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %3272 = getelementptr i8, ptr %result.i.i1319, i64 27
  store i8 0, ptr %3272, align 1
  %puts.i875 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i1319)
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %0)
  ret i32 0
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_bool_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr (i1, ptr null, i32 1) to i64), i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_bool_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5 {
  %3 = load i8, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i8 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @bool_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_bool_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #6 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i8
  store i8 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.inline.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #8

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_any_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 32, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Object(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_i8_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_i8_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5 {
  %3 = load i8, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i8 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @i8_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_i8_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #6 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i8
  store i8 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_i32_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 4, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_i32_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5 {
  %3 = load i32, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i32 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @i32_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_i32_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #6 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  store i32 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_i64_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 8, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_i64_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5 {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @i64_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_i64_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #6 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_i128_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 16, i64 4 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_i128_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5 {
  %.sroa.2.sroa.0.0.copyload = load i128, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i128 %.sroa.2.sroa.0.0.copyload to i160
  %3 = insertvalue { ptr, i160 } { ptr @i128_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_i128_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #6 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i128
  store i128 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_f64_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_f64_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5 {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @f64_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_f64_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #6 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_nil_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr ([0 x i8], ptr null, i32 1) to i64), i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { ptr, i160 } @_box_nil_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #0 {
  ret { ptr, i160 } { ptr @nil_typ, i160 undef }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @_unbox_nil_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #0 {
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_nothing_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr ([0 x i8], ptr null, i32 1) to i64), i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { ptr, i160 } @_box_nothing_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #0 {
  ret { ptr, i160 } { ptr @nothing_typ, i160 undef }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @_unbox_nothing_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #0 {
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_coroutine_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_coroutine_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5 {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @coroutine_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_coroutine_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #6 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_function_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_function_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5 {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @function_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_function_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #6 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_buffer_typ(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_buffer_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5 {
  %3 = load i64, ptr %0, align 1
  %.sroa.2.sroa.0.0.insert.ext = zext i64 %3 to i160
  %4 = insertvalue { ptr, i160 } { ptr @buffer_typ, i160 undef }, i160 %.sroa.2.sroa.0.0.insert.ext, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_buffer_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #6 {
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  store i64 %.sroa.1.8.extract.trunc, ptr %2, align 1
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn
define { ptr, i160 } @_box_tuple_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #9 {
  %.sroa.2 = alloca [24 x i8], align 8
  %3 = getelementptr i8, ptr %1, i64 8
  %4 = load i64, ptr %3, align 4
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %_data_size_tuple_typ.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %2, %.lr.ph.i
  %.reg2mem20.010.reg2mem.0.i = phi i64 [ %13, %.lr.ph.i ], [ 1, %2 ]
  %.reg2mem22.011.reg2mem.0.i = phi i64 [ %19, %.lr.ph.i ], [ 0, %2 ]
  %.reg2mem14.0.i = phi i64 [ %20, %.lr.ph.i ], [ 1, %2 ]
  %.in.reg2mem.0.i = phi i64 [ %22, %.lr.ph.i ], [ %4, %2 ]
  %6 = inttoptr i64 %.in.reg2mem.0.i to ptr
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = tail call { i64, i64 } %9(ptr nonnull align 8 %6) #7
  %11 = extractvalue { i64, i64 } %10, 0
  %12 = extractvalue { i64, i64 } %10, 1
  %13 = tail call i64 @llvm.umax.i64(i64 %12, i64 %.reg2mem20.010.reg2mem.0.i)
  %14 = urem i64 %.reg2mem22.011.reg2mem.0.i, %12
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 %12, %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 %11, %.reg2mem22.011.reg2mem.0.i
  %19 = add i64 %18, %17
  %20 = add i64 %.reg2mem14.0.i, 1
  %21 = getelementptr ptr, ptr %1, i64 %20
  %22 = load i64, ptr %21, align 4
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %_data_size_tuple_typ.exit, label %.lr.ph.i

_data_size_tuple_typ.exit:                        ; preds = %.lr.ph.i, %2
  %.reg2mem22.0.lcssa.reg2mem.0.i = phi i64 [ 0, %2 ], [ %19, %.lr.ph.i ]
  %.reg2mem20.0.lcssa.reg2mem.0.i = phi i64 [ 1, %2 ], [ %13, %.lr.ph.i ]
  %24 = urem i64 %.reg2mem22.0.lcssa.reg2mem.0.i, %.reg2mem20.0.lcssa.reg2mem.0.i
  %25 = icmp eq i64 %24, 0
  %26 = sub i64 %.reg2mem20.0.lcssa.reg2mem.0.i, %24
  %27 = select i1 %25, i64 0, i64 %26
  %28 = add i64 %27, %.reg2mem22.0.lcssa.reg2mem.0.i
  %29 = icmp slt i64 %28, 17
  br i1 %29, label %31, label %30

30:                                               ; preds = %_data_size_tuple_typ.exit
  %result.i4 = tail call noalias ptr @bump_malloc_inner(i64 noundef %28, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  tail call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %result.i4, ptr nocapture nofree readonly align 1 %0, i64 %28, i1 noundef false) #34
  store ptr %result.i4, ptr %.sroa.2, align 8
  br label %32

31:                                               ; preds = %_data_size_tuple_typ.exit
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %.sroa.2, ptr nocapture nofree readonly align 1 %0, i64 %28, i1 noundef false) #34
  br label %32

32:                                               ; preds = %31, %30
  %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8. = load i160, ptr %.sroa.2, align 8
  %33 = insertvalue { ptr, i160 } { ptr @tuple_typ, i160 undef }, i160 %.sroa.2.0..sroa.2.0..sroa.2.0..sroa.2.8., 1
  ret { ptr, i160 } %33
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn
define void @_unbox_tuple_typ({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #9 {
  %4 = alloca { ptr, i160 }, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %5 = getelementptr i8, ptr %1, i64 8
  %6 = load i64, ptr %5, align 4
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %_data_size_tuple_typ.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %3, %.lr.ph.i
  %.reg2mem20.010.reg2mem.0.i = phi i64 [ %15, %.lr.ph.i ], [ 1, %3 ]
  %.reg2mem22.011.reg2mem.0.i = phi i64 [ %21, %.lr.ph.i ], [ 0, %3 ]
  %.reg2mem14.0.i = phi i64 [ %22, %.lr.ph.i ], [ 1, %3 ]
  %.in.reg2mem.0.i = phi i64 [ %24, %.lr.ph.i ], [ %6, %3 ]
  %8 = inttoptr i64 %.in.reg2mem.0.i to ptr
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 72
  %11 = load ptr, ptr %10, align 8
  %12 = tail call { i64, i64 } %11(ptr nonnull align 8 %8) #7
  %13 = extractvalue { i64, i64 } %12, 0
  %14 = extractvalue { i64, i64 } %12, 1
  %15 = tail call i64 @llvm.umax.i64(i64 %14, i64 %.reg2mem20.010.reg2mem.0.i)
  %16 = urem i64 %.reg2mem22.011.reg2mem.0.i, %14
  %17 = icmp eq i64 %16, 0
  %18 = sub i64 %14, %16
  %19 = select i1 %17, i64 0, i64 %18
  %20 = add i64 %13, %.reg2mem22.011.reg2mem.0.i
  %21 = add i64 %20, %19
  %22 = add i64 %.reg2mem14.0.i, 1
  %23 = getelementptr ptr, ptr %1, i64 %22
  %24 = load i64, ptr %23, align 4
  %25 = icmp eq i64 %24, 0
  br i1 %25, label %_data_size_tuple_typ.exit, label %.lr.ph.i

_data_size_tuple_typ.exit:                        ; preds = %.lr.ph.i, %3
  %.reg2mem22.0.lcssa.reg2mem.0.i = phi i64 [ 0, %3 ], [ %21, %.lr.ph.i ]
  %.reg2mem20.0.lcssa.reg2mem.0.i = phi i64 [ 1, %3 ], [ %15, %.lr.ph.i ]
  %26 = trunc i160 %.fca.1.extract to i64
  %27 = inttoptr i64 %26 to ptr
  %28 = urem i64 %.reg2mem22.0.lcssa.reg2mem.0.i, %.reg2mem20.0.lcssa.reg2mem.0.i
  %29 = icmp eq i64 %28, 0
  %30 = sub i64 %.reg2mem20.0.lcssa.reg2mem.0.i, %28
  %31 = select i1 %29, i64 0, i64 %30
  %32 = add i64 %31, %.reg2mem22.0.lcssa.reg2mem.0.i
  %33 = icmp slt i64 %32, 17
  %34 = select i1 %33, ptr %.fca.1.gep, ptr %27
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %2, ptr nocapture nofree readonly align 1 %34, i64 %32, i1 noundef false) #34
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn
define { ptr, i160 } @_box_union_typ(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #9 {
  %3 = alloca { ptr, i160 }, align 8
  %4 = getelementptr inbounds i8, ptr %3, i64 8
  store ptr @union_typ, ptr %3, align 8
  %5 = getelementptr i8, ptr %1, i64 8
  %6 = load i64, ptr %5, align 4
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %_data_size_union_typ.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %2, %.lr.ph.i
  %.reg2mem20.010.reg2mem.0.i = phi i64 [ %15, %.lr.ph.i ], [ 1, %2 ]
  %.reg2mem22.011.reg2mem.0.i = phi i64 [ %.fr.i, %.lr.ph.i ], [ 0, %2 ]
  %.reg2mem14.0.i = phi i64 [ %22, %.lr.ph.i ], [ 1, %2 ]
  %.in.reg2mem.0.i = phi i64 [ %24, %.lr.ph.i ], [ %6, %2 ]
  %8 = inttoptr i64 %.in.reg2mem.0.i to ptr
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 72
  %11 = load ptr, ptr %10, align 8
  %12 = tail call { i64, i64 } %11(ptr nonnull align 8 %8) #7
  %13 = extractvalue { i64, i64 } %12, 0
  %14 = extractvalue { i64, i64 } %12, 1
  %15 = tail call i64 @llvm.umax.i64(i64 %14, i64 %.reg2mem20.010.reg2mem.0.i)
  %16 = urem i64 %.reg2mem22.011.reg2mem.0.i, %14
  %17 = icmp eq i64 %16, 0
  %18 = sub i64 %14, %16
  %19 = select i1 %17, i64 0, i64 %18
  %20 = add i64 %13, %.reg2mem22.011.reg2mem.0.i
  %21 = tail call i64 @llvm.umax.i64(i64 %20, i64 %19)
  %.fr.i = freeze i64 %21
  %22 = add i64 %.reg2mem14.0.i, 1
  %23 = getelementptr ptr, ptr %1, i64 %22
  %24 = load i64, ptr %23, align 4
  %25 = icmp eq i64 %24, 0
  br i1 %25, label %._crit_edge.i, label %.lr.ph.i

._crit_edge.i:                                    ; preds = %.lr.ph.i
  %right_size.i = icmp eq i64 %.fr.i, 32
  %spec.select.i = select i1 %right_size.i, i64 0, i64 8
  %26 = add i64 %spec.select.i, %.fr.i
  br label %_data_size_union_typ.exit

_data_size_union_typ.exit:                        ; preds = %2, %._crit_edge.i
  %.reg2mem20.0.lcssa.reg2mem.012.i = phi i64 [ 1, %2 ], [ %15, %._crit_edge.i ]
  %final_size.i = phi i64 [ 8, %2 ], [ %26, %._crit_edge.i ]
  %27 = urem i64 %final_size.i, %.reg2mem20.0.lcssa.reg2mem.012.i
  %28 = icmp eq i64 %27, 0
  %29 = sub i64 %.reg2mem20.0.lcssa.reg2mem.012.i, %27
  %30 = select i1 %28, i64 0, i64 %29
  %31 = add i64 %30, %final_size.i
  %32 = icmp eq i64 %31, 32
  br i1 %32, label %._crit_edge, label %33

._crit_edge:                                      ; preds = %33, %_data_size_union_typ.exit
  %.reg2mem10.0 = phi ptr [ %3, %_data_size_union_typ.exit ], [ %4, %33 ]
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %.reg2mem10.0, ptr nocapture nofree readonly align 1 %0, i64 %31, i1 noundef false) #34
  %.pre = load ptr, ptr %3, align 8
  br label %36

33:                                               ; preds = %_data_size_union_typ.exit
  %34 = icmp slt i64 %31, 17
  br i1 %34, label %._crit_edge, label %35

35:                                               ; preds = %33
  %result.i5 = tail call noalias ptr @bump_malloc_inner(i64 noundef %31, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  tail call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %result.i5, ptr nocapture nofree readonly align 1 %0, i64 %31, i1 noundef false) #34
  store ptr %result.i5, ptr %4, align 8
  br label %36

36:                                               ; preds = %35, %._crit_edge
  %37 = phi ptr [ @union_typ, %35 ], [ %.pre, %._crit_edge ]
  %38 = insertvalue { ptr, i160 } undef, ptr %37, 0
  %39 = load i160, ptr %4, align 8
  %40 = insertvalue { ptr, i160 } %38, i160 %39, 1
  ret { ptr, i160 } %40
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Tombstone(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Tombstone_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 88
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @Tombstone_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #0 {
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { i64, i64 } @_data_size_Entry(ptr nocapture nofree readonly align 8 %0) #10 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i = tail call { i64, i64 } %6(ptr nocapture nofree nonnull readonly %3) #5
  %7 = extractvalue { i64, i64 } %result.i, 0
  %8 = extractvalue { i64, i64 } %result.i, 1
  %9 = tail call i64 @llvm.umax.i64(i64 %8, i64 8)
  %10 = urem i64 20, %8
  %11 = icmp eq i64 %10, 0
  %12 = sub i64 %8, %10
  %13 = select i1 %11, i64 0, i64 %12
  %14 = add i64 %7, 20
  %15 = add i64 %14, %13
  %16 = and i64 %15, 7
  %17 = icmp eq i64 %16, 0
  %18 = sub nuw nsw i64 40, %16
  %19 = select i1 %17, i64 32, i64 %18
  %20 = add i64 %19, %15
  %21 = urem i64 %20, %9
  %22 = icmp eq i64 %21, 0
  %23 = sub i64 %9, %21
  %24 = select i1 %22, i64 0, i64 %23
  %25 = add i64 %20, %24
  %26 = insertvalue { i64, i64 } undef, i64 %25, 0
  %27 = insertvalue { i64, i64 } %26, i64 %9, 1
  ret { i64, i64 } %27
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Entry_field_Entry_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Entry_field_Entry_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_init_keyK_valueTombstone_hashPtri32_init_keyK_valueV_hashPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #11 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #34
  %4 = getelementptr inbounds i8, ptr %1, i64 8
  %5 = load ptr, ptr %4, align 8
  %6 = getelementptr i8, ptr %5, i64 8
  %7 = getelementptr i8, ptr %5, i64 16
  %8 = getelementptr i8, ptr %5, i64 24
  %9 = getelementptr i8, ptr %5, i64 32
  %10 = load i64, ptr %6, align 4
  %11 = load i64, ptr %7, align 4
  %12 = load ptr, ptr %8, align 8
  %13 = load ptr, ptr %9, align 8
  %result.i = tail call i1 %12(i64 %11, i64 %10, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %13) #5
  %14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %15 = select i1 %result.i, i64 9, i64 10
  %16 = getelementptr [14 x ptr], ptr %14, i64 0, i64 %15
  %17 = getelementptr i8, ptr %16, i64 80
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_key_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_value_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Entry_B_hash_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Entry_init_keyK_valueTombstone_hashPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4, i32 %5) #2 {
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !301
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !301
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !301
  %product.i.i.i = mul i64 %hash_coef.i.i, 4015701072841558310
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !301
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract8) #34
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract8, i64 %8
  %10 = getelementptr i8, ptr %9, i64 24
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  tail call void %13(ptr %.fca.1.extract9, { ptr, i160 } %3) #35
  %.fca.0.extract = extractvalue { ptr, i160 } %4, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %4, 1
  %hash_coef_ptr.i.i13 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i14 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i15 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i16 = load i64, ptr %hash_coef_ptr.i.i13, align 4, !noalias !304
  %tbl_size.i.i17 = load i64, ptr %tbl_size_ptr.i.i14, align 4, !noalias !304
  %offset_tbl.i.i18 = load ptr, ptr %offset_tbl_ptr.i.i15, align 8, !noalias !304
  %product.i.i.i19 = mul i64 %hash_coef.i.i16, -8477883990763853851
  %shifted.i.i.i20 = lshr i64 %product.i.i.i19, 32
  %xored.i.i.i21 = xor i64 %shifted.i.i.i20, %product.i.i.i19
  %hash.i.i.i22 = and i64 %xored.i.i.i21, %tbl_size.i.i17
  %offset_ptr.i.i23 = getelementptr i32, ptr %offset_tbl.i.i18, i64 %hash.i.i.i22
  %offset.i.i24 = load i32, ptr %offset_ptr.i.i23, align 4, !noalias !304
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract8) #34
  %15 = getelementptr i8, ptr %9, i64 32
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = insertvalue { ptr, i160 } undef, ptr %.fca.0.extract, 0
  %.sroa.5.8.insert.ext = zext i32 %offset.i.i24 to i160
  %.sroa.5.8.insert.shift = shl nuw i160 %.sroa.5.8.insert.ext, 128
  %.sroa.3.8.insert.ext = and i160 %.fca.1.extract, 340282366920938463463374607431768211455
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.5.8.insert.shift, %.sroa.3.8.insert.ext
  %20 = insertvalue { ptr, i160 } %19, i160 %.sroa.3.8.insert.insert, 1
  tail call void %18(ptr %.fca.1.extract9, { ptr, i160 } %20) #35
  %21 = tail call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract8) #34
  %22 = getelementptr i8, ptr %9, i64 16
  %23 = load ptr, ptr %22, align 8
  %24 = getelementptr i8, ptr %23, i64 8
  %25 = load ptr, ptr %24, align 8
  tail call void %25(ptr %.fca.1.extract9, i32 %5) #35
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Entry_init_keyK_valueV_hashPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4, i32 %5) #2 {
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !307
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !307
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !307
  %product.i.i.i = mul i64 %hash_coef.i.i, 4015701072841558310
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !307
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract10) #34
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract10, i64 %8
  %10 = getelementptr i8, ptr %9, i64 24
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  tail call void %13(ptr %.fca.1.extract11, { ptr, i160 } %3) #35
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract10) #34
  %15 = getelementptr i8, ptr %9, i64 32
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 8
  %18 = load ptr, ptr %17, align 8
  tail call void %18(ptr %.fca.1.extract11, { ptr, i160 } %4) #35
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract10) #34
  %20 = getelementptr i8, ptr %9, i64 16
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr i8, ptr %21, i64 8
  %23 = load ptr, ptr %22, align 8
  tail call void %23(ptr %.fca.1.extract11, i32 %5) #35
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Entry_key_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !310
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !310
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !310
  %product.i.i.i = mul i64 %hash_coef.i.i, 4015701072841558310
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !310
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract3) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract3, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call { ptr, i160 } %9(ptr %.fca.1.extract4) #36
  ret { ptr, i160 } %10
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Entry_value_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !313
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !313
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !313
  %product.i.i.i = mul i64 %hash_coef.i.i, 4015701072841558310
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !313
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract1) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract1, i64 %5
  %7 = getelementptr i8, ptr %6, i64 32
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call { ptr, i160 } %9(ptr %.fca.1.extract2) #36
  ret { ptr, i160 } %10
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @Entry_hash_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !316
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !316
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !316
  %product.i.i.i = mul i64 %hash_coef.i.i, 4015701072841558310
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !316
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract) #36
  ret i32 %10
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, i160 } @Entry_getter_value(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #10 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %result.i = tail call { i64, i64 } %5(ptr nocapture nofree nonnull readonly %2) #5
  %6 = extractvalue { i64, i64 } %result.i, 0
  %7 = extractvalue { i64, i64 } %result.i, 1
  %8 = urem i64 20, %7
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 %7, %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %6, 20
  %13 = add i64 %12, %11
  %14 = and i64 %13, 7
  %15 = icmp eq i64 %14, 0
  %16 = sub nuw nsw i64 8, %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = getelementptr i8, ptr %0, i64 %13
  %19 = getelementptr i8, ptr %18, i64 %17
  %20 = load ptr, ptr %19, align 8
  %21 = insertvalue { ptr, i160 } undef, ptr %20, 0
  %22 = getelementptr i8, ptr %19, i64 8
  %23 = load i160, ptr %22, align 4
  %24 = insertvalue { ptr, i160 } %21, i160 %23, 1
  ret { ptr, i160 } %24
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define void @Entry_setter_value(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0, { ptr, i160 } %1) #11 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i = tail call { i64, i64 } %6(ptr nocapture nofree nonnull readonly %3) #5
  %7 = extractvalue { i64, i64 } %result.i, 0
  %8 = extractvalue { i64, i64 } %result.i, 1
  %9 = urem i64 20, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 20
  %14 = add i64 %13, %12
  %15 = and i64 %14, 7
  %16 = icmp eq i64 %15, 0
  %17 = sub nuw nsw i64 8, %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = getelementptr i8, ptr %0, i64 %14
  %20 = getelementptr i8, ptr %19, i64 %18
  %.fca.0.extract = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  store ptr %.fca.0.extract, ptr %20, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  store i160 %.fca.1.extract, ptr %21, align 4
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, i160 } @Entry_getter_key(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #10 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %result.i = tail call { i64, i64 } %5(ptr nocapture nofree nonnull readonly %2) #5
  %6 = extractvalue { i64, i64 } %result.i, 1
  %7 = urem i64 20, %6
  %8 = icmp eq i64 %7, 0
  %reass.sub = sub i64 %6, %7
  %9 = add i64 %reass.sub, 20
  %10 = select i1 %8, i64 20, i64 %9
  %11 = getelementptr i8, ptr %0, i64 %10
  %12 = getelementptr i8, ptr %3, i64 56
  %13 = load ptr, ptr %12, align 8
  %result.i1 = tail call { ptr, i160 } %13(ptr nocapture nofree readonly %11, ptr nocapture nofree nonnull readonly %2) #5
  ret { ptr, i160 } %result.i1
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Entry_setter_key(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0, { ptr, i160 } %1) #12 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i = tail call { i64, i64 } %6(ptr nocapture nofree nonnull readonly %3) #5
  %7 = extractvalue { i64, i64 } %result.i, 1
  %8 = urem i64 20, %7
  %9 = icmp eq i64 %8, 0
  %reass.sub = sub i64 %7, %8
  %10 = add i64 %reass.sub, 20
  %11 = select i1 %9, i64 20, i64 %10
  %12 = getelementptr i8, ptr %0, i64 %11
  %13 = getelementptr i8, ptr %4, i64 64
  %14 = load ptr, ptr %13, align 8
  tail call void %14({ ptr, i160 } %1, ptr nocapture nofree nonnull readonly %3, ptr nocapture nofree writeonly %12) #13
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Entry_getter_hash(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Entry_setter_hash(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 16
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_HashMap(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 64, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @HashMap_field_HashMap_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @HashMap_field_HashMap_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @HashMap_field_HashMap_2(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_init_hasherFunctionK_to_Ptri32_eqFunctionK._K_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 320
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_find_slot_keyK_hashPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 328
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_ensure_capacity_required_loadPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 336
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_resize_new_capacityPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 344
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_insert_internal_keyK_valueV_hashPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 352
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 360
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_get_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 368
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_remove_keyK({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 376
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_clear_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 384
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_size_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 392
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 400
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 408
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 416
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 424
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 432
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 440
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 448
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 456
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 464
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 472
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMap_B_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 480
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @HashMap_init_hasherFunctionK_to_Ptri32_eqFunctionK._K_to_Ptri1({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, { ptr } %4) #2 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !319
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !319
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !319
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !319
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract7) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract7, i64 %7
  %9 = getelementptr i8, ptr %8, i64 56
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  tail call void %12(ptr %.fca.1.extract, { ptr } %3) #35
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract7) #34
  %14 = getelementptr i8, ptr %8, i64 64
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  tail call void %17(ptr %.fca.1.extract, { ptr } %4) #35
  %result.i = tail call noalias dereferenceable_or_null(512) ptr @bump_malloc_inner(i64 noundef 512, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract7) #34
  %19 = getelementptr i8, ptr %8, i64 24
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  %23 = insertvalue { ptr } undef, ptr %result.i, 0
  tail call void %22(ptr %.fca.1.extract, { ptr } %23) #35
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract7) #34
  %25 = getelementptr i8, ptr %8, i64 32
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  tail call void %28(ptr %.fca.1.extract, i32 16) #35
  %29 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract7) #34
  %30 = getelementptr i8, ptr %8, i64 40
  %31 = load ptr, ptr %30, align 8
  %32 = getelementptr i8, ptr %31, i64 8
  %33 = load ptr, ptr %32, align 8
  tail call void %33(ptr %.fca.1.extract, i32 0) #35
  %34 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract7) #34
  %35 = getelementptr i8, ptr %8, i64 48
  %36 = load ptr, ptr %35, align 8
  %37 = getelementptr i8, ptr %36, i64 8
  %38 = load ptr, ptr %37, align 8
  tail call void %38(ptr %.fca.1.extract, i32 0) #35
  ret void
}

define i32 @HashMap_find_slot_keyK_hashPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, i32 %4) {
  %6 = alloca [0 x ptr], align 8
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract9) #38
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract9, i64 %8
  %10 = getelementptr i8, ptr %9, i64 32
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = tail call i32 %12(ptr %.fca.1.extract10) #36
  %14 = add i32 %13, -1
  %15 = and i32 %14, %4
  %16 = alloca i32, align 4
  store i32 %15, ptr %16, align 4
  %17 = alloca i32, align 4
  store i32 -1, ptr %17, align 4
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull %.fca.0.extract9)
  %19 = getelementptr i8, ptr %9, i64 24
  %20 = load ptr, ptr %19, align 8
  %21 = load ptr, ptr %20, align 8
  %22 = tail call { ptr } %21(ptr %.fca.1.extract10) #36
  %.fca.0.extract48102 = extractvalue { ptr } %22, 0
  %23 = sext i32 %15 to i64
  %24 = shl nsw i64 %23, 5
  %25 = getelementptr i8, ptr %.fca.0.extract48102, i64 %24
  %26 = load ptr, ptr %25, align 8
  %27 = icmp eq ptr %26, @nil_typ
  %28 = icmp eq ptr %26, null
  %29 = or i1 %27, %28
  br i1 %29, label %._crit_edge105, label %.lr.ph

.lr.ph:                                           ; preds = %5
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %31 = getelementptr i8, ptr %9, i64 64
  br label %32

32:                                               ; preds = %.lr.ph, %._crit_edge.thread
  %33 = phi ptr [ %26, %.lr.ph ], [ %84, %._crit_edge.thread ]
  %34 = phi ptr [ %25, %.lr.ph ], [ %83, %._crit_edge.thread ]
  %35 = phi i32 [ %15, %.lr.ph ], [ %77, %._crit_edge.thread ]
  %.0.73101103 = phi i32 [ -1, %.lr.ph ], [ %spec.store.select, %._crit_edge.thread ]
  %.sroa_idx = getelementptr i8, ptr %34, i64 16
  %36 = load i64, ptr %.sroa_idx, align 4
  %37 = getelementptr i8, ptr %34, i64 8
  %38 = load i64, ptr %37, align 4
  %39 = inttoptr i64 %38 to ptr
  %40 = inttoptr i64 %36 to ptr
  %hash_coef_ptr.i.i56 = getelementptr i8, ptr %33, i64 8
  %tbl_size_ptr.i.i57 = getelementptr i8, ptr %33, i64 16
  %offset_tbl_ptr.i.i58 = getelementptr i8, ptr %33, i64 40
  %hash_coef.i.i59 = load i64, ptr %hash_coef_ptr.i.i56, align 4
  %tbl_size.i.i60 = load i64, ptr %tbl_size_ptr.i.i57, align 4
  %offset_tbl.i.i61 = load ptr, ptr %offset_tbl_ptr.i.i58, align 8
  %product.i.i.i62 = mul i64 %hash_coef.i.i59, 4015701072841558310
  %shifted.i.i.i63 = lshr i64 %product.i.i.i62, 32
  %xored.i.i.i64 = xor i64 %shifted.i.i.i63, %product.i.i.i62
  %hash.i.i.i65 = and i64 %xored.i.i.i64, %tbl_size.i.i60
  %offset_ptr.i.i66 = getelementptr i32, ptr %offset_tbl.i.i61, i64 %hash.i.i.i65
  %offset.i.i67 = load i32, ptr %offset_ptr.i.i66, align 4
  %41 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %33, 0
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %39, 1
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %40, 2
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, i32 %offset.i.i67, 3
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %33)
  %46 = sext i32 %offset.i.i67 to i64
  %47 = getelementptr ptr, ptr %33, i64 %46
  %48 = getelementptr i8, ptr %47, i64 64
  %49 = load ptr, ptr %48, align 8
  %result.i = call ptr %49({ ptr, ptr, ptr, i32 } %44, ptr nocapture nofree noundef nonnull readonly %6) #16
  %50 = call i32 %result.i({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr nonnull align 8 %6) #7
  %51 = icmp eq i32 %50, %4
  br i1 %51, label %._crit_edge, label %._crit_edge.thread

._crit_edge:                                      ; preds = %32
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %33)
  %54 = getelementptr i8, ptr %47, i64 48
  %55 = load ptr, ptr %54, align 8
  %result.i69 = call ptr %55({ ptr, ptr, ptr, i32 } %44, ptr nocapture nofree noundef nonnull readonly %6) #16
  %56 = call { ptr, i160 } %result.i69({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr nonnull align 8 %6) #7
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull %.fca.0.extract9)
  %58 = load ptr, ptr %31, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr } %59(ptr %.fca.1.extract10) #36
  %.fca.0.extract25 = extractvalue { ptr } %60, 0
  %61 = call i1 %.fca.0.extract25({ ptr, i160 } %56, { ptr, i160 } %3)
  br i1 %61, label %.thread, label %._crit_edge.thread

._crit_edge.thread:                               ; preds = %32, %._crit_edge
  %62 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %33)
  %64 = getelementptr i8, ptr %47, i64 56
  %65 = load ptr, ptr %64, align 8
  %result.i70 = call ptr %65({ ptr, ptr, ptr, i32 } %44, ptr nocapture nofree noundef nonnull readonly %6) #16
  %66 = call { ptr, i160 } %result.i70({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr nonnull align 8 %6) #7
  %.fca.0.extract19 = extractvalue { ptr, i160 } %66, 0
  %67 = getelementptr i8, ptr %.fca.0.extract19, i64 8
  %68 = getelementptr i8, ptr %.fca.0.extract19, i64 16
  %69 = getelementptr i8, ptr %.fca.0.extract19, i64 24
  %70 = getelementptr i8, ptr %.fca.0.extract19, i64 32
  %71 = load i64, ptr %67, align 4
  %72 = load i64, ptr %68, align 4
  %73 = load ptr, ptr %69, align 8
  %74 = load ptr, ptr %70, align 8
  %result.i71 = call i1 %73(i64 %72, i64 %71, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %74) #5
  %75 = icmp eq i32 %.0.73101103, -1
  %or.cond = select i1 %result.i71, i1 %75, i1 false
  %spec.store.select = select i1 %or.cond, i32 %35, i32 %.0.73101103
  store i32 %spec.store.select, ptr %17, align 4
  %76 = add i32 %35, 1
  %77 = and i32 %76, %14
  store i32 %77, ptr %16, align 4
  %78 = load ptr, ptr %19, align 8
  %79 = load ptr, ptr %78, align 8
  %80 = call { ptr } %79(ptr %.fca.1.extract10) #36
  %.fca.0.extract48 = extractvalue { ptr } %80, 0
  %81 = sext i32 %77 to i64
  %82 = shl nsw i64 %81, 5
  %83 = getelementptr i8, ptr %.fca.0.extract48, i64 %82
  %84 = load ptr, ptr %83, align 8
  %85 = icmp eq ptr %84, @nil_typ
  %86 = icmp eq ptr %84, null
  %87 = or i1 %85, %86
  br i1 %87, label %._crit_edge105.loopexit, label %32

._crit_edge105.loopexit:                          ; preds = %._crit_edge.thread
  %88 = icmp eq i32 %spec.store.select, -1
  %89 = select i1 %88, ptr %16, ptr %17
  br label %._crit_edge105

._crit_edge105:                                   ; preds = %._crit_edge105.loopexit, %5
  %.0..0.72 = phi ptr [ %89, %._crit_edge105.loopexit ], [ %16, %5 ]
  %.pre = load i32, ptr %.0..0.72, align 4
  br label %.thread

.thread:                                          ; preds = %._crit_edge, %._crit_edge105
  %90 = phi i32 [ %.pre, %._crit_edge105 ], [ %35, %._crit_edge ]
  ret i32 %90
}

; Function Attrs: nounwind
define void @HashMap_ensure_capacity_required_loadPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #7 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !322
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !322
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !322
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !322
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract) #34
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract, i64 %8
  %10 = getelementptr i8, ptr %9, i64 32
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = tail call i32 %12(ptr %.fca.1.extract) #36
  %14 = icmp eq i32 %13, 0
  %15 = mul i32 %3, 10
  %16 = mul i32 %13, 6
  %17 = icmp sge i32 %15, %16
  %.0 = select i1 %14, i1 true, i1 %17
  br i1 %.0, label %._crit_edge1, label %._crit_edge

._crit_edge1:                                     ; preds = %4
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %18 = shl i32 %13, 1
  %spec.select = tail call i32 @llvm.smax.i32(i32 %18, i32 16)
  %19 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.1.extract, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.2.extract, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 %offset.i.i, 3
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5) #40
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull %.fca.0.extract) #40
  %25 = getelementptr i8, ptr %9, i64 96
  %26 = load ptr, ptr %25, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i = call ptr %26({ ptr, ptr, ptr, i32 } %22, ptr nocapture nofree noundef nonnull readonly %6) #16
  call void %result.i({ ptr, ptr, ptr, i32 } %22, { ptr, ptr, ptr, i32 } %22, ptr nonnull align 8 dereferenceable(8) %5, i32 %spec.select) #7
  br label %._crit_edge

._crit_edge:                                      ; preds = %4, %._crit_edge1
  ret void
}

; Function Attrs: nounwind
define void @HashMap_resize_new_capacityPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #7 {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca [3 x ptr], align 8
  %7 = alloca { ptr, ptr, ptr }, align 8
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !325
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !325
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !325
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !325
  %8 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract10) #38
  %9 = sext i32 %offset.i.i to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract10, i64 %9
  %11 = getelementptr i8, ptr %10, i64 24
  %12 = load ptr, ptr %11, align 8
  %13 = load ptr, ptr %12, align 8
  %14 = tail call { ptr } %13(ptr %.fca.1.extract) #36
  %.fca.0.extract = extractvalue { ptr } %14, 0
  %15 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract10) #38
  %16 = getelementptr i8, ptr %10, i64 32
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = tail call i32 %18(ptr %.fca.1.extract) #36
  %20 = sext i32 %3 to i64
  %21 = shl nsw i64 %20, 5
  %result.i = tail call noalias ptr @bump_malloc_inner(i64 noundef %21, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %22 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract10) #38
  %23 = load ptr, ptr %11, align 8
  %24 = getelementptr i8, ptr %23, i64 8
  %25 = load ptr, ptr %24, align 8
  %26 = insertvalue { ptr } undef, ptr %result.i, 0
  tail call void %25(ptr %.fca.1.extract, { ptr } %26) #35
  %27 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract10) #38
  %28 = load ptr, ptr %16, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  tail call void %30(ptr %.fca.1.extract, i32 %3) #35
  %31 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract10) #38
  %32 = getelementptr i8, ptr %10, i64 40
  %33 = load ptr, ptr %32, align 8
  %34 = getelementptr i8, ptr %33, i64 8
  %35 = load ptr, ptr %34, align 8
  tail call void %35(ptr %.fca.1.extract, i32 0) #35
  %36 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract10) #38
  %37 = getelementptr i8, ptr %10, i64 48
  %38 = load ptr, ptr %37, align 8
  %39 = getelementptr i8, ptr %38, i64 8
  %40 = load ptr, ptr %39, align 8
  tail call void %40(ptr %.fca.1.extract, i32 0) #35
  %41 = icmp sgt i32 %19, 0
  br i1 %41, label %.lr.ph, label %._crit_edge3._crit_edge

.lr.ph:                                           ; preds = %4
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %42 = getelementptr i8, ptr %10, i64 8
  %43 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract10, 0
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, ptr %.fca.1.extract, 1
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %.fca.2.extract, 2
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, i32 %offset.i.i, 3
  %47 = getelementptr inbounds i8, ptr %6, i64 8
  %48 = getelementptr inbounds i8, ptr %6, i64 16
  %49 = getelementptr i8, ptr %10, i64 104
  %50 = getelementptr inbounds i8, ptr %7, i64 8
  %51 = getelementptr inbounds i8, ptr %7, i64 16
  br label %52

52:                                               ; preds = %.lr.ph, %._crit_edge
  %.096 = phi i32 [ 0, %.lr.ph ], [ %105, %._crit_edge ]
  %53 = zext nneg i32 %.096 to i64
  %54 = shl nuw nsw i64 %53, 5
  %55 = getelementptr i8, ptr %.fca.0.extract, i64 %54
  %56 = load ptr, ptr %55, align 8
  %57 = icmp ne ptr %56, @nil_typ
  %58 = icmp ne ptr %56, null
  %.not40 = and i1 %57, %58
  br i1 %.not40, label %59, label %._crit_edge

59:                                               ; preds = %52
  %60 = getelementptr i8, ptr %55, i64 8
  %61 = load i64, ptr %60, align 4
  %.sroa_idx = getelementptr i8, ptr %55, i64 16
  %62 = load i64, ptr %.sroa_idx, align 4
  %63 = inttoptr i64 %61 to ptr
  %64 = inttoptr i64 %62 to ptr
  %hash_coef_ptr.i.i42 = getelementptr i8, ptr %56, i64 8
  %tbl_size_ptr.i.i43 = getelementptr i8, ptr %56, i64 16
  %offset_tbl_ptr.i.i44 = getelementptr i8, ptr %56, i64 40
  %hash_coef.i.i45 = load i64, ptr %hash_coef_ptr.i.i42, align 4, !noalias !328
  %tbl_size.i.i46 = load i64, ptr %tbl_size_ptr.i.i43, align 4, !noalias !328
  %offset_tbl.i.i47 = load ptr, ptr %offset_tbl_ptr.i.i44, align 8, !noalias !328
  %product.i.i.i48 = mul i64 %hash_coef.i.i45, 4015701072841558310
  %shifted.i.i.i49 = lshr i64 %product.i.i.i48, 32
  %xored.i.i.i50 = xor i64 %shifted.i.i.i49, %product.i.i.i48
  %hash.i.i.i51 = and i64 %xored.i.i.i50, %tbl_size.i.i46
  %offset_ptr.i.i52 = getelementptr i32, ptr %offset_tbl.i.i47, i64 %hash.i.i.i51
  %offset.i.i53 = load i32, ptr %offset_ptr.i.i52, align 4, !noalias !328
  %65 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %56, 0
  %66 = insertvalue { ptr, ptr, ptr, i32 } %65, ptr %63, 1
  %67 = insertvalue { ptr, ptr, ptr, i32 } %66, ptr %64, 2
  %68 = insertvalue { ptr, ptr, ptr, i32 } %67, i32 %offset.i.i53, 3
  %69 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %56)
  %71 = sext i32 %offset.i.i53 to i64
  %72 = getelementptr ptr, ptr %56, i64 %71
  %73 = getelementptr i8, ptr %72, i64 56
  %74 = load ptr, ptr %73, align 8
  %result.i55 = call ptr %74({ ptr, ptr, ptr, i32 } %68, ptr nocapture nofree noundef nonnull readonly %5) #16
  %75 = call { ptr, i160 } %result.i55({ ptr, ptr, ptr, i32 } %68, { ptr, ptr, ptr, i32 } %68, ptr nonnull align 8 %5) #7
  %.fca.0.extract29 = extractvalue { ptr, i160 } %75, 0
  %76 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract10)
  %77 = load ptr, ptr %42, align 8
  %result.i56 = call align 8 ptr %77(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %78 = load ptr, ptr %result.i56, align 8
  %79 = ptrtoint ptr %78 to i64
  %80 = getelementptr i8, ptr %.fca.0.extract29, i64 8
  %81 = getelementptr i8, ptr %.fca.0.extract29, i64 16
  %82 = getelementptr i8, ptr %.fca.0.extract29, i64 24
  %83 = getelementptr i8, ptr %.fca.0.extract29, i64 32
  %84 = load i64, ptr %80, align 4
  %85 = load i64, ptr %81, align 4
  %86 = load ptr, ptr %82, align 8
  %87 = load ptr, ptr %83, align 8
  %88 = load i64, ptr %78, align 4
  %result.i57 = call i1 %86(i64 %85, i64 %84, i64 %88, i64 %79, ptr readonly %87) #5
  br i1 %result.i57, label %89, label %._crit_edge

89:                                               ; preds = %59
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %56)
  %92 = getelementptr i8, ptr %72, i64 48
  %93 = load ptr, ptr %92, align 8
  %result.i58 = call ptr %93({ ptr, ptr, ptr, i32 } %68, ptr nocapture nofree noundef nonnull readonly %5) #16
  %94 = call { ptr, i160 } %result.i58({ ptr, ptr, ptr, i32 } %68, { ptr, ptr, ptr, i32 } %68, ptr nonnull align 8 %5) #7
  %.fca.0.extract20 = extractvalue { ptr, i160 } %94, 0
  %95 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %96 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %56)
  %97 = getelementptr i8, ptr %72, i64 64
  %98 = load ptr, ptr %97, align 8
  %result.i59 = call ptr %98({ ptr, ptr, ptr, i32 } %68, ptr nocapture nofree noundef nonnull readonly %5) #16
  %99 = call i32 %result.i59({ ptr, ptr, ptr, i32 } %68, { ptr, ptr, ptr, i32 } %68, ptr nonnull align 8 %5) #7
  %100 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %101 = load ptr, ptr %10, align 8
  %result.i60 = call ptr %101(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  store ptr %result.i60, ptr %6, align 8
  store ptr %result.i56, ptr %47, align 8
  store ptr @_parameterization_Ptri32, ptr %48, align 8
  %102 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %6)
  %103 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %104 = load ptr, ptr %49, align 8
  store ptr %.fca.0.extract20, ptr %7, align 8
  store ptr %.fca.0.extract29, ptr %50, align 8
  store ptr @i32_typ, ptr %51, align 8
  %result.i61 = call ptr %104({ ptr, ptr, ptr, i32 } %46, ptr nocapture nofree noundef nonnull readonly %7) #16
  call void %result.i61({ ptr, ptr, ptr, i32 } %46, { ptr, ptr, ptr, i32 } %46, ptr nonnull align 8 dereferenceable(24) %6, { ptr, i160 } %94, { ptr, i160 } %75, i32 %99) #7
  br label %._crit_edge

._crit_edge:                                      ; preds = %52, %59, %89
  %105 = add nuw nsw i32 %.096, 1
  %106 = icmp slt i32 %105, %19
  br i1 %106, label %52, label %._crit_edge3._crit_edge

._crit_edge3._crit_edge:                          ; preds = %._crit_edge, %4
  ret void
}

; Function Attrs: nounwind
define void @HashMap_insert_internal_keyK_valueV_hashPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4, i32 %5) #7 {
  %7 = alloca [0 x ptr], align 8
  %.fca.0.extract41 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract42 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract41, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract41, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract41, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !331
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !331
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !331
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !331
  %.fca.0.extract37 = extractvalue { ptr, i160 } %3, 0
  %.fca.0.extract30 = extractvalue { ptr, i160 } %4, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract41, 0
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.1.extract42, 1
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr %.fca.2.extract, 2
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %offset.i.i, 3
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract41) #34
  %13 = sext i32 %offset.i.i to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract41, i64 %13
  %15 = load ptr, ptr %14, align 8
  %result.i = tail call ptr %15(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract42) #5
  %16 = alloca [2 x ptr], align 8
  store ptr %result.i, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %16, i64 8
  store ptr @_parameterization_Ptri32, ptr %17, align 8
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %16) #34
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract41) #34
  %20 = getelementptr i8, ptr %14, i64 80
  %21 = load ptr, ptr %20, align 8
  %22 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract37, ptr %22, align 8
  %23 = getelementptr inbounds i8, ptr %22, i64 8
  store ptr @i32_typ, ptr %23, align 8
  %result.i68 = call ptr %21({ ptr, ptr, ptr, i32 } %11, ptr nocapture nofree noundef nonnull readonly %22) #16
  %24 = call i32 %result.i68({ ptr, ptr, ptr, i32 } %11, { ptr, ptr, ptr, i32 } %11, ptr nonnull align 8 dereferenceable(16) %16, { ptr, i160 } %3, i32 %5) #7
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract41)
  %26 = getelementptr i8, ptr %14, i64 24
  %27 = load ptr, ptr %26, align 8
  %28 = load ptr, ptr %27, align 8
  %29 = call { ptr } %28(ptr %.fca.1.extract42) #36
  %.fca.0.extract20 = extractvalue { ptr } %29, 0
  %30 = sext i32 %24 to i64
  %31 = shl nsw i64 %30, 5
  %32 = getelementptr i8, ptr %.fca.0.extract20, i64 %31
  %33 = load ptr, ptr %32, align 8
  %34 = getelementptr i8, ptr %32, i64 8
  %35 = load i64, ptr %34, align 4
  %.sroa_idx = getelementptr i8, ptr %32, i64 16
  %36 = load i64, ptr %.sroa_idx, align 4
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract41)
  %38 = getelementptr i8, ptr %14, i64 8
  %39 = load ptr, ptr %38, align 8
  %result.i69 = call ptr %39(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract42) #5
  %40 = load ptr, ptr %result.i, align 8, !alias.scope !334
  %41 = getelementptr i8, ptr %40, i64 72
  %42 = load ptr, ptr %41, align 8, !alias.scope !334
  %result.i.i = call { i64, i64 } %42(ptr nocapture nofree nonnull readonly %result.i) #5, !alias.scope !334
  %43 = extractvalue { i64, i64 } %result.i.i, 0
  %44 = extractvalue { i64, i64 } %result.i.i, 1
  %45 = call i64 @llvm.umax.i64(i64 %44, i64 8)
  %46 = urem i64 20, %44
  %47 = icmp eq i64 %46, 0
  %48 = sub i64 %44, %46
  %49 = select i1 %47, i64 0, i64 %48
  %50 = add i64 %43, 20
  %51 = add i64 %50, %49
  %52 = and i64 %51, 7
  %53 = icmp eq i64 %52, 0
  %54 = sub nuw nsw i64 40, %52
  %55 = select i1 %53, i64 32, i64 %54
  %56 = add i64 %55, %51
  %57 = urem i64 %56, %45
  %58 = icmp eq i64 %57, 0
  %59 = sub i64 %45, %57
  %60 = select i1 %58, i64 0, i64 %59
  %61 = add i64 %56, %60
  %result.i71 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %61, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i, ptr %result.i71, align 8
  %62 = getelementptr inbounds i8, ptr %result.i71, i64 8
  store ptr %result.i69, ptr %62, align 8
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i71)
  %64 = insertvalue { ptr, ptr, ptr, i32 } { ptr @Entry, ptr undef, ptr undef, i32 undef }, ptr %result.i71, 1
  %65 = insertvalue { ptr, ptr, ptr, i32 } %64, ptr undef, 2
  %66 = insertvalue { ptr, ptr, ptr, i32 } %65, i32 10, 3
  %67 = alloca [3 x ptr], align 8
  store ptr %result.i, ptr %67, align 8
  %68 = getelementptr inbounds i8, ptr %67, i64 8
  store ptr %result.i69, ptr %68, align 8
  %69 = getelementptr inbounds i8, ptr %67, i64 16
  store ptr @_parameterization_Ptri32, ptr %69, align 8
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %67)
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull align 16 dereferenceable(192) @Entry)
  %72 = getelementptr i8, ptr %.fca.0.extract30, i64 8
  %73 = getelementptr i8, ptr %.fca.0.extract30, i64 16
  %74 = getelementptr i8, ptr %.fca.0.extract30, i64 24
  %75 = getelementptr i8, ptr %.fca.0.extract30, i64 32
  %76 = load i64, ptr %72, align 4
  %77 = load i64, ptr %73, align 4
  %78 = load ptr, ptr %74, align 8
  %79 = load ptr, ptr %75, align 8
  %result.i.i117 = call i1 %78(i64 %77, i64 %76, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %79) #5
  %80 = select i1 %result.i.i117, i64 9, i64 10
  %81 = getelementptr [14 x ptr], ptr @Entry, i64 0, i64 %80
  %82 = getelementptr i8, ptr %81, i64 80
  %83 = load ptr, ptr %82, align 8
  call void %83({ ptr, ptr, ptr, i32 } %66, { ptr, ptr, ptr, i32 } %66, ptr nonnull align 8 dereferenceable(24) %67, { ptr, i160 } %3, { ptr, i160 } %4, i32 %5) #7
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract41)
  %85 = load ptr, ptr %26, align 8
  %86 = load ptr, ptr %85, align 8
  %87 = call { ptr } %86(ptr %.fca.1.extract42) #36
  %.fca.0.extract = extractvalue { ptr } %87, 0
  %88 = getelementptr i8, ptr %.fca.0.extract, i64 %31
  store ptr @Entry, ptr %88, align 8
  %89 = getelementptr i8, ptr %88, i64 8
  %90 = ptrtoint ptr %result.i71 to i64
  store i64 %90, ptr %89, align 4
  %.sroa_idx4 = getelementptr i8, ptr %88, i64 24
  store i32 10, ptr %.sroa_idx4, align 4
  %91 = icmp eq ptr %33, @nil_typ
  %92 = icmp eq ptr %33, null
  %93 = or i1 %91, %92
  br i1 %93, label %94, label %104

94:                                               ; preds = %6
  %95 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull %.fca.0.extract41)
  %96 = getelementptr i8, ptr %14, i64 40
  %97 = load ptr, ptr %96, align 8
  %98 = load ptr, ptr %97, align 8
  %99 = call i32 %98(ptr %.fca.1.extract42) #36
  %100 = add i32 %99, 1
  %101 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull %.fca.0.extract41)
  %102 = getelementptr i8, ptr %97, i64 8
  %103 = load ptr, ptr %102, align 8
  call void %103(ptr %.fca.1.extract42, i32 %100) #35
  br label %._crit_edge.sink.split

104:                                              ; preds = %6
  %105 = inttoptr i64 %35 to ptr
  %106 = inttoptr i64 %36 to ptr
  %hash_coef_ptr.i.i88 = getelementptr i8, ptr %33, i64 8
  %tbl_size_ptr.i.i89 = getelementptr i8, ptr %33, i64 16
  %offset_tbl_ptr.i.i90 = getelementptr i8, ptr %33, i64 40
  %hash_coef.i.i91 = load i64, ptr %hash_coef_ptr.i.i88, align 4, !noalias !337
  %tbl_size.i.i92 = load i64, ptr %tbl_size_ptr.i.i89, align 4, !noalias !337
  %offset_tbl.i.i93 = load ptr, ptr %offset_tbl_ptr.i.i90, align 8, !noalias !337
  %product.i.i.i94 = mul i64 %hash_coef.i.i91, 4015701072841558310
  %shifted.i.i.i95 = lshr i64 %product.i.i.i94, 32
  %xored.i.i.i96 = xor i64 %shifted.i.i.i95, %product.i.i.i94
  %hash.i.i.i97 = and i64 %xored.i.i.i96, %tbl_size.i.i92
  %offset_ptr.i.i98 = getelementptr i32, ptr %offset_tbl.i.i93, i64 %hash.i.i.i97
  %offset.i.i99 = load i32, ptr %offset_ptr.i.i98, align 4, !noalias !337
  %107 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %33, 0
  %108 = insertvalue { ptr, ptr, ptr, i32 } %107, ptr %105, 1
  %109 = insertvalue { ptr, ptr, ptr, i32 } %108, ptr %106, 2
  %110 = insertvalue { ptr, ptr, ptr, i32 } %109, i32 %offset.i.i99, 3
  %111 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %7)
  %112 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %33)
  %113 = sext i32 %offset.i.i99 to i64
  %114 = getelementptr ptr, ptr %33, i64 %113
  %115 = getelementptr i8, ptr %114, i64 56
  %116 = load ptr, ptr %115, align 8
  %result.i101 = call ptr %116({ ptr, ptr, ptr, i32 } %110, ptr nocapture nofree noundef nonnull readonly %7) #16
  %117 = call { ptr, i160 } %result.i101({ ptr, ptr, ptr, i32 } %110, { ptr, ptr, ptr, i32 } %110, ptr nonnull align 8 %7) #7
  %.fca.0.extract51 = extractvalue { ptr, i160 } %117, 0
  %118 = getelementptr i8, ptr %.fca.0.extract51, i64 8
  %119 = getelementptr i8, ptr %.fca.0.extract51, i64 16
  %120 = getelementptr i8, ptr %.fca.0.extract51, i64 24
  %121 = getelementptr i8, ptr %.fca.0.extract51, i64 32
  %122 = load i64, ptr %118, align 4
  %123 = load i64, ptr %119, align 4
  %124 = load ptr, ptr %120, align 8
  %125 = load ptr, ptr %121, align 8
  %result.i102 = call i1 %124(i64 %123, i64 %122, i64 -8477883990763853851, i64 ptrtoint (ptr @Tombstone to i64), ptr readonly %125) #5
  br i1 %result.i102, label %._crit_edge.sink.split, label %._crit_edge

._crit_edge.sink.split:                           ; preds = %104, %94
  %.sink159 = phi i64 [ 48, %94 ], [ 40, %104 ]
  %126 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull %.fca.0.extract41)
  %127 = getelementptr i8, ptr %14, i64 %.sink159
  %128 = load ptr, ptr %127, align 8
  %129 = load ptr, ptr %128, align 8
  %130 = call i32 %129(ptr %.fca.1.extract42) #36
  %131 = add i32 %130, 1
  %132 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull %.fca.0.extract41)
  %133 = getelementptr i8, ptr %128, i64 8
  %134 = load ptr, ptr %133, align 8
  call void %134(ptr %.fca.1.extract42, i32 %131) #35
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.sink.split, %104
  ret void
}

define void @HashMap_insert_keyK_valueV({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4) {
  %.fca.0.extract21 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract22 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract21, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract21, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract21, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !340
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !340
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !340
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !340
  %.fca.0.extract17 = extractvalue { ptr, i160 } %3, 0
  %.fca.0.extract12 = extractvalue { ptr, i160 } %4, 0
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract21) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract21, i64 %7
  %9 = getelementptr i8, ptr %8, i64 48
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = tail call i32 %11(ptr %.fca.1.extract22) #36
  %13 = add i32 %12, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract21, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.1.extract22, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.2.extract, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %offset.i.i, 3
  %18 = alloca [1 x ptr], align 8
  store ptr @_parameterization_Ptri32, ptr %18, align 8
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %18) #40
  %20 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract21) #40
  %21 = getelementptr i8, ptr %8, i64 88
  %22 = load ptr, ptr %21, align 8
  %23 = alloca { ptr }, align 8
  store ptr @i32_typ, ptr %23, align 8
  %result.i = call ptr %22({ ptr, ptr, ptr, i32 } %17, ptr nocapture nofree noundef nonnull readonly %23) #16
  call void %result.i({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull align 8 dereferenceable(8) %18, i32 %13) #7
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract21)
  %25 = getelementptr i8, ptr %8, i64 56
  %26 = load ptr, ptr %25, align 8
  %27 = load ptr, ptr %26, align 8
  %28 = call { ptr } %27(ptr %.fca.1.extract22) #36
  %.fca.0.extract = extractvalue { ptr } %28, 0
  %29 = call i32 %.fca.0.extract({ ptr, i160 } %3)
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract21)
  %31 = load ptr, ptr %8, align 8
  %result.i25 = call ptr %31(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract22) #5
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract21)
  %33 = getelementptr i8, ptr %8, i64 8
  %34 = load ptr, ptr %33, align 8
  %result.i26 = call ptr %34(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract22) #5
  %35 = alloca [3 x ptr], align 8
  store ptr %result.i25, ptr %35, align 8
  %36 = getelementptr inbounds i8, ptr %35, i64 8
  store ptr %result.i26, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %35, i64 16
  store ptr @_parameterization_Ptri32, ptr %37, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 9, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %35)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract21)
  %40 = getelementptr i8, ptr %8, i64 104
  %41 = load ptr, ptr %40, align 8
  %42 = alloca { ptr, ptr, ptr }, align 8
  store ptr %.fca.0.extract17, ptr %42, align 8
  %43 = getelementptr inbounds i8, ptr %42, i64 8
  store ptr %.fca.0.extract12, ptr %43, align 8
  %44 = getelementptr inbounds i8, ptr %42, i64 16
  store ptr @i32_typ, ptr %44, align 8
  %result.i27 = call ptr %41({ ptr, ptr, ptr, i32 } %17, ptr nocapture nofree noundef nonnull readonly %42) #16
  call void %result.i27({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull align 8 dereferenceable(24) %35, { ptr, i160 } %3, { ptr, i160 } %4, i32 %29) #7
  ret void
}

define { ptr, i160 } @HashMap_get_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract25 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract26 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract25, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract25, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract25, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !343
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !343
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !343
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !343
  %.fca.0.extract20 = extractvalue { ptr, i160 } %3, 0
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract25) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract25, i64 %7
  %9 = getelementptr i8, ptr %8, i64 56
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = tail call { ptr } %11(ptr %.fca.1.extract26) #36
  %.fca.0.extract10 = extractvalue { ptr } %12, 0
  %13 = tail call i32 %.fca.0.extract10({ ptr, i160 } %3)
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract25, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.1.extract26, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.2.extract, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %offset.i.i, 3
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract25)
  %19 = load ptr, ptr %8, align 8
  %result.i = tail call ptr %19(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract26) #5
  %20 = alloca [2 x ptr], align 8
  store ptr %result.i, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %20, i64 8
  store ptr @_parameterization_Ptri32, ptr %21, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %20)
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract25)
  %24 = getelementptr i8, ptr %8, i64 80
  %25 = load ptr, ptr %24, align 8
  %26 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract20, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %26, i64 8
  store ptr @i32_typ, ptr %27, align 8
  %result.i58 = call ptr %25({ ptr, ptr, ptr, i32 } %17, ptr nocapture nofree noundef nonnull readonly %26) #16
  %28 = call i32 %result.i58({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull align 8 dereferenceable(16) %20, { ptr, i160 } %3, i32 %13) #7
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract25)
  %30 = getelementptr i8, ptr %8, i64 24
  %31 = load ptr, ptr %30, align 8
  %32 = load ptr, ptr %31, align 8
  %33 = call { ptr } %32(ptr %.fca.1.extract26) #36
  %.fca.0.extract = extractvalue { ptr } %33, 0
  %34 = sext i32 %28 to i64
  %35 = shl nsw i64 %34, 5
  %36 = getelementptr i8, ptr %.fca.0.extract, i64 %35
  %37 = load ptr, ptr %36, align 8
  %38 = icmp ne ptr %37, @nil_typ
  %39 = icmp ne ptr %37, null
  %.not57 = and i1 %38, %39
  br i1 %.not57, label %40, label %.thread

40:                                               ; preds = %4
  %41 = getelementptr i8, ptr %36, i64 8
  %42 = load i64, ptr %41, align 4
  %.sroa_idx = getelementptr i8, ptr %36, i64 16
  %43 = load i64, ptr %.sroa_idx, align 4
  %44 = inttoptr i64 %42 to ptr
  %45 = inttoptr i64 %43 to ptr
  %hash_coef_ptr.i.i60 = getelementptr i8, ptr %37, i64 8
  %tbl_size_ptr.i.i61 = getelementptr i8, ptr %37, i64 16
  %offset_tbl_ptr.i.i62 = getelementptr i8, ptr %37, i64 40
  %hash_coef.i.i63 = load i64, ptr %hash_coef_ptr.i.i60, align 4, !noalias !346
  %tbl_size.i.i64 = load i64, ptr %tbl_size_ptr.i.i61, align 4, !noalias !346
  %offset_tbl.i.i65 = load ptr, ptr %offset_tbl_ptr.i.i62, align 8, !noalias !346
  %product.i.i.i66 = mul i64 %hash_coef.i.i63, 4015701072841558310
  %shifted.i.i.i67 = lshr i64 %product.i.i.i66, 32
  %xored.i.i.i68 = xor i64 %shifted.i.i.i67, %product.i.i.i66
  %hash.i.i.i69 = and i64 %xored.i.i.i68, %tbl_size.i.i64
  %offset_ptr.i.i70 = getelementptr i32, ptr %offset_tbl.i.i65, i64 %hash.i.i.i69
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i70, align 4, !noalias !346
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %37, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %44, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %45, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %offset.i.i71, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %37)
  %52 = sext i32 %offset.i.i71 to i64
  %53 = getelementptr ptr, ptr %37, i64 %52
  %54 = getelementptr i8, ptr %53, i64 56
  %55 = load ptr, ptr %54, align 8
  %result.i73 = call ptr %55({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly %5) #16
  %56 = call { ptr, i160 } %result.i73({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %5) #7
  %.fca.0.extract51 = extractvalue { ptr, i160 } %56, 0
  %.fca.1.extract52 = extractvalue { ptr, i160 } %56, 1
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %37)
  %59 = getelementptr i8, ptr %53, i64 64
  %60 = load ptr, ptr %59, align 8
  %result.i74 = call ptr %60({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly %5) #16
  %61 = call i32 %result.i74({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %5) #7
  %62 = icmp eq i32 %61, %13
  br i1 %62, label %._crit_edge, label %.thread

._crit_edge:                                      ; preds = %40
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %37)
  %65 = getelementptr i8, ptr %53, i64 48
  %66 = load ptr, ptr %65, align 8
  %result.i75 = call ptr %66({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly %5) #16
  %67 = call { ptr, i160 } %result.i75({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %5) #7
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull %.fca.0.extract25)
  %69 = getelementptr i8, ptr %8, i64 64
  %70 = load ptr, ptr %69, align 8
  %71 = load ptr, ptr %70, align 8
  %72 = call { ptr } %71(ptr %.fca.1.extract26) #36
  %.fca.0.extract36 = extractvalue { ptr } %72, 0
  %73 = call i1 %.fca.0.extract36({ ptr, i160 } %67, { ptr, i160 } %3)
  br i1 %73, label %74, label %.thread

74:                                               ; preds = %._crit_edge
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull %.fca.0.extract25)
  %76 = getelementptr i8, ptr %8, i64 8
  %77 = load ptr, ptr %76, align 8
  %result.i76 = call align 8 ptr %77(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract26) #5
  %78 = load ptr, ptr %result.i76, align 8
  %79 = ptrtoint ptr %78 to i64
  %80 = getelementptr i8, ptr %.fca.0.extract51, i64 8
  %81 = getelementptr i8, ptr %.fca.0.extract51, i64 16
  %82 = getelementptr i8, ptr %.fca.0.extract51, i64 24
  %83 = getelementptr i8, ptr %.fca.0.extract51, i64 32
  %84 = load i64, ptr %80, align 4
  %85 = load i64, ptr %81, align 4
  %86 = load ptr, ptr %82, align 8
  %87 = load ptr, ptr %83, align 8
  %88 = load i64, ptr %78, align 4
  %result.i77 = call i1 %86(i64 %85, i64 %84, i64 %88, i64 %79, ptr readonly %87) #5
  %cond.fr = freeze i1 %result.i77
  %spec.select = select i1 %cond.fr, ptr %.fca.0.extract51, ptr @nil_typ
  br label %.thread

.thread:                                          ; preds = %74, %._crit_edge, %40, %4
  %.reg2mem60.sroa.3.0107 = phi i160 [ poison, %4 ], [ %.fca.1.extract52, %40 ], [ %.fca.1.extract52, %._crit_edge ], [ %.fca.1.extract52, %74 ]
  %89 = phi ptr [ @nil_typ, %4 ], [ @nil_typ, %40 ], [ @nil_typ, %._crit_edge ], [ %spec.select, %74 ]
  %.reload57.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %89, 0
  %.reload57.fca.1.insert = insertvalue { ptr, i160 } %.reload57.fca.0.insert, i160 %.reg2mem60.sroa.3.0107, 1
  ret { ptr, i160 } %.reload57.fca.1.insert
}

define { ptr, i160 } @HashMap_remove_keyK({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract26 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract27 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract26, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract26, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract26, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !349
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !349
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !349
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !349
  %.fca.0.extract21 = extractvalue { ptr, i160 } %3, 0
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract26) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract26, i64 %7
  %9 = getelementptr i8, ptr %8, i64 56
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = tail call { ptr } %11(ptr %.fca.1.extract27) #36
  %.fca.0.extract11 = extractvalue { ptr } %12, 0
  %13 = tail call i32 %.fca.0.extract11({ ptr, i160 } %3)
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract26, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.1.extract27, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.2.extract, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %offset.i.i, 3
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract26)
  %19 = load ptr, ptr %8, align 8
  %result.i = tail call ptr %19(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract27) #5
  %20 = alloca [2 x ptr], align 8
  store ptr %result.i, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %20, i64 8
  store ptr @_parameterization_Ptri32, ptr %21, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %20)
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract26)
  %24 = getelementptr i8, ptr %8, i64 80
  %25 = load ptr, ptr %24, align 8
  %26 = alloca { ptr, ptr }, align 8
  store ptr %.fca.0.extract21, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %26, i64 8
  store ptr @i32_typ, ptr %27, align 8
  %result.i101 = call ptr %25({ ptr, ptr, ptr, i32 } %17, ptr nocapture nofree noundef nonnull readonly %26) #16
  %28 = call i32 %result.i101({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull align 8 dereferenceable(16) %20, { ptr, i160 } %3, i32 %13) #7
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract26)
  %30 = getelementptr i8, ptr %8, i64 24
  %31 = load ptr, ptr %30, align 8
  %32 = load ptr, ptr %31, align 8
  %33 = call { ptr } %32(ptr %.fca.1.extract27) #36
  %.fca.0.extract = extractvalue { ptr } %33, 0
  %34 = sext i32 %28 to i64
  %35 = shl nsw i64 %34, 5
  %36 = getelementptr i8, ptr %.fca.0.extract, i64 %35
  %37 = load ptr, ptr %36, align 8
  %38 = icmp ne ptr %37, @nil_typ
  %39 = icmp ne ptr %37, null
  %.not100 = and i1 %38, %39
  br i1 %.not100, label %40, label %.thread

40:                                               ; preds = %4
  %41 = getelementptr i8, ptr %36, i64 8
  %42 = load i64, ptr %41, align 4
  %.sroa_idx = getelementptr i8, ptr %36, i64 16
  %43 = load i64, ptr %.sroa_idx, align 4
  %44 = inttoptr i64 %42 to ptr
  %45 = inttoptr i64 %43 to ptr
  %hash_coef_ptr.i.i103 = getelementptr i8, ptr %37, i64 8
  %tbl_size_ptr.i.i104 = getelementptr i8, ptr %37, i64 16
  %offset_tbl_ptr.i.i105 = getelementptr i8, ptr %37, i64 40
  %hash_coef.i.i106 = load i64, ptr %hash_coef_ptr.i.i103, align 4, !noalias !352
  %tbl_size.i.i107 = load i64, ptr %tbl_size_ptr.i.i104, align 4, !noalias !352
  %offset_tbl.i.i108 = load ptr, ptr %offset_tbl_ptr.i.i105, align 8, !noalias !352
  %product.i.i.i109 = mul i64 %hash_coef.i.i106, 4015701072841558310
  %shifted.i.i.i110 = lshr i64 %product.i.i.i109, 32
  %xored.i.i.i111 = xor i64 %shifted.i.i.i110, %product.i.i.i109
  %hash.i.i.i112 = and i64 %xored.i.i.i111, %tbl_size.i.i107
  %offset_ptr.i.i113 = getelementptr i32, ptr %offset_tbl.i.i108, i64 %hash.i.i.i112
  %offset.i.i114 = load i32, ptr %offset_ptr.i.i113, align 4, !noalias !352
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %37, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %44, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %45, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %offset.i.i114, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %37)
  %52 = sext i32 %offset.i.i114 to i64
  %53 = getelementptr ptr, ptr %37, i64 %52
  %54 = getelementptr i8, ptr %53, i64 64
  %55 = load ptr, ptr %54, align 8
  %result.i116 = call ptr %55({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly %5) #16
  %56 = call i32 %result.i116({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %5) #7
  %57 = icmp eq i32 %56, %13
  br i1 %57, label %._crit_edge, label %.thread

._crit_edge:                                      ; preds = %40
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %37)
  %60 = getelementptr i8, ptr %53, i64 48
  %61 = load ptr, ptr %60, align 8
  %result.i117 = call ptr %61({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly %5) #16
  %62 = call { ptr, i160 } %result.i117({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %5) #7
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull %.fca.0.extract26)
  %64 = getelementptr i8, ptr %8, i64 64
  %65 = load ptr, ptr %64, align 8
  %66 = load ptr, ptr %65, align 8
  %67 = call { ptr } %66(ptr %.fca.1.extract27) #36
  %.fca.0.extract83 = extractvalue { ptr } %67, 0
  %68 = call i1 %.fca.0.extract83({ ptr, i160 } %62, { ptr, i160 } %3)
  br i1 %68, label %69, label %.thread

69:                                               ; preds = %._crit_edge
  %70 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %37)
  %72 = getelementptr i8, ptr %53, i64 56
  %73 = load ptr, ptr %72, align 8
  %result.i118 = call ptr %73({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly %5) #16
  %74 = call { ptr, i160 } %result.i118({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %5) #7
  %.fca.0.extract76 = extractvalue { ptr, i160 } %74, 0
  %.fca.1.extract77 = extractvalue { ptr, i160 } %74, 1
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull %.fca.0.extract26)
  %76 = getelementptr i8, ptr %8, i64 8
  %77 = load ptr, ptr %76, align 8
  %result.i119 = call align 8 ptr %77(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract27) #5
  %78 = load ptr, ptr %result.i119, align 8
  %79 = ptrtoint ptr %78 to i64
  %80 = getelementptr i8, ptr %.fca.0.extract76, i64 8
  %81 = getelementptr i8, ptr %.fca.0.extract76, i64 16
  %82 = getelementptr i8, ptr %.fca.0.extract76, i64 24
  %83 = getelementptr i8, ptr %.fca.0.extract76, i64 32
  %84 = load i64, ptr %80, align 4
  %85 = load i64, ptr %81, align 4
  %86 = load ptr, ptr %82, align 8
  %87 = load ptr, ptr %83, align 8
  %88 = load i64, ptr %78, align 4
  %result.i120 = call i1 %86(i64 %85, i64 %84, i64 %88, i64 %79, ptr readonly %87) #5
  br i1 %result.i120, label %89, label %.thread

89:                                               ; preds = %69
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %91 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %37)
  %92 = load ptr, ptr %60, align 8
  %result.i121 = call ptr %92({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly %5) #16
  %93 = call { ptr, i160 } %result.i121({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %5) #7
  %94 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 16 dereferenceable(96) @Tombstone)
  %95 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %5) #34
  %96 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %97 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %37)
  %98 = load ptr, ptr %54, align 8
  %result.i125 = call ptr %98({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly %5) #16
  %99 = call i32 %result.i125({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %5) #7
  %100 = load ptr, ptr %result.i, align 8, !alias.scope !355
  %101 = getelementptr i8, ptr %100, i64 72
  %102 = load ptr, ptr %101, align 8, !alias.scope !355
  %result.i.i = call { i64, i64 } %102(ptr nocapture nofree nonnull readonly %result.i) #5, !alias.scope !355
  %103 = extractvalue { i64, i64 } %result.i.i, 0
  %104 = extractvalue { i64, i64 } %result.i.i, 1
  %105 = call i64 @llvm.umax.i64(i64 %104, i64 8)
  %106 = urem i64 20, %104
  %107 = icmp eq i64 %106, 0
  %108 = sub i64 %104, %106
  %109 = select i1 %107, i64 0, i64 %108
  %110 = add i64 %103, 20
  %111 = add i64 %110, %109
  %112 = and i64 %111, 7
  %113 = icmp eq i64 %112, 0
  %114 = sub nuw nsw i64 40, %112
  %115 = select i1 %113, i64 32, i64 %114
  %116 = add i64 %115, %111
  %117 = urem i64 %116, %105
  %118 = icmp eq i64 %117, 0
  %119 = sub i64 %105, %117
  %120 = select i1 %118, i64 0, i64 %119
  %121 = add i64 %116, %120
  %result.i127 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %121, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i, ptr %result.i127, align 8
  %122 = getelementptr inbounds i8, ptr %result.i127, i64 8
  store ptr %result.i119, ptr %122, align 8
  %123 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i127)
  %124 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %125 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %37)
  %126 = load ptr, ptr %60, align 8
  %result.i128 = call ptr %126({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly %5) #16
  %127 = call { ptr, i160 } %result.i128({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %5) #7
  %result.i130 = call noalias ptr @bump_malloc_inner(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %128 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 16 dereferenceable(96) @Tombstone)
  %129 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %5) #34
  %130 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %131 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %37)
  %132 = load ptr, ptr %54, align 8
  %result.i132 = call ptr %132({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly %5) #16
  %133 = call i32 %result.i132({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %5) #7
  %134 = ptrtoint ptr %result.i130 to i64
  %.sroa.3.8.insert.ext = zext i64 %134 to i160
  %135 = load ptr, ptr %result.i, align 8
  %136 = getelementptr i8, ptr %135, i64 72
  %137 = load ptr, ptr %136, align 8
  %result.i.i211 = call { i64, i64 } %137(ptr nocapture nofree nonnull readonly %result.i) #5
  %138 = extractvalue { i64, i64 } %result.i.i211, 1
  %139 = urem i64 20, %138
  %140 = icmp eq i64 %139, 0
  %reass.sub = sub i64 %138, %139
  %141 = add i64 %reass.sub, 20
  %142 = select i1 %140, i64 20, i64 %141
  %143 = getelementptr i8, ptr %result.i127, i64 %142
  %144 = getelementptr i8, ptr %135, i64 64
  %145 = load ptr, ptr %144, align 8
  call void %145({ ptr, i160 } %127, ptr nocapture nofree nonnull readonly %result.i, ptr nocapture nofree writeonly %143) #13
  %.sroa.3.8.insert.insert.i = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  %146 = load ptr, ptr %result.i127, align 8
  %147 = load ptr, ptr %146, align 8
  %148 = getelementptr i8, ptr %147, i64 72
  %149 = load ptr, ptr %148, align 8
  %result.i.i212 = call { i64, i64 } %149(ptr nocapture nofree nonnull readonly %146) #5
  %150 = extractvalue { i64, i64 } %result.i.i212, 0
  %151 = extractvalue { i64, i64 } %result.i.i212, 1
  %152 = urem i64 20, %151
  %153 = icmp eq i64 %152, 0
  %154 = sub i64 %151, %152
  %155 = select i1 %153, i64 0, i64 %154
  %156 = add i64 %150, 20
  %157 = add i64 %156, %155
  %158 = and i64 %157, 7
  %159 = icmp eq i64 %158, 0
  %160 = sub nuw nsw i64 8, %158
  %161 = select i1 %159, i64 0, i64 %160
  %162 = getelementptr i8, ptr %result.i127, i64 %157
  %163 = getelementptr i8, ptr %162, i64 %161
  store ptr @Tombstone, ptr %163, align 8
  %164 = getelementptr i8, ptr %163, i64 8
  store i160 %.sroa.3.8.insert.insert.i, ptr %164, align 4
  %165 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @Entry) #34
  %166 = getelementptr inbounds i8, ptr %result.i127, i64 16
  store i32 %133, ptr %166, align 8
  %167 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull %.fca.0.extract26)
  %168 = load ptr, ptr %30, align 8
  %169 = load ptr, ptr %168, align 8
  %170 = call { ptr } %169(ptr %.fca.1.extract27) #36
  %.fca.0.extract35 = extractvalue { ptr } %170, 0
  %171 = getelementptr i8, ptr %.fca.0.extract35, i64 %35
  store ptr @Entry, ptr %171, align 8
  %172 = getelementptr i8, ptr %171, i64 8
  %173 = ptrtoint ptr %result.i127 to i64
  store i64 %173, ptr %172, align 4
  %.sroa_idx39 = getelementptr i8, ptr %171, i64 24
  store i32 10, ptr %.sroa_idx39, align 4
  %174 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull %.fca.0.extract26)
  %175 = getelementptr i8, ptr %8, i64 40
  %176 = load ptr, ptr %175, align 8
  %177 = load ptr, ptr %176, align 8
  %178 = call i32 %177(ptr %.fca.1.extract27) #36
  %179 = add i32 %178, -1
  %180 = call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef nonnull %.fca.0.extract26)
  %181 = getelementptr i8, ptr %176, i64 8
  %182 = load ptr, ptr %181, align 8
  call void %182(ptr %.fca.1.extract27, i32 %179) #35
  br label %.thread

.thread:                                          ; preds = %69, %._crit_edge, %40, %4, %89
  %.reg2mem91.sroa.3.0205 = phi i160 [ %.fca.1.extract77, %89 ], [ poison, %4 ], [ poison, %40 ], [ poison, %._crit_edge ], [ %.fca.1.extract77, %69 ]
  %183 = phi ptr [ %.fca.0.extract76, %89 ], [ @nil_typ, %4 ], [ @nil_typ, %40 ], [ @nil_typ, %._crit_edge ], [ @nil_typ, %69 ]
  %.reload88.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %183, 0
  %.reload88.fca.1.insert = insertvalue { ptr, i160 } %.reload88.fca.0.insert, i160 %.reg2mem91.sroa.3.0205, 1
  ret { ptr, i160 } %.reload88.fca.1.insert
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @HashMap_clear_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #2 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !358
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !358
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !358
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !358
  %result.i = tail call noalias dereferenceable_or_null(512) ptr @bump_malloc_inner(i64 noundef 512, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = insertvalue { ptr } undef, ptr %result.i, 0
  tail call void %10(ptr %.fca.1.extract, { ptr } %11) #35
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract) #34
  %13 = getelementptr i8, ptr %6, i64 40
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  tail call void %16(ptr %.fca.1.extract, i32 0) #35
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract) #34
  %18 = getelementptr i8, ptr %6, i64 48
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  tail call void %21(ptr %.fca.1.extract, i32 0) #35
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @HashMap_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !361
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !361
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !361
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !361
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 40
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract) #36
  ret i32 %10
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, ptr, ptr, i32 } @HashMap_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !364
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !364
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !364
  %product.i.i.i = mul i64 %hash_coef.i.i, -2849643283898152329
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !364
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract10) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract10, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call { ptr } %9(ptr %.fca.1.extract) #36
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract10) #34
  %12 = getelementptr i8, ptr %6, i64 32
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = tail call i32 %14(ptr %.fca.1.extract) #36
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract10) #34
  %17 = load ptr, ptr %6, align 8
  %result.i = tail call ptr %17(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract10) #34
  %19 = getelementptr i8, ptr %6, i64 8
  %20 = load ptr, ptr %19, align 8
  %result.i11 = tail call ptr %20(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %result.i12 = tail call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %21 = getelementptr inbounds i8, ptr %result.i12, i64 16
  store ptr %result.i11, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i12, i64 8
  store ptr %result.i, ptr %22, align 8
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i12) #34
  store ptr @Pair, ptr %result.i12, align 8
  %result.i14 = tail call noalias nonnull align 8 dereferenceable(40) ptr @bump_malloc_inner(i64 noundef 40, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i, ptr %result.i14, align 8
  %24 = getelementptr inbounds i8, ptr %result.i14, i64 8
  store ptr %result.i11, ptr %24, align 8
  %25 = getelementptr inbounds i8, ptr %result.i14, i64 16
  store ptr %result.i12, ptr %25, align 8
  %26 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i14) #34
  %27 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract10) #34
  %28 = load ptr, ptr %7, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = tail call { ptr } %29(ptr %.fca.1.extract) #36
  %31 = tail call ptr @llvm.invariant.start.p0(i64 noundef 592, ptr nocapture nofree noundef %.fca.0.extract10) #34
  %32 = load ptr, ptr %12, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = tail call i32 %33(ptr %.fca.1.extract) #36
  %35 = insertvalue { ptr, ptr, ptr, i32 } { ptr @HashMapIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i14, 1
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr undef, 2
  %37 = getelementptr inbounds i8, ptr %result.i14, i64 24
  %.fca.0.extract.i = extractvalue { ptr } %30, 0
  store ptr %.fca.0.extract.i, ptr %37, align 8
  %38 = getelementptr inbounds i8, ptr %result.i14, i64 36
  store i32 %34, ptr %38, align 4
  %39 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull @HashMapIterator) #34
  %40 = insertvalue { ptr, ptr, ptr, i32 } %36, i32 20, 3
  ret { ptr, ptr, ptr, i32 } %40
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_HashMapIterator(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 40, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @HashMapIterator_field_HashMapIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @HashMapIterator_field_HashMapIterator_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @HashMapIterator_field_HashMapIterator_2(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMapIterator_B_init_map_entriesBufferEntryK._V_or_Nil_lengthPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 144
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @HashMapIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @HashMapIterator_init_map_entriesBufferEntryK._V_or_Nil_lengthPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, i32 %4) #2 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !367
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !367
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !367
  %product.i.i.i = mul i64 %hash_coef.i.i, -704669437586349537
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !367
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract2, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  tail call void %12(ptr %.fca.1.extract, { ptr } %3) #35
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %14 = getelementptr i8, ptr %8, i64 40
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  tail call void %17(ptr %.fca.1.extract, i32 %4) #35
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %19 = getelementptr i8, ptr %8, i64 32
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  tail call void %22(ptr %.fca.1.extract, i32 0) #35
  ret void
}

define { ptr, i160 } @HashMapIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -704669437586349537
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #38
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract4, i64 %6
  %8 = getelementptr i8, ptr %7, i64 32
  %9 = getelementptr i8, ptr %7, i64 40
  %10 = load ptr, ptr %8, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = tail call i32 %11(ptr %.fca.1.extract5) #36
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #38
  %14 = load ptr, ptr %9, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = tail call i32 %15(ptr %.fca.1.extract5) #36
  %17 = icmp slt i32 %12, %16
  br i1 %17, label %.lr.ph, label %.thread121

.lr.ph:                                           ; preds = %3
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull %.fca.0.extract4)
  %19 = getelementptr i8, ptr %7, i64 24
  %20 = getelementptr i8, ptr %7, i64 8
  br label %21

21:                                               ; preds = %.lr.ph, %.backedge
  %22 = phi ptr [ %11, %.lr.ph ], [ %72, %.backedge ]
  %23 = phi ptr [ %10, %.lr.ph ], [ %71, %.backedge ]
  %24 = load ptr, ptr %19, align 8
  %25 = load ptr, ptr %24, align 8
  %26 = call { ptr } %25(ptr %.fca.1.extract5) #36
  %.fca.0.extract40 = extractvalue { ptr } %26, 0
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull %.fca.0.extract4)
  %28 = call i32 %22(ptr %.fca.1.extract5) #36
  %29 = sext i32 %28 to i64
  %30 = shl nsw i64 %29, 5
  %31 = getelementptr i8, ptr %.fca.0.extract40, i64 %30
  %32 = load ptr, ptr %31, align 8
  %33 = getelementptr i8, ptr %31, i64 8
  %34 = load i64, ptr %33, align 4
  %.sroa_idx = getelementptr i8, ptr %31, i64 16
  %35 = load i64, ptr %.sroa_idx, align 4
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull %.fca.0.extract4)
  %37 = call i32 %22(ptr %.fca.1.extract5) #36
  %38 = add i32 %37, 1
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull %.fca.0.extract4)
  %40 = getelementptr i8, ptr %23, i64 8
  %41 = load ptr, ptr %40, align 8
  call void %41(ptr %.fca.1.extract5, i32 %38) #35
  %42 = icmp ne ptr %32, @nil_typ
  %43 = icmp ne ptr %32, null
  %.not46 = and i1 %42, %43
  br i1 %.not46, label %44, label %.backedge

44:                                               ; preds = %21
  %45 = inttoptr i64 %34 to ptr
  %46 = inttoptr i64 %35 to ptr
  %hash_coef_ptr.i.i49 = getelementptr i8, ptr %32, i64 8
  %tbl_size_ptr.i.i50 = getelementptr i8, ptr %32, i64 16
  %offset_tbl_ptr.i.i51 = getelementptr i8, ptr %32, i64 40
  %hash_coef.i.i52 = load i64, ptr %hash_coef_ptr.i.i49, align 4
  %tbl_size.i.i53 = load i64, ptr %tbl_size_ptr.i.i50, align 4
  %offset_tbl.i.i54 = load ptr, ptr %offset_tbl_ptr.i.i51, align 8
  %product.i.i.i55 = mul i64 %hash_coef.i.i52, 4015701072841558310
  %shifted.i.i.i56 = lshr i64 %product.i.i.i55, 32
  %xored.i.i.i57 = xor i64 %shifted.i.i.i56, %product.i.i.i55
  %hash.i.i.i58 = and i64 %xored.i.i.i57, %tbl_size.i.i53
  %offset_ptr.i.i59 = getelementptr i32, ptr %offset_tbl.i.i54, i64 %hash.i.i.i58
  %offset.i.i60 = load i32, ptr %offset_ptr.i.i59, align 4
  %47 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %32, 0
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %45, 1
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %46, 2
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, i32 %offset.i.i60, 3
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %32)
  %53 = sext i32 %offset.i.i60 to i64
  %54 = getelementptr ptr, ptr %32, i64 %53
  %55 = getelementptr i8, ptr %54, i64 56
  %56 = load ptr, ptr %55, align 8
  %result.i = call ptr %56({ ptr, ptr, ptr, i32 } %50, ptr nocapture nofree noundef nonnull readonly %4) #16
  %57 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %50, { ptr, ptr, ptr, i32 } %50, ptr nonnull align 8 %4) #7
  %.fca.0.extract27 = extractvalue { ptr, i160 } %57, 0
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull %.fca.0.extract4)
  %59 = load ptr, ptr %20, align 8
  %result.i62 = call align 8 ptr %59(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract5) #5
  %60 = load ptr, ptr %result.i62, align 8
  %61 = ptrtoint ptr %60 to i64
  %62 = getelementptr i8, ptr %.fca.0.extract27, i64 8
  %63 = getelementptr i8, ptr %.fca.0.extract27, i64 16
  %64 = getelementptr i8, ptr %.fca.0.extract27, i64 24
  %65 = getelementptr i8, ptr %.fca.0.extract27, i64 32
  %66 = load i64, ptr %62, align 4
  %67 = load i64, ptr %63, align 4
  %68 = load ptr, ptr %64, align 8
  %69 = load ptr, ptr %65, align 8
  %70 = load i64, ptr %60, align 4
  %result.i63 = call i1 %68(i64 %67, i64 %66, i64 %70, i64 %61, ptr readonly %69) #5
  br i1 %result.i63, label %79, label %.backedge

.backedge:                                        ; preds = %44, %21
  %71 = load ptr, ptr %8, align 8
  %72 = load ptr, ptr %71, align 8
  %73 = call i32 %72(ptr %.fca.1.extract5) #36
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #38
  %75 = load ptr, ptr %9, align 8
  %76 = load ptr, ptr %75, align 8
  %77 = call i32 %76(ptr %.fca.1.extract5) #36
  %78 = icmp slt i32 %73, %77
  br i1 %78, label %21, label %.thread121

79:                                               ; preds = %44
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %81 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %32)
  %82 = getelementptr i8, ptr %54, i64 48
  %83 = load ptr, ptr %82, align 8
  %result.i64 = call ptr %83({ ptr, ptr, ptr, i32 } %50, ptr nocapture nofree noundef nonnull readonly %4) #16
  %84 = call { ptr, i160 } %result.i64({ ptr, ptr, ptr, i32 } %50, { ptr, ptr, ptr, i32 } %50, ptr nonnull align 8 %4) #7
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull %.fca.0.extract4)
  %86 = load ptr, ptr %7, align 8
  %result.i65 = call ptr %86(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract5) #5
  %87 = load ptr, ptr %result.i65, align 8
  %88 = getelementptr i8, ptr %87, i64 72
  %89 = load ptr, ptr %88, align 8
  %result.i.i = call { i64, i64 } %89(ptr nocapture nofree nonnull readonly %result.i65) #5
  %90 = extractvalue { i64, i64 } %result.i.i, 0
  %91 = extractvalue { i64, i64 } %result.i.i, 1
  %92 = urem i64 16, %91
  %93 = icmp eq i64 %92, 0
  %94 = sub i64 %91, %92
  %95 = select i1 %93, i64 0, i64 %94
  %96 = add i64 %90, 16
  %97 = add i64 %96, %95
  %98 = load ptr, ptr %result.i62, align 8
  %99 = getelementptr i8, ptr %98, i64 72
  %100 = load ptr, ptr %99, align 8
  %result.i1.i = call { i64, i64 } %100(ptr nocapture nofree nonnull readonly %result.i62) #5
  %101 = extractvalue { i64, i64 } %result.i1.i, 0
  %102 = extractvalue { i64, i64 } %result.i1.i, 1
  %103 = call i64 @llvm.umax.i64(i64 %91, i64 %102)
  %104 = call i64 @llvm.umax.i64(i64 %103, i64 8)
  %105 = urem i64 %97, %102
  %106 = icmp eq i64 %105, 0
  %107 = sub i64 %102, %105
  %108 = select i1 %106, i64 0, i64 %107
  %109 = add i64 %101, %97
  %110 = add i64 %109, %108
  %111 = urem i64 %110, %104
  %112 = icmp eq i64 %111, 0
  %113 = sub i64 %104, %111
  %114 = select i1 %112, i64 0, i64 %113
  %115 = add i64 %114, %110
  %result.i67 = call noalias align 8 ptr @bump_malloc_inner(i64 noundef %115, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i65, ptr %result.i67, align 8
  %116 = getelementptr i8, ptr %result.i67, i64 8
  store ptr %result.i62, ptr %116, align 8
  %117 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i67)
  %118 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %119 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %32)
  %120 = load ptr, ptr %82, align 8
  %result.i68 = call ptr %120({ ptr, ptr, ptr, i32 } %50, ptr nocapture nofree noundef nonnull readonly %4) #16
  %121 = call { ptr, i160 } %result.i68({ ptr, ptr, ptr, i32 } %50, { ptr, ptr, ptr, i32 } %50, ptr nonnull align 8 %4) #7
  %122 = load ptr, ptr %result.i65, align 8
  %123 = getelementptr i8, ptr %122, i64 72
  %124 = load ptr, ptr %123, align 8
  %result.i.i155 = call { i64, i64 } %124(ptr nocapture nofree nonnull readonly %result.i65) #5
  %125 = extractvalue { i64, i64 } %result.i.i155, 1
  %126 = urem i64 16, %125
  %127 = icmp eq i64 %126, 0
  %reass.sub = sub i64 %125, %126
  %128 = add i64 %reass.sub, 16
  %129 = select i1 %127, i64 16, i64 %128
  %130 = getelementptr i8, ptr %result.i67, i64 %129
  %131 = getelementptr i8, ptr %122, i64 64
  %132 = load ptr, ptr %131, align 8
  call void %132({ ptr, i160 } %121, ptr nocapture nofree nonnull readonly %result.i65, ptr nocapture nofree writeonly %130) #13
  %133 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @Pair) #34
  %134 = load ptr, ptr %result.i67, align 8
  %135 = load ptr, ptr %134, align 8
  %136 = getelementptr i8, ptr %135, i64 72
  %137 = load ptr, ptr %136, align 8
  %result.i.i156 = call { i64, i64 } %137(ptr nocapture nofree nonnull readonly %134) #5
  %138 = extractvalue { i64, i64 } %result.i.i156, 0
  %139 = extractvalue { i64, i64 } %result.i.i156, 1
  %140 = urem i64 16, %139
  %141 = icmp eq i64 %140, 0
  %142 = sub i64 %139, %140
  %143 = select i1 %141, i64 0, i64 %142
  %144 = add i64 %138, 16
  %145 = add i64 %144, %143
  %146 = load ptr, ptr %116, align 8
  %147 = load ptr, ptr %146, align 8
  %148 = getelementptr i8, ptr %147, i64 72
  %149 = load ptr, ptr %148, align 8
  %result.i1.i157 = call { i64, i64 } %149(ptr nocapture nofree nonnull readonly %146) #5
  %150 = extractvalue { i64, i64 } %result.i1.i157, 1
  %151 = urem i64 %145, %150
  %152 = icmp eq i64 %151, 0
  %153 = sub i64 %150, %151
  %154 = select i1 %152, i64 0, i64 %153
  %155 = getelementptr i8, ptr %result.i67, i64 %145
  %156 = getelementptr i8, ptr %155, i64 %154
  %157 = getelementptr i8, ptr %147, i64 64
  %158 = load ptr, ptr %157, align 8
  call void %158({ ptr, i160 } %57, ptr nocapture nofree nonnull readonly %146, ptr nocapture nofree writeonly %156) #13
  %159 = ptrtoint ptr %result.i67 to i64
  %.sroa.3.8.insert.ext = zext i64 %159 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  br label %.thread121

.thread121:                                       ; preds = %.backedge, %3, %79
  %.reg2mem52.sroa.3.0 = phi i160 [ %.sroa.3.8.insert.insert, %79 ], [ undef, %3 ], [ undef, %.backedge ]
  %.reg2mem52.sroa.0.0 = phi ptr [ @Pair, %79 ], [ @nil_typ, %3 ], [ @nil_typ, %.backedge ]
  %.reload53.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem52.sroa.0.0, 0
  %.reload53.fca.1.insert = insertvalue { ptr, i160 } %.reload53.fca.0.insert, i160 %.reg2mem52.sroa.3.0, 1
  ret { ptr, i160 } %.reload53.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @HashMapIterator_getter_length(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 36
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMapIterator_setter_length(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 36
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @HashMapIterator_getter_index(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMapIterator_setter_index(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 32
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @HashMapIterator_getter_map_entries(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMapIterator_setter_map_entries(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @HashMap_getter_eq(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMap_setter_eq(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @HashMap_getter_hasher(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMap_setter_hasher(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @HashMap_getter_load(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMap_setter_load(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @HashMap_getter_size(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 36
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMap_setter_size(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 36
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @HashMap_getter_entries_len(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMap_setter_entries_len(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 32
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @HashMap_getter_entries(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @HashMap_setter_entries(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i32 @i32_hasher(i32 %0) #0 {
  %2 = add i32 %0, 2127912214
  %3 = shl i32 %0, 12
  %4 = add i32 %2, %3
  %5 = ashr i32 %4, 19
  %6 = xor i32 %4, %5
  %7 = xor i32 %6, -949894596
  %8 = add i32 %7, 374761393
  %9 = shl i32 %7, 5
  %10 = add i32 %8, %9
  %11 = add i32 %10, -744332180
  %12 = shl i32 %10, 9
  %13 = xor i32 %11, %12
  %14 = add i32 %13, -42973499
  %15 = shl i32 %13, 3
  %16 = add i32 %14, %15
  %17 = ashr i32 %16, 16
  %18 = xor i32 %16, %17
  %19 = xor i32 %18, -1252372727
  ret i32 %19
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i1 @i32_eq(i32 %0, i32 %1) #0 {
  %3 = icmp eq i32 %0, %1
  ret i1 %3
}

; Function Attrs: nounwind
define range(i32 0, -2147483648) i32 @string_hasher({ ptr, ptr, ptr, i32 } %0) local_unnamed_addr #7 {
  %2 = alloca [0 x ptr], align 8
  %.fca.0.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract6, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract6, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract6, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !370
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !370
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !370
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !370
  %3 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract6, 0
  %4 = insertvalue { ptr, ptr, ptr, i32 } %3, ptr %.fca.1.extract7, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %.fca.2.extract8, 2
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 %offset.i.i, 3
  %7 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #38
  %8 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract6) #38
  %9 = sext i32 %offset.i.i to i64
  %10 = getelementptr ptr, ptr %.fca.0.extract6, i64 %9
  %11 = getelementptr i8, ptr %10, i64 120
  %12 = load ptr, ptr %11, align 8
  %result.i = call ptr %12({ ptr, ptr, ptr, i32 } %6, ptr nocapture nofree noundef nonnull readonly %2) #16
  %13 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %6, { ptr, ptr, ptr, i32 } %6, ptr nonnull align 8 %2) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %13, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %13, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %13, 2
  %hash_coef_ptr.i.i32 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i33 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i34 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i35 = load i64, ptr %hash_coef_ptr.i.i32, align 4, !noalias !373
  %tbl_size.i.i36 = load i64, ptr %tbl_size_ptr.i.i33, align 4, !noalias !373
  %offset_tbl.i.i37 = load ptr, ptr %offset_tbl_ptr.i.i34, align 8, !noalias !373
  %product.i.i.i38 = mul i64 %hash_coef.i.i35, -7260570988945952630
  %shifted.i.i.i39 = lshr i64 %product.i.i.i38, 32
  %xored.i.i.i40 = xor i64 %shifted.i.i.i39, %product.i.i.i38
  %hash.i.i.i41 = and i64 %xored.i.i.i40, %tbl_size.i.i36
  %offset_ptr.i.i42 = getelementptr i32, ptr %offset_tbl.i.i37, i64 %hash.i.i.i41
  %offset.i.i57 = load i32, ptr %offset_ptr.i.i42, align 4, !noalias !374
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.1.extract, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.2.extract, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %offset.i.i57, 3
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  %19 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %20 = sext i32 %offset.i.i57 to i64
  %21 = getelementptr ptr, ptr %.fca.0.extract, i64 %20
  %22 = getelementptr i8, ptr %21, i64 24
  %23 = load ptr, ptr %22, align 8
  %result.i59102 = call ptr %23({ ptr, ptr, ptr, i32 } %17, ptr nocapture nofree noundef nonnull readonly %2) #16
  %24 = call { ptr, i160 } %result.i59102({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull align 8 %2) #7
  %.fca.0.extract21103 = extractvalue { ptr, i160 } %24, 0
  %25 = icmp ne ptr %.fca.0.extract21103, @nil_typ
  %26 = icmp ne ptr %.fca.0.extract21103, null
  %.not30104 = and i1 %25, %26
  br i1 %.not30104, label %._crit_edge.lr.ph, label %._crit_edge1._crit_edge

._crit_edge.lr.ph:                                ; preds = %1
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph, %._crit_edge
  %.fca.0.extract21106 = phi ptr [ %.fca.0.extract21103, %._crit_edge.lr.ph ], [ %.fca.0.extract21, %._crit_edge ]
  %28 = phi { ptr, i160 } [ %24, %._crit_edge.lr.ph ], [ %46, %._crit_edge ]
  %.0105 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %44, %._crit_edge ]
  %.fca.1.extract22 = extractvalue { ptr, i160 } %28, 1
  %.sroa.7.8.extract.shift = lshr i160 %.fca.1.extract22, 64
  %.sroa.7.8.extract.trunc = trunc i160 %.sroa.7.8.extract.shift to i64
  %.sroa.428.8.extract.trunc = trunc i160 %.fca.1.extract22 to i64
  %29 = inttoptr i64 %.sroa.428.8.extract.trunc to ptr
  %30 = inttoptr i64 %.sroa.7.8.extract.trunc to ptr
  %hash_coef_ptr.i.i61 = getelementptr i8, ptr %.fca.0.extract21106, i64 8
  %tbl_size_ptr.i.i62 = getelementptr i8, ptr %.fca.0.extract21106, i64 16
  %offset_tbl_ptr.i.i63 = getelementptr i8, ptr %.fca.0.extract21106, i64 40
  %hash_coef.i.i64 = load i64, ptr %hash_coef_ptr.i.i61, align 4, !noalias !377
  %tbl_size.i.i65 = load i64, ptr %tbl_size_ptr.i.i62, align 4, !noalias !377
  %offset_tbl.i.i66 = load ptr, ptr %offset_tbl_ptr.i.i63, align 8, !noalias !377
  %product.i.i.i67 = mul i64 %hash_coef.i.i64, 6681222582356018452
  %shifted.i.i.i68 = lshr i64 %product.i.i.i67, 32
  %xored.i.i.i69 = xor i64 %shifted.i.i.i68, %product.i.i.i67
  %hash.i.i.i70 = and i64 %xored.i.i.i69, %tbl_size.i.i65
  %offset_ptr.i.i71 = getelementptr i32, ptr %offset_tbl.i.i66, i64 %hash.i.i.i70
  %offset.i.i72 = load i32, ptr %offset_ptr.i.i71, align 4, !noalias !377
  %31 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract21106, 0
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %29, 1
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %30, 2
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, i32 %offset.i.i72, 3
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull %.fca.0.extract21106)
  %36 = sext i32 %offset.i.i72 to i64
  %37 = getelementptr ptr, ptr %.fca.0.extract21106, i64 %36
  %38 = getelementptr i8, ptr %37, i64 8
  %39 = load ptr, ptr %38, align 8
  %result.i74 = call ptr %39({ ptr, ptr, ptr, i32 } %34, ptr nocapture nofree noundef nonnull readonly %2) #16
  %40 = call i8 %result.i74({ ptr, ptr, ptr, i32 } %34, { ptr, ptr, ptr, i32 } %34, ptr nonnull align 8 %2) #7
  %41 = sext i8 %40 to i32
  %42 = mul i32 %.0105, 31
  %43 = add i32 %42, %41
  %44 = and i32 %43, 2147483647
  %45 = load ptr, ptr %22, align 8
  %result.i59 = call ptr %45({ ptr, ptr, ptr, i32 } %17, ptr nocapture nofree noundef nonnull readonly %2) #16
  %46 = call { ptr, i160 } %result.i59({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull align 8 %2) #7
  %.fca.0.extract21 = extractvalue { ptr, i160 } %46, 0
  %47 = icmp ne ptr %.fca.0.extract21, @nil_typ
  %48 = icmp ne ptr %.fca.0.extract21, null
  %.not30 = and i1 %47, %48
  br i1 %.not30, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge1._crit_edge:                          ; preds = %._crit_edge, %1
  %.0.lcssa = phi i32 [ 0, %1 ], [ %44, %._crit_edge ]
  ret i32 %.0.lcssa
}

; Function Attrs: nounwind
define i1 @string_eq({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1) local_unnamed_addr #7 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !380
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !380
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !380
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !380
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %hash_coef_ptr.i.i10 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i13 = load i64, ptr %hash_coef_ptr.i.i10, align 4, !noalias !373
  %tbl_size.i.i14 = load i64, ptr %tbl_size_ptr.i.i11, align 4, !noalias !373
  %offset_tbl.i.i15 = load ptr, ptr %offset_tbl_ptr.i.i12, align 8, !noalias !373
  %product.i.i.i16 = mul i64 %hash_coef.i.i13, 6499063144389013426
  %shifted.i.i.i17 = lshr i64 %product.i.i.i16, 32
  %xored.i.i.i18 = xor i64 %shifted.i.i.i17, %product.i.i.i16
  %hash.i.i.i19 = and i64 %xored.i.i.i18, %tbl_size.i.i14
  %offset_ptr.i.i20 = getelementptr i32, ptr %offset_tbl.i.i15, i64 %hash.i.i.i19
  %offset.i.i35 = load i32, ptr %offset_ptr.i.i20, align 4, !noalias !383
  %3 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %4 = insertvalue { ptr, ptr, ptr, i32 } %3, ptr %.fca.1.extract, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %.fca.2.extract, 2
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 %offset.i.i35, 3
  %7 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.1.extract2, 1
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.2.extract3, 2
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %offset.i.i, 3
  %11 = alloca [1 x ptr], align 8
  store ptr @_parameterization_String, ptr %11, align 8
  %12 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %11) #34
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract1) #34
  %14 = sext i32 %offset.i.i to i64
  %15 = getelementptr ptr, ptr %.fca.0.extract1, i64 %14
  %16 = getelementptr i8, ptr %15, i64 88
  %17 = load ptr, ptr %16, align 8
  %18 = alloca { ptr }, align 8
  store ptr %.fca.0.extract, ptr %18, align 8
  %result.i = call ptr %17({ ptr, ptr, ptr, i32 } %10, ptr nocapture nofree noundef nonnull readonly %18) #16
  %19 = call i1 %result.i({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull align 8 dereferenceable(8) %11, { ptr, ptr, ptr, i32 } %6) #7
  ret i1 %19
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { i64, i64 } @_data_size_Pair(ptr nocapture nofree readonly align 8 %0) #10 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i = tail call { i64, i64 } %6(ptr nocapture nofree nonnull readonly %3) #5
  %7 = extractvalue { i64, i64 } %result.i, 0
  %8 = extractvalue { i64, i64 } %result.i, 1
  %9 = urem i64 16, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 16
  %14 = add i64 %13, %12
  %15 = getelementptr i8, ptr %0, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %result.i1 = tail call { i64, i64 } %19(ptr nocapture nofree nonnull readonly %16) #5
  %20 = extractvalue { i64, i64 } %result.i1, 0
  %21 = extractvalue { i64, i64 } %result.i1, 1
  %22 = tail call i64 @llvm.umax.i64(i64 %8, i64 %21)
  %23 = tail call i64 @llvm.umax.i64(i64 %22, i64 8)
  %24 = urem i64 %14, %21
  %25 = icmp eq i64 %24, 0
  %26 = sub i64 %21, %24
  %27 = select i1 %25, i64 0, i64 %26
  %28 = add i64 %20, %14
  %29 = add i64 %28, %27
  %30 = urem i64 %29, %23
  %31 = icmp eq i64 %30, 0
  %32 = sub i64 %23, %30
  %33 = select i1 %31, i64 0, i64 %32
  %34 = add i64 %29, %33
  %35 = insertvalue { i64, i64 } undef, i64 %34, 0
  %36 = insertvalue { i64, i64 } %35, i64 %23, 1
  ret { i64, i64 } %36
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Pair_field_Pair_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Pair_field_Pair_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Pair_B_init_firstT_secondU({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Pair_B_first_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 144
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Pair_B_second_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Pair_init_firstT_secondU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr, i160 } %4) #2 {
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !386
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !386
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !386
  %product.i.i.i = mul i64 %hash_coef.i.i, 9197944775169318296
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !386
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract11) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract11, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  tail call void %12(ptr %.fca.1.extract12, { ptr, i160 } %3) #35
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract11) #34
  %14 = getelementptr i8, ptr %8, i64 24
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  tail call void %17(ptr %.fca.1.extract12, { ptr, i160 } %4) #35
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Pair_first_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !389
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !389
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !389
  %product.i.i.i = mul i64 %hash_coef.i.i, 9197944775169318296
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !389
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract3) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract3, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call { ptr, i160 } %9(ptr %.fca.1.extract4) #36
  ret { ptr, i160 } %10
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Pair_second_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !392
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !392
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !392
  %product.i.i.i = mul i64 %hash_coef.i.i, 9197944775169318296
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !392
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract3) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract3, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call { ptr, i160 } %9(ptr %.fca.1.extract4) #36
  ret { ptr, i160 } %10
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, i160 } @Pair_getter_second(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(16) %0) #10 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %result.i = tail call { i64, i64 } %5(ptr nocapture nofree nonnull readonly %2) #5
  %6 = extractvalue { i64, i64 } %result.i, 0
  %7 = extractvalue { i64, i64 } %result.i, 1
  %8 = urem i64 16, %7
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 %7, %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %6, 16
  %13 = add i64 %12, %11
  %14 = getelementptr inbounds i8, ptr %0, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr i8, ptr %16, i64 72
  %18 = load ptr, ptr %17, align 8
  %result.i1 = tail call { i64, i64 } %18(ptr nocapture nofree nonnull readonly %15) #5
  %19 = extractvalue { i64, i64 } %result.i1, 1
  %20 = urem i64 %13, %19
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 %19, %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = getelementptr i8, ptr %0, i64 %13
  %25 = getelementptr i8, ptr %24, i64 %23
  %26 = getelementptr i8, ptr %16, i64 56
  %27 = load ptr, ptr %26, align 8
  %result.i2 = tail call { ptr, i160 } %27(ptr nocapture nofree readonly %25, ptr nocapture nofree nonnull readonly %15) #5
  ret { ptr, i160 } %result.i2
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Pair_setter_second(ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %0, { ptr, i160 } %1) #12 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i = tail call { i64, i64 } %6(ptr nocapture nofree nonnull readonly %3) #5
  %7 = extractvalue { i64, i64 } %result.i, 0
  %8 = extractvalue { i64, i64 } %result.i, 1
  %9 = urem i64 16, %8
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 %8, %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %7, 16
  %14 = add i64 %13, %12
  %15 = getelementptr inbounds i8, ptr %0, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 72
  %19 = load ptr, ptr %18, align 8
  %result.i1 = tail call { i64, i64 } %19(ptr nocapture nofree nonnull readonly %16) #5
  %20 = extractvalue { i64, i64 } %result.i1, 1
  %21 = urem i64 %14, %20
  %22 = icmp eq i64 %21, 0
  %23 = sub i64 %20, %21
  %24 = select i1 %22, i64 0, i64 %23
  %25 = getelementptr i8, ptr %0, i64 %14
  %26 = getelementptr i8, ptr %25, i64 %24
  %27 = getelementptr i8, ptr %17, i64 64
  %28 = load ptr, ptr %27, align 8
  tail call void %28({ ptr, i160 } %1, ptr nocapture nofree nonnull readonly %16, ptr nocapture nofree writeonly %26) #13
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, i160 } @Pair_getter_first(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #10 {
  %2 = load ptr, ptr %0, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr i8, ptr %3, i64 72
  %5 = load ptr, ptr %4, align 8
  %result.i = tail call { i64, i64 } %5(ptr nocapture nofree nonnull readonly %2) #5
  %6 = extractvalue { i64, i64 } %result.i, 1
  %7 = urem i64 16, %6
  %8 = icmp eq i64 %7, 0
  %reass.sub = sub i64 %6, %7
  %9 = add i64 %reass.sub, 16
  %10 = select i1 %8, i64 16, i64 %9
  %11 = getelementptr i8, ptr %0, i64 %10
  %12 = getelementptr i8, ptr %3, i64 56
  %13 = load ptr, ptr %12, align 8
  %result.i1 = tail call { ptr, i160 } %13(ptr nocapture nofree readonly %11, ptr nocapture nofree nonnull readonly %2) #5
  ret { ptr, i160 } %result.i1
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Pair_setter_first(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0, { ptr, i160 } %1) #12 {
  %3 = load ptr, ptr %0, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr i8, ptr %4, i64 72
  %6 = load ptr, ptr %5, align 8
  %result.i = tail call { i64, i64 } %6(ptr nocapture nofree nonnull readonly %3) #5
  %7 = extractvalue { i64, i64 } %result.i, 1
  %8 = urem i64 16, %7
  %9 = icmp eq i64 %8, 0
  %reass.sub = sub i64 %7, %8
  %10 = add i64 %reass.sub, 16
  %11 = select i1 %9, i64 16, i64 %10
  %12 = getelementptr i8, ptr %0, i64 %11
  %13 = getelementptr i8, ptr %4, i64 64
  %14 = load ptr, ptr %13, align 8
  tail call void %14({ ptr, i160 } %1, ptr nocapture nofree nonnull readonly %3, ptr nocapture nofree writeonly %12) #13
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Container(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Iterator2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Iterable2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 8, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Array(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 24, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Array_field_Array_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite)
define noundef nonnull ptr @Array_B__Self_from_iterable_iterableIterable2T(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #13 {
  %2 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #34
  ret ptr @Array__Self_from_iterable_iterableIterable2T
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_capacityPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 320
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_init_lengthPtri32_capacityPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 328
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_length_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 336
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_capacity_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 344
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_append_xT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 352
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_reserve_new_capacityPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 360
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B__index_xPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 368
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B__set_index_xPtri32_valueT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 376
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_throw_oob_xPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 384
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_unchecked_index_xPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 392
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_unchecked_insert_xPtri32_valueT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 400
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 408
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 416
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 424
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 432
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 440
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 448
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 456
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 464
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 472
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 480
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Array_B_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 488
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @Array__Self_from_iterable_iterableIterable2T(ptr nocapture nofree readnone %0, { ptr, ptr, ptr, i32 } %1) #7 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract26 = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract27 = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract28 = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract29 = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract26, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract26, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract26, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !395
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !395
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !395
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !395
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract26) #38
  %5 = sext i32 %.fca.3.extract29 to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract26, i64 %5
  %7 = load ptr, ptr %6, align 8
  %result.i = tail call ptr %7(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract27) #5
  %result.i73 = tail call noalias nonnull align 8 dereferenceable(24) ptr @bump_malloc_inner(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i, ptr %result.i73, align 8
  %8 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %result.i73) #38
  %9 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %3) #34
  %10 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #34
  %11 = load ptr, ptr %result.i, align 8
  %12 = getelementptr i8, ptr %11, i64 72
  %13 = load ptr, ptr %12, align 8
  %result.i3.i = tail call { i64, i64 } %13(ptr nocapture nofree nonnull readonly %result.i) #5
  %14 = extractvalue { i64, i64 } %result.i3.i, 0
  %result.i4.i = tail call noalias ptr @bump_malloc_inner(i64 noundef %14, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %15 = getelementptr inbounds i8, ptr %result.i73, i64 8
  store ptr %result.i4.i, ptr %15, align 8
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  %17 = getelementptr inbounds i8, ptr %result.i73, i64 20
  store i32 1, ptr %17, align 4
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract26, 0
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.1.extract27, 1
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.2.extract28, 2
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 %offset.i.i, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract26)
  %24 = sext i32 %offset.i.i to i64
  %25 = getelementptr ptr, ptr %.fca.0.extract26, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %result.i89 = call ptr %27({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly %3) #16
  %28 = call { ptr, ptr, ptr, i32 } %result.i89({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %3) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %28, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %28, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %28, 2
  %hash_coef_ptr.i.i91 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i92 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i93 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i94 = load i64, ptr %hash_coef_ptr.i.i91, align 4, !noalias !373
  %tbl_size.i.i95 = load i64, ptr %tbl_size_ptr.i.i92, align 4, !noalias !373
  %offset_tbl.i.i96 = load ptr, ptr %offset_tbl_ptr.i.i93, align 8, !noalias !373
  %product.i.i.i97 = mul i64 %hash_coef.i.i94, 4189192806087951739
  %shifted.i.i.i98 = lshr i64 %product.i.i.i97, 32
  %xored.i.i.i99 = xor i64 %shifted.i.i.i98, %product.i.i.i97
  %hash.i.i.i100 = and i64 %xored.i.i.i99, %tbl_size.i.i95
  %offset_ptr.i.i101 = getelementptr i32, ptr %offset_tbl.i.i96, i64 %hash.i.i.i100
  %offset.i.i116 = load i32, ptr %offset_ptr.i.i101, align 4, !noalias !398
  %29 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.1.extract, 1
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, ptr %.fca.2.extract, 2
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, i32 %offset.i.i116, 3
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %35 = sext i32 %offset.i.i116 to i64
  %36 = getelementptr ptr, ptr %.fca.0.extract, i64 %35
  %37 = getelementptr i8, ptr %36, i64 8
  %38 = load ptr, ptr %37, align 8
  %result.i118164 = call ptr %38({ ptr, ptr, ptr, i32 } %32, ptr nocapture nofree noundef nonnull readonly %3) #16
  %39 = call { ptr, i160 } %result.i118164({ ptr, ptr, ptr, i32 } %32, { ptr, ptr, ptr, i32 } %32, ptr nonnull align 8 %3) #7
  %.fca.0.extract63165 = extractvalue { ptr, i160 } %39, 0
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract26)
  %41 = icmp ne ptr %.fca.0.extract63165, @nil_typ
  %42 = icmp ne ptr %.fca.0.extract63165, null
  %.not71166 = and i1 %41, %42
  br i1 %.not71166, label %._crit_edge.lr.ph, label %.critedge

._crit_edge.lr.ph:                                ; preds = %2
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract26)
  %44 = getelementptr inbounds i8, ptr %result.i73, i64 16
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph, %Array_append_xT.exit
  %45 = phi ptr [ %result.i4.i, %._crit_edge.lr.ph ], [ %74, %Array_append_xT.exit ]
  %.pre168 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %86, %Array_append_xT.exit ]
  %46 = phi { ptr, i160 } [ %39, %._crit_edge.lr.ph ], [ %89, %Array_append_xT.exit ]
  %47 = load i32, ptr %17, align 4
  %.not.i = icmp slt i32 %.pre168, %47
  br i1 %.not.i, label %Array_append_xT.exit, label %48

48:                                               ; preds = %._crit_edge
  %49 = shl i32 %47, 1
  %.not.i169 = icmp sgt i32 %49, %47
  %.pre.pre = load ptr, ptr %15, align 8
  br i1 %.not.i169, label %50, label %Array_append_xT.exit

50:                                               ; preds = %48
  store i32 %49, ptr %17, align 4
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array)
  %52 = load ptr, ptr %result.i, align 8
  %53 = getelementptr i8, ptr %52, i64 72
  %54 = load ptr, ptr %53, align 8
  %result.i25.i = call { i64, i64 } %54(ptr nocapture nofree nonnull readonly %result.i) #5
  %55 = extractvalue { i64, i64 } %result.i25.i, 0
  %56 = sext i32 %49 to i64
  %57 = mul i64 %55, %56
  %result.i26.i = call noalias ptr @bump_malloc_inner(i64 noundef %57, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i26.i, ptr %15, align 8
  %58 = icmp sgt i32 %.pre168, 0
  br i1 %58, label %._crit_edge.lr.ph.i, label %Array_append_xT.exit

._crit_edge.lr.ph.i:                              ; preds = %50
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array)
  br label %._crit_edge.i

._crit_edge.i:                                    ; preds = %._crit_edge.i, %._crit_edge.lr.ph.i
  %.052.i = phi i32 [ 0, %._crit_edge.lr.ph.i ], [ %72, %._crit_edge.i ]
  %60 = load ptr, ptr %result.i, align 8
  %61 = getelementptr i8, ptr %60, i64 72
  %62 = load ptr, ptr %61, align 8
  %result.i27.i = call { i64, i64 } %62(ptr nocapture nofree nonnull readonly %result.i) #5
  %63 = extractvalue { i64, i64 } %result.i27.i, 0
  %64 = zext nneg i32 %.052.i to i64
  %65 = mul i64 %63, %64
  %66 = getelementptr i8, ptr %.pre.pre, i64 %65
  %67 = getelementptr i8, ptr %60, i64 56
  %68 = load ptr, ptr %67, align 8
  %result.i28.i = call { ptr, i160 } %68(ptr nocapture nofree readonly %66, ptr nocapture nofree nonnull readonly %result.i) #5
  %69 = getelementptr i8, ptr %result.i26.i, i64 %65
  %70 = getelementptr i8, ptr %60, i64 64
  %71 = load ptr, ptr %70, align 8
  call void %71({ ptr, i160 } %result.i28.i, ptr nocapture nofree nonnull readonly %result.i, ptr nocapture nofree writeonly %69) #13
  %72 = add nuw nsw i32 %.052.i, 1
  %73 = icmp slt i32 %72, %.pre168
  br i1 %73, label %._crit_edge.i, label %Array_append_xT.exit

Array_append_xT.exit:                             ; preds = %._crit_edge.i, %50, %48, %._crit_edge
  %74 = phi ptr [ %45, %._crit_edge ], [ %.pre.pre, %48 ], [ %result.i26.i, %50 ], [ %result.i26.i, %._crit_edge.i ]
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  %76 = load ptr, ptr %result.i, align 8
  %77 = getelementptr i8, ptr %76, i64 72
  %78 = load ptr, ptr %77, align 8
  %result.i20.i = call { i64, i64 } %78(ptr nocapture nofree nonnull readonly %result.i) #5
  %79 = extractvalue { i64, i64 } %result.i20.i, 0
  %80 = sext i32 %.pre168 to i64
  %81 = mul i64 %79, %80
  %82 = getelementptr i8, ptr %74, i64 %81
  %83 = getelementptr i8, ptr %76, i64 64
  %84 = load ptr, ptr %83, align 8
  call void %84({ ptr, i160 } %46, ptr nocapture nofree nonnull readonly %result.i, ptr nocapture nofree writeonly %82) #13
  %85 = load i32, ptr %44, align 8
  %86 = add i32 %85, 1
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull @Array) #40
  store i32 %86, ptr %44, align 8
  %88 = load ptr, ptr %37, align 8
  %result.i118 = call ptr %88({ ptr, ptr, ptr, i32 } %32, ptr nocapture nofree noundef nonnull readonly %3) #16
  %89 = call { ptr, i160 } %result.i118({ ptr, ptr, ptr, i32 } %32, { ptr, ptr, ptr, i32 } %32, ptr nonnull align 8 %3) #7
  %.fca.0.extract63 = extractvalue { ptr, i160 } %89, 0
  %90 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract26)
  %91 = icmp ne ptr %.fca.0.extract63, @nil_typ
  %92 = icmp ne ptr %.fca.0.extract63, null
  %.not71 = and i1 %91, %92
  br i1 %.not71, label %._crit_edge, label %.critedge

.critedge:                                        ; preds = %Array_append_xT.exit, %2
  %.pre-phi = insertvalue { ptr, ptr, ptr, i32 } { ptr @Array, ptr undef, ptr undef, i32 undef }, ptr %result.i73, 1
  %93 = insertvalue { ptr, ptr, ptr, i32 } %.pre-phi, ptr undef, 2
  %94 = insertvalue { ptr, ptr, ptr, i32 } %93, i32 10, 3
  ret { ptr, ptr, ptr, i32 } %94
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Array_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #2 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !401
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !401
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !401
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !401
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %result.i = tail call nonnull align 8 dereferenceable(8) ptr %7(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %8 = load ptr, ptr %result.i, align 8
  %9 = getelementptr i8, ptr %8, i64 72
  %10 = load ptr, ptr %9, align 8
  %result.i3 = tail call { i64, i64 } %10(ptr nocapture nofree nonnull readonly %result.i) #5
  %11 = extractvalue { i64, i64 } %result.i3, 0
  %result.i4 = tail call noalias ptr @bump_malloc_inner(i64 noundef %11, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %13 = getelementptr i8, ptr %6, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = insertvalue { ptr } undef, ptr %result.i4, 0
  tail call void %16(ptr %.fca.1.extract, { ptr } %17) #35
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %19 = getelementptr i8, ptr %6, i64 16
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  tail call void %22(ptr %.fca.1.extract, i32 0) #35
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #40
  %24 = getelementptr i8, ptr %6, i64 24
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  tail call void %27(ptr %.fca.1.extract, i32 1) #35
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define void @Array_init_capacityPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !404
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !404
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !404
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !404
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  tail call void %11(ptr %.fca.1.extract, i32 %3) #35
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %13 = load ptr, ptr %8, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = tail call i32 %14(ptr %.fca.1.extract) #36
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %17 = load ptr, ptr %7, align 8
  %result.i = tail call nonnull align 8 dereferenceable(8) ptr %17(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %18 = load ptr, ptr %result.i, align 8
  %19 = getelementptr i8, ptr %18, i64 72
  %20 = load ptr, ptr %19, align 8
  %result.i3 = tail call { i64, i64 } %20(ptr nocapture nofree nonnull readonly %result.i) #5
  %21 = extractvalue { i64, i64 } %result.i3, 0
  %22 = sext i32 %15 to i64
  %23 = mul i64 %21, %22
  %result.i4 = tail call noalias ptr @bump_malloc_inner(i64 noundef %23, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %25 = getelementptr i8, ptr %7, i64 8
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr i8, ptr %26, i64 8
  %28 = load ptr, ptr %27, align 8
  %29 = insertvalue { ptr } undef, ptr %result.i4, 0
  tail call void %28(ptr %.fca.1.extract, { ptr } %29) #35
  %30 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %31 = getelementptr i8, ptr %7, i64 16
  %32 = load ptr, ptr %31, align 8
  %33 = getelementptr i8, ptr %32, i64 8
  %34 = load ptr, ptr %33, align 8
  tail call void %34(ptr %.fca.1.extract, i32 0) #35
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define void @Array_init_lengthPtri32_capacityPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, i32 %4) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !407
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !407
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !407
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !407
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  tail call void %12(ptr %.fca.1.extract, i32 %3) #35
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %14 = getelementptr i8, ptr %8, i64 24
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  tail call void %17(ptr %.fca.1.extract, i32 %4) #35
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %19 = load ptr, ptr %14, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = tail call i32 %20(ptr %.fca.1.extract) #36
  %22 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %23 = load ptr, ptr %8, align 8
  %result.i = tail call nonnull align 8 dereferenceable(8) ptr %23(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %24 = load ptr, ptr %result.i, align 8
  %25 = getelementptr i8, ptr %24, i64 72
  %26 = load ptr, ptr %25, align 8
  %result.i3 = tail call { i64, i64 } %26(ptr nocapture nofree nonnull readonly %result.i) #5
  %27 = extractvalue { i64, i64 } %result.i3, 0
  %28 = sext i32 %21 to i64
  %29 = mul i64 %27, %28
  %result.i4 = tail call noalias ptr @bump_malloc_inner(i64 noundef %29, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %30 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %31 = getelementptr i8, ptr %8, i64 8
  %32 = load ptr, ptr %31, align 8
  %33 = getelementptr i8, ptr %32, i64 8
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr } undef, ptr %result.i4, 0
  tail call void %34(ptr %.fca.1.extract, { ptr } %35) #35
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @Array_length_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !410
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !410
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !410
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !410
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract) #36
  ret i32 %10
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @Array_capacity_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !413
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !413
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !413
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !413
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 24
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract) #36
  ret i32 %10
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @Array_append_xT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3) #7 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !416
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !416
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !416
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !416
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract4) #34
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract4, i64 %8
  %10 = getelementptr i8, ptr %9, i64 16
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = tail call i32 %12(ptr %.fca.1.extract5) #36
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract4) #34
  %15 = getelementptr i8, ptr %9, i64 24
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = tail call i32 %17(ptr %.fca.1.extract5) #36
  %.not = icmp slt i32 %13, %18
  br i1 %.not, label %.._crit_edge_crit_edge, label %19

.._crit_edge_crit_edge:                           ; preds = %4
  %.pre65 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract4, 0
  %.pre66 = insertvalue { ptr, ptr, ptr, i32 } %.pre65, ptr %.fca.1.extract5, 1
  %.pre68 = insertvalue { ptr, ptr, ptr, i32 } %.pre66, ptr %.fca.2.extract, 2
  br label %._crit_edge

19:                                               ; preds = %4
  %20 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #40
  %21 = tail call i32 %17(ptr %.fca.1.extract5) #36
  %22 = shl i32 %21, 1
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract4, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract5, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %offset.i.i, 3
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5) #40
  %28 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #40
  %29 = getelementptr i8, ptr %9, i64 88
  %30 = load ptr, ptr %29, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i = call ptr %30({ ptr, ptr, ptr, i32 } %26, ptr nocapture nofree noundef nonnull readonly %6) #16
  call void %result.i({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull align 8 dereferenceable(8) %5, i32 %22) #7
  %.pre = load ptr, ptr %10, align 8
  %.pre64 = load ptr, ptr %.pre, align 8
  br label %._crit_edge

._crit_edge:                                      ; preds = %.._crit_edge_crit_edge, %19
  %.pre-phi69 = phi { ptr, ptr, ptr, i32 } [ %.pre68, %.._crit_edge_crit_edge ], [ %25, %19 ]
  %31 = phi ptr [ %12, %.._crit_edge_crit_edge ], [ %.pre64, %19 ]
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #40
  %33 = getelementptr i8, ptr %9, i64 8
  %34 = load ptr, ptr %33, align 8
  %35 = load ptr, ptr %34, align 8
  %36 = call { ptr } %35(ptr %.fca.1.extract5) #36
  %.fca.0.extract14 = extractvalue { ptr } %36, 0
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #40
  %38 = call i32 %31(ptr %.fca.1.extract5) #36
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #40
  %40 = load ptr, ptr %9, align 8
  %result.i19 = call nonnull align 8 dereferenceable(8) ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract5) #5
  %41 = load ptr, ptr %result.i19, align 8
  %42 = getelementptr i8, ptr %41, i64 72
  %43 = load ptr, ptr %42, align 8
  %result.i20 = call { i64, i64 } %43(ptr nocapture nofree nonnull readonly %result.i19) #5
  %44 = extractvalue { i64, i64 } %result.i20, 0
  %45 = sext i32 %38 to i64
  %46 = mul i64 %44, %45
  %47 = getelementptr i8, ptr %.fca.0.extract14, i64 %46
  %48 = getelementptr i8, ptr %41, i64 64
  %49 = load ptr, ptr %48, align 8
  call void %49({ ptr, i160 } %3, ptr nocapture nofree nonnull readonly %result.i19, ptr nocapture nofree writeonly %47) #13
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #40
  %51 = load ptr, ptr %10, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = call i32 %52(ptr %.fca.1.extract5) #36
  %54 = add i32 %53, 1
  %55 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #40
  %56 = getelementptr i8, ptr %51, i64 8
  %57 = load ptr, ptr %56, align 8
  call void %57(ptr %.fca.1.extract5, i32 %54) #35
  %hash_coef.i.i25 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !419
  %tbl_size.i.i26 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !419
  %offset_tbl.i.i27 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !419
  %product.i.i.i28 = mul i64 %hash_coef.i.i25, -5261542750394134544
  %shifted.i.i.i29 = lshr i64 %product.i.i.i28, 32
  %xored.i.i.i30 = xor i64 %shifted.i.i.i29, %product.i.i.i28
  %hash.i.i.i31 = and i64 %xored.i.i.i30, %tbl_size.i.i26
  %offset_ptr.i.i32 = getelementptr i32, ptr %offset_tbl.i.i27, i64 %hash.i.i.i31
  %offset.i.i33 = load i32, ptr %offset_ptr.i.i32, align 4, !noalias !419
  %58 = insertvalue { ptr, ptr, ptr, i32 } %.pre-phi69, i32 %offset.i.i33, 3
  ret { ptr, ptr, ptr, i32 } %58
}

define void @Array_reserve_new_capacityPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #38
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call i32 %10(ptr %.fca.1.extract) #36
  %.not = icmp sgt i32 %3, %11
  br i1 %.not, label %12, label %._crit_edge.thread

12:                                               ; preds = %4
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %14 = getelementptr i8, ptr %9, i64 8
  %15 = load ptr, ptr %14, align 8
  tail call void %15(ptr %.fca.1.extract, i32 %3) #35
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %17 = getelementptr i8, ptr %7, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = tail call { ptr } %19(ptr %.fca.1.extract) #36
  %.fca.0.extract22 = extractvalue { ptr } %20, 0
  %21 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %22 = load ptr, ptr %8, align 8
  %23 = load ptr, ptr %22, align 8
  %24 = tail call i32 %23(ptr %.fca.1.extract) #36
  %25 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %26 = load ptr, ptr %7, align 8
  %result.i = tail call nonnull align 8 dereferenceable(8) ptr %26(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %27 = load ptr, ptr %result.i, align 8
  %28 = getelementptr i8, ptr %27, i64 72
  %29 = load ptr, ptr %28, align 8
  %result.i25 = tail call { i64, i64 } %29(ptr nocapture nofree nonnull readonly %result.i) #5
  %30 = extractvalue { i64, i64 } %result.i25, 0
  %31 = sext i32 %24 to i64
  %32 = mul i64 %30, %31
  %result.i26 = tail call noalias ptr @bump_malloc_inner(i64 noundef %32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %33 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %34 = load ptr, ptr %17, align 8
  %35 = getelementptr i8, ptr %34, i64 8
  %36 = load ptr, ptr %35, align 8
  %37 = insertvalue { ptr } undef, ptr %result.i26, 0
  tail call void %36(ptr %.fca.1.extract, { ptr } %37) #35
  %38 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %39 = getelementptr i8, ptr %7, i64 16
  %40 = load ptr, ptr %39, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = tail call i32 %41(ptr %.fca.1.extract) #36
  %43 = icmp sgt i32 %42, 0
  br i1 %43, label %._crit_edge.lr.ph, label %._crit_edge.thread

._crit_edge.lr.ph:                                ; preds = %12
  %44 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph, %._crit_edge
  %.052 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %60, %._crit_edge ]
  %45 = load ptr, ptr %result.i, align 8
  %46 = getelementptr i8, ptr %45, i64 72
  %47 = load ptr, ptr %46, align 8
  %result.i27 = tail call { i64, i64 } %47(ptr nocapture nofree nonnull readonly %result.i) #5
  %48 = extractvalue { i64, i64 } %result.i27, 0
  %49 = zext nneg i32 %.052 to i64
  %50 = mul i64 %48, %49
  %51 = getelementptr i8, ptr %.fca.0.extract22, i64 %50
  %52 = getelementptr i8, ptr %45, i64 56
  %53 = load ptr, ptr %52, align 8
  %result.i28 = tail call { ptr, i160 } %53(ptr nocapture nofree readonly %51, ptr nocapture nofree nonnull readonly %result.i) #5
  %54 = load ptr, ptr %17, align 8
  %55 = load ptr, ptr %54, align 8
  %56 = tail call { ptr } %55(ptr %.fca.1.extract) #36
  %.fca.0.extract7 = extractvalue { ptr } %56, 0
  %57 = getelementptr i8, ptr %.fca.0.extract7, i64 %50
  %58 = getelementptr i8, ptr %45, i64 64
  %59 = load ptr, ptr %58, align 8
  tail call void %59({ ptr, i160 } %result.i28, ptr nocapture nofree nonnull readonly %result.i, ptr nocapture nofree writeonly %57) #13
  %60 = add nuw nsw i32 %.052, 1
  %61 = load ptr, ptr %39, align 8
  %62 = load ptr, ptr %61, align 8
  %63 = tail call i32 %62(ptr %.fca.1.extract) #36
  %64 = icmp slt i32 %60, %63
  br i1 %64, label %._crit_edge, label %._crit_edge.thread

._crit_edge.thread:                               ; preds = %._crit_edge, %12, %4
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @Array__index_xPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #7 {
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %7 = alloca [1 x ptr], align 8
  %8 = alloca { ptr }, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !422
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !422
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !422
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !422
  %9 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %10 = sext i32 %offset.i.i to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract, i64 %10
  %12 = getelementptr i8, ptr %11, i64 16
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = tail call i32 %14(ptr %.fca.1.extract) #36
  %16 = add i32 %15, -1
  %17 = icmp sgt i32 %3, %16
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %19 = tail call i32 %14(ptr %.fca.1.extract) #36
  %20 = add i32 %19, %3
  %21 = icmp slt i32 %20, 0
  %.0 = select i1 %17, i1 true, i1 %21
  br i1 %.0, label %22, label %._crit_edge

22:                                               ; preds = %4
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %offset.i.i, 3
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5) #40
  %28 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract) #40
  %29 = getelementptr i8, ptr %11, i64 112
  %30 = load ptr, ptr %29, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i = call ptr %30({ ptr, ptr, ptr, i32 } %26, ptr nocapture nofree noundef nonnull readonly %6) #16
  call void %result.i({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull align 8 dereferenceable(8) %5, i32 %3) #7
  br label %._crit_edge

._crit_edge:                                      ; preds = %4, %22
  %31 = icmp slt i32 %3, 0
  br i1 %31, label %32, label %._crit_edge1

32:                                               ; preds = %._crit_edge
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract) #40
  %34 = load ptr, ptr %12, align 8
  %35 = load ptr, ptr %34, align 8
  %36 = call i32 %35(ptr %.fca.1.extract) #36
  %37 = add i32 %36, %3
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %32
  %.027 = phi i32 [ %37, %32 ], [ %3, %._crit_edge ]
  %38 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, ptr %.fca.1.extract, 1
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %.fca.2.extract, 2
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, i32 %offset.i.i, 3
  store ptr @_parameterization_Ptri32, ptr %7, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %7) #40
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract) #40
  %44 = getelementptr i8, ptr %11, i64 120
  %45 = load ptr, ptr %44, align 8
  store ptr @i32_typ, ptr %8, align 8
  %result.i30 = call ptr %45({ ptr, ptr, ptr, i32 } %41, ptr nocapture nofree noundef nonnull readonly %8) #16
  %46 = call { ptr, i160 } %result.i30({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr nonnull align 8 dereferenceable(8) %7, i32 %.027) #7
  ret { ptr, i160 } %46
}

; Function Attrs: nounwind
define void @Array__set_index_xPtri32_valueT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, { ptr, i160 } %4) #7 {
  %6 = alloca [1 x ptr], align 8
  %7 = alloca { ptr }, align 8
  %8 = alloca [2 x ptr], align 8
  %9 = alloca { ptr, ptr }, align 8
  %.fca.0.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract17 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract16, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract16, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract16, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !425
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !425
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !425
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !425
  %10 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract16) #34
  %11 = sext i32 %offset.i.i to i64
  %12 = getelementptr ptr, ptr %.fca.0.extract16, i64 %11
  %13 = getelementptr i8, ptr %12, i64 16
  %14 = load ptr, ptr %13, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = tail call i32 %15(ptr %.fca.1.extract17) #36
  %17 = add i32 %16, -1
  %18 = icmp sgt i32 %3, %17
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract16) #34
  %20 = tail call i32 %15(ptr %.fca.1.extract17) #36
  %21 = add i32 %20, %3
  %22 = icmp slt i32 %21, 0
  %.0 = select i1 %18, i1 true, i1 %22
  br i1 %.0, label %23, label %._crit_edge

23:                                               ; preds = %5
  %24 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract16, 0
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.1.extract17, 1
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %.fca.2.extract, 2
  %27 = insertvalue { ptr, ptr, ptr, i32 } %26, i32 %offset.i.i, 3
  store ptr @_parameterization_Ptri32, ptr %6, align 8
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %6) #40
  %29 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract16) #40
  %30 = getelementptr i8, ptr %12, i64 112
  %31 = load ptr, ptr %30, align 8
  store ptr @i32_typ, ptr %7, align 8
  %result.i = call ptr %31({ ptr, ptr, ptr, i32 } %27, ptr nocapture nofree noundef nonnull readonly %7) #16
  call void %result.i({ ptr, ptr, ptr, i32 } %27, { ptr, ptr, ptr, i32 } %27, ptr nonnull align 8 dereferenceable(8) %6, i32 %3) #7
  br label %._crit_edge

._crit_edge:                                      ; preds = %5, %23
  %32 = icmp slt i32 %3, 0
  br i1 %32, label %33, label %._crit_edge1

33:                                               ; preds = %._crit_edge
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract16) #40
  %35 = load ptr, ptr %13, align 8
  %36 = load ptr, ptr %35, align 8
  %37 = call i32 %36(ptr %.fca.1.extract17) #36
  %38 = add i32 %37, %3
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %._crit_edge, %33
  %.027 = phi i32 [ %38, %33 ], [ %3, %._crit_edge ]
  %.fca.0.extract = extractvalue { ptr, i160 } %4, 0
  %39 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract16, 0
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %.fca.1.extract17, 1
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %.fca.2.extract, 2
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, i32 %offset.i.i, 3
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract16) #40
  %44 = load ptr, ptr %12, align 8
  %result.i30 = call ptr %44(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract17) #5
  store ptr @_parameterization_Ptri32, ptr %8, align 8
  %45 = getelementptr inbounds i8, ptr %8, i64 8
  store ptr %result.i30, ptr %45, align 8
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %8) #40
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef nonnull %.fca.0.extract16) #40
  %48 = getelementptr i8, ptr %12, i64 128
  %49 = load ptr, ptr %48, align 8
  store ptr @i32_typ, ptr %9, align 8
  %50 = getelementptr inbounds i8, ptr %9, i64 8
  store ptr %.fca.0.extract, ptr %50, align 8
  %result.i31 = call ptr %49({ ptr, ptr, ptr, i32 } %42, ptr nocapture nofree noundef nonnull readonly %9) #16
  call void %result.i31({ ptr, ptr, ptr, i32 } %42, { ptr, ptr, ptr, i32 } %42, ptr nonnull align 8 dereferenceable(16) %8, i32 %.027, { ptr, i160 } %4) #7
  ret void
}

; Function Attrs: nounwind
define void @Array_throw_oob_xPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #7 {
  %result.i26 = tail call noalias dereferenceable_or_null(72) ptr @bump_malloc_inner(i64 noundef 72, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %result.i.i = tail call noalias align 8 dereferenceable_or_null(7) ptr @bump_malloc_inner(i64 noundef 7, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %result.i.i, align 8
  %result.i29.i = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i.i, ptr %result.i29.i, align 8
  %5 = getelementptr i8, ptr %result.i29.i, i64 8
  store i32 6, ptr %5, align 4
  %6 = getelementptr i8, ptr %result.i29.i, i64 12
  store i32 7, ptr %6, align 4
  %7 = getelementptr i8, ptr %result.i26, i64 40
  store ptr @String, ptr %7, align 8
  %8 = getelementptr i8, ptr %result.i26, i64 48
  store ptr %result.i29.i, ptr %8, align 8
  %9 = getelementptr i8, ptr %result.i26, i64 64
  store i32 10, ptr %9, align 4
  %10 = getelementptr i8, ptr %result.i26, i64 8
  %11 = getelementptr i8, ptr %result.i26, i64 16
  %12 = getelementptr i8, ptr %result.i26, i64 32
  %result.i28 = tail call noalias align 16 dereferenceable_or_null(17) ptr @bump_malloc_inner(i64 noundef 17, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <16 x i8> <i8 99, i8 111, i8 108, i8 108, i8 101, i8 99, i8 116, i8 105, i8 111, i8 110, i8 115, i8 46, i8 109, i8 105, i8 110, i8 105>, ptr %result.i28, align 16
  %result.i30 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i28, ptr %result.i30, align 8
  %13 = getelementptr i8, ptr %result.i30, i64 8
  store i32 16, ptr %13, align 4
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String) #34
  %15 = getelementptr i8, ptr %result.i30, i64 12
  store i32 17, ptr %15, align 4
  store i32 152, ptr %result.i26, align 4
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull @Exception) #34
  store ptr @String, ptr %10, align 8
  store ptr %result.i30, ptr %11, align 8
  store i32 10, ptr %12, align 4
  %17 = ptrtoint ptr %result.i26 to i64
  %.sroa.4.8.insert.ext = zext i64 %17 to i160
  %.sroa.4.8.insert.insert = or disjoint i160 %.sroa.4.8.insert.ext, 3402823669209384634633746074317682114560
  %18 = insertvalue { ptr, i160 } { ptr @Exception, i160 undef }, i160 %.sroa.4.8.insert.insert, 1
  %current_coroutine.i = load ptr, ptr @current_coroutine, align 8
  %19 = getelementptr i8, ptr %current_coroutine.i, i64 48
  store { ptr, i160 } %18, ptr %19, align 8
  %into_callee_buf.i = getelementptr i8, ptr %current_coroutine.i, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf.i, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #41
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i160 } @Array_unchecked_index_xPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) #3 {
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !428
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !428
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !428
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !428
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract4) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract4, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr } %10(ptr %.fca.1.extract5) #36
  %.fca.0.extract1 = extractvalue { ptr } %11, 0
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract4) #40
  %13 = load ptr, ptr %7, align 8
  %result.i = tail call nonnull align 8 dereferenceable(8) ptr %13(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract5) #5
  %14 = load ptr, ptr %result.i, align 8
  %15 = getelementptr i8, ptr %14, i64 72
  %16 = load ptr, ptr %15, align 8
  %result.i8 = tail call { i64, i64 } %16(ptr nocapture nofree nonnull readonly %result.i) #5
  %17 = extractvalue { i64, i64 } %result.i8, 0
  %18 = sext i32 %3 to i64
  %19 = mul i64 %17, %18
  %20 = getelementptr i8, ptr %.fca.0.extract1, i64 %19
  %21 = getelementptr i8, ptr %14, i64 56
  %22 = load ptr, ptr %21, align 8
  %result.i9 = tail call { ptr, i160 } %22(ptr nocapture nofree readonly %20, ptr nocapture nofree nonnull readonly %result.i) #5
  ret { ptr, i160 } %result.i9
}

; Function Attrs: mustprogress nounwind willreturn
define void @Array_unchecked_insert_xPtri32_valueT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, { ptr, i160 } %4) #3 {
  %.fca.0.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract6, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract6, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract6, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !431
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !431
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !431
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !431
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract6) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract6, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = tail call { ptr } %11(ptr %.fca.1.extract7) #36
  %.fca.0.extract = extractvalue { ptr } %12, 0
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract6) #40
  %14 = load ptr, ptr %8, align 8
  %result.i = tail call nonnull align 8 dereferenceable(8) ptr %14(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract7) #5
  %15 = load ptr, ptr %result.i, align 8
  %16 = getelementptr i8, ptr %15, i64 72
  %17 = load ptr, ptr %16, align 8
  %result.i10 = tail call { i64, i64 } %17(ptr nocapture nofree nonnull readonly %result.i) #5
  %18 = extractvalue { i64, i64 } %result.i10, 0
  %19 = sext i32 %3 to i64
  %20 = mul i64 %18, %19
  %21 = getelementptr i8, ptr %.fca.0.extract, i64 %20
  %22 = getelementptr i8, ptr %15, i64 64
  %23 = load ptr, ptr %22, align 8
  tail call void %23({ ptr, i160 } %4, ptr nocapture nofree nonnull readonly %result.i, ptr nocapture nofree writeonly %21) #13
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Array_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #2 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !434
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !434
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !434
  %product.i.i.i = mul i64 %hash_coef.i.i, -5261542750394134544
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !434
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %result.i = tail call ptr %7(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %result.i8 = tail call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_inner(i64 noundef 48, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i, ptr %result.i8, align 8
  %8 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %result.i8) #34
  %hash_coef.i.i13 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !373
  %tbl_size.i.i14 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !373
  %offset_tbl.i.i15 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !373
  %product.i.i.i16 = mul i64 %hash_coef.i.i13, -5261542750394134544
  %shifted.i.i.i17 = lshr i64 %product.i.i.i16, 32
  %xored.i.i.i18 = xor i64 %shifted.i.i.i17, %product.i.i.i16
  %hash.i.i.i19 = and i64 %xored.i.i.i18, %tbl_size.i.i14
  %offset_ptr.i.i20 = getelementptr i32, ptr %offset_tbl.i.i15, i64 %hash.i.i.i19
  %offset.i.i21 = load i32, ptr %offset_ptr.i.i20, align 4, !noalias !373
  %9 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ArrayIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i8, 1
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, ptr undef, 2
  %11 = getelementptr inbounds i8, ptr %result.i8, i64 8
  store ptr %.fca.0.extract, ptr %11, align 8
  %12 = getelementptr inbounds i8, ptr %result.i8, i64 16
  store ptr %.fca.1.extract, ptr %12, align 8
  %13 = getelementptr inbounds i8, ptr %result.i8, i64 24
  store ptr %.fca.2.extract, ptr %13, align 8
  %14 = getelementptr inbounds i8, ptr %result.i8, i64 32
  store i32 %offset.i.i21, ptr %14, align 8
  %15 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @ArrayIterator) #34
  %16 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 17, 3
  ret { ptr, ptr, ptr, i32 } %16
}

define void @Iterable2_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !437
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !437
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !437
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !437
  %.fca.0.extract3 = extractvalue { ptr } %3, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract6, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract7, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #38
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract5) #38
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract5, i64 %12
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %result.i = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly %5) #16
  %16 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 2
  %hash_coef_ptr.i.i30 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i31 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i32 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i33 = load i64, ptr %hash_coef_ptr.i.i30, align 4, !noalias !373
  %tbl_size.i.i34 = load i64, ptr %tbl_size_ptr.i.i31, align 4, !noalias !373
  %offset_tbl.i.i35 = load ptr, ptr %offset_tbl_ptr.i.i32, align 8, !noalias !373
  %product.i.i.i36 = mul i64 %hash_coef.i.i33, 4189192806087951739
  %shifted.i.i.i37 = lshr i64 %product.i.i.i36, 32
  %xored.i.i.i38 = xor i64 %shifted.i.i.i37, %product.i.i.i36
  %hash.i.i.i39 = and i64 %xored.i.i.i38, %tbl_size.i.i34
  %offset_ptr.i.i40 = getelementptr i32, ptr %offset_tbl.i.i35, i64 %hash.i.i.i39
  %offset.i.i55 = load i32, ptr %offset_ptr.i.i40, align 4, !noalias !440
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i.i55, 3
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %23 = sext i32 %offset.i.i55 to i64
  %24 = getelementptr ptr, ptr %.fca.0.extract, i64 %23
  %25 = getelementptr i8, ptr %24, i64 8
  %26 = load ptr, ptr %25, align 8
  %result.i5764 = call ptr %26({ ptr, ptr, ptr, i32 } %20, ptr nocapture nofree noundef nonnull readonly %5) #16
  %27 = call { ptr, i160 } %result.i5764({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %5) #7
  %.fca.0.extract2265 = extractvalue { ptr, i160 } %27, 0
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract5)
  %29 = icmp ne ptr %.fca.0.extract2265, @nil_typ
  %30 = icmp ne ptr %.fca.0.extract2265, null
  %.not2866 = and i1 %29, %30
  br i1 %.not2866, label %._crit_edge, label %.critedge

._crit_edge:                                      ; preds = %4, %._crit_edge
  %31 = phi { ptr, i160 } [ %33, %._crit_edge ], [ %27, %4 ]
  call void %.fca.0.extract3({ ptr, i160 } %31)
  %32 = load ptr, ptr %25, align 8
  %result.i57 = call ptr %32({ ptr, ptr, ptr, i32 } %20, ptr nocapture nofree noundef nonnull readonly %5) #16
  %33 = call { ptr, i160 } %result.i57({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %5) #7
  %.fca.0.extract22 = extractvalue { ptr, i160 } %33, 0
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract5)
  %35 = icmp ne ptr %.fca.0.extract22, @nil_typ
  %36 = icmp ne ptr %.fca.0.extract22, null
  %.not28 = and i1 %35, %36
  br i1 %.not28, label %._crit_edge, label %.critedge

.critedge:                                        ; preds = %._crit_edge, %4
  ret void
}

define { ptr, i160 } @Iterable2_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, i160 } %3, { ptr } %4) {
  %6 = alloca [0 x ptr], align 8
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract15 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !443
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !443
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !443
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !443
  %.fca.0.extract3 = extractvalue { ptr } %4, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract13, 0
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.1.extract14, 1
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %.fca.2.extract15, 2
  %10 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %offset.i.i, 3
  %11 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6) #38
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract13) #38
  %13 = sext i32 %offset.i.i to i64
  %14 = getelementptr ptr, ptr %.fca.0.extract13, i64 %13
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %result.i = call ptr %16({ ptr, ptr, ptr, i32 } %10, ptr nocapture nofree noundef nonnull readonly %6) #16
  %17 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %10, { ptr, ptr, ptr, i32 } %10, ptr nonnull align 8 %6) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %17, 2
  %hash_coef_ptr.i.i50 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i51 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i52 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i53 = load i64, ptr %hash_coef_ptr.i.i50, align 4, !noalias !373
  %tbl_size.i.i54 = load i64, ptr %tbl_size_ptr.i.i51, align 4, !noalias !373
  %offset_tbl.i.i55 = load ptr, ptr %offset_tbl_ptr.i.i52, align 8, !noalias !373
  %product.i.i.i56 = mul i64 %hash_coef.i.i53, 4189192806087951739
  %shifted.i.i.i57 = lshr i64 %product.i.i.i56, 32
  %xored.i.i.i58 = xor i64 %shifted.i.i.i57, %product.i.i.i56
  %hash.i.i.i59 = and i64 %xored.i.i.i58, %tbl_size.i.i54
  %offset_ptr.i.i60 = getelementptr i32, ptr %offset_tbl.i.i55, i64 %hash.i.i.i59
  %offset.i.i75 = load i32, ptr %offset_ptr.i.i60, align 4, !noalias !446
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.1.extract, 1
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.2.extract, 2
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 %offset.i.i75, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %24 = sext i32 %offset.i.i75 to i64
  %25 = getelementptr ptr, ptr %.fca.0.extract, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %result.i7789 = call ptr %27({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly %6) #16
  %28 = call { ptr, i160 } %result.i7789({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %6) #7
  %.fca.0.extract4090 = extractvalue { ptr, i160 } %28, 0
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract13)
  %30 = icmp ne ptr %.fca.0.extract4090, @nil_typ
  %31 = icmp ne ptr %.fca.0.extract4090, null
  %.not4891 = and i1 %30, %31
  br i1 %.not4891, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge:                                      ; preds = %5, %._crit_edge
  %32 = phi { ptr, i160 } [ %35, %._crit_edge ], [ %28, %5 ]
  %.pn92 = phi { ptr, i160 } [ %33, %._crit_edge ], [ %3, %5 ]
  %33 = call { ptr, i160 } %.fca.0.extract3({ ptr, i160 } %.pn92, { ptr, i160 } %32)
  %34 = load ptr, ptr %26, align 8
  %result.i77 = call ptr %34({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly %6) #16
  %35 = call { ptr, i160 } %result.i77({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %6) #7
  %.fca.0.extract40 = extractvalue { ptr, i160 } %35, 0
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract13)
  %37 = icmp ne ptr %.fca.0.extract40, @nil_typ
  %38 = icmp ne ptr %.fca.0.extract40, null
  %.not48 = and i1 %37, %38
  br i1 %.not48, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge1._crit_edge:                          ; preds = %._crit_edge, %5
  %.pn.lcssa = phi { ptr, i160 } [ %3, %5 ], [ %33, %._crit_edge ]
  ret { ptr, i160 } %.pn.lcssa
}

define noundef i1 @Iterable2_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !449
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !449
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !449
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !449
  %.fca.0.extract3 = extractvalue { ptr } %3, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract6, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract7, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #38
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract5) #38
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract5, i64 %12
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %result.i = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly %5) #16
  %16 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 2
  %hash_coef_ptr.i.i31 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i32 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i33 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i34 = load i64, ptr %hash_coef_ptr.i.i31, align 4, !noalias !373
  %tbl_size.i.i35 = load i64, ptr %tbl_size_ptr.i.i32, align 4, !noalias !373
  %offset_tbl.i.i36 = load ptr, ptr %offset_tbl_ptr.i.i33, align 8, !noalias !373
  %product.i.i.i37 = mul i64 %hash_coef.i.i34, 4189192806087951739
  %shifted.i.i.i38 = lshr i64 %product.i.i.i37, 32
  %xored.i.i.i39 = xor i64 %shifted.i.i.i38, %product.i.i.i37
  %hash.i.i.i40 = and i64 %xored.i.i.i39, %tbl_size.i.i35
  %offset_ptr.i.i41 = getelementptr i32, ptr %offset_tbl.i.i36, i64 %hash.i.i.i40
  %offset.i.i56 = load i32, ptr %offset_ptr.i.i41, align 4, !noalias !452
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i.i56, 3
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %23 = sext i32 %offset.i.i56 to i64
  %24 = getelementptr ptr, ptr %.fca.0.extract, i64 %23
  %25 = getelementptr i8, ptr %24, i64 8
  br label %26

26:                                               ; preds = %32, %4
  %27 = load ptr, ptr %25, align 8
  %result.i58 = call ptr %27({ ptr, ptr, ptr, i32 } %20, ptr nocapture nofree noundef nonnull readonly %5) #16
  %28 = call { ptr, i160 } %result.i58({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %5) #7
  %.fca.0.extract25 = extractvalue { ptr, i160 } %28, 0
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract5)
  %30 = icmp eq ptr %.fca.0.extract25, @nil_typ
  %31 = icmp eq ptr %.fca.0.extract25, null
  %.not28.not = or i1 %30, %31
  br i1 %.not28.not, label %.critedge, label %32

32:                                               ; preds = %26
  %33 = call i1 %.fca.0.extract3({ ptr, i160 } %28)
  br i1 %33, label %26, label %.critedge

.critedge:                                        ; preds = %26, %32
  ret i1 %.not28.not
}

define noundef i1 @Iterable2_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !455
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !455
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !455
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !455
  %.fca.0.extract3 = extractvalue { ptr } %3, 0
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract5, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract6, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract7, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #38
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract5) #38
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract5, i64 %12
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %result.i = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly %5) #16
  %16 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %16, 2
  %hash_coef_ptr.i.i28 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i29 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i30 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i31 = load i64, ptr %hash_coef_ptr.i.i28, align 4, !noalias !373
  %tbl_size.i.i32 = load i64, ptr %tbl_size_ptr.i.i29, align 4, !noalias !373
  %offset_tbl.i.i33 = load ptr, ptr %offset_tbl_ptr.i.i30, align 8, !noalias !373
  %product.i.i.i34 = mul i64 %hash_coef.i.i31, 4189192806087951739
  %shifted.i.i.i35 = lshr i64 %product.i.i.i34, 32
  %xored.i.i.i36 = xor i64 %shifted.i.i.i35, %product.i.i.i34
  %hash.i.i.i37 = and i64 %xored.i.i.i36, %tbl_size.i.i32
  %offset_ptr.i.i38 = getelementptr i32, ptr %offset_tbl.i.i33, i64 %hash.i.i.i37
  %offset.i.i53 = load i32, ptr %offset_ptr.i.i38, align 4, !noalias !458
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i.i53, 3
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %23 = sext i32 %offset.i.i53 to i64
  %24 = getelementptr ptr, ptr %.fca.0.extract, i64 %23
  %25 = getelementptr i8, ptr %24, i64 8
  br label %26

26:                                               ; preds = %32, %4
  %27 = load ptr, ptr %25, align 8
  %result.i55 = call ptr %27({ ptr, ptr, ptr, i32 } %20, ptr nocapture nofree noundef nonnull readonly %5) #16
  %28 = call { ptr, i160 } %result.i55({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr nonnull align 8 %5) #7
  %.fca.0.extract23 = extractvalue { ptr, i160 } %28, 0
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract5)
  %30 = icmp ne ptr %.fca.0.extract23, @nil_typ
  %31 = icmp ne ptr %.fca.0.extract23, null
  %.not26 = and i1 %30, %31
  br i1 %.not26, label %32, label %.critedge

32:                                               ; preds = %26
  %33 = call i1 %.fca.0.extract3({ ptr, i160 } %28)
  br i1 %33, label %.critedge, label %26

.critedge:                                        ; preds = %26, %32
  ret i1 %.not26
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable2_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readonly %2, { ptr } %3) #2 {
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !461
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !461
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !461
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !461
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract8) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract8, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i = tail call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %9 = load ptr, ptr %2, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %result.i10 = tail call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_inner(i64 noundef 56, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i, ptr %result.i10, align 8
  %12 = getelementptr inbounds i8, ptr %result.i10, i64 8
  store ptr %11, ptr %12, align 8
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i10) #34
  %hash_coef.i.i15 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !373
  %tbl_size.i.i16 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !373
  %offset_tbl.i.i17 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !373
  %product.i.i.i18 = mul i64 %hash_coef.i.i15, 5693646204635713916
  %shifted.i.i.i19 = lshr i64 %product.i.i.i18, 32
  %xored.i.i.i20 = xor i64 %shifted.i.i.i19, %product.i.i.i18
  %hash.i.i.i21 = and i64 %xored.i.i.i20, %tbl_size.i.i16
  %offset_ptr.i.i22 = getelementptr i32, ptr %offset_tbl.i.i17, i64 %hash.i.i.i21
  %offset.i.i23 = load i32, ptr %offset_ptr.i.i22, align 4, !noalias !373
  %14 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapIterable2, ptr undef, ptr undef, i32 undef }, ptr %result.i10, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr undef, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 10, 3
  %17 = getelementptr inbounds i8, ptr %result.i10, i64 16
  store ptr %.fca.0.extract8, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %result.i10, i64 24
  store ptr %.fca.1.extract, ptr %18, align 8
  %19 = getelementptr inbounds i8, ptr %result.i10, i64 32
  store ptr %.fca.2.extract, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i10, i64 40
  store i32 %offset.i.i23, ptr %20, align 8
  %21 = tail call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef nonnull @MapIterable2) #34
  %22 = getelementptr inbounds i8, ptr %result.i10, i64 48
  %.fca.0.extract.i = extractvalue { ptr } %3, 0
  store ptr %.fca.0.extract.i, ptr %22, align 8
  ret { ptr, ptr, ptr, i32 } %16
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable2_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3) #2 {
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract8, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !464
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !464
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !464
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !464
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract8) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract8, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i = tail call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract) #5
  %result.i10 = tail call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_inner(i64 noundef 48, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i, ptr %result.i10, align 8
  %9 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %result.i10) #34
  %hash_coef.i.i15 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !373
  %tbl_size.i.i16 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !373
  %offset_tbl.i.i17 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !373
  %product.i.i.i18 = mul i64 %hash_coef.i.i15, 5693646204635713916
  %shifted.i.i.i19 = lshr i64 %product.i.i.i18, 32
  %xored.i.i.i20 = xor i64 %shifted.i.i.i19, %product.i.i.i18
  %hash.i.i.i21 = and i64 %xored.i.i.i20, %tbl_size.i.i16
  %offset_ptr.i.i22 = getelementptr i32, ptr %offset_tbl.i.i17, i64 %hash.i.i.i21
  %offset.i.i23 = load i32, ptr %offset_ptr.i.i22, align 4, !noalias !373
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @FilterIterable2, ptr undef, ptr undef, i32 undef }, ptr %result.i10, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 10, 3
  %13 = getelementptr inbounds i8, ptr %result.i10, i64 8
  store ptr %.fca.0.extract8, ptr %13, align 8
  %14 = getelementptr inbounds i8, ptr %result.i10, i64 16
  store ptr %.fca.1.extract, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %result.i10, i64 24
  store ptr %.fca.2.extract, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i10, i64 32
  store i32 %offset.i.i23, ptr %16, align 8
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef nonnull @FilterIterable2) #34
  %18 = getelementptr inbounds i8, ptr %result.i10, i64 40
  %.fca.0.extract.i = extractvalue { ptr } %3, 0
  store ptr %.fca.0.extract.i, ptr %18, align 8
  ret { ptr, ptr, ptr, i32 } %12
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable2_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #2 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !467
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !467
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !467
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !467
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i16 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i17 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract7) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract7, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i = tail call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract8) #5
  %result.i30 = tail call noalias nonnull align 8 dereferenceable(72) ptr @bump_malloc_inner(i64 noundef 72, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i, ptr %result.i30, align 8
  %9 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %result.i30) #34
  %hash_coef.i.i35 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !373
  %tbl_size.i.i36 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !373
  %offset_tbl.i.i37 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !373
  %product.i.i.i38 = mul i64 %hash_coef.i.i35, 5693646204635713916
  %shifted.i.i.i39 = lshr i64 %product.i.i.i38, 32
  %xored.i.i.i40 = xor i64 %shifted.i.i.i39, %product.i.i.i38
  %hash.i.i.i41 = and i64 %xored.i.i.i40, %tbl_size.i.i36
  %offset_ptr.i.i42 = getelementptr i32, ptr %offset_tbl.i.i37, i64 %hash.i.i.i41
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i42, align 4, !noalias !373
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ChainIterable2, ptr undef, ptr undef, i32 undef }, ptr %result.i30, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 10, 3
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef nonnull @ChainIterable2) #34
  %14 = getelementptr inbounds i8, ptr %result.i30, i64 8
  store ptr %.fca.0.extract7, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %result.i30, i64 16
  store ptr %.fca.1.extract8, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i30, i64 24
  store ptr %.fca.2.extract9, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i30, i64 32
  store i32 %offset.i.i43, ptr %17, align 8
  %hash_coef.i.i107 = load i64, ptr %hash_coef_ptr.i.i16, align 4, !noalias !373
  %tbl_size.i.i108 = load i64, ptr %tbl_size_ptr.i.i17, align 4, !noalias !373
  %offset_tbl.i.i109 = load ptr, ptr %offset_tbl_ptr.i.i18, align 8, !noalias !373
  %product.i.i.i110 = mul i64 %hash_coef.i.i107, 5693646204635713916
  %shifted.i.i.i111 = lshr i64 %product.i.i.i110, 32
  %xored.i.i.i112 = xor i64 %shifted.i.i.i111, %product.i.i.i110
  %hash.i.i.i113 = and i64 %xored.i.i.i112, %tbl_size.i.i108
  %offset_ptr.i.i114 = getelementptr i32, ptr %offset_tbl.i.i109, i64 %hash.i.i.i113
  %offset.i.i102 = load i32, ptr %offset_ptr.i.i114, align 4, !noalias !470
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef nonnull @ChainIterable2) #34
  %19 = getelementptr inbounds i8, ptr %result.i30, i64 40
  store ptr %.fca.0.extract, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i30, i64 48
  store ptr %.fca.1.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i30, i64 56
  store ptr %.fca.2.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i30, i64 64
  store i32 %offset.i.i102, ptr %22, align 8
  ret { ptr, ptr, ptr, i32 } %12
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable2_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #2 {
  %.fca.0.extract7 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract8 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract7, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !473
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !473
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !473
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !473
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i16 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i17 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract7) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract7, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i = tail call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract8) #5
  %result.i30 = tail call noalias nonnull align 8 dereferenceable(72) ptr @bump_malloc_inner(i64 noundef 72, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i, ptr %result.i30, align 8
  %9 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %result.i30) #34
  %hash_coef.i.i35 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !373
  %tbl_size.i.i36 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !373
  %offset_tbl.i.i37 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !373
  %product.i.i.i38 = mul i64 %hash_coef.i.i35, 5693646204635713916
  %shifted.i.i.i39 = lshr i64 %product.i.i.i38, 32
  %xored.i.i.i40 = xor i64 %shifted.i.i.i39, %product.i.i.i38
  %hash.i.i.i41 = and i64 %xored.i.i.i40, %tbl_size.i.i36
  %offset_ptr.i.i42 = getelementptr i32, ptr %offset_tbl.i.i37, i64 %hash.i.i.i41
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i42, align 4, !noalias !373
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @InterleaveIterable2, ptr undef, ptr undef, i32 undef }, ptr %result.i30, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 10, 3
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef nonnull @InterleaveIterable2) #34
  %14 = getelementptr inbounds i8, ptr %result.i30, i64 8
  store ptr %.fca.0.extract7, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %result.i30, i64 16
  store ptr %.fca.1.extract8, ptr %15, align 8
  %16 = getelementptr inbounds i8, ptr %result.i30, i64 24
  store ptr %.fca.2.extract9, ptr %16, align 8
  %17 = getelementptr inbounds i8, ptr %result.i30, i64 32
  store i32 %offset.i.i43, ptr %17, align 8
  %hash_coef.i.i107 = load i64, ptr %hash_coef_ptr.i.i16, align 4, !noalias !373
  %tbl_size.i.i108 = load i64, ptr %tbl_size_ptr.i.i17, align 4, !noalias !373
  %offset_tbl.i.i109 = load ptr, ptr %offset_tbl_ptr.i.i18, align 8, !noalias !373
  %product.i.i.i110 = mul i64 %hash_coef.i.i107, 5693646204635713916
  %shifted.i.i.i111 = lshr i64 %product.i.i.i110, 32
  %xored.i.i.i112 = xor i64 %shifted.i.i.i111, %product.i.i.i110
  %hash.i.i.i113 = and i64 %xored.i.i.i112, %tbl_size.i.i108
  %offset_ptr.i.i114 = getelementptr i32, ptr %offset_tbl.i.i109, i64 %hash.i.i.i113
  %offset.i.i102 = load i32, ptr %offset_ptr.i.i114, align 4, !noalias !476
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef nonnull @InterleaveIterable2) #34
  %19 = getelementptr inbounds i8, ptr %result.i30, i64 40
  store ptr %.fca.0.extract, ptr %19, align 8
  %20 = getelementptr inbounds i8, ptr %result.i30, i64 48
  store ptr %.fca.1.extract, ptr %20, align 8
  %21 = getelementptr inbounds i8, ptr %result.i30, i64 56
  store ptr %.fca.2.extract, ptr %21, align 8
  %22 = getelementptr inbounds i8, ptr %result.i30, i64 64
  store i32 %offset.i.i102, ptr %22, align 8
  ret { ptr, ptr, ptr, i32 } %12
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable2_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #2 {
  %.fca.0.extract30 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !479
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !479
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !479
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !479
  %.fca.0.extract23 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract24 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract25 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract26 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %hash_coef_ptr.i.i39 = getelementptr i8, ptr %.fca.0.extract23, i64 8
  %tbl_size_ptr.i.i40 = getelementptr i8, ptr %.fca.0.extract23, i64 16
  %offset_tbl_ptr.i.i41 = getelementptr i8, ptr %.fca.0.extract23, i64 40
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract30) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract30, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i = tail call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract31) #5
  %9 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract23) #34
  %10 = sext i32 %.fca.3.extract26 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract23, i64 %10
  %12 = load ptr, ptr %11, align 8
  %result.i52 = tail call ptr %12(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract24) #5
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract23) #34
  %result.i53 = tail call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %14 = getelementptr inbounds i8, ptr %result.i53, i64 16
  store ptr %result.i52, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %result.i53, i64 8
  store ptr %result.i, ptr %15, align 8
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i53) #34
  store ptr @Pair, ptr %result.i53, align 8
  %result.i55 = tail call noalias nonnull align 8 dereferenceable(88) ptr @bump_malloc_inner(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i, ptr %result.i55, align 8
  %17 = getelementptr inbounds i8, ptr %result.i55, i64 8
  store ptr %result.i52, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %result.i55, i64 16
  store ptr %result.i53, ptr %18, align 8
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i55) #34
  %hash_coef.i.i60 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !373
  %tbl_size.i.i61 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !373
  %offset_tbl.i.i62 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !373
  %product.i.i.i63 = mul i64 %hash_coef.i.i60, 5693646204635713916
  %shifted.i.i.i64 = lshr i64 %product.i.i.i63, 32
  %xored.i.i.i65 = xor i64 %shifted.i.i.i64, %product.i.i.i63
  %hash.i.i.i66 = and i64 %xored.i.i.i65, %tbl_size.i.i61
  %offset_ptr.i.i67 = getelementptr i32, ptr %offset_tbl.i.i62, i64 %hash.i.i.i66
  %offset.i.i68 = load i32, ptr %offset_ptr.i.i67, align 4, !noalias !373
  %20 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ZipIterable2, ptr undef, ptr undef, i32 undef }, ptr %result.i55, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr undef, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 10, 3
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract23) #34
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef nonnull @ZipIterable2) #34
  %25 = getelementptr inbounds i8, ptr %result.i55, i64 24
  store ptr %.fca.0.extract30, ptr %25, align 8
  %26 = getelementptr inbounds i8, ptr %result.i55, i64 32
  store ptr %.fca.1.extract31, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %result.i55, i64 40
  store ptr %.fca.2.extract32, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %result.i55, i64 48
  store i32 %offset.i.i68, ptr %28, align 8
  %hash_coef.i.i136 = load i64, ptr %hash_coef_ptr.i.i39, align 4, !noalias !373
  %tbl_size.i.i137 = load i64, ptr %tbl_size_ptr.i.i40, align 4, !noalias !373
  %offset_tbl.i.i138 = load ptr, ptr %offset_tbl_ptr.i.i41, align 8, !noalias !373
  %product.i.i.i139 = mul i64 %hash_coef.i.i136, 5693646204635713916
  %shifted.i.i.i140 = lshr i64 %product.i.i.i139, 32
  %xored.i.i.i141 = xor i64 %shifted.i.i.i140, %product.i.i.i139
  %hash.i.i.i142 = and i64 %xored.i.i.i141, %tbl_size.i.i137
  %offset_ptr.i.i143 = getelementptr i32, ptr %offset_tbl.i.i138, i64 %hash.i.i.i142
  %offset.i.i131 = load i32, ptr %offset_ptr.i.i143, align 4, !noalias !482
  %29 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef nonnull @ZipIterable2) #34
  %30 = getelementptr inbounds i8, ptr %result.i55, i64 56
  store ptr %.fca.0.extract23, ptr %30, align 8
  %31 = getelementptr inbounds i8, ptr %result.i55, i64 64
  store ptr %.fca.1.extract24, ptr %31, align 8
  %32 = getelementptr inbounds i8, ptr %result.i55, i64 72
  store ptr %.fca.2.extract25, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %result.i55, i64 80
  store i32 %offset.i.i131, ptr %33, align 8
  ret { ptr, ptr, ptr, i32 } %22
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Iterable2_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #2 {
  %.fca.0.extract30 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract31 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract30, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !485
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !485
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !485
  %product.i.i.i = mul i64 %hash_coef.i.i, 5693646204635713916
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !485
  %.fca.0.extract23 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract24 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract25 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %.fca.3.extract26 = extractvalue { ptr, ptr, ptr, i32 } %3, 3
  %hash_coef_ptr.i.i39 = getelementptr i8, ptr %.fca.0.extract23, i64 8
  %tbl_size_ptr.i.i40 = getelementptr i8, ptr %.fca.0.extract23, i64 16
  %offset_tbl_ptr.i.i41 = getelementptr i8, ptr %.fca.0.extract23, i64 40
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract30) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract30, i64 %6
  %8 = load ptr, ptr %7, align 8
  %result.i = tail call ptr %8(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract31) #5
  %9 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract23) #34
  %10 = sext i32 %.fca.3.extract26 to i64
  %11 = getelementptr ptr, ptr %.fca.0.extract23, i64 %10
  %12 = load ptr, ptr %11, align 8
  %result.i52 = tail call ptr %12(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract24) #5
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract23) #34
  %result.i53 = tail call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %14 = getelementptr inbounds i8, ptr %result.i53, i64 16
  store ptr %result.i52, ptr %14, align 8
  %15 = getelementptr inbounds i8, ptr %result.i53, i64 8
  store ptr %result.i, ptr %15, align 8
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i53) #34
  store ptr @Pair, ptr %result.i53, align 8
  %result.i55 = tail call noalias nonnull align 8 dereferenceable(88) ptr @bump_malloc_inner(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i, ptr %result.i55, align 8
  %17 = getelementptr inbounds i8, ptr %result.i55, i64 8
  store ptr %result.i52, ptr %17, align 8
  %18 = getelementptr inbounds i8, ptr %result.i55, i64 16
  store ptr %result.i53, ptr %18, align 8
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i55) #34
  %hash_coef.i.i60 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !373
  %tbl_size.i.i61 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !373
  %offset_tbl.i.i62 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !373
  %product.i.i.i63 = mul i64 %hash_coef.i.i60, 5693646204635713916
  %shifted.i.i.i64 = lshr i64 %product.i.i.i63, 32
  %xored.i.i.i65 = xor i64 %shifted.i.i.i64, %product.i.i.i63
  %hash.i.i.i66 = and i64 %xored.i.i.i65, %tbl_size.i.i61
  %offset_ptr.i.i67 = getelementptr i32, ptr %offset_tbl.i.i62, i64 %hash.i.i.i66
  %offset.i.i68 = load i32, ptr %offset_ptr.i.i67, align 4, !noalias !373
  %20 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ProductIterable2, ptr undef, ptr undef, i32 undef }, ptr %result.i55, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr undef, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 10, 3
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract23) #34
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef nonnull @ProductIterable2) #34
  %25 = getelementptr inbounds i8, ptr %result.i55, i64 24
  store ptr %.fca.0.extract30, ptr %25, align 8
  %26 = getelementptr inbounds i8, ptr %result.i55, i64 32
  store ptr %.fca.1.extract31, ptr %26, align 8
  %27 = getelementptr inbounds i8, ptr %result.i55, i64 40
  store ptr %.fca.2.extract32, ptr %27, align 8
  %28 = getelementptr inbounds i8, ptr %result.i55, i64 48
  store i32 %offset.i.i68, ptr %28, align 8
  %hash_coef.i.i136 = load i64, ptr %hash_coef_ptr.i.i39, align 4, !noalias !373
  %tbl_size.i.i137 = load i64, ptr %tbl_size_ptr.i.i40, align 4, !noalias !373
  %offset_tbl.i.i138 = load ptr, ptr %offset_tbl_ptr.i.i41, align 8, !noalias !373
  %product.i.i.i139 = mul i64 %hash_coef.i.i136, 5693646204635713916
  %shifted.i.i.i140 = lshr i64 %product.i.i.i139, 32
  %xored.i.i.i141 = xor i64 %shifted.i.i.i140, %product.i.i.i139
  %hash.i.i.i142 = and i64 %xored.i.i.i141, %tbl_size.i.i137
  %offset_ptr.i.i143 = getelementptr i32, ptr %offset_tbl.i.i138, i64 %hash.i.i.i142
  %offset.i.i131 = load i32, ptr %offset_ptr.i.i143, align 4, !noalias !488
  %29 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef nonnull @ProductIterable2) #34
  %30 = getelementptr inbounds i8, ptr %result.i55, i64 56
  store ptr %.fca.0.extract23, ptr %30, align 8
  %31 = getelementptr inbounds i8, ptr %result.i55, i64 64
  store ptr %.fca.1.extract24, ptr %31, align 8
  %32 = getelementptr inbounds i8, ptr %result.i55, i64 72
  store ptr %.fca.2.extract25, ptr %32, align 8
  %33 = getelementptr inbounds i8, ptr %result.i55, i64 80
  store i32 %offset.i.i131, ptr %33, align 8
  ret { ptr, ptr, ptr, i32 } %22
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ProductIterable2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterable2_field_ProductIterable2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterable2_field_ProductIterable2_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterable2_field_ProductIterable2_2(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_init_firstIterable2T_secondIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterable2_B_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ProductIterable2_init_firstIterable2T_secondIterable2U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #2 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !491
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !491
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !491
  %product.i.i.i = mul i64 %hash_coef.i.i, 7827074759551300494
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !491
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4, !noalias !373
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4, !noalias !373
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8, !noalias !373
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 5693646204635713916
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4, !noalias !494
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #35
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4, !noalias !373
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4, !noalias !373
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8, !noalias !373
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 5693646204635713916
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4, !noalias !497
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %18 = getelementptr i8, ptr %8, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #35
  ret void
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @ProductIterable2_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract51 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract53 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract51, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract51, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract51, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !500
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !500
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !500
  %product.i.i.i = mul i64 %hash_coef.i.i, 7827074759551300494
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !500
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract51) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract51, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract53) #36
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract45, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract47, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract49, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #40
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract43) #40
  %18 = sext i32 %.fca.3.extract49 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract43, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #16
  %22 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract51)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract53) #36
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract51)
  %29 = load ptr, ptr %7, align 8
  %result.i77 = call ptr %29(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract53) #5
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract51)
  %31 = getelementptr i8, ptr %7, i64 8
  %32 = load ptr, ptr %31, align 8
  %result.i78 = call ptr %32(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract53) #5
  %result.i79 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %33 = getelementptr inbounds i8, ptr %result.i79, i64 16
  store ptr %result.i78, ptr %33, align 8
  %34 = getelementptr inbounds i8, ptr %result.i79, i64 8
  store ptr %result.i77, ptr %34, align 8
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i79)
  store ptr @Pair, ptr %result.i79, align 8
  %result.i81 = call noalias nonnull align 8 dereferenceable(152) ptr @bump_malloc_inner(i64 noundef 152, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i77, ptr %result.i81, align 8
  %36 = getelementptr inbounds i8, ptr %result.i81, i64 8
  store ptr %result.i78, ptr %36, align 8
  %37 = getelementptr inbounds i8, ptr %result.i81, i64 16
  store ptr %result.i79, ptr %37, align 8
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i81)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract51)
  %40 = load ptr, ptr %8, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = call { ptr, ptr, ptr, i32 } %41(ptr %.fca.1.extract53) #36
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %42, 0
  %.fca.1.extract11 = extractvalue { ptr, ptr, ptr, i32 } %42, 1
  %.fca.2.extract13 = extractvalue { ptr, ptr, ptr, i32 } %42, 2
  %.fca.3.extract15 = extractvalue { ptr, ptr, ptr, i32 } %42, 3
  %43 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract9, 0
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, ptr %.fca.1.extract11, 1
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %.fca.2.extract13, 2
  %46 = insertvalue { ptr, ptr, ptr, i32 } %45, i32 %.fca.3.extract15, 3
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract9)
  %49 = sext i32 %.fca.3.extract15 to i64
  %50 = getelementptr ptr, ptr %.fca.0.extract9, i64 %49
  %51 = getelementptr i8, ptr %50, i64 8
  %52 = load ptr, ptr %51, align 8
  %result.i82 = call ptr %52({ ptr, ptr, ptr, i32 } %46, ptr nocapture nofree noundef nonnull readonly %4) #16
  %53 = call { ptr, ptr, ptr, i32 } %result.i82({ ptr, ptr, ptr, i32 } %46, { ptr, ptr, ptr, i32 } %46, ptr nonnull align 8 %4) #7
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %53, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %53, 1
  %.fca.2.extract5 = extractvalue { ptr, ptr, ptr, i32 } %53, 2
  %hash_coef_ptr.i.i84 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i85 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i86 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i87 = load i64, ptr %hash_coef_ptr.i.i84, align 4, !noalias !373
  %tbl_size.i.i88 = load i64, ptr %tbl_size_ptr.i.i85, align 4, !noalias !373
  %offset_tbl.i.i89 = load ptr, ptr %offset_tbl_ptr.i.i86, align 8, !noalias !373
  %product.i.i.i90 = mul i64 %hash_coef.i.i87, 4189192806087951739
  %shifted.i.i.i91 = lshr i64 %product.i.i.i90, 32
  %xored.i.i.i92 = xor i64 %shifted.i.i.i91, %product.i.i.i90
  %hash.i.i.i93 = and i64 %xored.i.i.i92, %tbl_size.i.i88
  %offset_ptr.i.i94 = getelementptr i32, ptr %offset_tbl.i.i89, i64 %hash.i.i.i93
  %54 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract51)
  %55 = load ptr, ptr %24, align 8
  %56 = load ptr, ptr %55, align 8
  %57 = call { ptr, ptr, ptr, i32 } %56(ptr %.fca.1.extract53) #36
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %57, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %57, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %57, 2
  %offset.i.i109 = load i32, ptr %offset_ptr.i.i94, align 4, !noalias !373
  %hash_coef_ptr.i.i112 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i113 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i114 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %58 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %59 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %.fca.1.extract, 1
  %60 = insertvalue { ptr, ptr, ptr, i32 } %59, ptr %.fca.2.extract, 2
  %61 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ProductIterator2, ptr undef, ptr undef, i32 undef }, ptr %result.i81, 1
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr undef, 2
  call void @llvm.lifetime.start.p0(i64 0, ptr nonnull %4)
  %63 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @ProductIterator2) #34
  %64 = getelementptr inbounds i8, ptr %result.i81, i64 24
  store ptr %.fca.0.extract1, ptr %64, align 8
  %65 = getelementptr inbounds i8, ptr %result.i81, i64 32
  store ptr %.fca.1.extract3, ptr %65, align 8
  %66 = getelementptr inbounds i8, ptr %result.i81, i64 40
  store ptr %.fca.2.extract5, ptr %66, align 8
  %67 = getelementptr inbounds i8, ptr %result.i81, i64 48
  store i32 %offset.i.i109, ptr %67, align 8
  %hash_coef.i.i89.i = load i64, ptr %hash_coef_ptr.i.i112, align 4, !noalias !373
  %tbl_size.i.i90.i = load i64, ptr %tbl_size_ptr.i.i113, align 4, !noalias !373
  %offset_tbl.i.i91.i = load ptr, ptr %offset_tbl_ptr.i.i114, align 8, !noalias !373
  %product.i.i.i92.i = mul i64 %hash_coef.i.i89.i, 5693646204635713916
  %shifted.i.i.i93.i = lshr i64 %product.i.i.i92.i, 32
  %xored.i.i.i94.i = xor i64 %shifted.i.i.i93.i, %product.i.i.i92.i
  %hash.i.i.i95.i = and i64 %xored.i.i.i94.i, %tbl_size.i.i90.i
  %offset_ptr.i.i96.i = getelementptr i32, ptr %offset_tbl.i.i91.i, i64 %hash.i.i.i95.i
  %offset.i.i111.i = load i32, ptr %offset_ptr.i.i96.i, align 4, !noalias !503
  %68 = getelementptr inbounds i8, ptr %result.i81, i64 88
  store ptr %.fca.0.extract, ptr %68, align 8
  %69 = getelementptr inbounds i8, ptr %result.i81, i64 96
  store ptr %.fca.1.extract, ptr %69, align 8
  %70 = getelementptr inbounds i8, ptr %result.i81, i64 104
  store ptr %.fca.2.extract, ptr %70, align 8
  %71 = getelementptr inbounds i8, ptr %result.i81, i64 112
  store i32 %offset.i.i111.i, ptr %71, align 8
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @ProductIterator2) #34
  %73 = insertvalue { ptr, ptr, ptr, i32 } %60, i32 %offset.i.i111.i, 3
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #34
  %75 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract) #34
  %76 = sext i32 %offset.i.i111.i to i64
  %77 = getelementptr ptr, ptr %.fca.0.extract, i64 %76
  %78 = getelementptr i8, ptr %77, i64 8
  %79 = load ptr, ptr %78, align 8
  %result.i.i = call ptr %79({ ptr, ptr, ptr, i32 } %73, ptr nocapture nofree noundef nonnull readonly %4) #16
  %80 = call { ptr, ptr, ptr, i32 } %result.i.i({ ptr, ptr, ptr, i32 } %73, { ptr, ptr, ptr, i32 } %73, ptr nonnull align 8 %4) #7
  %.fca.0.extract3.i = extractvalue { ptr, ptr, ptr, i32 } %80, 0
  %.fca.1.extract5.i = extractvalue { ptr, ptr, ptr, i32 } %80, 1
  %.fca.2.extract7.i = extractvalue { ptr, ptr, ptr, i32 } %80, 2
  %hash_coef_ptr.i.i114.i = getelementptr i8, ptr %.fca.0.extract3.i, i64 8
  %tbl_size_ptr.i.i115.i = getelementptr i8, ptr %.fca.0.extract3.i, i64 16
  %offset_tbl_ptr.i.i116.i = getelementptr i8, ptr %.fca.0.extract3.i, i64 40
  %hash_coef.i.i117.i = load i64, ptr %hash_coef_ptr.i.i114.i, align 4, !noalias !373
  %tbl_size.i.i118.i = load i64, ptr %tbl_size_ptr.i.i115.i, align 4, !noalias !373
  %offset_tbl.i.i119.i = load ptr, ptr %offset_tbl_ptr.i.i116.i, align 8, !noalias !373
  %product.i.i.i120.i = mul i64 %hash_coef.i.i117.i, 4189192806087951739
  %shifted.i.i.i121.i = lshr i64 %product.i.i.i120.i, 32
  %xored.i.i.i122.i = xor i64 %shifted.i.i.i121.i, %product.i.i.i120.i
  %hash.i.i.i123.i = and i64 %xored.i.i.i122.i, %tbl_size.i.i118.i
  %offset_ptr.i.i124.i = getelementptr i32, ptr %offset_tbl.i.i119.i, i64 %hash.i.i.i123.i
  %offset.i.i139.i = load i32, ptr %offset_ptr.i.i124.i, align 4, !noalias !506
  %81 = getelementptr inbounds i8, ptr %result.i81, i64 56
  store ptr %.fca.0.extract3.i, ptr %81, align 8
  %82 = getelementptr inbounds i8, ptr %result.i81, i64 64
  store ptr %.fca.1.extract5.i, ptr %82, align 8
  %83 = getelementptr inbounds i8, ptr %result.i81, i64 72
  store ptr %.fca.2.extract7.i, ptr %83, align 8
  %84 = getelementptr inbounds i8, ptr %result.i81, i64 80
  store i32 %offset.i.i139.i, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @ProductIterator2)
  %86 = load ptr, ptr %64, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %86, 0
  %88 = load ptr, ptr %65, align 8
  %89 = insertvalue { ptr, ptr, ptr, i32 } %87, ptr %88, 1
  %90 = load ptr, ptr %66, align 8
  %91 = insertvalue { ptr, ptr, ptr, i32 } %89, ptr %90, 2
  %92 = load i32, ptr %67, align 8
  %93 = insertvalue { ptr, ptr, ptr, i32 } %91, i32 %92, 3
  %94 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %95 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %86)
  %96 = sext i32 %92 to i64
  %97 = getelementptr ptr, ptr %86, i64 %96
  %98 = getelementptr i8, ptr %97, i64 8
  %99 = load ptr, ptr %98, align 8
  %result.i141.i = call ptr %99({ ptr, ptr, ptr, i32 } %93, ptr nocapture nofree noundef nonnull readonly %4) #16
  %100 = call { ptr, i160 } %result.i141.i({ ptr, ptr, ptr, i32 } %93, { ptr, ptr, ptr, i32 } %93, ptr nonnull align 8 %4) #7
  %101 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull @ProductIterator2)
  %102 = getelementptr inbounds i8, ptr %result.i81, i64 120
  %.fca.0.extract.i = extractvalue { ptr, i160 } %100, 0
  %.fca.1.extract.i = extractvalue { ptr, i160 } %100, 1
  store ptr %.fca.0.extract.i, ptr %102, align 8
  %103 = getelementptr inbounds i8, ptr %result.i81, i64 128
  store i160 %.fca.1.extract.i, ptr %103, align 8
  call void @llvm.lifetime.end.p0(i64 0, ptr nonnull %4)
  %104 = insertvalue { ptr, ptr, ptr, i32 } %62, i32 21, 3
  ret { ptr, ptr, ptr, i32 } %104
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ProductIterator2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 152, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterator2_field_ProductIterator2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterator2_field_ProductIterator2_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ProductIterator2_field_ProductIterator2_2(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterator2_B_init_first_iteratorIterator2T_second_iterableIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ProductIterator2_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: nounwind
define void @ProductIterator2_init_first_iteratorIterator2T_second_iterableIterable2U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #7 {
  %6 = alloca [0 x ptr], align 8
  %.fca.0.extract45 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract47 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract45, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract45, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract45, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !509
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !509
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !509
  %product.i.i.i = mul i64 %hash_coef.i.i, 4440657219728359865
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !509
  %.fca.0.extract33 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract35 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract37 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i58 = getelementptr i8, ptr %.fca.0.extract33, i64 8
  %tbl_size_ptr.i.i59 = getelementptr i8, ptr %.fca.0.extract33, i64 16
  %offset_tbl_ptr.i.i60 = getelementptr i8, ptr %.fca.0.extract33, i64 40
  %hash_coef.i.i61 = load i64, ptr %hash_coef_ptr.i.i58, align 4, !noalias !373
  %tbl_size.i.i62 = load i64, ptr %tbl_size_ptr.i.i59, align 4, !noalias !373
  %offset_tbl.i.i63 = load ptr, ptr %offset_tbl_ptr.i.i60, align 8, !noalias !373
  %product.i.i.i64 = mul i64 %hash_coef.i.i61, 4189192806087951739
  %shifted.i.i.i65 = lshr i64 %product.i.i.i64, 32
  %xored.i.i.i66 = xor i64 %shifted.i.i.i65, %product.i.i.i64
  %hash.i.i.i67 = and i64 %xored.i.i.i66, %tbl_size.i.i62
  %offset_ptr.i.i68 = getelementptr i32, ptr %offset_tbl.i.i63, i64 %hash.i.i.i67
  %offset.i.i83 = load i32, ptr %offset_ptr.i.i68, align 4, !noalias !512
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract45) #34
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract45, i64 %8
  %10 = getelementptr i8, ptr %9, i64 24
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr i8, ptr %11, i64 8
  %13 = load ptr, ptr %12, align 8
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract33, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.1.extract35, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.2.extract37, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %offset.i.i83, 3
  tail call void %13(ptr %.fca.1.extract47, { ptr, ptr, ptr, i32 } %17) #35
  %.fca.0.extract21 = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract23 = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract25 = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i86 = getelementptr i8, ptr %.fca.0.extract21, i64 8
  %tbl_size_ptr.i.i87 = getelementptr i8, ptr %.fca.0.extract21, i64 16
  %offset_tbl_ptr.i.i88 = getelementptr i8, ptr %.fca.0.extract21, i64 40
  %hash_coef.i.i89 = load i64, ptr %hash_coef_ptr.i.i86, align 4, !noalias !373
  %tbl_size.i.i90 = load i64, ptr %tbl_size_ptr.i.i87, align 4, !noalias !373
  %offset_tbl.i.i91 = load ptr, ptr %offset_tbl_ptr.i.i88, align 8, !noalias !373
  %product.i.i.i92 = mul i64 %hash_coef.i.i89, 5693646204635713916
  %shifted.i.i.i93 = lshr i64 %product.i.i.i92, 32
  %xored.i.i.i94 = xor i64 %shifted.i.i.i93, %product.i.i.i92
  %hash.i.i.i95 = and i64 %xored.i.i.i94, %tbl_size.i.i90
  %offset_ptr.i.i96 = getelementptr i32, ptr %offset_tbl.i.i91, i64 %hash.i.i.i95
  %offset.i.i111 = load i32, ptr %offset_ptr.i.i96, align 4, !noalias !515
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract45) #34
  %19 = getelementptr i8, ptr %9, i64 40
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract21, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract23, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract25, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %offset.i.i111, 3
  tail call void %22(ptr %.fca.1.extract47, { ptr, ptr, ptr, i32 } %26) #35
  %27 = tail call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract45) #34
  %28 = load ptr, ptr %19, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = tail call { ptr, ptr, ptr, i32 } %29(ptr %.fca.1.extract47) #36
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %30, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %30, 1
  %.fca.2.extract17 = extractvalue { ptr, ptr, ptr, i32 } %30, 2
  %.fca.3.extract19 = extractvalue { ptr, ptr, ptr, i32 } %30, 3
  %31 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract13, 0
  %32 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %.fca.1.extract15, 1
  %33 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %.fca.2.extract17, 2
  %34 = insertvalue { ptr, ptr, ptr, i32 } %33, i32 %.fca.3.extract19, 3
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6) #34
  %36 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract13) #34
  %37 = sext i32 %.fca.3.extract19 to i64
  %38 = getelementptr ptr, ptr %.fca.0.extract13, i64 %37
  %39 = getelementptr i8, ptr %38, i64 8
  %40 = load ptr, ptr %39, align 8
  %result.i = call ptr %40({ ptr, ptr, ptr, i32 } %34, ptr nocapture nofree noundef nonnull readonly %6) #16
  %41 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %34, { ptr, ptr, ptr, i32 } %34, ptr nonnull align 8 %6) #7
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %41, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %41, 1
  %.fca.2.extract7 = extractvalue { ptr, ptr, ptr, i32 } %41, 2
  %hash_coef_ptr.i.i114 = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i115 = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i116 = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i117 = load i64, ptr %hash_coef_ptr.i.i114, align 4, !noalias !373
  %tbl_size.i.i118 = load i64, ptr %tbl_size_ptr.i.i115, align 4, !noalias !373
  %offset_tbl.i.i119 = load ptr, ptr %offset_tbl_ptr.i.i116, align 8, !noalias !373
  %product.i.i.i120 = mul i64 %hash_coef.i.i117, 4189192806087951739
  %shifted.i.i.i121 = lshr i64 %product.i.i.i120, 32
  %xored.i.i.i122 = xor i64 %shifted.i.i.i121, %product.i.i.i120
  %hash.i.i.i123 = and i64 %xored.i.i.i122, %tbl_size.i.i118
  %offset_ptr.i.i124 = getelementptr i32, ptr %offset_tbl.i.i119, i64 %hash.i.i.i123
  %offset.i.i139 = load i32, ptr %offset_ptr.i.i124, align 4, !noalias !518
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract45)
  %43 = getelementptr i8, ptr %9, i64 32
  %44 = load ptr, ptr %43, align 8
  %45 = getelementptr i8, ptr %44, i64 8
  %46 = load ptr, ptr %45, align 8
  %47 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract3, 0
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.1.extract5, 1
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %.fca.2.extract7, 2
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, i32 %offset.i.i139, 3
  call void %46(ptr %.fca.1.extract47, { ptr, ptr, ptr, i32 } %50) #35
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract45)
  %52 = load ptr, ptr %10, align 8
  %53 = load ptr, ptr %52, align 8
  %54 = call { ptr, ptr, ptr, i32 } %53(ptr %.fca.1.extract47) #36
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %54, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %54, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %54, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %54, 3
  %55 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %56 = insertvalue { ptr, ptr, ptr, i32 } %55, ptr %.fca.1.extract2, 1
  %57 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %.fca.2.extract, 2
  %58 = insertvalue { ptr, ptr, ptr, i32 } %57, i32 %.fca.3.extract, 3
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %6)
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract1)
  %61 = sext i32 %.fca.3.extract to i64
  %62 = getelementptr ptr, ptr %.fca.0.extract1, i64 %61
  %63 = getelementptr i8, ptr %62, i64 8
  %64 = load ptr, ptr %63, align 8
  %result.i141 = call ptr %64({ ptr, ptr, ptr, i32 } %58, ptr nocapture nofree noundef nonnull readonly %6) #16
  %65 = call { ptr, i160 } %result.i141({ ptr, ptr, ptr, i32 } %58, { ptr, ptr, ptr, i32 } %58, ptr nonnull align 8 %6) #7
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract45)
  %67 = getelementptr i8, ptr %9, i64 48
  %68 = load ptr, ptr %67, align 8
  %69 = getelementptr i8, ptr %68, i64 8
  %70 = load ptr, ptr %69, align 8
  call void %70(ptr %.fca.1.extract47, { ptr, i160 } %65) #35
  ret void
}

define { ptr, i160 } @ProductIterator2_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 4440657219728359865
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef %.fca.0.extract10) #38
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract10, i64 %6
  %8 = getelementptr i8, ptr %7, i64 48
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, i160 } %10(ptr %.fca.1.extract12) #36
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %.sroa.0.0188 = extractvalue { ptr, i160 } %11, 0
  %13 = icmp ne ptr %.sroa.0.0188, @nil_typ
  %14 = icmp ne ptr %.sroa.0.0188, null
  %.not82189 = and i1 %13, %14
  br i1 %.not82189, label %.lr.ph, label %.loopexit

.lr.ph:                                           ; preds = %3
  %15 = tail call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %16 = getelementptr i8, ptr %7, i64 32
  %17 = getelementptr i8, ptr %7, i64 24
  %18 = getelementptr i8, ptr %7, i64 40
  br label %19

19:                                               ; preds = %.lr.ph, %37
  %.pn190 = phi { ptr, i160 } [ %11, %.lr.ph ], [ %83, %37 ]
  %20 = load ptr, ptr %16, align 8
  %21 = load ptr, ptr %20, align 8
  %22 = call { ptr, ptr, ptr, i32 } %21(ptr %.fca.1.extract12) #36
  %.fca.0.extract68 = extractvalue { ptr, ptr, ptr, i32 } %22, 0
  %.fca.1.extract70 = extractvalue { ptr, ptr, ptr, i32 } %22, 1
  %.fca.2.extract72 = extractvalue { ptr, ptr, ptr, i32 } %22, 2
  %.fca.3.extract74 = extractvalue { ptr, ptr, ptr, i32 } %22, 3
  %23 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract68, 0
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.1.extract70, 1
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, ptr %.fca.2.extract72, 2
  %26 = insertvalue { ptr, ptr, ptr, i32 } %25, i32 %.fca.3.extract74, 3
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract68)
  %29 = sext i32 %.fca.3.extract74 to i64
  %30 = getelementptr ptr, ptr %.fca.0.extract68, i64 %29
  %31 = getelementptr i8, ptr %30, i64 8
  %32 = load ptr, ptr %31, align 8
  %result.i = call ptr %32({ ptr, ptr, ptr, i32 } %26, ptr nocapture nofree noundef nonnull readonly %4) #16
  %33 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr nonnull align 8 %4) #7
  %.fca.0.extract61 = extractvalue { ptr, i160 } %33, 0
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %35 = icmp ne ptr %.fca.0.extract61, @nil_typ
  %36 = icmp ne ptr %.fca.0.extract61, null
  %.not84 = and i1 %35, %36
  br i1 %.not84, label %86, label %37

37:                                               ; preds = %19
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %39 = load ptr, ptr %17, align 8
  %40 = load ptr, ptr %39, align 8
  %41 = call { ptr, ptr, ptr, i32 } %40(ptr nonnull %.fca.1.extract12) #36
  %.fca.0.extract42 = extractvalue { ptr, ptr, ptr, i32 } %41, 0
  %.fca.1.extract44 = extractvalue { ptr, ptr, ptr, i32 } %41, 1
  %.fca.2.extract46 = extractvalue { ptr, ptr, ptr, i32 } %41, 2
  %.fca.3.extract48 = extractvalue { ptr, ptr, ptr, i32 } %41, 3
  %42 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract42, 0
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %.fca.1.extract44, 1
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, ptr %.fca.2.extract46, 2
  %45 = insertvalue { ptr, ptr, ptr, i32 } %44, i32 %.fca.3.extract48, 3
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %47 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract42)
  %48 = sext i32 %.fca.3.extract48 to i64
  %49 = getelementptr ptr, ptr %.fca.0.extract42, i64 %48
  %50 = getelementptr i8, ptr %49, i64 8
  %51 = load ptr, ptr %50, align 8
  %result.i86 = call ptr %51({ ptr, ptr, ptr, i32 } %45, ptr nocapture nofree noundef nonnull readonly %4) #16
  %52 = call { ptr, i160 } %result.i86({ ptr, ptr, ptr, i32 } %45, { ptr, ptr, ptr, i32 } %45, ptr nonnull align 8 %4) #7
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %54 = load ptr, ptr %8, align 8
  %55 = getelementptr i8, ptr %54, i64 8
  %56 = load ptr, ptr %55, align 8
  call void %56(ptr %.fca.1.extract12, { ptr, i160 } %52) #35
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %58 = load ptr, ptr %18, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr %.fca.1.extract12) #36
  %.fca.0.extract30 = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract32 = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract34 = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %.fca.3.extract35 = extractvalue { ptr, ptr, ptr, i32 } %60, 3
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract30, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract32, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract34, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %.fca.3.extract35, 3
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract30)
  %67 = sext i32 %.fca.3.extract35 to i64
  %68 = getelementptr ptr, ptr %.fca.0.extract30, i64 %67
  %69 = getelementptr i8, ptr %68, i64 8
  %70 = load ptr, ptr %69, align 8
  %result.i87 = call ptr %70({ ptr, ptr, ptr, i32 } %64, ptr nocapture nofree noundef nonnull readonly %4) #16
  %71 = call { ptr, ptr, ptr, i32 } %result.i87({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull align 8 %4) #7
  %.fca.0.extract20 = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract22 = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract24 = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %hash_coef_ptr.i.i89 = getelementptr i8, ptr %.fca.0.extract20, i64 8
  %tbl_size_ptr.i.i90 = getelementptr i8, ptr %.fca.0.extract20, i64 16
  %offset_tbl_ptr.i.i91 = getelementptr i8, ptr %.fca.0.extract20, i64 40
  %hash_coef.i.i92 = load i64, ptr %hash_coef_ptr.i.i89, align 4
  %tbl_size.i.i93 = load i64, ptr %tbl_size_ptr.i.i90, align 4
  %offset_tbl.i.i94 = load ptr, ptr %offset_tbl_ptr.i.i91, align 8
  %product.i.i.i95 = mul i64 %hash_coef.i.i92, 4189192806087951739
  %shifted.i.i.i96 = lshr i64 %product.i.i.i95, 32
  %xored.i.i.i97 = xor i64 %shifted.i.i.i96, %product.i.i.i95
  %hash.i.i.i98 = and i64 %xored.i.i.i97, %tbl_size.i.i93
  %offset_ptr.i.i99 = getelementptr i32, ptr %offset_tbl.i.i94, i64 %hash.i.i.i98
  %offset.i.i114 = load i32, ptr %offset_ptr.i.i99, align 4
  %72 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %73 = load ptr, ptr %16, align 8
  %74 = getelementptr i8, ptr %73, i64 8
  %75 = load ptr, ptr %74, align 8
  %76 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract20, 0
  %77 = insertvalue { ptr, ptr, ptr, i32 } %76, ptr %.fca.1.extract22, 1
  %78 = insertvalue { ptr, ptr, ptr, i32 } %77, ptr %.fca.2.extract24, 2
  %79 = insertvalue { ptr, ptr, ptr, i32 } %78, i32 %offset.i.i114, 3
  call void %75(ptr %.fca.1.extract12, { ptr, ptr, ptr, i32 } %79) #35
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %81 = load ptr, ptr %8, align 8
  %82 = load ptr, ptr %81, align 8
  %83 = call { ptr, i160 } %82(ptr %.fca.1.extract12) #36
  %.sroa.0.0 = extractvalue { ptr, i160 } %83, 0
  %84 = icmp ne ptr %.sroa.0.0, @nil_typ
  %85 = icmp ne ptr %.sroa.0.0, null
  %.not82 = and i1 %84, %85
  br i1 %.not82, label %19, label %.loopexit

86:                                               ; preds = %19
  %87 = getelementptr i8, ptr %7, i64 8
  %88 = load ptr, ptr %87, align 8
  %result.i85 = call ptr %88(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract12) #5
  %89 = call ptr @llvm.invariant.start.p0(i64 noundef 112, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %90 = load ptr, ptr %7, align 8
  %result.i116 = call ptr %90(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract12) #5
  %91 = load ptr, ptr %result.i116, align 8
  %92 = getelementptr i8, ptr %91, i64 72
  %93 = load ptr, ptr %92, align 8
  %result.i.i = call { i64, i64 } %93(ptr nocapture nofree nonnull readonly %result.i116) #5
  %94 = extractvalue { i64, i64 } %result.i.i, 0
  %95 = extractvalue { i64, i64 } %result.i.i, 1
  %96 = urem i64 16, %95
  %97 = icmp eq i64 %96, 0
  %98 = sub i64 %95, %96
  %99 = select i1 %97, i64 0, i64 %98
  %100 = add i64 %94, 16
  %101 = add i64 %100, %99
  %102 = load ptr, ptr %result.i85, align 8
  %103 = getelementptr i8, ptr %102, i64 72
  %104 = load ptr, ptr %103, align 8
  %result.i1.i = call { i64, i64 } %104(ptr nocapture nofree nonnull readonly %result.i85) #5
  %105 = extractvalue { i64, i64 } %result.i1.i, 0
  %106 = extractvalue { i64, i64 } %result.i1.i, 1
  %107 = call i64 @llvm.umax.i64(i64 %95, i64 %106)
  %108 = call i64 @llvm.umax.i64(i64 %107, i64 8)
  %109 = urem i64 %101, %106
  %110 = icmp eq i64 %109, 0
  %111 = sub i64 %106, %109
  %112 = select i1 %110, i64 0, i64 %111
  %113 = add i64 %105, %101
  %114 = add i64 %113, %112
  %115 = urem i64 %114, %108
  %116 = icmp eq i64 %115, 0
  %117 = sub i64 %108, %115
  %118 = select i1 %116, i64 0, i64 %117
  %119 = add i64 %118, %114
  %result.i118 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %119, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i116, ptr %result.i118, align 8
  %120 = getelementptr inbounds i8, ptr %result.i118, i64 8
  store ptr %result.i85, ptr %120, align 8
  %121 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i118)
  %122 = load ptr, ptr %result.i116, align 8
  %123 = getelementptr i8, ptr %122, i64 72
  %124 = load ptr, ptr %123, align 8
  %result.i.i201 = call { i64, i64 } %124(ptr nocapture nofree nonnull readonly %result.i116) #5
  %125 = extractvalue { i64, i64 } %result.i.i201, 1
  %126 = urem i64 16, %125
  %127 = icmp eq i64 %126, 0
  %reass.sub = sub i64 %125, %126
  %128 = add i64 %reass.sub, 16
  %129 = select i1 %127, i64 16, i64 %128
  %130 = getelementptr i8, ptr %result.i118, i64 %129
  %131 = getelementptr i8, ptr %122, i64 64
  %132 = load ptr, ptr %131, align 8
  call void %132({ ptr, i160 } %.pn190, ptr nocapture nofree nonnull readonly %result.i116, ptr nocapture nofree writeonly %130) #13
  %133 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @Pair) #34
  %134 = load ptr, ptr %result.i118, align 8
  %135 = load ptr, ptr %134, align 8
  %136 = getelementptr i8, ptr %135, i64 72
  %137 = load ptr, ptr %136, align 8
  %result.i.i202 = call { i64, i64 } %137(ptr nocapture nofree nonnull readonly %134) #5
  %138 = extractvalue { i64, i64 } %result.i.i202, 0
  %139 = extractvalue { i64, i64 } %result.i.i202, 1
  %140 = urem i64 16, %139
  %141 = icmp eq i64 %140, 0
  %142 = sub i64 %139, %140
  %143 = select i1 %141, i64 0, i64 %142
  %144 = add i64 %138, 16
  %145 = add i64 %144, %143
  %146 = load ptr, ptr %120, align 8
  %147 = load ptr, ptr %146, align 8
  %148 = getelementptr i8, ptr %147, i64 72
  %149 = load ptr, ptr %148, align 8
  %result.i1.i203 = call { i64, i64 } %149(ptr nocapture nofree nonnull readonly %146) #5
  %150 = extractvalue { i64, i64 } %result.i1.i203, 1
  %151 = urem i64 %145, %150
  %152 = icmp eq i64 %151, 0
  %153 = sub i64 %150, %151
  %154 = select i1 %152, i64 0, i64 %153
  %155 = getelementptr i8, ptr %result.i118, i64 %145
  %156 = getelementptr i8, ptr %155, i64 %154
  %157 = getelementptr i8, ptr %147, i64 64
  %158 = load ptr, ptr %157, align 8
  call void %158({ ptr, i160 } %33, ptr nocapture nofree nonnull readonly %146, ptr nocapture nofree writeonly %156) #13
  %159 = ptrtoint ptr %result.i118 to i64
  %.sroa.3.8.insert.ext = zext i64 %159 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  br label %.loopexit

.loopexit:                                        ; preds = %37, %3, %86
  %.reg2mem49.sroa.3.0 = phi i160 [ %.sroa.3.8.insert.insert, %86 ], [ undef, %3 ], [ undef, %37 ]
  %.reg2mem49.sroa.0.0 = phi ptr [ @Pair, %86 ], [ @nil_typ, %3 ], [ @nil_typ, %37 ]
  %.reload50.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem49.sroa.0.0, 0
  %.reload50.fca.1.insert = insertvalue { ptr, i160 } %.reload50.fca.0.insert, i160 %.reg2mem49.sroa.3.0, 1
  ret { ptr, i160 } %.reload50.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @ProductIterator2_getter_current_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 120
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, i160 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 128
  %6 = load i160, ptr %5, align 4
  %7 = insertvalue { ptr, i160 } %4, i160 %6, 1
  ret { ptr, i160 } %7
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator2_setter_current_first(ptr nocapture nofree writeonly %0, { ptr, i160 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 120
  %.fca.0.extract = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 128
  store i160 %.fca.1.extract, ptr %4, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterator2_getter_second_iterable(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 88
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 96
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 104
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 112
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator2_setter_second_iterable(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 88
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 96
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 104
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 112
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterator2_getter_second_iterator(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator2_setter_second_iterator(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterator2_getter_first_iterator(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterator2_setter_first_iterator(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterable2_getter_second(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterable2_setter_second(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ProductIterable2_getter_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ProductIterable2_setter_first(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ZipIterable2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterable2_field_ZipIterable2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterable2_field_ZipIterable2_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterable2_field_ZipIterable2_2(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_init_firstIterable2T_secondIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterable2_B_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ZipIterable2_init_firstIterable2T_secondIterable2U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #2 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !521
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !521
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !521
  %product.i.i.i = mul i64 %hash_coef.i.i, -3218950579047519815
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !521
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4, !noalias !373
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4, !noalias !373
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8, !noalias !373
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 5693646204635713916
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4, !noalias !524
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #35
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4, !noalias !373
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4, !noalias !373
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8, !noalias !373
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 5693646204635713916
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4, !noalias !527
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %18 = getelementptr i8, ptr %8, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #35
  ret void
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @ZipIterable2_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract71 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract73 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !530
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !530
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !530
  %product.i.i.i = mul i64 %hash_coef.i.i, -3218950579047519815
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !530
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract71) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract71, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract73) #36
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract67 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract69 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract63, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract65, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract67, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract69, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #40
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract63) #40
  %18 = sext i32 %.fca.3.extract69 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract63, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #16
  %22 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract71)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract73) #36
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract45, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract47, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract49, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract43)
  %34 = sext i32 %.fca.3.extract49 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract43, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i97 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly %4) #16
  %38 = call { ptr, ptr, ptr, i32 } %result.i97({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4) #7
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract71)
  %40 = load ptr, ptr %7, align 8
  %result.i112 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract73) #5
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract71)
  %42 = getelementptr i8, ptr %7, i64 8
  %43 = load ptr, ptr %42, align 8
  %result.i113 = call ptr %43(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract73) #5
  %result.i114 = call noalias nonnull align 8 dereferenceable(32) ptr @bump_malloc_inner(i64 noundef 32, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %44 = getelementptr inbounds i8, ptr %result.i114, i64 16
  store ptr %result.i113, ptr %44, align 8
  %45 = getelementptr inbounds i8, ptr %result.i114, i64 8
  store ptr %result.i112, ptr %45, align 8
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(32) %result.i114)
  store ptr @Pair, ptr %result.i114, align 8
  %result.i116 = call noalias nonnull align 8 dereferenceable(88) ptr @bump_malloc_inner(i64 noundef 88, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i112, ptr %result.i116, align 8
  %47 = getelementptr inbounds i8, ptr %result.i116, i64 8
  store ptr %result.i113, ptr %47, align 8
  %48 = getelementptr inbounds i8, ptr %result.i116, i64 16
  store ptr %result.i114, ptr %48, align 8
  %49 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %result.i116)
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract71)
  %51 = load ptr, ptr %8, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = call { ptr, ptr, ptr, i32 } %52(ptr %.fca.1.extract73) #36
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %53, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %53, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %53, 2
  %.fca.3.extract23 = extractvalue { ptr, ptr, ptr, i32 } %53, 3
  %54 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract17, 0
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %.fca.1.extract19, 1
  %56 = insertvalue { ptr, ptr, ptr, i32 } %55, ptr %.fca.2.extract21, 2
  %57 = insertvalue { ptr, ptr, ptr, i32 } %56, i32 %.fca.3.extract23, 3
  %58 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %59 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract17)
  %60 = sext i32 %.fca.3.extract23 to i64
  %61 = getelementptr ptr, ptr %.fca.0.extract17, i64 %60
  %62 = getelementptr i8, ptr %61, i64 8
  %63 = load ptr, ptr %62, align 8
  %result.i117 = call ptr %63({ ptr, ptr, ptr, i32 } %57, ptr nocapture nofree noundef nonnull readonly %4) #16
  %64 = call { ptr, ptr, ptr, i32 } %result.i117({ ptr, ptr, ptr, i32 } %57, { ptr, ptr, ptr, i32 } %57, ptr nonnull align 8 %4) #7
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %64, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %64, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %64, 2
  %hash_coef_ptr.i.i119 = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i120 = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i121 = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 416, ptr nocapture nofree noundef %.fca.0.extract71)
  %66 = load ptr, ptr %24, align 8
  %67 = load ptr, ptr %66, align 8
  %68 = call { ptr, ptr, ptr, i32 } %67(ptr %.fca.1.extract73) #36
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %68, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %68, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %68, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %68, 3
  %69 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %70 = insertvalue { ptr, ptr, ptr, i32 } %69, ptr %.fca.1.extract2, 1
  %71 = insertvalue { ptr, ptr, ptr, i32 } %70, ptr %.fca.2.extract3, 2
  %72 = insertvalue { ptr, ptr, ptr, i32 } %71, i32 %.fca.3.extract4, 3
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract1)
  %75 = sext i32 %.fca.3.extract4 to i64
  %76 = getelementptr ptr, ptr %.fca.0.extract1, i64 %75
  %77 = getelementptr i8, ptr %76, i64 8
  %78 = load ptr, ptr %77, align 8
  %result.i132 = call ptr %78({ ptr, ptr, ptr, i32 } %72, ptr nocapture nofree noundef nonnull readonly %4) #16
  %79 = call { ptr, ptr, ptr, i32 } %result.i132({ ptr, ptr, ptr, i32 } %72, { ptr, ptr, ptr, i32 } %72, ptr nonnull align 8 %4) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %79, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %79, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %79, 2
  %hash_coef_ptr.i.i134 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i135 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i136 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i151 = load i64, ptr %hash_coef_ptr.i.i119, align 4, !noalias !373
  %tbl_size.i.i152 = load i64, ptr %tbl_size_ptr.i.i120, align 4, !noalias !373
  %offset_tbl.i.i153 = load ptr, ptr %offset_tbl_ptr.i.i121, align 8, !noalias !373
  %product.i.i.i154 = mul i64 %hash_coef.i.i151, 4189192806087951739
  %shifted.i.i.i155 = lshr i64 %product.i.i.i154, 32
  %xored.i.i.i156 = xor i64 %shifted.i.i.i155, %product.i.i.i154
  %hash.i.i.i157 = and i64 %xored.i.i.i156, %tbl_size.i.i152
  %offset_ptr.i.i158 = getelementptr i32, ptr %offset_tbl.i.i153, i64 %hash.i.i.i157
  %offset.i.i159 = load i32, ptr %offset_ptr.i.i158, align 4, !noalias !373
  %80 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ZipIterator2, ptr undef, ptr undef, i32 undef }, ptr %result.i116, 1
  %81 = insertvalue { ptr, ptr, ptr, i32 } %80, ptr undef, 2
  %82 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull @ZipIterator2) #34
  %83 = getelementptr inbounds i8, ptr %result.i116, i64 24
  store ptr %.fca.0.extract5, ptr %83, align 8
  %84 = getelementptr inbounds i8, ptr %result.i116, i64 32
  store ptr %.fca.1.extract7, ptr %84, align 8
  %85 = getelementptr inbounds i8, ptr %result.i116, i64 40
  store ptr %.fca.2.extract9, ptr %85, align 8
  %86 = getelementptr inbounds i8, ptr %result.i116, i64 48
  store i32 %offset.i.i159, ptr %86, align 8
  %hash_coef.i.i49.i = load i64, ptr %hash_coef_ptr.i.i134, align 4, !noalias !373
  %tbl_size.i.i50.i = load i64, ptr %tbl_size_ptr.i.i135, align 4, !noalias !373
  %offset_tbl.i.i51.i = load ptr, ptr %offset_tbl_ptr.i.i136, align 8, !noalias !373
  %product.i.i.i52.i = mul i64 %hash_coef.i.i49.i, 4189192806087951739
  %shifted.i.i.i53.i = lshr i64 %product.i.i.i52.i, 32
  %xored.i.i.i54.i = xor i64 %shifted.i.i.i53.i, %product.i.i.i52.i
  %hash.i.i.i55.i = and i64 %xored.i.i.i54.i, %tbl_size.i.i50.i
  %offset_ptr.i.i56.i = getelementptr i32, ptr %offset_tbl.i.i51.i, i64 %hash.i.i.i55.i
  %offset.i.i71.i = load i32, ptr %offset_ptr.i.i56.i, align 4, !noalias !533
  %87 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull @ZipIterator2) #34
  %88 = getelementptr inbounds i8, ptr %result.i116, i64 56
  store ptr %.fca.0.extract, ptr %88, align 8
  %89 = getelementptr inbounds i8, ptr %result.i116, i64 64
  store ptr %.fca.1.extract, ptr %89, align 8
  %90 = getelementptr inbounds i8, ptr %result.i116, i64 72
  store ptr %.fca.2.extract, ptr %90, align 8
  %91 = getelementptr inbounds i8, ptr %result.i116, i64 80
  store i32 %offset.i.i71.i, ptr %91, align 8
  %92 = insertvalue { ptr, ptr, ptr, i32 } %81, i32 19, 3
  ret { ptr, ptr, ptr, i32 } %92
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ZipIterator2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 88, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterator2_field_ZipIterator2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterator2_field_ZipIterator2_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ZipIterator2_field_ZipIterator2_2(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterator2_B_init_firstIterator2T_secondIterator2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ZipIterator2_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 144
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ZipIterator2_init_firstIterator2T_secondIterator2U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #2 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !536
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !536
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !536
  %product.i.i.i = mul i64 %hash_coef.i.i, 5502728639611621286
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !536
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4, !noalias !373
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4, !noalias !373
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8, !noalias !373
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 4189192806087951739
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4, !noalias !539
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 24
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #35
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4, !noalias !373
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4, !noalias !373
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8, !noalias !373
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 4189192806087951739
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4, !noalias !542
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %18 = getelementptr i8, ptr %8, i64 32
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #35
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @ZipIterator2_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract28, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract28, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract28, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !545
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !545
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !545
  %product.i.i.i = mul i64 %hash_coef.i.i, 5502728639611621286
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !545
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %.fca.0.extract28) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract28, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract30) #36
  %.fca.0.extract8 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract12 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract14 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract8, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract10, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract12, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract14, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #40
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract8) #40
  %18 = sext i32 %.fca.3.extract14 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract8, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #16
  %22 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %.fca.0.extract4 = extractvalue { ptr, i160 } %22, 0
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %.fca.0.extract28)
  %24 = getelementptr i8, ptr %7, i64 32
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract30) #36
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract3, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract2)
  %34 = sext i32 %.fca.3.extract to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract2, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i60 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly %4) #16
  %38 = call { ptr, i160 } %result.i60({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4) #7
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef %.fca.0.extract28)
  %40 = load ptr, ptr %7, align 8
  %result.i61 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract30) #5
  %41 = icmp ne ptr %.fca.0.extract4, @nil_typ
  %42 = icmp ne ptr %.fca.0.extract4, null
  %.not55 = and i1 %41, %42
  br i1 %.not55, label %43, label %.thread

43:                                               ; preds = %3
  %.fca.0.extract = extractvalue { ptr, i160 } %38, 0
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 96, ptr nocapture nofree noundef nonnull %.fca.0.extract28)
  %45 = icmp ne ptr %.fca.0.extract, @nil_typ
  %46 = icmp ne ptr %.fca.0.extract, null
  %.not57.not.not = and i1 %45, %46
  br i1 %.not57.not.not, label %47, label %.thread

47:                                               ; preds = %43
  %48 = getelementptr i8, ptr %7, i64 8
  %49 = load ptr, ptr %48, align 8
  %result.i62 = call ptr %49(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract30) #5
  %50 = load ptr, ptr %result.i61, align 8, !alias.scope !548
  %51 = getelementptr i8, ptr %50, i64 72
  %52 = load ptr, ptr %51, align 8, !alias.scope !548
  %result.i.i = call { i64, i64 } %52(ptr nocapture nofree nonnull readonly %result.i61) #5, !alias.scope !548
  %53 = extractvalue { i64, i64 } %result.i.i, 0
  %54 = extractvalue { i64, i64 } %result.i.i, 1
  %55 = urem i64 16, %54
  %56 = icmp eq i64 %55, 0
  %57 = sub i64 %54, %55
  %58 = select i1 %56, i64 0, i64 %57
  %59 = add i64 %53, 16
  %60 = add i64 %59, %58
  %61 = load ptr, ptr %result.i62, align 8, !alias.scope !548
  %62 = getelementptr i8, ptr %61, i64 72
  %63 = load ptr, ptr %62, align 8, !alias.scope !548
  %result.i1.i = call { i64, i64 } %63(ptr nocapture nofree nonnull readonly %result.i62) #5, !alias.scope !548
  %64 = extractvalue { i64, i64 } %result.i1.i, 0
  %65 = extractvalue { i64, i64 } %result.i1.i, 1
  %66 = call i64 @llvm.umax.i64(i64 %54, i64 %65)
  %67 = call i64 @llvm.umax.i64(i64 %66, i64 8)
  %68 = urem i64 %60, %65
  %69 = icmp eq i64 %68, 0
  %70 = sub i64 %65, %68
  %71 = select i1 %69, i64 0, i64 %70
  %72 = add i64 %64, %60
  %73 = add i64 %72, %71
  %74 = urem i64 %73, %67
  %75 = icmp eq i64 %74, 0
  %76 = sub i64 %67, %74
  %77 = select i1 %75, i64 0, i64 %76
  %78 = add i64 %77, %73
  %result.i64 = call noalias nonnull align 8 dereferenceable(16) ptr @bump_malloc_inner(i64 noundef %78, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i61, ptr %result.i64, align 8
  %79 = getelementptr inbounds i8, ptr %result.i64, i64 8
  store ptr %result.i62, ptr %79, align 8
  %80 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i64)
  %81 = load ptr, ptr %result.i61, align 8
  %82 = getelementptr i8, ptr %81, i64 72
  %83 = load ptr, ptr %82, align 8
  %result.i.i83 = call { i64, i64 } %83(ptr nocapture nofree nonnull readonly %result.i61) #5
  %84 = extractvalue { i64, i64 } %result.i.i83, 1
  %85 = urem i64 16, %84
  %86 = icmp eq i64 %85, 0
  %reass.sub = sub i64 %84, %85
  %87 = add i64 %reass.sub, 16
  %88 = select i1 %86, i64 16, i64 %87
  %89 = getelementptr i8, ptr %result.i64, i64 %88
  %90 = getelementptr i8, ptr %81, i64 64
  %91 = load ptr, ptr %90, align 8
  call void %91({ ptr, i160 } %22, ptr nocapture nofree nonnull readonly %result.i61, ptr nocapture nofree writeonly %89) #13
  %92 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @Pair) #34
  %93 = load ptr, ptr %result.i64, align 8
  %94 = load ptr, ptr %93, align 8
  %95 = getelementptr i8, ptr %94, i64 72
  %96 = load ptr, ptr %95, align 8
  %result.i.i84 = call { i64, i64 } %96(ptr nocapture nofree nonnull readonly %93) #5
  %97 = extractvalue { i64, i64 } %result.i.i84, 0
  %98 = extractvalue { i64, i64 } %result.i.i84, 1
  %99 = urem i64 16, %98
  %100 = icmp eq i64 %99, 0
  %101 = sub i64 %98, %99
  %102 = select i1 %100, i64 0, i64 %101
  %103 = add i64 %97, 16
  %104 = add i64 %103, %102
  %105 = load ptr, ptr %79, align 8
  %106 = load ptr, ptr %105, align 8
  %107 = getelementptr i8, ptr %106, i64 72
  %108 = load ptr, ptr %107, align 8
  %result.i1.i85 = call { i64, i64 } %108(ptr nocapture nofree nonnull readonly %105) #5
  %109 = extractvalue { i64, i64 } %result.i1.i85, 1
  %110 = urem i64 %104, %109
  %111 = icmp eq i64 %110, 0
  %112 = sub i64 %109, %110
  %113 = select i1 %111, i64 0, i64 %112
  %114 = getelementptr i8, ptr %result.i64, i64 %104
  %115 = getelementptr i8, ptr %114, i64 %113
  %116 = getelementptr i8, ptr %106, i64 64
  %117 = load ptr, ptr %116, align 8
  call void %117({ ptr, i160 } %38, ptr nocapture nofree nonnull readonly %105, ptr nocapture nofree writeonly %115) #13
  %118 = ptrtoint ptr %result.i64 to i64
  %.sroa.344.8.insert.ext = zext i64 %118 to i160
  %.sroa.344.8.insert.insert = or disjoint i160 %.sroa.344.8.insert.ext, 3402823669209384634633746074317682114560
  br label %.thread

.thread:                                          ; preds = %3, %43, %47
  %.reg2mem41.sroa.3.082 = phi i160 [ %.sroa.344.8.insert.insert, %47 ], [ poison, %43 ], [ poison, %3 ]
  %119 = phi ptr [ @Pair, %47 ], [ @nil_typ, %43 ], [ @nil_typ, %3 ]
  %.reload38.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %119, 0
  %.reload38.fca.1.insert = insertvalue { ptr, i160 } %.reload38.fca.0.insert, i160 %.reg2mem41.sroa.3.082, 1
  ret { ptr, i160 } %.reload38.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterator2_getter_second(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterator2_setter_second(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterator2_getter_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterator2_setter_first(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterable2_getter_second(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 56
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 64
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 72
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 80
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterable2_setter_second(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 56
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 64
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 72
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 80
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ZipIterable2_getter_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 24
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 32
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 40
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 48
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ZipIterable2_setter_first(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 24
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 40
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 48
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_InterleaveIterable2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 72, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @InterleaveIterable2_field_InterleaveIterable2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_init_firstIterable2T_secondIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 200
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterable2_B_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @InterleaveIterable2_init_firstIterable2T_secondIterable2T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #2 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !551
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !551
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !551
  %product.i.i.i = mul i64 %hash_coef.i.i, -6258231685215461775
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !551
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4, !noalias !373
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4, !noalias !373
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8, !noalias !373
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 5693646204635713916
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4, !noalias !554
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #35
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4, !noalias !373
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4, !noalias !373
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8, !noalias !373
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 5693646204635713916
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4, !noalias !557
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #35
  ret void
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @InterleaveIterable2_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract71 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract73 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !560
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !560
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !560
  %product.i.i.i = mul i64 %hash_coef.i.i, -6258231685215461775
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !560
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract71, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract73) #36
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract67 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract69 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract63, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract65, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract67, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract69, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #40
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract63) #40
  %18 = sext i32 %.fca.3.extract69 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract63, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #16
  %22 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract73) #36
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract45, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract47, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract49, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract43)
  %34 = sext i32 %.fca.3.extract49 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract43, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i97 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly %4) #16
  %38 = call { ptr, ptr, ptr, i32 } %result.i97({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4) #7
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %40 = load ptr, ptr %7, align 8
  %result.i112 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract73) #5
  %result.i114 = call noalias nonnull align 8 dereferenceable(80) ptr @bump_malloc_inner(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i112, ptr %result.i114, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %result.i114)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %43 = load ptr, ptr %8, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr %.fca.1.extract73) #36
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.3.extract23 = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract17, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.1.extract19, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.2.extract21, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %.fca.3.extract23, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract17)
  %52 = sext i32 %.fca.3.extract23 to i64
  %53 = getelementptr ptr, ptr %.fca.0.extract17, i64 %52
  %54 = getelementptr i8, ptr %53, i64 8
  %55 = load ptr, ptr %54, align 8
  %result.i115 = call ptr %55({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly %4) #16
  %56 = call { ptr, ptr, ptr, i32 } %result.i115({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %4) #7
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %hash_coef_ptr.i.i117 = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i118 = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i119 = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %58 = load ptr, ptr %24, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr %.fca.1.extract73) #36
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %60, 3
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract2, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract3, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %.fca.3.extract4, 3
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract1)
  %67 = sext i32 %.fca.3.extract4 to i64
  %68 = getelementptr ptr, ptr %.fca.0.extract1, i64 %67
  %69 = getelementptr i8, ptr %68, i64 8
  %70 = load ptr, ptr %69, align 8
  %result.i130 = call ptr %70({ ptr, ptr, ptr, i32 } %64, ptr nocapture nofree noundef nonnull readonly %4) #16
  %71 = call { ptr, ptr, ptr, i32 } %result.i130({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull align 8 %4) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %hash_coef_ptr.i.i132 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i133 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i134 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i149 = load i64, ptr %hash_coef_ptr.i.i117, align 4, !noalias !373
  %tbl_size.i.i150 = load i64, ptr %tbl_size_ptr.i.i118, align 4, !noalias !373
  %offset_tbl.i.i151 = load ptr, ptr %offset_tbl_ptr.i.i119, align 8, !noalias !373
  %product.i.i.i152 = mul i64 %hash_coef.i.i149, 4189192806087951739
  %shifted.i.i.i153 = lshr i64 %product.i.i.i152, 32
  %xored.i.i.i154 = xor i64 %shifted.i.i.i153, %product.i.i.i152
  %hash.i.i.i155 = and i64 %xored.i.i.i154, %tbl_size.i.i150
  %offset_ptr.i.i156 = getelementptr i32, ptr %offset_tbl.i.i151, i64 %hash.i.i.i155
  %offset.i.i157 = load i32, ptr %offset_ptr.i.i156, align 4, !noalias !373
  %72 = insertvalue { ptr, ptr, ptr, i32 } { ptr @InterleaveIterator2, ptr undef, ptr undef, i32 undef }, ptr %result.i114, 1
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr undef, 2
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull @InterleaveIterator2) #34
  %75 = getelementptr inbounds i8, ptr %result.i114, i64 8
  store ptr %.fca.0.extract5, ptr %75, align 8
  %76 = getelementptr inbounds i8, ptr %result.i114, i64 16
  store ptr %.fca.1.extract7, ptr %76, align 8
  %77 = getelementptr inbounds i8, ptr %result.i114, i64 24
  store ptr %.fca.2.extract9, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %result.i114, i64 32
  store i32 %offset.i.i157, ptr %78, align 8
  %hash_coef.i.i49.i = load i64, ptr %hash_coef_ptr.i.i132, align 4, !noalias !373
  %tbl_size.i.i50.i = load i64, ptr %tbl_size_ptr.i.i133, align 4, !noalias !373
  %offset_tbl.i.i51.i = load ptr, ptr %offset_tbl_ptr.i.i134, align 8, !noalias !373
  %product.i.i.i52.i = mul i64 %hash_coef.i.i49.i, 4189192806087951739
  %shifted.i.i.i53.i = lshr i64 %product.i.i.i52.i, 32
  %xored.i.i.i54.i = xor i64 %shifted.i.i.i53.i, %product.i.i.i52.i
  %hash.i.i.i55.i = and i64 %xored.i.i.i54.i, %tbl_size.i.i50.i
  %offset_ptr.i.i56.i = getelementptr i32, ptr %offset_tbl.i.i51.i, i64 %hash.i.i.i55.i
  %offset.i.i71.i = load i32, ptr %offset_ptr.i.i56.i, align 4, !noalias !563
  %79 = getelementptr inbounds i8, ptr %result.i114, i64 40
  store ptr %.fca.0.extract, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %result.i114, i64 48
  store ptr %.fca.1.extract, ptr %80, align 8
  %81 = getelementptr inbounds i8, ptr %result.i114, i64 56
  store ptr %.fca.2.extract, ptr %81, align 8
  %82 = getelementptr inbounds i8, ptr %result.i114, i64 64
  store i32 %offset.i.i71.i, ptr %82, align 8
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull @InterleaveIterator2) #34
  %84 = getelementptr inbounds i8, ptr %result.i114, i64 72
  store i1 true, ptr %84, align 8
  %85 = insertvalue { ptr, ptr, ptr, i32 } %73, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %85
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_InterleaveIterator2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 80, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @InterleaveIterator2_field_InterleaveIterator2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterator2_B_init_firstIterator2T_secondIterator2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @InterleaveIterator2_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @InterleaveIterator2_init_firstIterator2T_secondIterator2T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #2 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !566
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !566
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !566
  %product.i.i.i = mul i64 %hash_coef.i.i, 6709847746581360093
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !566
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4, !noalias !373
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4, !noalias !373
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8, !noalias !373
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 4189192806087951739
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4, !noalias !569
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #35
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4, !noalias !373
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4, !noalias !373
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8, !noalias !373
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 4189192806087951739
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4, !noalias !572
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #35
  %26 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %27 = getelementptr i8, ptr %8, i64 24
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  tail call void %30(ptr %.fca.1.extract10, i1 true) #35
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @InterleaveIterator2_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract3, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !575
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !575
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !575
  %product.i.i.i = mul i64 %hash_coef.i.i, 6709847746581360093
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !575
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract3) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract3, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call i1 %10(ptr %.fca.1.extract4) #36
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull %.fca.0.extract3) #40
  %13 = getelementptr i8, ptr %9, i64 8
  %14 = load ptr, ptr %13, align 8
  %not. = xor i1 %11, true
  %.62 = select i1 %11, i64 8, i64 16
  tail call void %14(ptr %.fca.1.extract4, i1 %not.) #35
  %15 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull %.fca.0.extract3) #40
  %16 = getelementptr i8, ptr %7, i64 %.62
  %17 = load ptr, ptr %16, align 8
  %18 = load ptr, ptr %17, align 8
  %19 = tail call { ptr, ptr, ptr, i32 } %18(ptr %.fca.1.extract4) #36
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %19, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %19, 1
  %.fca.2.extract11 = extractvalue { ptr, ptr, ptr, i32 } %19, 2
  %.fca.3.extract12 = extractvalue { ptr, ptr, ptr, i32 } %19, 3
  %20 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract9, 0
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.1.extract10, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr %.fca.2.extract11, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %.fca.3.extract12, 3
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #40
  %25 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract9) #40
  %26 = sext i32 %.fca.3.extract12 to i64
  %27 = getelementptr ptr, ptr %.fca.0.extract9, i64 %26
  %28 = getelementptr i8, ptr %27, i64 8
  %29 = load ptr, ptr %28, align 8
  %result.i30 = call ptr %29({ ptr, ptr, ptr, i32 } %23, ptr nocapture nofree noundef nonnull readonly %4) #16
  %30 = call { ptr, i160 } %result.i30({ ptr, ptr, ptr, i32 } %23, { ptr, ptr, ptr, i32 } %23, ptr nonnull align 8 %4) #7
  ret { ptr, i160 } %30
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i1 @InterleaveIterator2_getter_on_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load i1, ptr %2, align 1
  ret i1 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterator2_setter_on_first(ptr nocapture nofree writeonly %0, i1 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 72
  store i1 %1, ptr %3, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterator2_getter_second(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterator2_setter_second(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterator2_getter_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterator2_setter_first(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterable2_getter_second(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterable2_setter_second(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @InterleaveIterable2_getter_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @InterleaveIterable2_setter_first(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ChainIterable2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 72, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ChainIterable2_field_ChainIterable2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_init_firstIterable2T_secondIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 200
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterable2_B_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ChainIterable2_init_firstIterable2T_secondIterable2T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #2 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !578
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !578
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !578
  %product.i.i.i = mul i64 %hash_coef.i.i, -5233298072945030060
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !578
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4, !noalias !373
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4, !noalias !373
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8, !noalias !373
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 5693646204635713916
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4, !noalias !581
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #35
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4, !noalias !373
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4, !noalias !373
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8, !noalias !373
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 5693646204635713916
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4, !noalias !584
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #35
  ret void
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @ChainIterable2_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract71 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract73 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract71, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !587
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !587
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !587
  %product.i.i.i = mul i64 %hash_coef.i.i, -5233298072945030060
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !587
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract71, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract73) #36
  %.fca.0.extract63 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract65 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract67 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract69 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract63, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract65, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract67, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract69, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #40
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract63) #40
  %18 = sext i32 %.fca.3.extract69 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract63, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #16
  %22 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr, ptr, ptr, i32 } %26(ptr %.fca.1.extract73) #36
  %.fca.0.extract43 = extractvalue { ptr, ptr, ptr, i32 } %27, 0
  %.fca.1.extract45 = extractvalue { ptr, ptr, ptr, i32 } %27, 1
  %.fca.2.extract47 = extractvalue { ptr, ptr, ptr, i32 } %27, 2
  %.fca.3.extract49 = extractvalue { ptr, ptr, ptr, i32 } %27, 3
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract43, 0
  %29 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %.fca.1.extract45, 1
  %30 = insertvalue { ptr, ptr, ptr, i32 } %29, ptr %.fca.2.extract47, 2
  %31 = insertvalue { ptr, ptr, ptr, i32 } %30, i32 %.fca.3.extract49, 3
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract43)
  %34 = sext i32 %.fca.3.extract49 to i64
  %35 = getelementptr ptr, ptr %.fca.0.extract43, i64 %34
  %36 = getelementptr i8, ptr %35, i64 8
  %37 = load ptr, ptr %36, align 8
  %result.i97 = call ptr %37({ ptr, ptr, ptr, i32 } %31, ptr nocapture nofree noundef nonnull readonly %4) #16
  %38 = call { ptr, ptr, ptr, i32 } %result.i97({ ptr, ptr, ptr, i32 } %31, { ptr, ptr, ptr, i32 } %31, ptr nonnull align 8 %4) #7
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %40 = load ptr, ptr %7, align 8
  %result.i112 = call ptr %40(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract73) #5
  %result.i114 = call noalias nonnull align 8 dereferenceable(80) ptr @bump_malloc_inner(i64 noundef 80, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i112, ptr %result.i114, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %result.i114)
  %42 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %43 = load ptr, ptr %8, align 8
  %44 = load ptr, ptr %43, align 8
  %45 = call { ptr, ptr, ptr, i32 } %44(ptr %.fca.1.extract73) #36
  %.fca.0.extract17 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract19 = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract21 = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %.fca.3.extract23 = extractvalue { ptr, ptr, ptr, i32 } %45, 3
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract17, 0
  %47 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %.fca.1.extract19, 1
  %48 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %.fca.2.extract21, 2
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %.fca.3.extract23, 3
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %51 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract17)
  %52 = sext i32 %.fca.3.extract23 to i64
  %53 = getelementptr ptr, ptr %.fca.0.extract17, i64 %52
  %54 = getelementptr i8, ptr %53, i64 8
  %55 = load ptr, ptr %54, align 8
  %result.i115 = call ptr %55({ ptr, ptr, ptr, i32 } %49, ptr nocapture nofree noundef nonnull readonly %4) #16
  %56 = call { ptr, ptr, ptr, i32 } %result.i115({ ptr, ptr, ptr, i32 } %49, { ptr, ptr, ptr, i32 } %49, ptr nonnull align 8 %4) #7
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %56, 0
  %.fca.1.extract7 = extractvalue { ptr, ptr, ptr, i32 } %56, 1
  %.fca.2.extract9 = extractvalue { ptr, ptr, ptr, i32 } %56, 2
  %hash_coef_ptr.i.i117 = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i118 = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i119 = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %57 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract71)
  %58 = load ptr, ptr %24, align 8
  %59 = load ptr, ptr %58, align 8
  %60 = call { ptr, ptr, ptr, i32 } %59(ptr %.fca.1.extract73) #36
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %60, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %60, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %60, 2
  %.fca.3.extract4 = extractvalue { ptr, ptr, ptr, i32 } %60, 3
  %61 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.1.extract2, 1
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %.fca.2.extract3, 2
  %64 = insertvalue { ptr, ptr, ptr, i32 } %63, i32 %.fca.3.extract4, 3
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %66 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract1)
  %67 = sext i32 %.fca.3.extract4 to i64
  %68 = getelementptr ptr, ptr %.fca.0.extract1, i64 %67
  %69 = getelementptr i8, ptr %68, i64 8
  %70 = load ptr, ptr %69, align 8
  %result.i130 = call ptr %70({ ptr, ptr, ptr, i32 } %64, ptr nocapture nofree noundef nonnull readonly %4) #16
  %71 = call { ptr, ptr, ptr, i32 } %result.i130({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr nonnull align 8 %4) #7
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %71, 2
  %hash_coef_ptr.i.i132 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i133 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i134 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i149 = load i64, ptr %hash_coef_ptr.i.i117, align 4, !noalias !373
  %tbl_size.i.i150 = load i64, ptr %tbl_size_ptr.i.i118, align 4, !noalias !373
  %offset_tbl.i.i151 = load ptr, ptr %offset_tbl_ptr.i.i119, align 8, !noalias !373
  %product.i.i.i152 = mul i64 %hash_coef.i.i149, 4189192806087951739
  %shifted.i.i.i153 = lshr i64 %product.i.i.i152, 32
  %xored.i.i.i154 = xor i64 %shifted.i.i.i153, %product.i.i.i152
  %hash.i.i.i155 = and i64 %xored.i.i.i154, %tbl_size.i.i150
  %offset_ptr.i.i156 = getelementptr i32, ptr %offset_tbl.i.i151, i64 %hash.i.i.i155
  %offset.i.i157 = load i32, ptr %offset_ptr.i.i156, align 4, !noalias !373
  %72 = insertvalue { ptr, ptr, ptr, i32 } { ptr @ChainIterator2, ptr undef, ptr undef, i32 undef }, ptr %result.i114, 1
  %73 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr undef, 2
  %74 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull @ChainIterator2) #34
  %75 = getelementptr inbounds i8, ptr %result.i114, i64 8
  store ptr %.fca.0.extract5, ptr %75, align 8
  %76 = getelementptr inbounds i8, ptr %result.i114, i64 16
  store ptr %.fca.1.extract7, ptr %76, align 8
  %77 = getelementptr inbounds i8, ptr %result.i114, i64 24
  store ptr %.fca.2.extract9, ptr %77, align 8
  %78 = getelementptr inbounds i8, ptr %result.i114, i64 32
  store i32 %offset.i.i157, ptr %78, align 8
  %hash_coef.i.i49.i = load i64, ptr %hash_coef_ptr.i.i132, align 4, !noalias !373
  %tbl_size.i.i50.i = load i64, ptr %tbl_size_ptr.i.i133, align 4, !noalias !373
  %offset_tbl.i.i51.i = load ptr, ptr %offset_tbl_ptr.i.i134, align 8, !noalias !373
  %product.i.i.i52.i = mul i64 %hash_coef.i.i49.i, 4189192806087951739
  %shifted.i.i.i53.i = lshr i64 %product.i.i.i52.i, 32
  %xored.i.i.i54.i = xor i64 %shifted.i.i.i53.i, %product.i.i.i52.i
  %hash.i.i.i55.i = and i64 %xored.i.i.i54.i, %tbl_size.i.i50.i
  %offset_ptr.i.i56.i = getelementptr i32, ptr %offset_tbl.i.i51.i, i64 %hash.i.i.i55.i
  %offset.i.i71.i = load i32, ptr %offset_ptr.i.i56.i, align 4, !noalias !590
  %79 = getelementptr inbounds i8, ptr %result.i114, i64 40
  store ptr %.fca.0.extract, ptr %79, align 8
  %80 = getelementptr inbounds i8, ptr %result.i114, i64 48
  store ptr %.fca.1.extract, ptr %80, align 8
  %81 = getelementptr inbounds i8, ptr %result.i114, i64 56
  store ptr %.fca.2.extract, ptr %81, align 8
  %82 = getelementptr inbounds i8, ptr %result.i114, i64 64
  store i32 %offset.i.i71.i, ptr %82, align 8
  %83 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull @ChainIterator2) #34
  %84 = getelementptr inbounds i8, ptr %result.i114, i64 72
  store i1 true, ptr %84, align 8
  %85 = insertvalue { ptr, ptr, ptr, i32 } %73, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %85
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ChainIterator2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 80, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ChainIterator2_field_ChainIterator2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterator2_B_init_firstIterator2T_secondIterator2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ChainIterator2_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ChainIterator2_init_firstIterator2T_secondIterator2T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) #2 {
  %.fca.0.extract9 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract9, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !593
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !593
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !593
  %product.i.i.i = mul i64 %hash_coef.i.i, -228267985060461774
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !593
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract3 = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i18 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i19 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i20 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i21 = load i64, ptr %hash_coef_ptr.i.i18, align 4, !noalias !373
  %tbl_size.i.i22 = load i64, ptr %tbl_size_ptr.i.i19, align 4, !noalias !373
  %offset_tbl.i.i23 = load ptr, ptr %offset_tbl_ptr.i.i20, align 8, !noalias !373
  %product.i.i.i24 = mul i64 %hash_coef.i.i21, 4189192806087951739
  %shifted.i.i.i25 = lshr i64 %product.i.i.i24, 32
  %xored.i.i.i26 = xor i64 %shifted.i.i.i25, %product.i.i.i24
  %hash.i.i.i27 = and i64 %xored.i.i.i26, %tbl_size.i.i22
  %offset_ptr.i.i28 = getelementptr i32, ptr %offset_tbl.i.i23, i64 %hash.i.i.i27
  %offset.i.i43 = load i32, ptr %offset_ptr.i.i28, align 4, !noalias !596
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract9, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract2, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract3, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i43, 3
  tail call void %12(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %16) #35
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i46 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i47 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i48 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i49 = load i64, ptr %hash_coef_ptr.i.i46, align 4, !noalias !373
  %tbl_size.i.i50 = load i64, ptr %tbl_size_ptr.i.i47, align 4, !noalias !373
  %offset_tbl.i.i51 = load ptr, ptr %offset_tbl_ptr.i.i48, align 8, !noalias !373
  %product.i.i.i52 = mul i64 %hash_coef.i.i49, 4189192806087951739
  %shifted.i.i.i53 = lshr i64 %product.i.i.i52, 32
  %xored.i.i.i54 = xor i64 %shifted.i.i.i53, %product.i.i.i52
  %hash.i.i.i55 = and i64 %xored.i.i.i54, %tbl_size.i.i50
  %offset_ptr.i.i56 = getelementptr i32, ptr %offset_tbl.i.i51, i64 %hash.i.i.i55
  %offset.i.i71 = load i32, ptr %offset_ptr.i.i56, align 4, !noalias !599
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %.fca.1.extract, 1
  %24 = insertvalue { ptr, ptr, ptr, i32 } %23, ptr %.fca.2.extract, 2
  %25 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %offset.i.i71, 3
  tail call void %21(ptr %.fca.1.extract10, { ptr, ptr, ptr, i32 } %25) #35
  %26 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract9) #34
  %27 = getelementptr i8, ptr %8, i64 24
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  tail call void %30(ptr %.fca.1.extract10, i1 true) #35
  ret void
}

define { ptr, i160 } @ChainIterator2_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract6 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract5, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, -228267985060461774
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract5) #38
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract5, i64 %6
  %8 = getelementptr i8, ptr %7, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call i1 %10(ptr %.fca.1.extract6) #36
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull %.fca.0.extract5)
  br i1 %11, label %29, label %13

13:                                               ; preds = %3
  %14 = getelementptr i8, ptr %7, i64 16
  %15 = load ptr, ptr %14, align 8
  %16 = load ptr, ptr %15, align 8
  %17 = tail call { ptr, ptr, ptr, i32 } %16(ptr %.fca.1.extract6) #36
  %.fca.0.extract24 = extractvalue { ptr, ptr, ptr, i32 } %17, 0
  %.fca.1.extract26 = extractvalue { ptr, ptr, ptr, i32 } %17, 1
  %.fca.2.extract28 = extractvalue { ptr, ptr, ptr, i32 } %17, 2
  %.fca.3.extract30 = extractvalue { ptr, ptr, ptr, i32 } %17, 3
  %18 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract24, 0
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.1.extract26, 1
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.2.extract28, 2
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, i32 %.fca.3.extract30, 3
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract24)
  %24 = sext i32 %.fca.3.extract30 to i64
  %25 = getelementptr ptr, ptr %.fca.0.extract24, i64 %24
  %26 = getelementptr i8, ptr %25, i64 8
  %27 = load ptr, ptr %26, align 8
  %result.i = call ptr %27({ ptr, ptr, ptr, i32 } %21, ptr nocapture nofree noundef nonnull readonly %4) #16
  %28 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %21, { ptr, ptr, ptr, i32 } %21, ptr nonnull align 8 %4) #7
  %.fca.0.extract18 = extractvalue { ptr, i160 } %28, 0
  br label %52

29:                                               ; preds = %3
  %30 = getelementptr i8, ptr %7, i64 8
  %31 = load ptr, ptr %30, align 8
  %32 = load ptr, ptr %31, align 8
  %33 = tail call { ptr, ptr, ptr, i32 } %32(ptr %.fca.1.extract6) #36
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %33, 0
  %.fca.1.extract15 = extractvalue { ptr, ptr, ptr, i32 } %33, 1
  %.fca.2.extract16 = extractvalue { ptr, ptr, ptr, i32 } %33, 2
  %.fca.3.extract17 = extractvalue { ptr, ptr, ptr, i32 } %33, 3
  %34 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract14, 0
  %35 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr %.fca.1.extract15, 1
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %.fca.2.extract16, 2
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, i32 %.fca.3.extract17, 3
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %39 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract14)
  %40 = sext i32 %.fca.3.extract17 to i64
  %41 = getelementptr ptr, ptr %.fca.0.extract14, i64 %40
  %42 = getelementptr i8, ptr %41, i64 8
  %43 = load ptr, ptr %42, align 8
  %result.i35 = call ptr %43({ ptr, ptr, ptr, i32 } %37, ptr nocapture nofree noundef nonnull readonly %4) #16
  %44 = call { ptr, i160 } %result.i35({ ptr, ptr, ptr, i32 } %37, { ptr, ptr, ptr, i32 } %37, ptr nonnull align 8 %4) #7
  %.fca.0.extract10 = extractvalue { ptr, i160 } %44, 0
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull %.fca.0.extract5)
  %46 = icmp eq ptr %.fca.0.extract10, @nil_typ
  %47 = icmp eq ptr %.fca.0.extract10, null
  %.not33.not = or i1 %46, %47
  br i1 %.not33.not, label %._crit_edge.preheader, label %52

._crit_edge.preheader:                            ; preds = %29
  %48 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull %.fca.0.extract5)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.preheader, %._crit_edge
  %49 = load ptr, ptr %8, align 8
  %50 = getelementptr i8, ptr %49, i64 8
  %51 = load ptr, ptr %50, align 8
  call void %51(ptr %.fca.1.extract6, i1 false) #35
  br label %._crit_edge

52:                                               ; preds = %29, %13
  %.reg2mem29.sroa.0.0 = phi ptr [ %.fca.0.extract18, %13 ], [ %.fca.0.extract10, %29 ]
  %.pn = phi { ptr, i160 } [ %28, %13 ], [ %44, %29 ]
  %.reload30.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem29.sroa.0.0, 0
  %.reg2mem29.sroa.3.0 = extractvalue { ptr, i160 } %.pn, 1
  %.reload30.fca.1.insert = insertvalue { ptr, i160 } %.reload30.fca.0.insert, i160 %.reg2mem29.sroa.3.0, 1
  ret { ptr, i160 } %.reload30.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i1 @ChainIterator2_getter_on_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 72
  %3 = load i1, ptr %2, align 1
  ret i1 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterator2_setter_on_first(ptr nocapture nofree writeonly %0, i1 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 72
  store i1 %1, ptr %3, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterator2_getter_second(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterator2_setter_second(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterator2_getter_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterator2_setter_first(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterable2_getter_second(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterable2_setter_second(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ChainIterable2_getter_first(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ChainIterable2_setter_first(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_FilterIterable2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @FilterIterable2_field_FilterIterable2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_init_iterableIterable2T_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 200
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterable2_B_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @FilterIterable2_init_iterableIterable2T_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #2 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !602
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !602
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !602
  %product.i.i.i = mul i64 %hash_coef.i.i, 1178467452958968374
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !602
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i13 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i14 = load i64, ptr %hash_coef_ptr.i.i11, align 4, !noalias !373
  %tbl_size.i.i15 = load i64, ptr %tbl_size_ptr.i.i12, align 4, !noalias !373
  %offset_tbl.i.i16 = load ptr, ptr %offset_tbl_ptr.i.i13, align 8, !noalias !373
  %product.i.i.i17 = mul i64 %hash_coef.i.i14, 5693646204635713916
  %shifted.i.i.i18 = lshr i64 %product.i.i.i17, 32
  %xored.i.i.i19 = xor i64 %shifted.i.i.i18, %product.i.i.i17
  %hash.i.i.i20 = and i64 %xored.i.i.i19, %tbl_size.i.i15
  %offset_ptr.i.i21 = getelementptr i32, ptr %offset_tbl.i.i16, i64 %hash.i.i.i20
  %offset.i.i36 = load i32, ptr %offset_ptr.i.i21, align 4, !noalias !605
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract2, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i36, 3
  tail call void %12(ptr %.fca.1.extract3, { ptr, ptr, ptr, i32 } %16) #35
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  tail call void %21(ptr %.fca.1.extract3, { ptr } %4) #35
  ret void
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @FilterIterable2_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract37 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !608
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !608
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !608
  %product.i.i.i = mul i64 %hash_coef.i.i, 1178467452958968374
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !608
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract35) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract35, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract37) #36
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract29 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract31 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract27, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract29, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract31, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract33, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #40
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract27) #40
  %18 = sext i32 %.fca.3.extract33 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract27, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #16
  %22 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract35)
  %24 = getelementptr i8, ptr %7, i64 16
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr } %26(ptr %.fca.1.extract37) #36
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract35)
  %29 = load ptr, ptr %7, align 8
  %result.i61 = call ptr %29(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract37) #5
  %result.i63 = call noalias nonnull align 8 dereferenceable(48) ptr @bump_malloc_inner(i64 noundef 48, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i61, ptr %result.i63, align 8
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %result.i63)
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract35)
  %32 = load ptr, ptr %8, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call { ptr, ptr, ptr, i32 } %33(ptr %.fca.1.extract37) #36
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %34, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %34, 1
  %.fca.2.extract4 = extractvalue { ptr, ptr, ptr, i32 } %34, 2
  %.fca.3.extract5 = extractvalue { ptr, ptr, ptr, i32 } %34, 3
  %35 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %36 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %.fca.1.extract3, 1
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %.fca.2.extract4, 2
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, i32 %.fca.3.extract5, 3
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract2)
  %41 = sext i32 %.fca.3.extract5 to i64
  %42 = getelementptr ptr, ptr %.fca.0.extract2, i64 %41
  %43 = getelementptr i8, ptr %42, i64 8
  %44 = load ptr, ptr %43, align 8
  %result.i64 = call ptr %44({ ptr, ptr, ptr, i32 } %38, ptr nocapture nofree noundef nonnull readonly %4) #16
  %45 = call { ptr, ptr, ptr, i32 } %result.i64({ ptr, ptr, ptr, i32 } %38, { ptr, ptr, ptr, i32 } %38, ptr nonnull align 8 %4) #7
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %45, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %45, 2
  %hash_coef_ptr.i.i66 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i67 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i68 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i69 = load i64, ptr %hash_coef_ptr.i.i66, align 4, !noalias !373
  %tbl_size.i.i70 = load i64, ptr %tbl_size_ptr.i.i67, align 4, !noalias !373
  %offset_tbl.i.i71 = load ptr, ptr %offset_tbl_ptr.i.i68, align 8, !noalias !373
  %product.i.i.i72 = mul i64 %hash_coef.i.i69, 4189192806087951739
  %shifted.i.i.i73 = lshr i64 %product.i.i.i72, 32
  %xored.i.i.i74 = xor i64 %shifted.i.i.i73, %product.i.i.i72
  %hash.i.i.i75 = and i64 %xored.i.i.i74, %tbl_size.i.i70
  %offset_ptr.i.i76 = getelementptr i32, ptr %offset_tbl.i.i71, i64 %hash.i.i.i75
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 400, ptr nocapture nofree noundef %.fca.0.extract35)
  %47 = load ptr, ptr %24, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr } %48(ptr %.fca.1.extract37) #36
  %offset.i.i91 = load i32, ptr %offset_ptr.i.i76, align 4, !noalias !373
  %50 = insertvalue { ptr, ptr, ptr, i32 } { ptr @FilterIterator2, ptr undef, ptr undef, i32 undef }, ptr %result.i63, 1
  %51 = insertvalue { ptr, ptr, ptr, i32 } %50, ptr undef, 2
  %52 = getelementptr inbounds i8, ptr %result.i63, i64 8
  store ptr %.fca.0.extract1, ptr %52, align 8
  %53 = getelementptr inbounds i8, ptr %result.i63, i64 16
  store ptr %.fca.1.extract, ptr %53, align 8
  %54 = getelementptr inbounds i8, ptr %result.i63, i64 24
  store ptr %.fca.2.extract, ptr %54, align 8
  %55 = getelementptr inbounds i8, ptr %result.i63, i64 32
  store i32 %offset.i.i91, ptr %55, align 8
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull @FilterIterator2) #34
  %57 = getelementptr inbounds i8, ptr %result.i63, i64 40
  %.fca.0.extract.i = extractvalue { ptr } %49, 0
  store ptr %.fca.0.extract.i, ptr %57, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %51, i32 17, 3
  ret { ptr, ptr, ptr, i32 } %58
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_FilterIterator2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @FilterIterator2_field_FilterIterator2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterator2_B_init_iteratorIterator2T_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @FilterIterator2_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @FilterIterator2_init_iteratorIterator2T_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #2 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !611
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !611
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !611
  %product.i.i.i = mul i64 %hash_coef.i.i, 8213847504843366470
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !611
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i13 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i14 = load i64, ptr %hash_coef_ptr.i.i11, align 4, !noalias !373
  %tbl_size.i.i15 = load i64, ptr %tbl_size_ptr.i.i12, align 4, !noalias !373
  %offset_tbl.i.i16 = load ptr, ptr %offset_tbl_ptr.i.i13, align 8, !noalias !373
  %product.i.i.i17 = mul i64 %hash_coef.i.i14, 4189192806087951739
  %shifted.i.i.i18 = lshr i64 %product.i.i.i17, 32
  %xored.i.i.i19 = xor i64 %shifted.i.i.i18, %product.i.i.i17
  %hash.i.i.i20 = and i64 %xored.i.i.i19, %tbl_size.i.i15
  %offset_ptr.i.i21 = getelementptr i32, ptr %offset_tbl.i.i16, i64 %hash.i.i.i20
  %offset.i.i36 = load i32, ptr %offset_ptr.i.i21, align 4, !noalias !614
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract2, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i36, 3
  tail call void %12(ptr %.fca.1.extract3, { ptr, ptr, ptr, i32 } %16) #35
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %18 = getelementptr i8, ptr %8, i64 16
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  tail call void %21(ptr %.fca.1.extract3, { ptr } %4) #35
  ret void
}

define { ptr, i160 } @FilterIterator2_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract16 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract14, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !617
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !617
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !617
  %product.i.i.i = mul i64 %hash_coef.i.i, 8213847504843366470
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !617
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract14) #38
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract14, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract16) #36
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract3, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract1)
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract1, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #16
  %22 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract14)
  %.sroa.0.081 = extractvalue { ptr, i160 } %22, 0
  %24 = icmp ne ptr %.sroa.0.081, @nil_typ
  %25 = icmp ne ptr %.sroa.0.081, null
  %.not5083 = and i1 %24, %25
  br i1 %.not5083, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %3
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract14)
  %27 = getelementptr i8, ptr %7, i64 16
  %28 = load ptr, ptr %27, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = call { ptr } %29(ptr %.fca.1.extract16) #36
  %.fca.0.extract3791 = extractvalue { ptr } %30, 0
  %31 = call i1 %.fca.0.extract3791({ ptr, i160 } %22)
  br i1 %31, label %._crit_edge.loopexit, label %.lr.ph93.preheader

.lr.ph93.preheader:                               ; preds = %.lr.ph
  %32 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract14)
  br label %.lr.ph93

33:                                               ; preds = %.lr.ph93
  %34 = load ptr, ptr %27, align 8
  %35 = load ptr, ptr %34, align 8
  %36 = call { ptr } %35(ptr %.fca.1.extract16) #36
  %.fca.0.extract37 = extractvalue { ptr } %36, 0
  %37 = call i1 %.fca.0.extract37({ ptr, i160 } %51)
  br i1 %37, label %._crit_edge.loopexit, label %.lr.ph93

.lr.ph93:                                         ; preds = %.lr.ph93.preheader, %33
  %.pn8492 = phi { ptr, i160 } [ %51, %33 ], [ %22, %.lr.ph93.preheader ]
  %38 = load ptr, ptr %8, align 8
  %39 = load ptr, ptr %38, align 8
  %40 = call { ptr, ptr, ptr, i32 } %39(ptr %.fca.1.extract16) #36
  %.fca.0.extract28 = extractvalue { ptr, ptr, ptr, i32 } %40, 0
  %.fca.1.extract30 = extractvalue { ptr, ptr, ptr, i32 } %40, 1
  %.fca.2.extract32 = extractvalue { ptr, ptr, ptr, i32 } %40, 2
  %.fca.3.extract34 = extractvalue { ptr, ptr, ptr, i32 } %40, 3
  %41 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract28, 0
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %.fca.1.extract30, 1
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %.fca.2.extract32, 2
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, i32 %.fca.3.extract34, 3
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract28)
  %47 = sext i32 %.fca.3.extract34 to i64
  %48 = getelementptr ptr, ptr %.fca.0.extract28, i64 %47
  %49 = getelementptr i8, ptr %48, i64 8
  %50 = load ptr, ptr %49, align 8
  %result.i51 = call ptr %50({ ptr, ptr, ptr, i32 } %44, ptr nocapture nofree noundef nonnull readonly %4) #16
  %51 = call { ptr, i160 } %result.i51({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr nonnull align 8 %4) #7
  %.sroa.0.0 = extractvalue { ptr, i160 } %51, 0
  %52 = icmp ne ptr %.sroa.0.0, @nil_typ
  %53 = icmp ne ptr %.sroa.0.0, null
  %.not50 = and i1 %52, %53
  br i1 %.not50, label %33, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %.lr.ph93, %33, %.lr.ph
  %.pn84.lcssa = phi { ptr, i160 } [ %22, %.lr.ph ], [ %.pn8492, %.lr.ph93 ], [ %51, %33 ]
  %.ph = phi ptr [ %.sroa.0.081, %.lr.ph ], [ @nil_typ, %.lr.ph93 ], [ %.sroa.0.0, %33 ]
  %.sroa.3.086.le = extractvalue { ptr, i160 } %.pn84.lcssa, 1
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %3
  %.1.ph78 = phi i160 [ undef, %3 ], [ %.sroa.3.086.le, %._crit_edge.loopexit ]
  %54 = phi ptr [ @nil_typ, %3 ], [ %.ph, %._crit_edge.loopexit ]
  %.reload31.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %54, 0
  %.reload31.fca.1.insert = insertvalue { ptr, i160 } %.reload31.fca.0.insert, i160 %.1.ph78, 1
  ret { ptr, i160 } %.reload31.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @FilterIterator2_getter_f(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterator2_setter_f(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @FilterIterator2_getter_iterator(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterator2_setter_iterator(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @FilterIterable2_getter_f(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterable2_setter_f(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @FilterIterable2_getter_iterable(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @FilterIterable2_setter_iterable(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MapIterable2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 56, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterable2_field_MapIterable2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterable2_field_MapIterable2_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_init_iterableIterable2T_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterable2_B_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @MapIterable2_init_iterableIterable2T_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #2 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !620
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !620
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !620
  %product.i.i.i = mul i64 %hash_coef.i.i, -1724859134596891929
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !620
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i13 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i14 = load i64, ptr %hash_coef_ptr.i.i11, align 4, !noalias !373
  %tbl_size.i.i15 = load i64, ptr %tbl_size_ptr.i.i12, align 4, !noalias !373
  %offset_tbl.i.i16 = load ptr, ptr %offset_tbl_ptr.i.i13, align 8, !noalias !373
  %product.i.i.i17 = mul i64 %hash_coef.i.i14, 5693646204635713916
  %shifted.i.i.i18 = lshr i64 %product.i.i.i17, 32
  %xored.i.i.i19 = xor i64 %shifted.i.i.i18, %product.i.i.i17
  %hash.i.i.i20 = and i64 %xored.i.i.i19, %tbl_size.i.i15
  %offset_ptr.i.i21 = getelementptr i32, ptr %offset_tbl.i.i16, i64 %hash.i.i.i20
  %offset.i.i36 = load i32, ptr %offset_ptr.i.i21, align 4, !noalias !623
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract2, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i36, 3
  tail call void %12(ptr %.fca.1.extract3, { ptr, ptr, ptr, i32 } %16) #35
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %18 = getelementptr i8, ptr %8, i64 24
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  tail call void %21(ptr %.fca.1.extract3, { ptr } %4) #35
  ret void
}

; Function Attrs: nounwind
define { ptr, ptr, ptr, i32 } @MapIterable2_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract35 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract37 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract35, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !626
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !626
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !626
  %product.i.i.i = mul i64 %hash_coef.i.i, -1724859134596891929
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !626
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef %.fca.0.extract35) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract35, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract37) #36
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract29 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract31 = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract27, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract29, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract31, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract33, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #40
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract27) #40
  %18 = sext i32 %.fca.3.extract33 to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract27, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #16
  %22 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef %.fca.0.extract35)
  %24 = getelementptr i8, ptr %7, i64 24
  %25 = load ptr, ptr %24, align 8
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr } %26(ptr %.fca.1.extract37) #36
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef %.fca.0.extract35)
  %29 = load ptr, ptr %7, align 8
  %result.i61 = call ptr %29(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract37) #5
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef %.fca.0.extract35)
  %31 = getelementptr i8, ptr %7, i64 8
  %32 = load ptr, ptr %31, align 8
  %result.i62 = call ptr %32(ptr nocapture nofree noundef nonnull readonly %.fca.1.extract37) #5
  %result.i64 = call noalias nonnull align 8 dereferenceable(56) ptr @bump_malloc_inner(i64 noundef 56, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store ptr %result.i61, ptr %result.i64, align 8
  %33 = getelementptr inbounds i8, ptr %result.i64, i64 8
  store ptr %result.i62, ptr %33, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %result.i64)
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef %.fca.0.extract35)
  %36 = load ptr, ptr %8, align 8
  %37 = load ptr, ptr %36, align 8
  %38 = call { ptr, ptr, ptr, i32 } %37(ptr %.fca.1.extract37) #36
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %38, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %38, 1
  %.fca.2.extract4 = extractvalue { ptr, ptr, ptr, i32 } %38, 2
  %.fca.3.extract5 = extractvalue { ptr, ptr, ptr, i32 } %38, 3
  %39 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %40 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %.fca.1.extract3, 1
  %41 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %.fca.2.extract4, 2
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, i32 %.fca.3.extract5, 3
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 184, ptr nocapture nofree noundef %.fca.0.extract2)
  %45 = sext i32 %.fca.3.extract5 to i64
  %46 = getelementptr ptr, ptr %.fca.0.extract2, i64 %45
  %47 = getelementptr i8, ptr %46, i64 8
  %48 = load ptr, ptr %47, align 8
  %result.i65 = call ptr %48({ ptr, ptr, ptr, i32 } %42, ptr nocapture nofree noundef nonnull readonly %4) #16
  %49 = call { ptr, ptr, ptr, i32 } %result.i65({ ptr, ptr, ptr, i32 } %42, { ptr, ptr, ptr, i32 } %42, ptr nonnull align 8 %4) #7
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %49, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %49, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %49, 2
  %hash_coef_ptr.i.i67 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i68 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i69 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i70 = load i64, ptr %hash_coef_ptr.i.i67, align 4, !noalias !373
  %tbl_size.i.i71 = load i64, ptr %tbl_size_ptr.i.i68, align 4, !noalias !373
  %offset_tbl.i.i72 = load ptr, ptr %offset_tbl_ptr.i.i69, align 8, !noalias !373
  %product.i.i.i73 = mul i64 %hash_coef.i.i70, 4189192806087951739
  %shifted.i.i.i74 = lshr i64 %product.i.i.i73, 32
  %xored.i.i.i75 = xor i64 %shifted.i.i.i74, %product.i.i.i73
  %hash.i.i.i76 = and i64 %xored.i.i.i75, %tbl_size.i.i71
  %offset_ptr.i.i77 = getelementptr i32, ptr %offset_tbl.i.i72, i64 %hash.i.i.i76
  %50 = call ptr @llvm.invariant.start.p0(i64 noundef 408, ptr nocapture nofree noundef %.fca.0.extract35)
  %51 = load ptr, ptr %24, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = call { ptr } %52(ptr %.fca.1.extract37) #36
  %offset.i.i92 = load i32, ptr %offset_ptr.i.i77, align 4, !noalias !373
  %54 = insertvalue { ptr, ptr, ptr, i32 } { ptr @MapIterator2, ptr undef, ptr undef, i32 undef }, ptr %result.i64, 1
  %55 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr undef, 2
  %56 = getelementptr inbounds i8, ptr %result.i64, i64 16
  store ptr %.fca.0.extract1, ptr %56, align 8
  %57 = getelementptr inbounds i8, ptr %result.i64, i64 24
  store ptr %.fca.1.extract, ptr %57, align 8
  %58 = getelementptr inbounds i8, ptr %result.i64, i64 32
  store ptr %.fca.2.extract, ptr %58, align 8
  %59 = getelementptr inbounds i8, ptr %result.i64, i64 40
  store i32 %offset.i.i92, ptr %59, align 8
  %60 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull @MapIterator2) #34
  %61 = getelementptr inbounds i8, ptr %result.i64, i64 48
  %.fca.0.extract.i = extractvalue { ptr } %53, 0
  store ptr %.fca.0.extract.i, ptr %61, align 8
  %62 = insertvalue { ptr, ptr, ptr, i32 } %55, i32 18, 3
  ret { ptr, ptr, ptr, i32 } %62
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_MapIterator2(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 56, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterator2_field_MapIterator2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @MapIterator2_field_MapIterator2_1(ptr nocapture nofree readonly align 8 %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterator2_B_init_iteratorIterator2T_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @MapIterator2_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 136
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @MapIterator2_init_iteratorIterator2T_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) #2 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !629
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !629
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !629
  %product.i.i.i = mul i64 %hash_coef.i.i, -10255947709272500
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !629
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i13 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i14 = load i64, ptr %hash_coef_ptr.i.i11, align 4, !noalias !373
  %tbl_size.i.i15 = load i64, ptr %tbl_size_ptr.i.i12, align 4, !noalias !373
  %offset_tbl.i.i16 = load ptr, ptr %offset_tbl_ptr.i.i13, align 8, !noalias !373
  %product.i.i.i17 = mul i64 %hash_coef.i.i14, 4189192806087951739
  %shifted.i.i.i18 = lshr i64 %product.i.i.i17, 32
  %xored.i.i.i19 = xor i64 %shifted.i.i.i18, %product.i.i.i17
  %hash.i.i.i20 = and i64 %xored.i.i.i19, %tbl_size.i.i15
  %offset_ptr.i.i21 = getelementptr i32, ptr %offset_tbl.i.i16, i64 %hash.i.i.i20
  %offset.i.i36 = load i32, ptr %offset_ptr.i.i21, align 4, !noalias !632
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract2, i64 %7
  %9 = getelementptr i8, ptr %8, i64 16
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i36, 3
  tail call void %12(ptr %.fca.1.extract3, { ptr, ptr, ptr, i32 } %16) #35
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %18 = getelementptr i8, ptr %8, i64 24
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  tail call void %21(ptr %.fca.1.extract3, { ptr } %4) #35
  ret void
}

define { ptr, i160 } @MapIterator2_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !635
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !635
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !635
  %product.i.i.i = mul i64 %hash_coef.i.i, -10255947709272500
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !635
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract12) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract12, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract14) #36
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract3, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #40
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef %.fca.0.extract2) #40
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract2, i64 %18
  %20 = getelementptr i8, ptr %19, i64 8
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #16
  %22 = call { ptr, i160 } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %.fca.0.extract = extractvalue { ptr, i160 } %22, 0
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef %.fca.0.extract12)
  %24 = icmp ne ptr %.fca.0.extract, @nil_typ
  %25 = icmp ne ptr %.fca.0.extract, null
  %.not36 = and i1 %24, %25
  br i1 %.not36, label %26, label %33

26:                                               ; preds = %3
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 88, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %28 = getelementptr i8, ptr %7, i64 24
  %29 = load ptr, ptr %28, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = call { ptr } %30(ptr %.fca.1.extract14) #36
  %.fca.0.extract28 = extractvalue { ptr } %31, 0
  %32 = call { ptr, i160 } %.fca.0.extract28({ ptr, i160 } %22)
  %.fca.0.extract22 = extractvalue { ptr, i160 } %32, 0
  %.fca.1.extract24 = extractvalue { ptr, i160 } %32, 1
  br label %33

33:                                               ; preds = %3, %26
  %.reg2mem15.sroa.0.0 = phi ptr [ %.fca.0.extract22, %26 ], [ @nil_typ, %3 ]
  %.reg2mem15.sroa.3.0 = phi i160 [ %.fca.1.extract24, %26 ], [ undef, %3 ]
  %.reload16.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem15.sroa.0.0, 0
  %.reload16.fca.1.insert = insertvalue { ptr, i160 } %.reload16.fca.0.insert, i160 %.reg2mem15.sroa.3.0, 1
  ret { ptr, i160 } %.reload16.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @MapIterator2_getter_f(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterator2_setter_f(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapIterator2_getter_iterator(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterator2_setter_iterator(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @MapIterable2_getter_f(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 48
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterable2_setter_f(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 48
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @MapIterable2_getter_iterable(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 24
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 32
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 40
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @MapIterable2_setter_iterable(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 16
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 32
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 40
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_ArrayIterator(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 48, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @ArrayIterator_field_ArrayIterator_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ArrayIterator_B_init_arrayArrayT({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @ArrayIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 128
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @ArrayIterator_init_arrayArrayT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #2 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !638
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !638
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !638
  %product.i.i.i = mul i64 %hash_coef.i.i, 3447345754186651411
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !638
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i10 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i13 = load i64, ptr %hash_coef_ptr.i.i10, align 4, !noalias !373
  %tbl_size.i.i14 = load i64, ptr %tbl_size_ptr.i.i11, align 4, !noalias !373
  %offset_tbl.i.i15 = load ptr, ptr %offset_tbl_ptr.i.i12, align 8, !noalias !373
  %product.i.i.i16 = mul i64 %hash_coef.i.i13, -5261542750394134544
  %shifted.i.i.i17 = lshr i64 %product.i.i.i16, 32
  %xored.i.i.i18 = xor i64 %shifted.i.i.i17, %product.i.i.i16
  %hash.i.i.i19 = and i64 %xored.i.i.i18, %tbl_size.i.i14
  %offset_ptr.i.i20 = getelementptr i32, ptr %offset_tbl.i.i15, i64 %hash.i.i.i19
  %offset.i.i35 = load i32, ptr %offset_ptr.i.i20, align 4, !noalias !641
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract1) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract1, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i.i35, 3
  tail call void %11(ptr %.fca.1.extract2, { ptr, ptr, ptr, i32 } %15) #35
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract1) #34
  %17 = getelementptr i8, ptr %7, i64 16
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  tail call void %20(ptr %.fca.1.extract2, i32 0) #35
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @ArrayIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca [1 x ptr], align 8
  %6 = alloca { ptr }, align 8
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !644
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !644
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !644
  %product.i.i.i = mul i64 %hash_coef.i.i, 3447345754186651411
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !644
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract10) #34
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract10, i64 %8
  %10 = getelementptr i8, ptr %9, i64 16
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = tail call i32 %12(ptr %.fca.1.extract12) #36
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef %.fca.0.extract10) #34
  %15 = getelementptr i8, ptr %9, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = tail call { ptr, ptr, ptr, i32 } %17(ptr %.fca.1.extract12) #36
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %18, 3
  %19 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %.fca.1.extract, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %.fca.2.extract, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 %.fca.3.extract, 3
  %23 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #34
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract) #34
  %25 = sext i32 %.fca.3.extract to i64
  %26 = getelementptr ptr, ptr %.fca.0.extract, i64 %25
  %27 = getelementptr i8, ptr %26, i64 64
  %28 = load ptr, ptr %27, align 8
  %result.i = call ptr %28({ ptr, ptr, ptr, i32 } %22, ptr nocapture nofree noundef nonnull readonly %4) #16
  %29 = call i32 %result.i({ ptr, ptr, ptr, i32 } %22, { ptr, ptr, ptr, i32 } %22, ptr nonnull align 8 %4) #7
  %.not = icmp slt i32 %13, %29
  br i1 %.not, label %30, label %59

30:                                               ; preds = %3
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %32 = load ptr, ptr %10, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call i32 %33(ptr %.fca.1.extract12) #36
  %35 = add i32 %34, 1
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %37 = getelementptr i8, ptr %32, i64 8
  %38 = load ptr, ptr %37, align 8
  call void %38(ptr %.fca.1.extract12, i32 %35) #35
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %40 = load ptr, ptr %10, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = call i32 %41(ptr %.fca.1.extract12) #36
  %43 = add i32 %42, -1
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 80, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %45 = load ptr, ptr %15, align 8
  %46 = load ptr, ptr %45, align 8
  %47 = call { ptr, ptr, ptr, i32 } %46(ptr %.fca.1.extract12) #36
  %.fca.0.extract26 = extractvalue { ptr, ptr, ptr, i32 } %47, 0
  %.fca.1.extract28 = extractvalue { ptr, ptr, ptr, i32 } %47, 1
  %.fca.2.extract30 = extractvalue { ptr, ptr, ptr, i32 } %47, 2
  %.fca.3.extract32 = extractvalue { ptr, ptr, ptr, i32 } %47, 3
  %48 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract26, 0
  %49 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %.fca.1.extract28, 1
  %50 = insertvalue { ptr, ptr, ptr, i32 } %49, ptr %.fca.2.extract30, 2
  %51 = insertvalue { ptr, ptr, ptr, i32 } %50, i32 %.fca.3.extract32, 3
  store ptr @_parameterization_Ptri32, ptr %5, align 8
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %5)
  %53 = call ptr @llvm.invariant.start.p0(i64 noundef 600, ptr nocapture nofree noundef %.fca.0.extract26)
  %54 = sext i32 %.fca.3.extract32 to i64
  %55 = getelementptr ptr, ptr %.fca.0.extract26, i64 %54
  %56 = getelementptr i8, ptr %55, i64 120
  %57 = load ptr, ptr %56, align 8
  store ptr @i32_typ, ptr %6, align 8
  %result.i42 = call ptr %57({ ptr, ptr, ptr, i32 } %51, ptr nocapture nofree noundef nonnull readonly %6) #16
  %58 = call { ptr, i160 } %result.i42({ ptr, ptr, ptr, i32 } %51, { ptr, ptr, ptr, i32 } %51, ptr nonnull align 8 dereferenceable(8) %5, i32 %43) #7
  %.fca.0.extract20 = extractvalue { ptr, i160 } %58, 0
  %.fca.1.extract22 = extractvalue { ptr, i160 } %58, 1
  br label %59

59:                                               ; preds = %3, %30
  %.reg2mem21.sroa.0.0 = phi ptr [ %.fca.0.extract20, %30 ], [ @nil_typ, %3 ]
  %.reg2mem21.sroa.3.0 = phi i160 [ %.fca.1.extract22, %30 ], [ undef, %3 ]
  %.reload22.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem21.sroa.0.0, 0
  %.reload22.fca.1.insert = insertvalue { ptr, i160 } %.reload22.fca.0.insert, i160 %.reg2mem21.sroa.3.0, 1
  ret { ptr, i160 } %.reload22.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @ArrayIterator_getter_index(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ArrayIterator_setter_index(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @ArrayIterator_getter_array(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @ArrayIterator_setter_array(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Array_getter_capacity(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 20
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Array_setter_capacity(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 20
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Array_getter_length(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 16
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Array_setter_length(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 16
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @Array_getter_buffer(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr } undef, ptr %3, 0
  ret { ptr } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Array_setter_buffer(ptr nocapture nofree writeonly %0, { ptr } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %3, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Iterator2_field_Iterator2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) local_unnamed_addr #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterator2_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 96
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @Iterable2_field_Iterable2_0(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) local_unnamed_addr #5 {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 184
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 192
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_all_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 200
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_any_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 208
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_filter_fFunctionT_to_Ptri1({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_chain_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_interleave_otherIterable2T({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_zip_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable2_B_product_otherIterable2U({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Iterator(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Iterable(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Representable(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Representable_B_repr_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 88
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: none, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @Representable_repr_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #14 {
  %result.i = tail call noalias align 8 dereferenceable_or_null(7) ptr @bump_malloc_inner(i64 noundef 7, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <6 x i8> <i8 79, i8 98, i8 106, i8 101, i8 99, i8 116>, ptr %result.i, align 8
  %result.i15 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %4 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i15, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr undef, 2
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 10, 3
  store ptr %result.i, ptr %result.i15, align 8
  %7 = getelementptr i8, ptr %result.i15, i64 8
  store i32 6, ptr %7, align 4
  %8 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String) #34
  %9 = getelementptr i8, ptr %result.i15, i64 12
  store i32 7, ptr %9, align 4
  ret { ptr, ptr, ptr, i32 } %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_String(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 16, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 216
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_init_bytesBufferPtri8_lengthPtri32_capacityPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 24, ptr nocapture nofree noundef nonnull align 8 dereferenceable(24) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 224
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_length_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 232
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_capacity_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 240
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_bytes_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 248
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_append_xPtri8({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 256
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_extend_strString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 264
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B__index_xPtri32({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 272
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B__EQ_otherString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 280
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_pop_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 288
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_copy_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 296
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_c_string_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 304
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 312
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @String_B_repr_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 320
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @String_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #2 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !647
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !647
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !647
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !647
  %result.i = tail call noalias dereferenceable_or_null(1) ptr @bump_malloc_inner(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr } undef, ptr %result.i, 0
  tail call void %9(ptr %.fca.1.extract, { ptr } %10) #35
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract) #34
  %12 = getelementptr i8, ptr %6, i64 16
  %13 = load ptr, ptr %12, align 8
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  tail call void %15(ptr %.fca.1.extract, i32 1) #35
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract) #34
  %17 = getelementptr i8, ptr %6, i64 8
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  tail call void %20(ptr %.fca.1.extract, i32 0) #35
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @String_init_bytesBufferPtri8_lengthPtri32_capacityPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr } %3, i32 %4, i32 %5) #2 {
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !650
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !650
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !650
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !650
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract2, i64 %8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr i8, ptr %10, i64 8
  %12 = load ptr, ptr %11, align 8
  tail call void %12(ptr %.fca.1.extract, { ptr } %3) #35
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %14 = getelementptr i8, ptr %9, i64 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr i8, ptr %15, i64 8
  %17 = load ptr, ptr %16, align 8
  tail call void %17(ptr %.fca.1.extract, i32 %4) #35
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %19 = getelementptr i8, ptr %9, i64 16
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr i8, ptr %20, i64 8
  %22 = load ptr, ptr %21, align 8
  tail call void %22(ptr %.fca.1.extract, i32 %5) #35
  ret void
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @String_length_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !653
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !653
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !653
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !653
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract) #36
  ret i32 %10
}

; Function Attrs: mustprogress nounwind willreturn
define i32 @String_capacity_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !656
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !656
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !656
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !656
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract) #36
  ret i32 %10
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr } @String_bytes_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !659
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !659
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !659
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !659
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract1) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract1, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = tail call { ptr } %8(ptr %.fca.1.extract) #36
  ret { ptr } %9
}

define { ptr, ptr, ptr, i32 } @String_append_xPtri8({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i8 %3) {
  %.sroa.091 = alloca ptr, align 8
  %5 = alloca i32, align 4
  %.sroa.087 = alloca ptr, align 8
  %.sroa.188 = alloca ptr, align 8
  %.sroa.289 = alloca ptr, align 8
  %.sroa.390 = alloca i32, align 8
  %.sroa.086 = alloca ptr, align 8
  %6 = alloca i32, align 4
  %.sroa.085 = alloca ptr, align 8
  %.sroa.1 = alloca ptr, align 8
  %.sroa.2 = alloca ptr, align 8
  %.sroa.3 = alloca i32, align 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract) #38
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract, i64 %8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = tail call i32 %12(ptr %.fca.1.extract) #36
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract) #38
  %15 = getelementptr i8, ptr %9, i64 16
  %16 = load ptr, ptr %15, align 8
  %17 = load ptr, ptr %16, align 8
  %18 = tail call i32 %17(ptr %.fca.1.extract) #36
  %19 = icmp slt i32 %13, %18
  br i1 %19, label %._crit_edge.thread, label %20

20:                                               ; preds = %4
  %21 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %22 = tail call i32 %17(ptr %.fca.1.extract) #36
  %23 = shl i32 %22, 1
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %25 = getelementptr i8, ptr %16, i64 8
  %26 = load ptr, ptr %25, align 8
  tail call void %26(ptr %.fca.1.extract, i32 %23) #35
  %27 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %28 = load ptr, ptr %9, align 8
  %29 = load ptr, ptr %28, align 8
  %30 = tail call { ptr } %29(ptr %.fca.1.extract) #36
  %.fca.0.extract17 = extractvalue { ptr } %30, 0
  %31 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %32 = load ptr, ptr %15, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = tail call i32 %33(ptr %.fca.1.extract) #36
  %35 = sext i32 %34 to i64
  %result.i = tail call noalias ptr @bump_malloc_inner(i64 noundef %35, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %36 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %37 = load ptr, ptr %9, align 8
  %38 = getelementptr i8, ptr %37, i64 8
  %39 = load ptr, ptr %38, align 8
  %40 = insertvalue { ptr } undef, ptr %result.i, 0
  tail call void %39(ptr %.fca.1.extract, { ptr } %40) #35
  %41 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %42 = load ptr, ptr %10, align 8
  %43 = load ptr, ptr %42, align 8
  %44 = tail call i32 %43(ptr %.fca.1.extract) #36
  %45 = icmp sgt i32 %44, 0
  br i1 %45, label %._crit_edge.lr.ph, label %._crit_edge.thread

._crit_edge.lr.ph:                                ; preds = %20
  %46 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph, %._crit_edge
  %.093 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %54, %._crit_edge ]
  %47 = zext nneg i32 %.093 to i64
  %48 = getelementptr i8, ptr %.fca.0.extract17, i64 %47
  %49 = load i8, ptr %48, align 1
  %50 = load ptr, ptr %9, align 8
  %51 = load ptr, ptr %50, align 8
  %52 = tail call { ptr } %51(ptr %.fca.1.extract) #36
  %.fca.0.extract5 = extractvalue { ptr } %52, 0
  %53 = getelementptr i8, ptr %.fca.0.extract5, i64 %47
  store i8 %49, ptr %53, align 1
  %54 = add nuw nsw i32 %.093, 1
  %55 = load ptr, ptr %10, align 8
  %56 = load ptr, ptr %55, align 8
  %57 = tail call i32 %56(ptr %.fca.1.extract) #36
  %58 = icmp slt i32 %54, %57
  br i1 %58, label %._crit_edge, label %._crit_edge.thread

._crit_edge.thread:                               ; preds = %._crit_edge, %20, %4
  %.sroa.phi = phi ptr [ %.sroa.188, %4 ], [ %.sroa.1, %20 ], [ %.sroa.1, %._crit_edge ]
  %.sroa.phi76 = phi ptr [ %.sroa.289, %4 ], [ %.sroa.2, %20 ], [ %.sroa.2, %._crit_edge ]
  %.sroa.phi79 = phi ptr [ %.sroa.390, %4 ], [ %.sroa.3, %20 ], [ %.sroa.3, %._crit_edge ]
  %59 = phi ptr [ %.sroa.087, %4 ], [ %.sroa.085, %20 ], [ %.sroa.085, %._crit_edge ]
  %60 = phi ptr [ %5, %4 ], [ %6, %20 ], [ %6, %._crit_edge ]
  %61 = phi ptr [ %.sroa.091, %4 ], [ %.sroa.086, %20 ], [ %.sroa.086, %._crit_edge ]
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %62 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %63 = load ptr, ptr %9, align 8
  %64 = load ptr, ptr %63, align 8
  %65 = tail call { ptr } %64(ptr %.fca.1.extract) #36
  %66 = extractvalue { ptr } %65, 0
  store ptr %66, ptr %61, align 8
  %67 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %68 = load ptr, ptr %10, align 8
  %69 = load ptr, ptr %68, align 8
  %70 = tail call i32 %69(ptr %.fca.1.extract) #36
  %71 = sext i32 %70 to i64
  %72 = getelementptr i8, ptr %66, i64 %71
  store i8 %3, ptr %72, align 1
  %73 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %74 = load ptr, ptr %10, align 8
  %75 = load ptr, ptr %74, align 8
  %76 = tail call i32 %75(ptr %.fca.1.extract) #36
  store i32 %76, ptr %60, align 4
  %77 = add i32 %76, 1
  %78 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %79 = getelementptr i8, ptr %74, i64 8
  %80 = load ptr, ptr %79, align 8
  tail call void %80(ptr %.fca.1.extract, i32 %77) #35
  store ptr %.fca.0.extract, ptr %59, align 8
  store ptr %.fca.1.extract, ptr %.sroa.phi, align 8
  store ptr %.fca.2.extract, ptr %.sroa.phi76, align 8
  store i32 %offset.i.i, ptr %.sroa.phi79, align 8
  %hash_coef.i.i26 = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i27 = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i28 = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i29 = mul i64 %hash_coef.i.i26, 6499063144389013426
  %shifted.i.i.i30 = lshr i64 %product.i.i.i29, 32
  %xored.i.i.i31 = xor i64 %shifted.i.i.i30, %product.i.i.i29
  %hash.i.i.i32 = and i64 %xored.i.i.i31, %tbl_size.i.i27
  %offset_ptr.i.i33 = getelementptr i32, ptr %offset_tbl.i.i28, i64 %hash.i.i.i32
  %offset.i.i34 = load i32, ptr %offset_ptr.i.i33, align 4
  store i32 %offset.i.i34, ptr %.sroa.phi79, align 8
  %81 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %82 = insertvalue { ptr, ptr, ptr, i32 } %81, ptr %.fca.1.extract, 1
  %83 = insertvalue { ptr, ptr, ptr, i32 } %82, ptr %.fca.2.extract, 2
  %84 = insertvalue { ptr, ptr, ptr, i32 } %83, i32 %offset.i.i34, 3
  ret { ptr, ptr, ptr, i32 } %84
}

define { ptr, ptr, ptr, i32 } @String_extend_strString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) {
  %5 = alloca [0 x ptr], align 8
  %.sroa.0168 = alloca ptr, align 8
  %.sroa.1169 = alloca ptr, align 8
  %.sroa.2170 = alloca ptr, align 8
  %.sroa.3171 = alloca i32, align 8
  %.sroa.0167 = alloca ptr, align 8
  %.sroa.1 = alloca ptr, align 8
  %.sroa.2 = alloca ptr, align 8
  %.sroa.3 = alloca i32, align 8
  %.fca.0.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract12, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %.fca.0.extract11 = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i75 = getelementptr i8, ptr %.fca.0.extract11, i64 8
  %tbl_size_ptr.i.i76 = getelementptr i8, ptr %.fca.0.extract11, i64 16
  %offset_tbl_ptr.i.i77 = getelementptr i8, ptr %.fca.0.extract11, i64 40
  %hash_coef.i.i78 = load i64, ptr %hash_coef_ptr.i.i75, align 4
  %tbl_size.i.i79 = load i64, ptr %tbl_size_ptr.i.i76, align 4
  %offset_tbl.i.i80 = load ptr, ptr %offset_tbl_ptr.i.i77, align 8
  %product.i.i.i81 = mul i64 %hash_coef.i.i78, 6499063144389013426
  %shifted.i.i.i82 = lshr i64 %product.i.i.i81, 32
  %xored.i.i.i83 = xor i64 %shifted.i.i.i82, %product.i.i.i81
  %hash.i.i.i84 = and i64 %xored.i.i.i83, %tbl_size.i.i79
  %offset_ptr.i.i85 = getelementptr i32, ptr %offset_tbl.i.i80, i64 %hash.i.i.i84
  %offset.i.i86 = load i32, ptr %offset_ptr.i.i85, align 4
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract11, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %.fca.1.extract, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %.fca.2.extract, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i86, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5) #38
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract11) #38
  %12 = sext i32 %offset.i.i86 to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract11, i64 %12
  %14 = getelementptr i8, ptr %13, i64 56
  %15 = load ptr, ptr %14, align 8
  %result.i = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly %5) #16
  %16 = call { ptr } %result.i({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5) #7
  %.fca.0.extract = extractvalue { ptr } %16, 0
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract11)
  %19 = getelementptr i8, ptr %13, i64 40
  %20 = load ptr, ptr %19, align 8
  %result.i88 = call ptr %20({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly %5) #16
  %21 = call i32 %result.i88({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %5) #7
  %22 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract12)
  %23 = sext i32 %offset.i.i to i64
  %24 = getelementptr ptr, ptr %.fca.0.extract12, i64 %23
  %25 = getelementptr i8, ptr %24, i64 8
  %26 = load ptr, ptr %25, align 8
  %27 = load ptr, ptr %26, align 8
  %28 = call i32 %27(ptr %.fca.1.extract13) #36
  %29 = add i32 %28, %21
  %30 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract12)
  %31 = getelementptr i8, ptr %24, i64 16
  %32 = load ptr, ptr %31, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call i32 %33(ptr %.fca.1.extract13) #36
  %35 = icmp slt i32 %29, %34
  %36 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %37 = call i32 %27(ptr %.fca.1.extract13) #36
  br i1 %35, label %38, label %59

38:                                               ; preds = %4
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %40 = call i32 %27(ptr %.fca.1.extract13) #36
  %41 = add i32 %40, %21
  %42 = icmp slt i32 %37, %41
  br i1 %42, label %._crit_edge.lr.ph, label %._crit_edge.thread

._crit_edge.lr.ph:                                ; preds = %38
  %43 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph, %._crit_edge
  %.0181 = phi i32 [ %37, %._crit_edge.lr.ph ], [ %52, %._crit_edge ]
  %.068180 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %53, %._crit_edge ]
  %44 = sext i32 %.068180 to i64
  %45 = getelementptr i8, ptr %.fca.0.extract, i64 %44
  %46 = load i8, ptr %45, align 1
  %47 = load ptr, ptr %24, align 8
  %48 = load ptr, ptr %47, align 8
  %49 = call { ptr } %48(ptr %.fca.1.extract13) #36
  %.fca.0.extract57 = extractvalue { ptr } %49, 0
  %50 = sext i32 %.0181 to i64
  %51 = getelementptr i8, ptr %.fca.0.extract57, i64 %50
  store i8 %46, ptr %51, align 1
  %52 = add nsw i32 %.0181, 1
  %53 = add i32 %.068180, 1
  %54 = load ptr, ptr %25, align 8
  %55 = load ptr, ptr %54, align 8
  %56 = call i32 %55(ptr %.fca.1.extract13) #36
  %57 = add i32 %56, %21
  %58 = icmp slt i32 %52, %57
  br i1 %58, label %._crit_edge, label %._crit_edge.thread

59:                                               ; preds = %4
  %60 = add i32 %37, %21
  %61 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %62 = getelementptr i8, ptr %32, i64 8
  %63 = load ptr, ptr %62, align 8
  call void %63(ptr %.fca.1.extract13, i32 %60) #35
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %65 = load ptr, ptr %24, align 8
  %66 = load ptr, ptr %65, align 8
  %67 = call { ptr } %66(ptr %.fca.1.extract13) #36
  %.fca.0.extract49 = extractvalue { ptr } %67, 0
  %68 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %69 = load ptr, ptr %31, align 8
  %70 = load ptr, ptr %69, align 8
  %71 = call i32 %70(ptr %.fca.1.extract13) #36
  %72 = sext i32 %71 to i64
  %result.i89 = call noalias ptr @bump_malloc_inner(i64 noundef %72, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %73 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %74 = load ptr, ptr %24, align 8
  %75 = getelementptr i8, ptr %74, i64 8
  %76 = load ptr, ptr %75, align 8
  %77 = insertvalue { ptr } undef, ptr %result.i89, 0
  call void %76(ptr %.fca.1.extract13, { ptr } %77) #35
  %78 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %79 = load ptr, ptr %25, align 8
  %80 = load ptr, ptr %79, align 8
  %81 = call i32 %80(ptr %.fca.1.extract13) #36
  %82 = add i32 %81, %21
  %83 = icmp sgt i32 %82, 0
  br i1 %83, label %.lr.ph, label %._crit_edge.thread

.lr.ph:                                           ; preds = %59
  %84 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  br label %85

85:                                               ; preds = %.lr.ph, %._crit_edge2
  %86 = phi ptr [ %80, %.lr.ph ], [ %110, %._crit_edge2 ]
  %.070178 = phi i32 [ 0, %.lr.ph ], [ %.171, %._crit_edge2 ]
  %.072177 = phi i32 [ 0, %.lr.ph ], [ %.173, %._crit_edge2 ]
  %87 = call i32 %86(ptr %.fca.1.extract13) #36
  %88 = icmp slt i32 %.070178, %87
  br i1 %88, label %89, label %98

89:                                               ; preds = %85
  %90 = zext nneg i32 %.070178 to i64
  %91 = getelementptr i8, ptr %.fca.0.extract49, i64 %90
  %92 = load i8, ptr %91, align 1
  %93 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %94 = load ptr, ptr %24, align 8
  %95 = load ptr, ptr %94, align 8
  %96 = call { ptr } %95(ptr %.fca.1.extract13) #36
  %.fca.0.extract29 = extractvalue { ptr } %96, 0
  %97 = getelementptr i8, ptr %.fca.0.extract29, i64 %90
  store i8 %92, ptr %97, align 1
  br label %._crit_edge2

98:                                               ; preds = %85
  %99 = sext i32 %.072177 to i64
  %100 = getelementptr i8, ptr %.fca.0.extract, i64 %99
  %101 = load i8, ptr %100, align 1
  %102 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %103 = load ptr, ptr %24, align 8
  %104 = load ptr, ptr %103, align 8
  %105 = call { ptr } %104(ptr %.fca.1.extract13) #36
  %.fca.0.extract24 = extractvalue { ptr } %105, 0
  %106 = zext nneg i32 %.070178 to i64
  %107 = getelementptr i8, ptr %.fca.0.extract24, i64 %106
  store i8 %101, ptr %107, align 1
  %108 = add i32 %.072177, 1
  br label %._crit_edge2

._crit_edge2:                                     ; preds = %89, %98
  %.173 = phi i32 [ %.072177, %89 ], [ %108, %98 ]
  %.171 = add nuw nsw i32 %.070178, 1
  %109 = load ptr, ptr %25, align 8
  %110 = load ptr, ptr %109, align 8
  %111 = call i32 %110(ptr %.fca.1.extract13) #36
  %112 = add i32 %111, %21
  %113 = icmp slt i32 %.171, %112
  br i1 %113, label %85, label %._crit_edge.thread

._crit_edge.thread:                               ; preds = %._crit_edge2, %._crit_edge, %59, %38
  %114 = phi ptr [ %27, %38 ], [ %80, %59 ], [ %55, %._crit_edge ], [ %110, %._crit_edge2 ]
  %115 = phi ptr [ %26, %38 ], [ %79, %59 ], [ %54, %._crit_edge ], [ %109, %._crit_edge2 ]
  %.sroa.phi = phi ptr [ %.sroa.1169, %38 ], [ %.sroa.1, %59 ], [ %.sroa.1169, %._crit_edge ], [ %.sroa.1, %._crit_edge2 ]
  %.sroa.phi158 = phi ptr [ %.sroa.2170, %38 ], [ %.sroa.2, %59 ], [ %.sroa.2170, %._crit_edge ], [ %.sroa.2, %._crit_edge2 ]
  %.sroa.phi161 = phi ptr [ %.sroa.3171, %38 ], [ %.sroa.3, %59 ], [ %.sroa.3171, %._crit_edge ], [ %.sroa.3, %._crit_edge2 ]
  %116 = phi ptr [ %.sroa.0168, %38 ], [ %.sroa.0167, %59 ], [ %.sroa.0168, %._crit_edge ], [ %.sroa.0167, %._crit_edge2 ]
  %.fca.2.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %117 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %118 = call i32 %114(ptr %.fca.1.extract13) #36
  %119 = add i32 %118, %21
  %120 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract12)
  %121 = getelementptr i8, ptr %115, i64 8
  %122 = load ptr, ptr %121, align 8
  call void %122(ptr %.fca.1.extract13, i32 %119) #35
  store ptr %.fca.0.extract12, ptr %116, align 8
  store ptr %.fca.1.extract13, ptr %.sroa.phi, align 8
  store ptr %.fca.2.extract14, ptr %.sroa.phi158, align 8
  store i32 %offset.i.i, ptr %.sroa.phi161, align 8
  %hash_coef.i.i94 = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i95 = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i96 = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i97 = mul i64 %hash_coef.i.i94, 6499063144389013426
  %shifted.i.i.i98 = lshr i64 %product.i.i.i97, 32
  %xored.i.i.i99 = xor i64 %shifted.i.i.i98, %product.i.i.i97
  %hash.i.i.i100 = and i64 %xored.i.i.i99, %tbl_size.i.i95
  %offset_ptr.i.i101 = getelementptr i32, ptr %offset_tbl.i.i96, i64 %hash.i.i.i100
  %offset.i.i102 = load i32, ptr %offset_ptr.i.i101, align 4
  store i32 %offset.i.i102, ptr %.sroa.phi161, align 8
  %123 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract12, 0
  %124 = insertvalue { ptr, ptr, ptr, i32 } %123, ptr %.fca.1.extract13, 1
  %125 = insertvalue { ptr, ptr, ptr, i32 } %124, ptr %.fca.2.extract14, 2
  %126 = insertvalue { ptr, ptr, ptr, i32 } %125, i32 %offset.i.i102, 3
  ret { ptr, ptr, ptr, i32 } %126
}

define i8 @String__index_xPtri32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call i32 %10(ptr %.fca.1.extract) #36
  %12 = add i32 %11, -1
  %13 = icmp sgt i32 %3, %12
  br i1 %13, label %14, label %._crit_edge

14:                                               ; preds = %4
  %current_coroutine.i = load ptr, ptr @current_coroutine, align 8
  %into_callee_buf.i = getelementptr i8, ptr %current_coroutine.i, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf.i, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #41
  br label %._crit_edge

._crit_edge:                                      ; preds = %4, %14
  %15 = icmp sgt i32 %3, -1
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract) #40
  br i1 %15, label %17, label %23

17:                                               ; preds = %._crit_edge
  %18 = load ptr, ptr %7, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = tail call { ptr } %19(ptr %.fca.1.extract) #36
  %.fca.0.extract18 = extractvalue { ptr } %20, 0
  %21 = zext nneg i32 %3 to i64
  %22 = getelementptr i8, ptr %.fca.0.extract18, i64 %21
  br label %40

23:                                               ; preds = %._crit_edge
  %24 = load ptr, ptr %8, align 8
  %25 = load ptr, ptr %24, align 8
  %26 = tail call i32 %25(ptr %.fca.1.extract) #36
  %27 = add i32 %26, %3
  %28 = icmp slt i32 %27, 0
  br i1 %28, label %29, label %._crit_edge1

29:                                               ; preds = %23
  %current_coroutine.i22 = load ptr, ptr @current_coroutine, align 8
  %into_callee_buf.i23 = getelementptr i8, ptr %current_coroutine.i22, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf.i23, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #41
  %.pre = load ptr, ptr %8, align 8
  %.pre36 = load ptr, ptr %.pre, align 8
  br label %._crit_edge1

._crit_edge1:                                     ; preds = %23, %29
  %30 = phi ptr [ %25, %23 ], [ %.pre36, %29 ]
  %31 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %32 = load ptr, ptr %7, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = tail call { ptr } %33(ptr %.fca.1.extract) #36
  %.fca.0.extract11 = extractvalue { ptr } %34, 0
  %35 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %36 = tail call i32 %30(ptr %.fca.1.extract) #36
  %37 = add i32 %36, %3
  %38 = sext i32 %37 to i64
  %39 = getelementptr i8, ptr %.fca.0.extract11, i64 %38
  br label %40

40:                                               ; preds = %._crit_edge1, %17
  %.reg2mem20.0.in = phi ptr [ %22, %17 ], [ %39, %._crit_edge1 ]
  %.reg2mem20.0 = load i8, ptr %.reg2mem20.0.in, align 1
  ret i8 %.reg2mem20.0
}

; Function Attrs: nounwind
define noundef i1 @String__EQ_otherString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #7 {
  %5 = alloca [0 x ptr], align 8
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract3 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !662
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !662
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !662
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !662
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i27 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i28 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i29 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i30 = load i64, ptr %hash_coef_ptr.i.i27, align 4, !noalias !665
  %tbl_size.i.i31 = load i64, ptr %tbl_size_ptr.i.i28, align 4, !noalias !665
  %offset_tbl.i.i32 = load ptr, ptr %offset_tbl_ptr.i.i29, align 8, !noalias !665
  %product.i.i.i33 = mul i64 %hash_coef.i.i30, 6499063144389013426
  %shifted.i.i.i34 = lshr i64 %product.i.i.i33, 32
  %xored.i.i.i35 = xor i64 %shifted.i.i.i34, %product.i.i.i33
  %hash.i.i.i36 = and i64 %xored.i.i.i35, %tbl_size.i.i31
  %offset_ptr.i.i37 = getelementptr i32, ptr %offset_tbl.i.i32, i64 %hash.i.i.i36
  %offset.i.i38 = load i32, ptr %offset_ptr.i.i37, align 4, !noalias !665
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract2) #38
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract2, i64 %7
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = load ptr, ptr %10, align 8
  %12 = tail call i32 %11(ptr %.fca.1.extract3) #36
  %13 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.1.extract, 1
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.2.extract, 2
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, i32 %offset.i.i38, 3
  %17 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract)
  %19 = sext i32 %offset.i.i38 to i64
  %20 = getelementptr ptr, ptr %.fca.0.extract, i64 %19
  %21 = getelementptr i8, ptr %20, i64 40
  %22 = load ptr, ptr %21, align 8
  %result.i = call ptr %22({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %5) #16
  %23 = call i32 %result.i({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 %5) #7
  %.not = icmp eq i32 %12, %23
  br i1 %.not, label %.preheader, label %.thread

.preheader:                                       ; preds = %4
  %24 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract2)
  %25 = getelementptr i8, ptr %20, i64 56
  br label %26

26:                                               ; preds = %.preheader, %30
  %.0 = phi i32 [ %44, %30 ], [ 0, %.preheader ]
  %27 = load ptr, ptr %9, align 8
  %28 = load ptr, ptr %27, align 8
  %29 = call i32 %28(ptr %.fca.1.extract3) #36
  %.not52.not.not = icmp sge i32 %.0, %29
  br i1 %.not52.not.not, label %.thread, label %30

30:                                               ; preds = %26
  %31 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract2)
  %32 = load ptr, ptr %8, align 8
  %33 = load ptr, ptr %32, align 8
  %34 = call { ptr } %33(ptr %.fca.1.extract3) #36
  %.fca.0.extract17 = extractvalue { ptr } %34, 0
  %35 = zext nneg i32 %.0 to i64
  %36 = getelementptr i8, ptr %.fca.0.extract17, i64 %35
  %37 = load i8, ptr %36, align 1
  %38 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %5)
  %39 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %40 = load ptr, ptr %25, align 8
  %result.i40 = call ptr %40({ ptr, ptr, ptr, i32 } %16, ptr nocapture nofree noundef nonnull readonly %5) #16
  %41 = call { ptr } %result.i40({ ptr, ptr, ptr, i32 } %16, { ptr, ptr, ptr, i32 } %16, ptr nonnull align 8 %5) #7
  %.fca.0.extract14 = extractvalue { ptr } %41, 0
  %42 = getelementptr i8, ptr %.fca.0.extract14, i64 %35
  %43 = load i8, ptr %42, align 1
  %.not25 = icmp eq i8 %37, %43
  %44 = add nuw nsw i32 %.0, 1
  br i1 %.not25, label %26, label %.thread

.thread:                                          ; preds = %26, %30, %4
  %.reg2mem42.0 = phi i1 [ false, %4 ], [ %.not52.not.not, %30 ], [ %.not52.not.not, %26 ]
  ret i1 %.reg2mem42.0
}

; Function Attrs: mustprogress nounwind willreturn
define { ptr, i8 } @String_pop_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract5 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract4, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !668
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !668
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !668
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !668
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract4) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract4, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract5) #36
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %30, label %12

12:                                               ; preds = %3
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #40
  %14 = tail call i32 %9(ptr %.fca.1.extract5) #36
  %15 = add i32 %14, -1
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #40
  %17 = getelementptr i8, ptr %8, i64 8
  %18 = load ptr, ptr %17, align 8
  tail call void %18(ptr %.fca.1.extract5, i32 %15) #35
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #40
  %20 = load ptr, ptr %6, align 8
  %21 = load ptr, ptr %20, align 8
  %22 = tail call { ptr } %21(ptr %.fca.1.extract5) #36
  %.fca.0.extract10 = extractvalue { ptr } %22, 0
  %23 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract4) #40
  %24 = load ptr, ptr %7, align 8
  %25 = load ptr, ptr %24, align 8
  %26 = tail call i32 %25(ptr %.fca.1.extract5) #36
  %27 = sext i32 %26 to i64
  %28 = getelementptr i8, ptr %.fca.0.extract10, i64 %27
  %29 = load i8, ptr %28, align 1
  br label %30

30:                                               ; preds = %3, %12
  %.reg2mem19.sroa.0.0 = phi ptr [ @i8_typ, %12 ], [ @nil_typ, %3 ]
  %.reg2mem19.sroa.3.0 = phi i8 [ %29, %12 ], [ undef, %3 ]
  %.reload20.fca.0.insert = insertvalue { ptr, i8 } poison, ptr %.reg2mem19.sroa.0.0, 0
  %.reload20.fca.1.insert = insertvalue { ptr, i8 } %.reload20.fca.0.insert, i8 %.reg2mem19.sroa.3.0, 1
  ret { ptr, i8 } %.reload20.fca.1.insert
}

define { ptr, ptr, ptr, i32 } @String_copy_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract) #38
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract) #36
  %11 = sext i32 %10 to i64
  %result.i = tail call noalias ptr @bump_malloc_inner(i64 noundef %11, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %13 = load ptr, ptr %7, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = tail call i32 %14(ptr %.fca.1.extract) #36
  %16 = icmp sgt i32 %15, 0
  br i1 %16, label %._crit_edge.lr.ph, label %._crit_edge1._crit_edge

._crit_edge.lr.ph:                                ; preds = %3
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph, %._crit_edge
  %.083 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %25, %._crit_edge ]
  %18 = load ptr, ptr %6, align 8
  %19 = load ptr, ptr %18, align 8
  %20 = tail call { ptr } %19(ptr %.fca.1.extract) #36
  %.fca.0.extract24 = extractvalue { ptr } %20, 0
  %21 = zext nneg i32 %.083 to i64
  %22 = getelementptr i8, ptr %.fca.0.extract24, i64 %21
  %23 = load i8, ptr %22, align 1
  %24 = getelementptr i8, ptr %result.i, i64 %21
  store i8 %23, ptr %24, align 1
  %25 = add nuw nsw i32 %.083, 1
  %26 = load ptr, ptr %7, align 8
  %27 = load ptr, ptr %26, align 8
  %28 = tail call i32 %27(ptr %.fca.1.extract) #36
  %29 = icmp slt i32 %25, %28
  br i1 %29, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge1._crit_edge:                          ; preds = %._crit_edge, %3
  %30 = phi ptr [ %14, %3 ], [ %27, %._crit_edge ]
  %31 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %32 = tail call i32 %30(ptr %.fca.1.extract) #36
  %33 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %34 = tail call i32 %30(ptr %.fca.1.extract) #36
  %result.i29 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %35 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %36 = load ptr, ptr %7, align 8
  %37 = load ptr, ptr %36, align 8
  %38 = tail call i32 %37(ptr %.fca.1.extract) #36
  %39 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %40 = tail call i32 %37(ptr %.fca.1.extract) #36
  %41 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i29, 1
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr undef, 2
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, i32 10, 3
  store ptr %result.i, ptr %result.i29, align 8
  %44 = getelementptr i8, ptr %result.i29, i64 8
  store i32 %38, ptr %44, align 4
  %45 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String) #34
  %46 = getelementptr i8, ptr %result.i29, i64 12
  store i32 %40, ptr %46, align 4
  ret { ptr, ptr, ptr, i32 } %43
}

; Function Attrs: nounwind
define { ptr } @String_c_string_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !671
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !671
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !671
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !671
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract) #38
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = getelementptr i8, ptr %6, i64 8
  %8 = load ptr, ptr %7, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = tail call i32 %9(ptr %.fca.1.extract) #36
  %11 = add i32 %10, 1
  %12 = sext i32 %11 to i64
  %result.i = tail call noalias ptr @bump_malloc_inner(i64 noundef %12, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %13 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %14 = load ptr, ptr %7, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = tail call i32 %15(ptr %.fca.1.extract) #36
  %17 = icmp sgt i32 %16, 0
  br i1 %17, label %._crit_edge.lr.ph, label %._crit_edge1._crit_edge

._crit_edge.lr.ph:                                ; preds = %3
  %18 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.lr.ph, %._crit_edge
  %.029 = phi i32 [ 0, %._crit_edge.lr.ph ], [ %26, %._crit_edge ]
  %19 = load ptr, ptr %6, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = tail call { ptr } %20(ptr %.fca.1.extract) #36
  %.fca.0.extract15 = extractvalue { ptr } %21, 0
  %22 = zext nneg i32 %.029 to i64
  %23 = getelementptr i8, ptr %.fca.0.extract15, i64 %22
  %24 = load i8, ptr %23, align 1
  %25 = getelementptr i8, ptr %result.i, i64 %22
  store i8 %24, ptr %25, align 1
  %26 = add nuw nsw i32 %.029, 1
  %27 = load ptr, ptr %7, align 8
  %28 = load ptr, ptr %27, align 8
  %29 = tail call i32 %28(ptr %.fca.1.extract) #36
  %30 = icmp slt i32 %26, %29
  br i1 %30, label %._crit_edge, label %._crit_edge1._crit_edge

._crit_edge1._crit_edge:                          ; preds = %._crit_edge, %3
  %31 = phi ptr [ %15, %3 ], [ %28, %._crit_edge ]
  %32 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull %.fca.0.extract)
  %33 = tail call i32 %31(ptr %.fca.1.extract) #36
  %34 = sext i32 %33 to i64
  %35 = getelementptr i8, ptr %result.i, i64 %34
  store i8 0, ptr %35, align 1
  %36 = insertvalue { ptr } undef, ptr %result.i, 0
  ret { ptr } %36
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: read, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @String_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #15 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %result.i7 = tail call noalias dereferenceable_or_null(40) ptr @bump_malloc_inner(i64 noundef 40, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %hash_coef.i.i12 = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !373
  %tbl_size.i.i13 = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !373
  %offset_tbl.i.i14 = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !373
  %product.i.i.i15 = mul i64 %hash_coef.i.i12, 6499063144389013426
  %shifted.i.i.i16 = lshr i64 %product.i.i.i15, 32
  %xored.i.i.i17 = xor i64 %shifted.i.i.i16, %product.i.i.i15
  %hash.i.i.i18 = and i64 %xored.i.i.i17, %tbl_size.i.i13
  %offset_ptr.i.i19 = getelementptr i32, ptr %offset_tbl.i.i14, i64 %hash.i.i.i18
  %offset.i.i20 = load i32, ptr %offset_ptr.i.i19, align 4, !noalias !373
  %4 = insertvalue { ptr, ptr, ptr, i32 } { ptr @StringIterator, ptr undef, ptr undef, i32 undef }, ptr %result.i7, 1
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr undef, 2
  store ptr %.fca.0.extract, ptr %result.i7, align 8
  %6 = getelementptr inbounds i8, ptr %result.i7, i64 8
  store ptr %.fca.1.extract, ptr %6, align 8
  %7 = getelementptr inbounds i8, ptr %result.i7, i64 16
  store ptr %.fca.2.extract, ptr %7, align 8
  %8 = getelementptr inbounds i8, ptr %result.i7, i64 24
  store i32 %offset.i.i20, ptr %8, align 4
  %9 = tail call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull @StringIterator) #34
  %10 = insertvalue { ptr, ptr, ptr, i32 } %5, i32 16, 3
  ret { ptr, ptr, ptr, i32 } %10
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define { ptr, ptr, ptr, i32 } @String_repr_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #16 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !373
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !373
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !373
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i13 = load i32, ptr %offset_ptr.i.i, align 4, !noalias !674
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %5 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %.fca.1.extract, 1
  %6 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr %.fca.2.extract, 2
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, i32 %offset.i.i13, 3
  ret { ptr, ptr, ptr, i32 } %7
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_StringIterator(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 40, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @StringIterator_B_init_strString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @StringIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 120
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @StringIterator_init_strString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #2 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !677
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !677
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !677
  %product.i.i.i = mul i64 %hash_coef.i.i, -7260570988945952630
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !677
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i10 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i13 = load i64, ptr %hash_coef_ptr.i.i10, align 4, !noalias !373
  %tbl_size.i.i14 = load i64, ptr %tbl_size_ptr.i.i11, align 4, !noalias !373
  %offset_tbl.i.i15 = load ptr, ptr %offset_tbl_ptr.i.i12, align 8, !noalias !373
  %product.i.i.i16 = mul i64 %hash_coef.i.i13, 6499063144389013426
  %shifted.i.i.i17 = lshr i64 %product.i.i.i16, 32
  %xored.i.i.i18 = xor i64 %shifted.i.i.i17, %product.i.i.i16
  %hash.i.i.i19 = and i64 %xored.i.i.i18, %tbl_size.i.i14
  %offset_ptr.i.i20 = getelementptr i32, ptr %offset_tbl.i.i15, i64 %hash.i.i.i19
  %offset.i.i35 = load i32, ptr %offset_ptr.i.i20, align 4, !noalias !680
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef %.fca.0.extract1) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract1, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  %11 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr %.fca.1.extract, 1
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.2.extract, 2
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, i32 %offset.i.i35, 3
  tail call void %10(ptr %.fca.1.extract2, { ptr, ptr, ptr, i32 } %14) #35
  %15 = tail call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef %.fca.0.extract1) #34
  %16 = getelementptr i8, ptr %7, i64 8
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  tail call void %19(ptr %.fca.1.extract2, i32 0) #35
  ret void
}

; Function Attrs: nounwind
define { ptr, i160 } @StringIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract12 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract10, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !683
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !683
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !683
  %product.i.i.i = mul i64 %hash_coef.i.i, -7260570988945952630
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !683
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef %.fca.0.extract10) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract10, i64 %6
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call i32 %10(ptr %.fca.1.extract12) #36
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef %.fca.0.extract10) #34
  %13 = load ptr, ptr %7, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = tail call { ptr, ptr, ptr, i32 } %14(ptr %.fca.1.extract12) #36
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 3
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %.fca.3.extract, 3
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #34
  %21 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract) #34
  %22 = sext i32 %.fca.3.extract to i64
  %23 = getelementptr ptr, ptr %.fca.0.extract, i64 %22
  %24 = getelementptr i8, ptr %23, i64 40
  %25 = load ptr, ptr %24, align 8
  %result.i = call ptr %25({ ptr, ptr, ptr, i32 } %19, ptr nocapture nofree noundef nonnull readonly %4) #16
  %26 = call i32 %result.i({ ptr, ptr, ptr, i32 } %19, { ptr, ptr, ptr, i32 } %19, ptr nonnull align 8 %4) #7
  %27 = icmp slt i32 %11, %26
  br i1 %27, label %28, label %81

28:                                               ; preds = %3
  %29 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %30 = load ptr, ptr %8, align 8
  %31 = load ptr, ptr %30, align 8
  %32 = call i32 %31(ptr %.fca.1.extract12) #36
  %33 = add i32 %32, 1
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %35 = getelementptr i8, ptr %30, i64 8
  %36 = load ptr, ptr %35, align 8
  call void %36(ptr %.fca.1.extract12, i32 %33) #35
  %37 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %38 = load ptr, ptr %7, align 8
  %39 = load ptr, ptr %38, align 8
  %40 = call { ptr, ptr, ptr, i32 } %39(ptr %.fca.1.extract12) #36
  %.fca.0.extract45 = extractvalue { ptr, ptr, ptr, i32 } %40, 0
  %.fca.1.extract47 = extractvalue { ptr, ptr, ptr, i32 } %40, 1
  %.fca.2.extract49 = extractvalue { ptr, ptr, ptr, i32 } %40, 2
  %.fca.3.extract51 = extractvalue { ptr, ptr, ptr, i32 } %40, 3
  %41 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract45, 0
  %42 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %.fca.1.extract47, 1
  %43 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %.fca.2.extract49, 2
  %44 = insertvalue { ptr, ptr, ptr, i32 } %43, i32 %.fca.3.extract51, 3
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract45)
  %47 = sext i32 %.fca.3.extract51 to i64
  %48 = getelementptr ptr, ptr %.fca.0.extract45, i64 %47
  %49 = getelementptr i8, ptr %48, i64 56
  %50 = load ptr, ptr %49, align 8
  %result.i56 = call ptr %50({ ptr, ptr, ptr, i32 } %44, ptr nocapture nofree noundef nonnull readonly %4) #16
  %51 = call { ptr } %result.i56({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr nonnull align 8 %4) #7
  %52 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %53 = load ptr, ptr %8, align 8
  %54 = load ptr, ptr %53, align 8
  %55 = call i32 %54(ptr %.fca.1.extract12) #36
  %result.i58 = call noalias dereferenceable_or_null(1) ptr @bump_malloc_inner(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %56 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %57 = load ptr, ptr %7, align 8
  %58 = load ptr, ptr %57, align 8
  %59 = call { ptr, ptr, ptr, i32 } %58(ptr %.fca.1.extract12) #36
  %.fca.0.extract27 = extractvalue { ptr, ptr, ptr, i32 } %59, 0
  %.fca.1.extract29 = extractvalue { ptr, ptr, ptr, i32 } %59, 1
  %.fca.2.extract31 = extractvalue { ptr, ptr, ptr, i32 } %59, 2
  %.fca.3.extract33 = extractvalue { ptr, ptr, ptr, i32 } %59, 3
  %60 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract27, 0
  %61 = insertvalue { ptr, ptr, ptr, i32 } %60, ptr %.fca.1.extract29, 1
  %62 = insertvalue { ptr, ptr, ptr, i32 } %61, ptr %.fca.2.extract31, 2
  %63 = insertvalue { ptr, ptr, ptr, i32 } %62, i32 %.fca.3.extract33, 3
  %64 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4)
  %65 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract27)
  %66 = sext i32 %.fca.3.extract33 to i64
  %67 = getelementptr ptr, ptr %.fca.0.extract27, i64 %66
  %68 = getelementptr i8, ptr %67, i64 56
  %69 = load ptr, ptr %68, align 8
  %result.i59 = call ptr %69({ ptr, ptr, ptr, i32 } %63, ptr nocapture nofree noundef nonnull readonly %4) #16
  %70 = call { ptr } %result.i59({ ptr, ptr, ptr, i32 } %63, { ptr, ptr, ptr, i32 } %63, ptr nonnull align 8 %4) #7
  %.fca.0.extract24 = extractvalue { ptr } %70, 0
  %71 = call ptr @llvm.invariant.start.p0(i64 noundef 48, ptr nocapture nofree noundef nonnull %.fca.0.extract10)
  %72 = load ptr, ptr %8, align 8
  %73 = load ptr, ptr %72, align 8
  %74 = call i32 %73(ptr %.fca.1.extract12) #36
  %75 = add i32 %74, -1
  %76 = sext i32 %75 to i64
  %77 = getelementptr i8, ptr %.fca.0.extract24, i64 %76
  %78 = load i8, ptr %77, align 1
  %79 = call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef nonnull @Character) #34
  store i8 %78, ptr %result.i58, align 1
  %80 = ptrtoint ptr %result.i58 to i64
  %.sroa.3.8.insert.ext = zext i64 %80 to i160
  %.sroa.3.8.insert.insert = or disjoint i160 %.sroa.3.8.insert.ext, 3402823669209384634633746074317682114560
  br label %81

81:                                               ; preds = %3, %28
  %.reg2mem25.sroa.0.0 = phi ptr [ @Character, %28 ], [ @nil_typ, %3 ]
  %.reg2mem25.sroa.3.0 = phi i160 [ %.sroa.3.8.insert.insert, %28 ], [ undef, %3 ]
  %.reload26.fca.0.insert = insertvalue { ptr, i160 } poison, ptr %.reg2mem25.sroa.0.0, 0
  %.reload26.fca.1.insert = insertvalue { ptr, i160 } %.reload26.fca.0.insert, i160 %.reg2mem25.sroa.3.0, 1
  ret { ptr, i160 } %.reload26.fca.1.insert
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Character(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), i64 1 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Character_B_byte_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 104
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Character_B_init_bytePtri8({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 112
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn
define i8 @Character_byte_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #3 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !686
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !686
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !686
  %product.i.i.i = mul i64 %hash_coef.i.i, 6681222582356018452
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !686
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %.fca.0.extract) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = load ptr, ptr %7, align 8
  %9 = tail call i8 %8(ptr %.fca.1.extract) #36
  ret i8 %9
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Character_init_bytePtri8({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i8 %3) #2 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !689
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !689
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !689
  %product.i.i.i = mul i64 %hash_coef.i.i, 6681222582356018452
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !689
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %.fca.0.extract) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract, i64 %6
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 8
  %10 = load ptr, ptr %9, align 8
  tail call void %10(ptr %.fca.1.extract, i8 %3) #35
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i8 @Character_getter_byte(ptr nocapture nofree noundef nonnull readonly dereferenceable(1) %0) #5 {
  %2 = load i8, ptr %0, align 1
  ret i8 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Character_setter_byte(ptr nocapture nofree noundef nonnull writeonly dereferenceable(1) %0, i8 %1) #6 {
  store i8 %1, ptr %0, align 1
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @StringIterator_getter_index(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 32
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @StringIterator_setter_index(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 32
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @StringIterator_getter_str(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(28) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %2, 0
  %4 = getelementptr inbounds i8, ptr %0, i64 8
  %5 = load ptr, ptr %4, align 8
  %6 = insertvalue { ptr, ptr, ptr, i32 } %3, ptr %5, 1
  %7 = getelementptr inbounds i8, ptr %0, i64 16
  %8 = load ptr, ptr %7, align 8
  %9 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %8, 2
  %10 = getelementptr inbounds i8, ptr %0, i64 24
  %11 = load i32, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } %9, i32 %11, 3
  ret { ptr, ptr, ptr, i32 } %12
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @StringIterator_setter_str(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(28) %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %0, align 8
  %3 = getelementptr inbounds i8, ptr %0, i64 8
  store ptr %.fca.1.extract, ptr %3, align 8
  %4 = getelementptr inbounds i8, ptr %0, i64 16
  store ptr %.fca.2.extract, ptr %4, align 8
  %5 = getelementptr inbounds i8, ptr %0, i64 24
  store i32 %.fca.3.extract, ptr %5, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @String_getter_capacity(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 12
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_capacity(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 12
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @String_getter_length(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_length(ptr nocapture nofree writeonly %0, i32 %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  store i32 %1, ptr %3, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr } @String_getter_bytes(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %0) #5 {
  %2 = load ptr, ptr %0, align 8
  %3 = insertvalue { ptr } undef, ptr %2, 0
  ret { ptr } %3
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @String_setter_bytes(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(8) %0, { ptr } %1) #6 {
  %.fca.0.extract = extractvalue { ptr } %1, 0
  store ptr %.fca.0.extract, ptr %0, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_Exception(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 72, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_init_messageString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 144
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_init_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 152
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_set_info_line_numberPtri32_file_nameString({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(16) %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 160
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_report_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 168
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Exception_B_print_message_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 176
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Exception_init_messageString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, { ptr, ptr, ptr, i32 } %3) #2 {
  %.fca.0.extract13 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract14 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract13, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !692
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !692
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !692
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !692
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %3, 2
  %hash_coef_ptr.i.i22 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i23 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i24 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i25 = load i64, ptr %hash_coef_ptr.i.i22, align 4, !noalias !373
  %tbl_size.i.i26 = load i64, ptr %tbl_size_ptr.i.i23, align 4, !noalias !373
  %offset_tbl.i.i27 = load ptr, ptr %offset_tbl_ptr.i.i24, align 8, !noalias !373
  %product.i.i.i28 = mul i64 %hash_coef.i.i25, 6499063144389013426
  %shifted.i.i.i29 = lshr i64 %product.i.i.i28, 32
  %xored.i.i.i30 = xor i64 %shifted.i.i.i29, %product.i.i.i28
  %hash.i.i.i31 = and i64 %xored.i.i.i30, %tbl_size.i.i26
  %offset_ptr.i.i32 = getelementptr i32, ptr %offset_tbl.i.i27, i64 %hash.i.i.i31
  %offset.i.i47 = load i32, ptr %offset_ptr.i.i32, align 4, !noalias !695
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract13) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract13, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %offset.i.i47, 3
  tail call void %11(ptr %.fca.1.extract14, { ptr, ptr, ptr, i32 } %15) #35
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract13) #34
  %17 = load ptr, ptr %7, align 8
  %18 = getelementptr i8, ptr %17, i64 8
  %19 = load ptr, ptr %18, align 8
  tail call void %19(ptr %.fca.1.extract14, i32 0) #35
  %result.i = tail call noalias dereferenceable_or_null(1) ptr @bump_malloc_inner(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %result.i50 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %20 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i50, 1
  %21 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr undef, 2
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, i32 10, 3
  store ptr %result.i, ptr %result.i50, align 8
  %23 = getelementptr i8, ptr %result.i50, i64 8
  store i32 0, ptr %23, align 4
  %24 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String) #34
  %25 = getelementptr i8, ptr %result.i50, i64 12
  store i32 1, ptr %25, align 4
  %26 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract13)
  %27 = getelementptr i8, ptr %7, i64 8
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr i8, ptr %28, i64 8
  %30 = load ptr, ptr %29, align 8
  tail call void %30(ptr %.fca.1.extract14, { ptr, ptr, ptr, i32 } %22) #35
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Exception_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #2 {
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !698
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !698
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !698
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !698
  %4 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract) #34
  %5 = sext i32 %offset.i.i to i64
  %6 = getelementptr ptr, ptr %.fca.0.extract, i64 %5
  %7 = load ptr, ptr %6, align 8
  %8 = getelementptr i8, ptr %7, i64 8
  %9 = load ptr, ptr %8, align 8
  tail call void %9(ptr %.fca.1.extract, i32 0) #35
  %result.i = tail call noalias align 8 dereferenceable_or_null(7) ptr @bump_malloc_inner(i64 noundef 7, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <6 x i8> <i8 60, i8 78, i8 111, i8 110, i8 101, i8 62>, ptr %result.i, align 8
  %result.i29 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %10 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i29, 1
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr undef, 2
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 10, 3
  store ptr %result.i, ptr %result.i29, align 8
  %13 = getelementptr i8, ptr %result.i29, i64 8
  store i32 6, ptr %13, align 4
  %14 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String) #34
  %15 = getelementptr i8, ptr %result.i29, i64 12
  store i32 7, ptr %15, align 4
  %16 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract)
  %17 = getelementptr i8, ptr %6, i64 16
  %18 = load ptr, ptr %17, align 8
  %19 = getelementptr i8, ptr %18, i64 8
  %20 = load ptr, ptr %19, align 8
  tail call void %20(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %12) #35
  %result.i45 = tail call noalias dereferenceable_or_null(1) ptr @bump_malloc_inner(i64 noundef 1, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %result.i47 = tail call noalias dereferenceable_or_null(16) ptr @bump_malloc_inner(i64 noundef 16, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %21 = insertvalue { ptr, ptr, ptr, i32 } { ptr @String, ptr undef, ptr undef, i32 undef }, ptr %result.i47, 1
  %22 = insertvalue { ptr, ptr, ptr, i32 } %21, ptr undef, 2
  %23 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 10, 3
  store ptr %result.i45, ptr %result.i47, align 8
  %24 = getelementptr i8, ptr %result.i47, i64 8
  store i32 0, ptr %24, align 4
  %25 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String) #34
  %26 = getelementptr i8, ptr %result.i47, i64 12
  store i32 1, ptr %26, align 4
  %27 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract)
  %28 = getelementptr i8, ptr %6, i64 8
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr i8, ptr %29, i64 8
  %31 = load ptr, ptr %30, align 8
  tail call void %31(ptr %.fca.1.extract, { ptr, ptr, ptr, i32 } %23) #35
  ret void
}

; Function Attrs: mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none)
define void @Exception_set_info_line_numberPtri32_file_nameString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2, i32 %3, { ptr, ptr, ptr, i32 } %4) #2 {
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !701
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !701
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !701
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !701
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract1) #34
  %7 = sext i32 %offset.i.i to i64
  %8 = getelementptr ptr, ptr %.fca.0.extract1, i64 %7
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  tail call void %11(ptr %.fca.1.extract2, i32 %3) #35
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %4, 2
  %hash_coef_ptr.i.i10 = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i11 = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i12 = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i13 = load i64, ptr %hash_coef_ptr.i.i10, align 4, !noalias !373
  %tbl_size.i.i14 = load i64, ptr %tbl_size_ptr.i.i11, align 4, !noalias !373
  %offset_tbl.i.i15 = load ptr, ptr %offset_tbl_ptr.i.i12, align 8, !noalias !373
  %product.i.i.i16 = mul i64 %hash_coef.i.i13, 6499063144389013426
  %shifted.i.i.i17 = lshr i64 %product.i.i.i16, 32
  %xored.i.i.i18 = xor i64 %shifted.i.i.i17, %product.i.i.i16
  %hash.i.i.i19 = and i64 %xored.i.i.i18, %tbl_size.i.i14
  %offset_ptr.i.i20 = getelementptr i32, ptr %offset_tbl.i.i15, i64 %hash.i.i.i19
  %offset.i.i35 = load i32, ptr %offset_ptr.i.i20, align 4, !noalias !704
  %12 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract1) #34
  %13 = getelementptr i8, ptr %8, i64 8
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr i8, ptr %14, i64 8
  %16 = load ptr, ptr %15, align 8
  %17 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.1.extract, 1
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, ptr %.fca.2.extract, 2
  %20 = insertvalue { ptr, ptr, ptr, i32 } %19, i32 %offset.i.i35, 3
  tail call void %16(ptr %.fca.1.extract2, { ptr, ptr, ptr, i32 } %20) #35
  ret void
}

; Function Attrs: nounwind
define void @Exception_report_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
._crit_edge.lr.ph.i:
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract89 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract91 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract89, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract89, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract89, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !707
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !707
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !707
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !707
  %result.i = tail call noalias align 16 dereferenceable_or_null(10) ptr @bump_malloc_inner(i64 noundef 10, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <9 x i8> <i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45>, ptr %result.i, align 16
  %4 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %3) #34
  %result.i.i = tail call noalias dereferenceable_or_null(10) ptr @bump_malloc_inner(i64 noundef 10, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(9) %result.i.i, ptr noundef nonnull align 16 dereferenceable(9) %result.i, i64 9, i1 false)
  %puts = tail call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i)
  %result.i106 = tail call noalias align 32 dereferenceable_or_null(27) ptr @bump_malloc_inner(i64 noundef 27, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <26 x i8> <i8 69, i8 120, i8 99, i8 101, i8 112, i8 116, i8 105, i8 111, i8 110, i8 32, i8 116, i8 104, i8 114, i8 111, i8 119, i8 110, i8 32, i8 102, i8 114, i8 111, i8 109, i8 32, i8 102, i8 105, i8 108, i8 101>, ptr %result.i106, align 32
  %5 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %3) #34
  %result.i.i178 = tail call noalias dereferenceable_or_null(27) ptr @bump_malloc_inner(i64 noundef 27, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(26) %result.i.i178, ptr noundef nonnull align 32 dereferenceable(26) %result.i106, i64 26, i1 false)
  %6 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %puts97 = tail call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i178)
  %7 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract89)
  %8 = sext i32 %offset.i.i to i64
  %9 = getelementptr ptr, ptr %.fca.0.extract89, i64 %8
  %10 = getelementptr i8, ptr %9, i64 8
  %11 = load ptr, ptr %10, align 8
  %12 = load ptr, ptr %11, align 8
  %13 = tail call { ptr, ptr, ptr, i32 } %12(ptr %.fca.1.extract91) #36
  %.fca.0.extract52 = extractvalue { ptr, ptr, ptr, i32 } %13, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %13, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %13, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %13, 3
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract52, 0
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %.fca.1.extract, 1
  %16 = insertvalue { ptr, ptr, ptr, i32 } %15, ptr %.fca.2.extract, 2
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %.fca.3.extract, 3
  %18 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %19 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract52)
  %20 = sext i32 %.fca.3.extract to i64
  %21 = getelementptr ptr, ptr %.fca.0.extract52, i64 %20
  %22 = getelementptr i8, ptr %21, i64 112
  %23 = load ptr, ptr %22, align 8
  %result.i111 = call ptr %23({ ptr, ptr, ptr, i32 } %17, ptr nocapture nofree noundef nonnull readonly %3) #16
  %24 = call { ptr } %result.i111({ ptr, ptr, ptr, i32 } %17, { ptr, ptr, ptr, i32 } %17, ptr nonnull align 8 %3) #7
  %.fca.0.extract50 = extractvalue { ptr } %24, 0
  %puts98 = call i32 @puts(ptr nonnull dereferenceable(1) %.fca.0.extract50)
  %result.i112 = call noalias align 8 dereferenceable_or_null(8) ptr @bump_malloc_inner(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <7 x i8> <i8 65, i8 116, i8 32, i8 108, i8 105, i8 110, i8 101>, ptr %result.i112, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %26 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %3) #34
  %result.i.i210 = call noalias dereferenceable_or_null(8) ptr @bump_malloc_inner(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(7) %result.i.i210, ptr noundef nonnull align 8 dereferenceable(7) %result.i112, i64 7, i1 false)
  %27 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %puts99 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i210)
  %28 = call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract89)
  %29 = load ptr, ptr %9, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = call i32 %30(ptr %.fca.1.extract91) #36
  %32 = call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %31) #7
  %result.i117 = call noalias align 16 dereferenceable_or_null(13) ptr @bump_malloc_inner(i64 noundef 13, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <12 x i8> <i8 87, i8 105, i8 116, i8 104, i8 32, i8 109, i8 101, i8 115, i8 115, i8 97, i8 103, i8 101>, ptr %result.i117, align 16
  %33 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %34 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %3) #34
  %result.i.i242 = call noalias dereferenceable_or_null(13) ptr @bump_malloc_inner(i64 noundef 13, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(12) %result.i.i242, ptr noundef nonnull align 16 dereferenceable(12) %result.i117, i64 12, i1 false)
  %.fca.2.extract93 = extractvalue { ptr, ptr, ptr, i32 } %0, 2
  %35 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %puts100 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i242)
  %36 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract89, 0
  %37 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %.fca.1.extract91, 1
  %38 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %.fca.2.extract93, 2
  %39 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %offset.i.i, 3
  %40 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %41 = call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract89)
  %42 = getelementptr i8, ptr %9, i64 56
  %43 = load ptr, ptr %42, align 8
  %result.i122 = call ptr %43({ ptr, ptr, ptr, i32 } %39, ptr nocapture nofree noundef nonnull readonly %3) #16
  call void %result.i122({ ptr, ptr, ptr, i32 } %39, { ptr, ptr, ptr, i32 } %39, ptr nonnull align 8 %3) #7
  %result.i123 = call noalias align 16 dereferenceable_or_null(10) ptr @bump_malloc_inner(i64 noundef 10, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <9 x i8> <i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45, i8 45>, ptr %result.i123, align 16
  %44 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %45 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree nonnull readonly %3) #34
  %result.i.i274 = call noalias dereferenceable_or_null(10) ptr @bump_malloc_inner(i64 noundef 10, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(9) %result.i.i274, ptr noundef nonnull align 16 dereferenceable(9) %result.i123, i64 9, i1 false)
  %46 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %puts101 = call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i274)
  ret void
}

; Function Attrs: nounwind
define void @Exception_print_message_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr nocapture nofree readnone %2) #7 {
  %4 = alloca [0 x ptr], align 8
  %.fca.0.extract2 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %.fca.1.extract4 = extractvalue { ptr, ptr, ptr, i32 } %0, 1
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !710
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !710
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !710
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !710
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %6 = sext i32 %offset.i.i to i64
  %7 = getelementptr ptr, ptr %.fca.0.extract2, i64 %6
  %8 = getelementptr i8, ptr %7, i64 16
  %9 = load ptr, ptr %8, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = tail call { ptr, ptr, ptr, i32 } %10(ptr %.fca.1.extract4) #36
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %11, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %11, 3
  %12 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, ptr %.fca.1.extract, 1
  %14 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %.fca.2.extract, 2
  %15 = insertvalue { ptr, ptr, ptr, i32 } %14, i32 %.fca.3.extract, 3
  %16 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %4) #40
  %17 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract1) #40
  %18 = sext i32 %.fca.3.extract to i64
  %19 = getelementptr ptr, ptr %.fca.0.extract1, i64 %18
  %20 = getelementptr i8, ptr %19, i64 112
  %21 = load ptr, ptr %20, align 8
  %result.i = call ptr %21({ ptr, ptr, ptr, i32 } %15, ptr nocapture nofree noundef nonnull readonly %4) #16
  %22 = call { ptr } %result.i({ ptr, ptr, ptr, i32 } %15, { ptr, ptr, ptr, i32 } %15, ptr nonnull align 8 %4) #7
  %.fca.0.extract = extractvalue { ptr } %22, 0
  %puts = call i32 @puts(ptr nonnull dereferenceable(1) %.fca.0.extract)
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @printf(ptr nocapture noundef readonly, ...) local_unnamed_addr #17

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Exception_getter_message(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 40
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 48
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 56
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 64
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_message(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 40
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 48
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 56
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 64
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, ptr, ptr, i32 } @Exception_getter_file_name(ptr nocapture nofree readonly %0) #5 {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load ptr, ptr %2, align 8
  %4 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %3, 0
  %5 = getelementptr i8, ptr %0, i64 16
  %6 = load ptr, ptr %5, align 8
  %7 = insertvalue { ptr, ptr, ptr, i32 } %4, ptr %6, 1
  %8 = getelementptr i8, ptr %0, i64 24
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %9, 2
  %11 = getelementptr i8, ptr %0, i64 32
  %12 = load i32, ptr %11, align 4
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, i32 %12, 3
  ret { ptr, ptr, ptr, i32 } %13
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_file_name(ptr nocapture nofree writeonly %0, { ptr, ptr, ptr, i32 } %1) #6 {
  %3 = getelementptr i8, ptr %0, i64 8
  %.fca.0.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 2
  %.fca.3.extract = extractvalue { ptr, ptr, ptr, i32 } %1, 3
  store ptr %.fca.0.extract, ptr %3, align 8
  %4 = getelementptr i8, ptr %0, i64 16
  store ptr %.fca.1.extract, ptr %4, align 8
  %5 = getelementptr i8, ptr %0, i64 24
  store ptr %.fca.2.extract, ptr %5, align 8
  %6 = getelementptr i8, ptr %0, i64 32
  store i32 %.fca.3.extract, ptr %6, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define i32 @Exception_getter_line_number(ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(4) %0) #5 {
  %2 = load i32, ptr %0, align 4
  ret i32 %2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @Exception_setter_line_number(ptr nocapture nofree noundef nonnull writeonly align 4 dereferenceable(4) %0, i32 %1) #6 {
  store i32 %1, ptr %0, align 4
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @Iterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree %1) local_unnamed_addr #1 {
  %3 = tail call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree %1) #34
  %4 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %5 = getelementptr i8, ptr %4, i64 88
  %6 = load ptr, ptr %5, align 8
  ret ptr %6
}

; Function Attrs: nounwind
define void @report_exception({ ptr } %0) local_unnamed_addr #7 {
  %2 = alloca [0 x ptr], align 8
  %.fca.0.extract2 = extractvalue { ptr } %0, 0
  %3 = getelementptr i8, ptr %.fca.0.extract2, i64 48
  %4 = load { ptr, i160 }, ptr %3, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %4, 0
  %5 = icmp ne ptr %.fca.0.extract, @nil_typ
  %6 = icmp ne ptr %.fca.0.extract, null
  %.not5 = and i1 %5, %6
  br i1 %.not5, label %7, label %._crit_edge

7:                                                ; preds = %1
  %.fca.1.extract = extractvalue { ptr, i160 } %4, 1
  %.sroa.3.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %8 = inttoptr i64 %.sroa.3.8.extract.trunc to ptr
  %.sroa.5.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.5.8.extract.trunc = trunc i160 %.sroa.5.8.extract.shift to i64
  %9 = inttoptr i64 %.sroa.5.8.extract.trunc to ptr
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !713
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !713
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !713
  %product.i.i.i = mul i64 %hash_coef.i.i, 9027164862567808692
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !713
  %10 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %11 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %8, 1
  %12 = insertvalue { ptr, ptr, ptr, i32 } %11, ptr %9, 2
  %13 = insertvalue { ptr, ptr, ptr, i32 } %12, i32 %offset.i.i, 3
  %14 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %2) #34
  %15 = tail call ptr @llvm.invariant.start.p0(i64 noundef 104, ptr nocapture nofree noundef nonnull %.fca.0.extract) #34
  %16 = sext i32 %offset.i.i to i64
  %17 = getelementptr ptr, ptr %.fca.0.extract, i64 %16
  %18 = getelementptr i8, ptr %17, i64 48
  %19 = load ptr, ptr %18, align 8
  %result.i = call ptr %19({ ptr, ptr, ptr, i32 } %13, ptr nocapture nofree noundef nonnull readonly %2) #16
  call void %result.i({ ptr, ptr, ptr, i32 } %13, { ptr, ptr, ptr, i32 } %13, ptr nonnull align 8 %2) #7
  br label %._crit_edge

._crit_edge:                                      ; preds = %1, %7
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_data_size_IO(ptr nocapture nofree readnone %0) #0 {
  ret { i64, i64 } { i64 0, i64 1 }
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define ptr @IO_B__Self_print_xCharacter__Self_print_xPtri1__Self_print_xPtri32__Self_print_xNil__Self_print_xString__Self_print_xPtri64__Self_print_xRepresentable__Self_print_xPtrf64__Self_print_xPtri8(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #11 {
  %2 = tail call ptr @llvm.invariant.start.p0(i64 noundef 8, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %0) #34
  %3 = load ptr, ptr %0, align 8
  %4 = getelementptr i8, ptr %3, i64 8
  %5 = getelementptr i8, ptr %3, i64 16
  %6 = getelementptr i8, ptr %3, i64 24
  %7 = getelementptr i8, ptr %3, i64 32
  %8 = load i64, ptr %4, align 4
  %9 = load i64, ptr %5, align 4
  %10 = load ptr, ptr %6, align 8
  %11 = load ptr, ptr %7, align 8
  %result.i = tail call i1 %10(i64 %9, i64 %8, i64 -7260840641129990118, i64 ptrtoint (ptr @Representable to i64), ptr readonly %11) #5
  br i1 %result.i, label %12, label %.critedge

12:                                               ; preds = %1
  %result.i14 = tail call i1 %10(i64 %9, i64 %8, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %11) #5
  %result.i15 = tail call i1 %10(i64 %9, i64 %8, i64 6681222582356018452, i64 ptrtoint (ptr @Character to i64), ptr readonly %11) #5
  %.reg2mem47.0 = select i1 %result.i14, i1 true, i1 %result.i15
  br i1 %.reg2mem47.0, label %.critedge, label %26

.critedge:                                        ; preds = %1, %12
  %13 = icmp eq ptr %3, @bool_typ
  br i1 %13, label %26, label %14

14:                                               ; preds = %.critedge
  %15 = icmp eq ptr %3, @f64_typ
  br i1 %15, label %26, label %16

16:                                               ; preds = %14
  %17 = icmp eq ptr %3, @i32_typ
  br i1 %17, label %26, label %18

18:                                               ; preds = %16
  %19 = icmp eq ptr %3, @i8_typ
  br i1 %19, label %26, label %20

20:                                               ; preds = %18
  %result.i16 = tail call i1 %10(i64 %9, i64 %8, i64 6499063144389013426, i64 ptrtoint (ptr @String to i64), ptr readonly %11) #5
  %result.i17 = tail call i1 %10(i64 %9, i64 %8, i64 6681222582356018452, i64 ptrtoint (ptr @Character to i64), ptr readonly %11) #5
  %not.result.i16 = xor i1 %result.i16, true
  %.reg2mem43.0 = select i1 %not.result.i16, i1 true, i1 %result.i17
  br i1 %.reg2mem43.0, label %21, label %26

21:                                               ; preds = %20
  %not.result.i17 = xor i1 %result.i17, true
  %.reg2mem41.0 = or i1 %result.i16, %not.result.i17
  %22 = icmp eq ptr %3, @nil_typ
  %23 = icmp eq ptr %3, null
  %24 = or i1 %22, %23
  %25 = select i1 %24, i32 4, i32 6
  %.reg2mem39.0 = select i1 %.reg2mem41.0, i32 %25, i32 1
  br label %26

26:                                               ; preds = %12, %.critedge, %16, %21, %20, %18, %14
  %.reg2mem27.0 = phi i32 [ 2, %.critedge ], [ 8, %14 ], [ 3, %16 ], [ 9, %18 ], [ %.reg2mem39.0, %21 ], [ 5, %20 ], [ 7, %12 ]
  %27 = zext nneg i32 %.reg2mem27.0 to i64
  %28 = getelementptr [10 x ptr], ptr @IO, i64 0, i64 %27
  %29 = getelementptr i8, ptr %28, i64 80
  %30 = load ptr, ptr %29, align 8
  ret ptr %30
}

; Function Attrs: nounwind
define void @IO__Self_print_xCharacter(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #7 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.3.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %4 = inttoptr i64 %.sroa.3.8.extract.trunc to ptr
  %.sroa.5.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.5.8.extract.trunc = trunc i160 %.sroa.5.8.extract.shift to i64
  %5 = inttoptr i64 %.sroa.5.8.extract.trunc to ptr
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !716
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !716
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !716
  %product.i.i.i = mul i64 %hash_coef.i.i, 6681222582356018452
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !716
  %result.i = tail call noalias dereferenceable_or_null(2) ptr @bump_malloc_inner(i64 noundef 2, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %4, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %5, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #34
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 40, ptr nocapture nofree noundef %.fca.0.extract) #34
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract, i64 %12
  %14 = getelementptr i8, ptr %13, i64 8
  %15 = load ptr, ptr %14, align 8
  %result.i8 = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly %3) #16
  %16 = call i8 %result.i8({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %3) #7
  store i8 %16, ptr %result.i, align 1
  %puts = call i32 @puts(ptr nonnull dereferenceable(1) %result.i)
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xPtri1(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #17 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %3 = trunc i160 %.fca.1.extract to i1
  br i1 %3, label %._crit_edge.lr.ph.i, label %._crit_edge.lr.ph.i84

._crit_edge.lr.ph.i:                              ; preds = %2
  %result.i.i = tail call noalias dereferenceable_or_null(5) ptr @bump_malloc_inner(i64 noundef 5, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store i32 1702195828, ptr %result.i.i, align 1
  br label %String_c_string_.exit

._crit_edge.lr.ph.i84:                            ; preds = %2
  %result.i39 = tail call noalias align 8 dereferenceable_or_null(6) ptr @bump_malloc_inner(i64 noundef 6, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <5 x i8> <i8 102, i8 97, i8 108, i8 115, i8 101>, ptr %result.i39, align 8
  %result.i.i83 = tail call noalias dereferenceable_or_null(6) ptr @bump_malloc_inner(i64 noundef 6, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(5) %result.i.i83, ptr noundef nonnull align 8 dereferenceable(5) %result.i39, i64 5, i1 false)
  br label %String_c_string_.exit

String_c_string_.exit:                            ; preds = %._crit_edge.lr.ph.i84, %._crit_edge.lr.ph.i
  %4 = phi i32 [ 4, %._crit_edge.lr.ph.i ], [ 5, %._crit_edge.lr.ph.i84 ]
  %result.i.i83.sink = phi ptr [ %result.i.i, %._crit_edge.lr.ph.i ], [ %result.i.i83, %._crit_edge.lr.ph.i84 ]
  %5 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %6 = zext nneg i32 %4 to i64
  %7 = getelementptr i8, ptr %result.i.i83.sink, i64 %6
  store i8 0, ptr %7, align 1
  %puts = tail call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i83.sink)
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xPtri32(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #17 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i32
  %3 = tail call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %.sroa.1.8.extract.trunc) #17
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xNil(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #17 {
._crit_edge.lr.ph.i:
  %result.i = tail call noalias align 4 dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  store <3 x i8> <i8 110, i8 105, i8 108>, ptr %result.i, align 4
  %result.i.i = tail call noalias dereferenceable_or_null(4) ptr @bump_malloc_inner(i64 noundef 4, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  tail call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 1 dereferenceable(3) %result.i.i, ptr noundef nonnull align 4 dereferenceable(3) %result.i, i64 3, i1 false)
  %2 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef nonnull @String)
  %puts = tail call i32 @puts(ptr nonnull dereferenceable(1) %result.i.i)
  ret void
}

; Function Attrs: nounwind
define void @IO__Self_print_xString(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #7 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract1 = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.3.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %4 = inttoptr i64 %.sroa.3.8.extract.trunc to ptr
  %.sroa.5.8.extract.shift = lshr i160 %.fca.1.extract, 64
  %.sroa.5.8.extract.trunc = trunc i160 %.sroa.5.8.extract.shift to i64
  %5 = inttoptr i64 %.sroa.5.8.extract.trunc to ptr
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !719
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !719
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !719
  %product.i.i.i = mul i64 %hash_coef.i.i, 6499063144389013426
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !719
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %4, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %5, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #34
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract1) #34
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract1, i64 %12
  %14 = getelementptr i8, ptr %13, i64 112
  %15 = load ptr, ptr %14, align 8
  %result.i = call ptr %15({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly %3) #16
  %16 = call { ptr } %result.i({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %3) #7
  %.fca.0.extract = extractvalue { ptr } %16, 0
  %puts = call i32 @puts(ptr nonnull dereferenceable(1) %.fca.0.extract)
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xPtri64(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #17 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %3 = tail call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(6) @i64_string, i64 %.sroa.1.8.extract.trunc) #17
  ret void
}

; Function Attrs: nounwind
define void @IO__Self_print_xRepresentable(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #7 {
  %3 = alloca [0 x ptr], align 8
  %.fca.0.extract2 = extractvalue { ptr, i160 } %1, 0
  %.fca.1.extract3 = extractvalue { ptr, i160 } %1, 1
  %.sroa.322.8.extract.trunc = trunc i160 %.fca.1.extract3 to i64
  %4 = inttoptr i64 %.sroa.322.8.extract.trunc to ptr
  %.sroa.523.8.extract.shift = lshr i160 %.fca.1.extract3, 64
  %.sroa.523.8.extract.trunc = trunc i160 %.sroa.523.8.extract.shift to i64
  %5 = inttoptr i64 %.sroa.523.8.extract.trunc to ptr
  %hash_coef_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 8
  %tbl_size_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 16
  %offset_tbl_ptr.i.i = getelementptr i8, ptr %.fca.0.extract2, i64 40
  %hash_coef.i.i = load i64, ptr %hash_coef_ptr.i.i, align 4, !noalias !722
  %tbl_size.i.i = load i64, ptr %tbl_size_ptr.i.i, align 4, !noalias !722
  %offset_tbl.i.i = load ptr, ptr %offset_tbl_ptr.i.i, align 8, !noalias !722
  %product.i.i.i = mul i64 %hash_coef.i.i, -7260840641129990118
  %shifted.i.i.i = lshr i64 %product.i.i.i, 32
  %xored.i.i.i = xor i64 %shifted.i.i.i, %product.i.i.i
  %hash.i.i.i = and i64 %xored.i.i.i, %tbl_size.i.i
  %offset_ptr.i.i = getelementptr i32, ptr %offset_tbl.i.i, i64 %hash.i.i.i
  %offset.i.i = load i32, ptr %offset_ptr.i.i, align 4, !noalias !722
  %6 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract2, 0
  %7 = insertvalue { ptr, ptr, ptr, i32 } %6, ptr %4, 1
  %8 = insertvalue { ptr, ptr, ptr, i32 } %7, ptr %5, 2
  %9 = insertvalue { ptr, ptr, ptr, i32 } %8, i32 %offset.i.i, 3
  %10 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3) #34
  %11 = tail call ptr @llvm.invariant.start.p0(i64 noundef 16, ptr nocapture nofree noundef %.fca.0.extract2) #34
  %12 = sext i32 %offset.i.i to i64
  %13 = getelementptr ptr, ptr %.fca.0.extract2, i64 %12
  %14 = load ptr, ptr %13, align 8
  %result.i = call ptr %14({ ptr, ptr, ptr, i32 } %9, ptr nocapture nofree noundef nonnull readonly %3) #16
  %15 = call { ptr, ptr, ptr, i32 } %result.i({ ptr, ptr, ptr, i32 } %9, { ptr, ptr, ptr, i32 } %9, ptr nonnull align 8 %3) #7
  %.fca.0.extract1 = extractvalue { ptr, ptr, ptr, i32 } %15, 0
  %.fca.1.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 1
  %.fca.2.extract = extractvalue { ptr, ptr, ptr, i32 } %15, 2
  %hash_coef_ptr.i.i7 = getelementptr i8, ptr %.fca.0.extract1, i64 8
  %tbl_size_ptr.i.i8 = getelementptr i8, ptr %.fca.0.extract1, i64 16
  %offset_tbl_ptr.i.i9 = getelementptr i8, ptr %.fca.0.extract1, i64 40
  %hash_coef.i.i10 = load i64, ptr %hash_coef_ptr.i.i7, align 4, !noalias !725
  %tbl_size.i.i11 = load i64, ptr %tbl_size_ptr.i.i8, align 4, !noalias !725
  %offset_tbl.i.i12 = load ptr, ptr %offset_tbl_ptr.i.i9, align 8, !noalias !725
  %product.i.i.i13 = mul i64 %hash_coef.i.i10, 6499063144389013426
  %shifted.i.i.i14 = lshr i64 %product.i.i.i13, 32
  %xored.i.i.i15 = xor i64 %shifted.i.i.i14, %product.i.i.i13
  %hash.i.i.i16 = and i64 %xored.i.i.i15, %tbl_size.i.i11
  %offset_ptr.i.i17 = getelementptr i32, ptr %offset_tbl.i.i12, i64 %hash.i.i.i16
  %offset.i.i18 = load i32, ptr %offset_ptr.i.i17, align 4, !noalias !725
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %.fca.0.extract1, 0
  %17 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %.fca.1.extract, 1
  %18 = insertvalue { ptr, ptr, ptr, i32 } %17, ptr %.fca.2.extract, 2
  %19 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %offset.i.i18, 3
  %20 = call ptr @llvm.invariant.start.p0(i64 noundef 0, ptr nocapture nofree noundef nonnull align 8 %3)
  %21 = call ptr @llvm.invariant.start.p0(i64 noundef 280, ptr nocapture nofree noundef %.fca.0.extract1)
  %22 = sext i32 %offset.i.i18 to i64
  %23 = getelementptr ptr, ptr %.fca.0.extract1, i64 %22
  %24 = getelementptr i8, ptr %23, i64 112
  %25 = load ptr, ptr %24, align 8
  %result.i20 = call ptr %25({ ptr, ptr, ptr, i32 } %19, ptr nocapture nofree noundef nonnull readonly %3) #16
  %26 = call { ptr } %result.i20({ ptr, ptr, ptr, i32 } %19, { ptr, ptr, ptr, i32 } %19, ptr nonnull align 8 %3) #7
  %.fca.0.extract = extractvalue { ptr } %26, 0
  %puts = call i32 @puts(ptr nonnull dereferenceable(1) %.fca.0.extract)
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xPtrf64(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #17 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i64
  %3 = bitcast i64 %.sroa.1.8.extract.trunc to double
  %4 = tail call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @float_string, double %3) #17
  ret void
}

; Function Attrs: nofree nounwind
define void @IO__Self_print_xPtri8(ptr nocapture nofree readnone %0, { ptr, i160 } %1) #17 {
  %.fca.1.extract = extractvalue { ptr, i160 } %1, 1
  %.sroa.1.8.extract.trunc = trunc i160 %.fca.1.extract to i8
  %3 = sext i8 %.sroa.1.8.extract.trunc to i32
  %4 = tail call i32 (ptr, ...) @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @i32_string, i32 %3) #17
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define ptr @typegetter_wrapper(ptr nocapture nofree noundef nonnull readonly %f, ptr nocapture nofree noundef nonnull readonly %0) local_unnamed_addr #18 {
  %result = tail call ptr %f(ptr nocapture nofree noundef nonnull readonly %0) #5
  ret ptr %result
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define { i64, i64 } @size_wrapper(ptr nocapture nofree noundef nonnull readonly %f, ptr nocapture nofree readonly %0) local_unnamed_addr #18 {
  %result = tail call { i64, i64 } %f(ptr nocapture nofree readonly %0) #5
  ret { i64, i64 } %result
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define { ptr, i160 } @box_wrapper(ptr nocapture nofree noundef nonnull readonly %f, ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) local_unnamed_addr #18 {
  %result = tail call { ptr, i160 } %f(ptr nocapture nofree readonly %0, ptr nocapture nofree readonly %1) #5
  ret { ptr, i160 } %result
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: readwrite)
define void @unbox_wrapper(ptr nocapture nofree noundef nonnull readonly %f, { ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) local_unnamed_addr #19 {
  tail call void %f({ ptr, i160 } %0, ptr nocapture nofree readonly %1, ptr nocapture nofree writeonly %2) #13
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, inaccessiblemem: none)
define ptr @behavior_wrapper(ptr nocapture nofree noundef nonnull readonly %f, { ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull readonly %1) local_unnamed_addr #20 {
  %result = tail call ptr %f({ ptr, ptr, ptr, i32 } %0, ptr nocapture nofree noundef nonnull %1) #16
  ret ptr %result
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, inaccessiblemem: none)
define ptr @class_behavior_wrapper(ptr nocapture nofree noundef nonnull readonly %f, ptr nocapture nofree noundef nonnull readonly %0) local_unnamed_addr #20 {
  %result = tail call ptr %f(ptr nocapture nofree noundef nonnull %0) #16
  ret ptr %result
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define ptr @adjust_trampoline(ptr nofree readonly %tramp) local_unnamed_addr #5 {
  %ret = tail call ptr @llvm.adjust.trampoline(ptr nofree readonly %tramp) #39
  ret ptr %ret
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: read)
declare ptr @llvm.adjust.trampoline(ptr) #21

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(readwrite, argmem: none, inaccessiblemem: none)
define noalias ptr @bump_malloc(i64 noundef %size) local_unnamed_addr #22 {
  %result = tail call noalias ptr @bump_malloc_inner(i64 noundef %size, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) @current_ptr) #37
  ret ptr %result
}

; Function Attrs: mustprogress nofree noinline norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(argmem: readwrite)
define noalias ptr @bump_malloc_inner(i64 noundef %size, ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %current_ptr) local_unnamed_addr #23 {
  %size_plus_15 = add i64 %size, 15
  %aligned_size = and i64 %size_plus_15, -16
  %current = load ptr, ptr %current_ptr, align 8
  %new_ptr = getelementptr i8, ptr %current, i64 %aligned_size
  store ptr %new_ptr, ptr %current_ptr, align 8
  ret ptr %current
}

define { i64, i64 } @_data_size_tuple_typ(ptr nocapture nofree readonly align 4 %0) {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i64, ptr %2, align 4
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %._crit_edge, label %.lr.ph

.lr.ph:                                           ; preds = %1, %.lr.ph
  %.reg2mem20.010.reg2mem.0 = phi i64 [ %12, %.lr.ph ], [ 1, %1 ]
  %.reg2mem22.011.reg2mem.0 = phi i64 [ %18, %.lr.ph ], [ 0, %1 ]
  %.reg2mem14.0 = phi i64 [ %19, %.lr.ph ], [ 1, %1 ]
  %.in.reg2mem.0 = phi i64 [ %21, %.lr.ph ], [ %3, %1 ]
  %5 = inttoptr i64 %.in.reg2mem.0 to ptr
  %6 = load ptr, ptr %5, align 8
  %7 = getelementptr i8, ptr %6, i64 72
  %8 = load ptr, ptr %7, align 8
  %9 = tail call { i64, i64 } %8(ptr nonnull align 8 %5)
  %10 = extractvalue { i64, i64 } %9, 0
  %11 = extractvalue { i64, i64 } %9, 1
  %12 = tail call i64 @llvm.umax.i64(i64 %11, i64 %.reg2mem20.010.reg2mem.0)
  %13 = urem i64 %.reg2mem22.011.reg2mem.0, %11
  %14 = icmp eq i64 %13, 0
  %15 = sub i64 %11, %13
  %16 = select i1 %14, i64 0, i64 %15
  %17 = add i64 %10, %.reg2mem22.011.reg2mem.0
  %18 = add i64 %17, %16
  %19 = add i64 %.reg2mem14.0, 1
  %20 = getelementptr ptr, ptr %0, i64 %19
  %21 = load i64, ptr %20, align 4
  %22 = icmp eq i64 %21, 0
  br i1 %22, label %._crit_edge, label %.lr.ph

._crit_edge:                                      ; preds = %.lr.ph, %1
  %.reg2mem22.0.lcssa.reg2mem.0 = phi i64 [ 0, %1 ], [ %18, %.lr.ph ]
  %.reg2mem20.0.lcssa.reg2mem.0 = phi i64 [ 1, %1 ], [ %12, %.lr.ph ]
  %23 = urem i64 %.reg2mem22.0.lcssa.reg2mem.0, %.reg2mem20.0.lcssa.reg2mem.0
  %24 = icmp eq i64 %23, 0
  %25 = sub i64 %.reg2mem20.0.lcssa.reg2mem.0, %23
  %26 = select i1 %24, i64 0, i64 %25
  %27 = add i64 %26, %.reg2mem22.0.lcssa.reg2mem.0
  %28 = insertvalue { i64, i64 } undef, i64 %27, 0
  %29 = insertvalue { i64, i64 } %28, i64 %.reg2mem20.0.lcssa.reg2mem.0, 1
  ret { i64, i64 } %29
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.umax.i64(i64, i64) #24

define { i64, i64 } @_data_size_union_typ(ptr nocapture nofree readonly align 4 %0) {
  %2 = getelementptr i8, ptr %0, i64 8
  %3 = load i64, ptr %2, align 4
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %._crit_edge.thread, label %.lr.ph

.lr.ph:                                           ; preds = %1, %.lr.ph
  %.reg2mem20.010.reg2mem.0 = phi i64 [ %12, %.lr.ph ], [ 1, %1 ]
  %.reg2mem22.011.reg2mem.0 = phi i64 [ %.fr, %.lr.ph ], [ 0, %1 ]
  %.reg2mem14.0 = phi i64 [ %19, %.lr.ph ], [ 1, %1 ]
  %.in.reg2mem.0 = phi i64 [ %21, %.lr.ph ], [ %3, %1 ]
  %5 = inttoptr i64 %.in.reg2mem.0 to ptr
  %6 = load ptr, ptr %5, align 8
  %7 = getelementptr i8, ptr %6, i64 72
  %8 = load ptr, ptr %7, align 8
  %9 = tail call { i64, i64 } %8(ptr nonnull align 8 %5)
  %10 = extractvalue { i64, i64 } %9, 0
  %11 = extractvalue { i64, i64 } %9, 1
  %12 = tail call i64 @llvm.umax.i64(i64 %11, i64 %.reg2mem20.010.reg2mem.0)
  %13 = urem i64 %.reg2mem22.011.reg2mem.0, %11
  %14 = icmp eq i64 %13, 0
  %15 = sub i64 %11, %13
  %16 = select i1 %14, i64 0, i64 %15
  %17 = add i64 %10, %.reg2mem22.011.reg2mem.0
  %18 = tail call i64 @llvm.umax.i64(i64 %17, i64 %16)
  %.fr = freeze i64 %18
  %19 = add i64 %.reg2mem14.0, 1
  %20 = getelementptr ptr, ptr %0, i64 %19
  %21 = load i64, ptr %20, align 4
  %22 = icmp eq i64 %21, 0
  br i1 %22, label %._crit_edge, label %.lr.ph

._crit_edge:                                      ; preds = %.lr.ph
  %right_size = icmp eq i64 %.fr, 32
  %spec.select = select i1 %right_size, i64 0, i64 8
  %23 = add i64 %spec.select, %.fr
  br label %._crit_edge.thread

._crit_edge.thread:                               ; preds = %._crit_edge, %1
  %.reg2mem20.0.lcssa.reg2mem.012 = phi i64 [ 1, %1 ], [ %12, %._crit_edge ]
  %final_size = phi i64 [ 8, %1 ], [ %23, %._crit_edge ]
  %24 = urem i64 %final_size, %.reg2mem20.0.lcssa.reg2mem.012
  %25 = icmp eq i64 %24, 0
  %26 = sub i64 %.reg2mem20.0.lcssa.reg2mem.012, %24
  %27 = select i1 %25, i64 0, i64 %26
  %28 = add i64 %27, %final_size
  %29 = insertvalue { i64, i64 } undef, i64 %28, 0
  %30 = insertvalue { i64, i64 } %29, i64 %.reg2mem20.0.lcssa.reg2mem.012, 1
  ret { i64, i64 } %30
}

define void @_unbox_union_typ({ ptr, i160 } %0, ptr nocapture nofree readonly align 4 %1, ptr nocapture nofree writeonly %2) {
  %4 = alloca { ptr, i160 }, align 8
  %.fca.0.extract = extractvalue { ptr, i160 } %0, 0
  store ptr %.fca.0.extract, ptr %4, align 8
  %.fca.1.extract = extractvalue { ptr, i160 } %0, 1
  %.fca.1.gep = getelementptr inbounds i8, ptr %4, i64 8
  store i160 %.fca.1.extract, ptr %.fca.1.gep, align 8
  %5 = getelementptr i8, ptr %1, i64 8
  %6 = load i64, ptr %5, align 4
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %_data_size_union_typ.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %3, %.lr.ph.i
  %.reg2mem20.010.reg2mem.0.i = phi i64 [ %15, %.lr.ph.i ], [ 1, %3 ]
  %.reg2mem22.011.reg2mem.0.i = phi i64 [ %.fr.i, %.lr.ph.i ], [ 0, %3 ]
  %.reg2mem14.0.i = phi i64 [ %22, %.lr.ph.i ], [ 1, %3 ]
  %.in.reg2mem.0.i = phi i64 [ %24, %.lr.ph.i ], [ %6, %3 ]
  %8 = inttoptr i64 %.in.reg2mem.0.i to ptr
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr i8, ptr %9, i64 72
  %11 = load ptr, ptr %10, align 8
  %12 = tail call { i64, i64 } %11(ptr nonnull align 8 %8)
  %13 = extractvalue { i64, i64 } %12, 0
  %14 = extractvalue { i64, i64 } %12, 1
  %15 = tail call i64 @llvm.umax.i64(i64 %14, i64 %.reg2mem20.010.reg2mem.0.i)
  %16 = urem i64 %.reg2mem22.011.reg2mem.0.i, %14
  %17 = icmp eq i64 %16, 0
  %18 = sub i64 %14, %16
  %19 = select i1 %17, i64 0, i64 %18
  %20 = add i64 %13, %.reg2mem22.011.reg2mem.0.i
  %21 = tail call i64 @llvm.umax.i64(i64 %20, i64 %19)
  %.fr.i = freeze i64 %21
  %22 = add i64 %.reg2mem14.0.i, 1
  %23 = getelementptr ptr, ptr %1, i64 %22
  %24 = load i64, ptr %23, align 4
  %25 = icmp eq i64 %24, 0
  br i1 %25, label %._crit_edge.i, label %.lr.ph.i

._crit_edge.i:                                    ; preds = %.lr.ph.i
  %right_size.i = icmp eq i64 %.fr.i, 32
  %spec.select.i = select i1 %right_size.i, i64 0, i64 8
  %26 = add i64 %spec.select.i, %.fr.i
  br label %_data_size_union_typ.exit

_data_size_union_typ.exit:                        ; preds = %3, %._crit_edge.i
  %.reg2mem20.0.lcssa.reg2mem.012.i = phi i64 [ 1, %3 ], [ %15, %._crit_edge.i ]
  %final_size.i = phi i64 [ 8, %3 ], [ %26, %._crit_edge.i ]
  %27 = trunc i160 %.fca.1.extract to i64
  %28 = inttoptr i64 %27 to ptr
  %29 = urem i64 %final_size.i, %.reg2mem20.0.lcssa.reg2mem.012.i
  %30 = icmp eq i64 %29, 0
  %31 = sub i64 %.reg2mem20.0.lcssa.reg2mem.012.i, %29
  %32 = select i1 %30, i64 0, i64 %31
  %33 = add i64 %32, %final_size.i
  %34 = icmp slt i64 %33, 17
  %35 = icmp eq i64 %33, 32
  %36 = select i1 %34, ptr %.fca.1.gep, ptr %28
  %37 = select i1 %35, ptr %4, ptr %36
  call void @llvm.memcpy.inline.p0.p0.i64(ptr nocapture nofree writeonly align 1 %2, ptr nocapture nofree readonly align 1 %37, i64 %33, i1 noundef false)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define { i64, i64 } @_size_Default(ptr nocapture nofree readnone %parameterization) #0 {
  ret { i64, i64 } { i64 32, i64 8 }
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read)
define { ptr, i160 } @_box_Default(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(28) %fat_ptr, ptr nocapture nofree readnone %parameterization) #5 {
  %vptr = load ptr, ptr %fat_ptr, align 8
  %1 = insertvalue { ptr, i160 } undef, ptr %vptr, 0
  %2 = getelementptr inbounds i8, ptr %fat_ptr, i64 8
  %3 = load i160, ptr %2, align 8
  %4 = insertvalue { ptr, i160 } %1, i160 %3, 1
  ret { ptr, i160 } %4
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write)
define void @_unbox_Default({ ptr, i160 } %fat_ptr, ptr nocapture nofree readnone %parameterization, ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(28) %destination) #6 {
  %vptr = extractvalue { ptr, i160 } %fat_ptr, 0
  %data = extractvalue { ptr, i160 } %fat_ptr, 1
  %dest_data = getelementptr inbounds i8, ptr %destination, i64 8
  store ptr %vptr, ptr %destination, align 8
  store i160 %data, ptr %dest_data, align 8
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite)
define void @anoint_trampoline(ptr nofree %tramp) local_unnamed_addr #25 {
  %oldProtect = alloca i32, align 4
  %result = call i32 @VirtualProtect(ptr nofree %tramp, i64 noundef 16, i32 noundef 64, ptr nofree noundef nonnull align 4 dereferenceable(4) %oldProtect) #25
  ret void
}

; Function Attrs: mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite)
declare i32 @VirtualProtect(ptr, i64, i32, ptr) local_unnamed_addr #25

define noundef nonnull align 8 dereferenceable(16) ptr @coroutine_create(ptr nofree %func, ptr nofree %arg_passer) local_unnamed_addr {
  %stack = tail call noalias noundef nonnull align 8 dereferenceable(8388608) ptr @VirtualAlloc(ptr nofree noundef align 4294967296 null, i64 noundef 8388608, i32 noundef 12288, i32 noundef 4) #42
  store ptr %func, ptr %stack, align 8
  %stack_top = getelementptr inbounds i8, ptr %stack, i64 8388608
  %stack_top_i64 = ptrtoint ptr %stack_top to i64
  %stack_top_aligned = and i64 %stack_top_i64, -16
  %into_callee_buf = getelementptr inbounds i8, ptr %stack, i64 8
  %arg_passer_slot = getelementptr inbounds i8, ptr %stack, i64 32
  %into_callee_second_word = getelementptr inbounds i8, ptr %stack, i64 16
  %into_callee_third_word = getelementptr inbounds i8, ptr %stack, i64 24
  store i64 %stack_top_aligned, ptr %into_callee_buf, align 8
  store i64 %stack_top_aligned, ptr %into_callee_third_word, align 8
  store ptr %arg_passer, ptr %arg_passer_slot, align 8
  %is_finished = getelementptr inbounds i8, ptr %stack, i64 40
  store i1 false, ptr %is_finished, align 8
  tail call void @coroutine_trampoline(ptr noundef nonnull %into_callee_second_word)
  ret ptr %stack
}

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(1)
declare noalias ptr @VirtualAlloc(ptr, i64, i32, i32) local_unnamed_addr #26

declare void @coroutine_trampoline(ptr) local_unnamed_addr

define void @setup_landing_pad() {
  %region = tail call noalias dereferenceable_or_null(21474836480) ptr @VirtualAlloc(ptr nofree noundef align 4294967296 null, i64 noundef 21474836480, i32 noundef 12288, i32 noundef 4) #42
  store ptr %region, ptr @current_ptr, align 8
  %sp = tail call ptr @llvm.stacksave.p0() #9
  store ptr %sp, ptr @into_caller_buf, align 8
  store ptr blockaddress(@setup_landing_pad, %landing_pad), ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 8), align 8
  store ptr %sp, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  %stack.i = tail call noalias noundef nonnull align 8 dereferenceable(8388608) ptr @VirtualAlloc(ptr nofree noundef align 4294967296 null, i64 noundef 8388608, i32 noundef 12288, i32 noundef 4) #42
  store ptr @setup_landing_pad, ptr %stack.i, align 8
  %stack_top.i = getelementptr inbounds i8, ptr %stack.i, i64 8388608
  %stack_top_i64.i = ptrtoint ptr %stack_top.i to i64
  %stack_top_aligned.i = and i64 %stack_top_i64.i, -16
  %into_callee_buf.i = getelementptr inbounds i8, ptr %stack.i, i64 8
  %arg_passer_slot.i = getelementptr inbounds i8, ptr %stack.i, i64 32
  %into_callee_second_word.i = getelementptr inbounds i8, ptr %stack.i, i64 16
  %into_callee_third_word.i = getelementptr inbounds i8, ptr %stack.i, i64 24
  store i64 %stack_top_aligned.i, ptr %into_callee_buf.i, align 8
  store i64 %stack_top_aligned.i, ptr %into_callee_third_word.i, align 8
  store ptr @arg_passer, ptr %arg_passer_slot.i, align 8
  %is_finished.i = getelementptr inbounds i8, ptr %stack.i, i64 40
  store i1 false, ptr %is_finished.i, align 8
  tail call void @coroutine_trampoline(ptr noundef nonnull %into_callee_second_word.i)
  store ptr %stack.i, ptr @current_coroutine, align 8
  %retval.i = load i1, ptr @always_one, align 1
  br i1 %retval.i, label %exit, label %landing_pad

landing_pad:                                      ; preds = %0
  %ok = tail call i32 @printf(ptr nocapture nofree noundef nonnull readonly dereferenceable(4) @string_string.95, ptr nofree noundef nonnull align 16 dereferenceable(45) @exception_message) #7
  %cc.unpack = load ptr, ptr @current_coroutine, align 8
  %cc1 = insertvalue { ptr } poison, ptr %cc.unpack, 0
  tail call void @report_exception({ ptr } %cc1) #7
  tail call void @exit()
  unreachable

exit:                                             ; preds = %0
  ret void
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn
declare ptr @llvm.stacksave.p0() #27

define void @arg_passer(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %current_coroutine) {
  %func = load ptr, ptr %current_coroutine, align 8
  tail call void %func()
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none)
define i1 @returns_one() local_unnamed_addr #28 {
  %retval = load i1, ptr @always_one, align 1
  ret i1 %retval
}

declare void @exit() local_unnamed_addr

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none)
define i32 @get_offset(ptr nocapture nofree readonly align 8 %vptr, ptr nocapture nofree noundef nonnull readonly align 4 dereferenceable(8) %id_ptr) local_unnamed_addr #16 {
  %id = load i64, ptr %id_ptr, align 4
  %hash_coef_ptr = getelementptr i8, ptr %vptr, i64 8
  %tbl_size_ptr = getelementptr i8, ptr %vptr, i64 16
  %offset_tbl_ptr = getelementptr i8, ptr %vptr, i64 40
  %hash_coef = load i64, ptr %hash_coef_ptr, align 8
  %tbl_size = load i64, ptr %tbl_size_ptr, align 8
  %offset_tbl = load ptr, ptr %offset_tbl_ptr, align 8
  %product.i = mul i64 %hash_coef, %id
  %shifted.i = lshr i64 %product.i, 32
  %xored.i = xor i64 %shifted.i, %product.i
  %hash.i = and i64 %xored.i, %tbl_size
  %offset_ptr = getelementptr i32, ptr %offset_tbl, i64 %hash.i
  %offset = load i32, ptr %offset_ptr, align 4
  ret i32 %offset
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i64 @hash_to_index(i64 %tbl_size, i64 %hash_coef, i64 %cand_id) local_unnamed_addr #0 {
  %product = mul i64 %cand_id, %hash_coef
  %shifted = lshr i64 %product, 32
  %xored = xor i64 %shifted, %product
  %hash = and i64 %xored, %tbl_size
  ret i64 %hash
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @assume_offset(ptr nocapture nofree noundef nonnull readonly align 8 dereferenceable(8) %fat_ptr, ptr nocapture nofree readonly align 4 %id_ptr) local_unnamed_addr #0 {
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none)
define void @set_offset(ptr nocapture nofree noundef nonnull align 8 dereferenceable(8) %fat_ptr, ptr nocapture nofree readonly align 4 %id_ptr) local_unnamed_addr #1 {
  %vptr = load ptr, ptr %fat_ptr, align 8
  %id.i = load i64, ptr %id_ptr, align 4
  %hash_coef_ptr.i = getelementptr i8, ptr %vptr, i64 8
  %tbl_size_ptr.i = getelementptr i8, ptr %vptr, i64 16
  %offset_tbl_ptr.i = getelementptr i8, ptr %vptr, i64 40
  %hash_coef.i = load i64, ptr %hash_coef_ptr.i, align 4
  %tbl_size.i = load i64, ptr %tbl_size_ptr.i, align 4
  %offset_tbl.i = load ptr, ptr %offset_tbl_ptr.i, align 8
  %product.i.i = mul i64 %hash_coef.i, %id.i
  %shifted.i.i = lshr i64 %product.i.i, 32
  %xored.i.i = xor i64 %shifted.i.i, %product.i.i
  %hash.i.i = and i64 %xored.i.i, %tbl_size.i
  %offset_ptr.i = getelementptr i32, ptr %offset_tbl.i, i64 %hash.i.i
  %offset.i = load i32, ptr %offset_ptr.i, align 4
  %destination = getelementptr i8, ptr %fat_ptr, i64 24
  store i32 %offset.i, ptr %destination, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define i1 @subtype_test(i64 %tbl_size, i64 %hash_coef, i64 %cand_id, i64 %candidate, ptr nocapture nofree readonly %supertype_tbl) #18 {
  %product.i = mul i64 %cand_id, %hash_coef
  %shifted.i = lshr i64 %product.i, 32
  %xored.i = xor i64 %shifted.i, %product.i
  %hash.i = and i64 %xored.i, %tbl_size
  %gep = getelementptr i64, ptr %supertype_tbl, i64 %hash.i
  %stored_val = load i64, ptr %gep, align 4
  %eq = icmp eq i64 %stored_val, %candidate
  ret i1 %eq
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read)
define i1 @subtype_test_wrapper(ptr nocapture nofree noundef nonnull readonly %f, i64 %tbl_size, i64 %hash_coef, i64 %cand_id, i64 %candidate, ptr nofree readonly %supertype_tbl) local_unnamed_addr #18 {
  %result = tail call i1 %f(i64 %tbl_size, i64 %hash_coef, i64 %cand_id, i64 %candidate, ptr %supertype_tbl) #5
  ret i1 %result
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define void @arg_buffer_filler(ptr nocapture nofree readnone %coroutine) local_unnamed_addr #0 {
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none)
define ptr @get_current_coroutine() local_unnamed_addr #28 {
  %current_coroutine = load ptr, ptr @current_coroutine, align 8
  ret ptr %current_coroutine
}

; Function Attrs: noinline nounwind memory(readwrite)
define preserve_nonecc void @context_switch(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) %from_buf, ptr %to_buf) #29 {
  %from_buf_second_word = getelementptr inbounds i8, ptr %from_buf, i64 8
  %from_buf_third_word = getelementptr inbounds i8, ptr %from_buf, i64 16
  store ptr blockaddress(@context_switch, %return_from_switch), ptr %from_buf_second_word, align 8
  %sp = tail call ptr @llvm.stacksave.p0() #9
  store ptr %sp, ptr %from_buf, align 8
  store ptr %sp, ptr %from_buf_third_word, align 8
  %retval.i = load i1, ptr @always_one, align 1
  br i1 %retval.i, label %do_switch, label %return_from_switch

do_switch:                                        ; preds = %0
  tail call void @llvm.eh.sjlj.longjmp(ptr %to_buf) #30
  unreachable

return_from_switch:                               ; preds = %0
  ret void
}

; Function Attrs: noreturn nounwind
declare void @llvm.eh.sjlj.longjmp(ptr) #30

; Function Attrs: nounwind
define void @coroutine_yield(ptr nocapture nofree writeonly align 8 %current_coroutine) local_unnamed_addr #7 {
  %into_callee_buf = getelementptr i8, ptr %current_coroutine, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture nofree noundef writeonly align 8 %into_callee_buf, ptr noundef nonnull align 8 dereferenceable(24) @into_caller_buf) #41
  ret void
}

; Function Attrs: nounwind
define void @coroutine_call(ptr %coroutine) local_unnamed_addr #7 {
  %old_into_caller.unpack = load ptr, ptr @into_caller_buf, align 8
  %old_into_caller.unpack1 = load ptr, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 8), align 8
  %old_into_caller.unpack2 = load ptr, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  %old_coroutine = load ptr, ptr @current_coroutine, align 8
  store ptr %coroutine, ptr @current_coroutine, align 8
  %into_callee_buf = getelementptr i8, ptr %coroutine, i64 8
  tail call preserve_nonecc void @context_switch(ptr nocapture nofree noundef nonnull writeonly align 8 dereferenceable(24) @into_caller_buf, ptr %into_callee_buf) #41
  store ptr %old_coroutine, ptr @current_coroutine, align 8
  store ptr %old_into_caller.unpack, ptr @into_caller_buf, align 8
  store ptr %old_into_caller.unpack1, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 8), align 8
  store ptr %old_into_caller.unpack2, ptr getelementptr inbounds (i8, ptr @into_caller_buf, i64 16), align 8
  ret void
}

; Function Attrs: nofree nounwind
declare noundef i32 @puts(ptr nocapture noundef readonly) local_unnamed_addr #17

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #31

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #32

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #32

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #33

attributes #0 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none) }
attributes #2 = { mustprogress nounwind willreturn memory(readwrite, inaccessiblemem: none) }
attributes #3 = { mustprogress nounwind willreturn }
attributes #4 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #5 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: read) }
attributes #6 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: write) }
attributes #7 = { nounwind }
attributes #8 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #9 = { mustprogress nofree nosync nounwind willreturn }
attributes #10 = { mustprogress nofree nosync nounwind willreturn memory(read, inaccessiblemem: none) }
attributes #11 = { mustprogress nofree nosync nounwind willreturn memory(read, argmem: readwrite, inaccessiblemem: none) }
attributes #12 = { mustprogress nofree nosync nounwind willreturn memory(readwrite, inaccessiblemem: none) }
attributes #13 = { mustprogress nofree norecurse nosync nounwind willreturn memory(argmem: readwrite) }
attributes #14 = { mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: none, inaccessiblemem: none) }
attributes #15 = { mustprogress nofree norecurse nosync nounwind willreturn memory(readwrite, argmem: read, inaccessiblemem: none) }
attributes #16 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, inaccessiblemem: none) }
attributes #17 = { nofree nounwind }
attributes #18 = { mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: read) }
attributes #19 = { mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(argmem: readwrite) }
attributes #20 = { mustprogress nofree norecurse nosync nounwind speculatable willreturn memory(read, inaccessiblemem: none) }
attributes #21 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: read) }
attributes #22 = { mustprogress nofree norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(readwrite, argmem: none, inaccessiblemem: none) "alloc-family"="malloc" }
attributes #23 = { mustprogress nofree noinline norecurse nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) memory(argmem: readwrite) "alloc-family"="malloc" }
attributes #24 = { mustprogress nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #25 = { mustprogress nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #26 = { mustprogress nofree nounwind willreturn allockind("alloc,zeroed") allocsize(1) "alloc-family"="malloc" }
attributes #27 = { mustprogress nocallback nofree nosync nounwind willreturn }
attributes #28 = { mustprogress nofree norecurse nosync nounwind willreturn memory(read, argmem: none, inaccessiblemem: none) }
attributes #29 = { noinline nounwind memory(readwrite) }
attributes #30 = { noreturn nounwind }
attributes #31 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #32 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #33 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #34 = { nofree willreturn }
attributes #35 = { nounwind willreturn memory(argmem: readwrite) }
attributes #36 = { nounwind willreturn memory(argmem: read, inaccessiblemem: readwrite) }
attributes #37 = { mustprogress nofree nosync nounwind willreturn allockind("alloc,zeroed") allocsize(0) "alloc-family"="malloc" }
attributes #38 = { nofree }
attributes #39 = { mustprogress nofree nosync nounwind willreturn memory(argmem: read) }
attributes #40 = { willreturn }
attributes #41 = { nounwind memory(readwrite) }
attributes #42 = { mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(1) "alloc-family"="malloc" }

!llvm.module.flags = !{!0}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{!2}
!2 = distinct !{!2, !3, !"set_offset: %fat_ptr"}
!3 = distinct !{!3, !"set_offset"}
!4 = !{!5}
!5 = distinct !{!5, !6, !"set_offset: %fat_ptr"}
!6 = distinct !{!6, !"set_offset"}
!7 = !{!8}
!8 = distinct !{!8, !9, !"set_offset: %fat_ptr"}
!9 = distinct !{!9, !"set_offset"}
!10 = !{!11}
!11 = distinct !{!11, !12, !"set_offset: %fat_ptr"}
!12 = distinct !{!12, !"set_offset"}
!13 = !{!14}
!14 = distinct !{!14, !15, !"size_wrapper: argument 0"}
!15 = distinct !{!15, !"size_wrapper"}
!16 = !{!17}
!17 = distinct !{!17, !18, !"set_offset: %fat_ptr"}
!18 = distinct !{!18, !"set_offset"}
!19 = !{!20}
!20 = distinct !{!20, !21, !"size_wrapper: argument 0"}
!21 = distinct !{!21, !"size_wrapper"}
!22 = !{!23}
!23 = distinct !{!23, !24, !"set_offset: %fat_ptr"}
!24 = distinct !{!24, !"set_offset"}
!25 = !{!26}
!26 = distinct !{!26, !27, !"set_offset: %fat_ptr"}
!27 = distinct !{!27, !"set_offset"}
!28 = !{!29}
!29 = distinct !{!29, !30, !"set_offset: %fat_ptr"}
!30 = distinct !{!30, !"set_offset"}
!31 = !{!32}
!32 = distinct !{!32, !33, !"size_wrapper: argument 0"}
!33 = distinct !{!33, !"size_wrapper"}
!34 = !{!35}
!35 = distinct !{!35, !36, !"set_offset: %fat_ptr"}
!36 = distinct !{!36, !"set_offset"}
!37 = !{!38}
!38 = distinct !{!38, !39, !"size_wrapper: argument 0"}
!39 = distinct !{!39, !"size_wrapper"}
!40 = !{!41}
!41 = distinct !{!41, !42, !"set_offset: %fat_ptr"}
!42 = distinct !{!42, !"set_offset"}
!43 = !{!44}
!44 = distinct !{!44, !45, !"set_offset: %fat_ptr"}
!45 = distinct !{!45, !"set_offset"}
!46 = !{!47}
!47 = distinct !{!47, !48, !"size_wrapper: argument 0"}
!48 = distinct !{!48, !"size_wrapper"}
!49 = !{!50}
!50 = distinct !{!50, !51, !"set_offset: %fat_ptr"}
!51 = distinct !{!51, !"set_offset"}
!52 = !{!53}
!53 = distinct !{!53, !54, !"size_wrapper: argument 0"}
!54 = distinct !{!54, !"size_wrapper"}
!55 = !{!56}
!56 = distinct !{!56, !57, !"set_offset: %fat_ptr"}
!57 = distinct !{!57, !"set_offset"}
!58 = !{!59}
!59 = distinct !{!59, !60, !"set_offset: %fat_ptr"}
!60 = distinct !{!60, !"set_offset"}
!61 = !{!62}
!62 = distinct !{!62, !63, !"set_offset: %fat_ptr"}
!63 = distinct !{!63, !"set_offset"}
!64 = !{!65}
!65 = distinct !{!65, !66, !"size_wrapper: argument 0"}
!66 = distinct !{!66, !"size_wrapper"}
!67 = !{!68}
!68 = distinct !{!68, !69, !"set_offset: %fat_ptr"}
!69 = distinct !{!69, !"set_offset"}
!70 = !{!71}
!71 = distinct !{!71, !72, !"size_wrapper: argument 0"}
!72 = distinct !{!72, !"size_wrapper"}
!73 = !{!74}
!74 = distinct !{!74, !75, !"set_offset: %fat_ptr"}
!75 = distinct !{!75, !"set_offset"}
!76 = !{!77}
!77 = distinct !{!77, !78, !"set_offset: %fat_ptr"}
!78 = distinct !{!78, !"set_offset"}
!79 = !{!80}
!80 = distinct !{!80, !81, !"set_offset: %fat_ptr"}
!81 = distinct !{!81, !"set_offset"}
!82 = !{!83}
!83 = distinct !{!83, !84, !"set_offset: %fat_ptr"}
!84 = distinct !{!84, !"set_offset"}
!85 = !{!86}
!86 = distinct !{!86, !87, !"size_wrapper: argument 0"}
!87 = distinct !{!87, !"size_wrapper"}
!88 = !{!89}
!89 = distinct !{!89, !90, !"set_offset: %fat_ptr"}
!90 = distinct !{!90, !"set_offset"}
!91 = !{!92}
!92 = distinct !{!92, !93, !"size_wrapper: argument 0"}
!93 = distinct !{!93, !"size_wrapper"}
!94 = !{!95}
!95 = distinct !{!95, !96, !"set_offset: %fat_ptr"}
!96 = distinct !{!96, !"set_offset"}
!97 = !{!98}
!98 = distinct !{!98, !99, !"set_offset: %fat_ptr"}
!99 = distinct !{!99, !"set_offset"}
!100 = !{!101}
!101 = distinct !{!101, !102, !"size_wrapper: argument 0"}
!102 = distinct !{!102, !"size_wrapper"}
!103 = !{!104}
!104 = distinct !{!104, !105, !"set_offset: %fat_ptr"}
!105 = distinct !{!105, !"set_offset"}
!106 = !{!107}
!107 = distinct !{!107, !108, !"size_wrapper: argument 0"}
!108 = distinct !{!108, !"size_wrapper"}
!109 = !{!110}
!110 = distinct !{!110, !111, !"set_offset: %fat_ptr"}
!111 = distinct !{!111, !"set_offset"}
!112 = !{!113}
!113 = distinct !{!113, !114, !"set_offset: %fat_ptr"}
!114 = distinct !{!114, !"set_offset"}
!115 = !{!116}
!116 = distinct !{!116, !117, !"set_offset: %fat_ptr"}
!117 = distinct !{!117, !"set_offset"}
!118 = !{!119}
!119 = distinct !{!119, !120, !"set_offset: %fat_ptr"}
!120 = distinct !{!120, !"set_offset"}
!121 = !{!122}
!122 = distinct !{!122, !123, !"size_wrapper: argument 0"}
!123 = distinct !{!123, !"size_wrapper"}
!124 = !{!125}
!125 = distinct !{!125, !126, !"set_offset: %fat_ptr"}
!126 = distinct !{!126, !"set_offset"}
!127 = !{!128}
!128 = distinct !{!128, !129, !"size_wrapper: argument 0"}
!129 = distinct !{!129, !"size_wrapper"}
!130 = !{!131}
!131 = distinct !{!131, !132, !"set_offset: %fat_ptr"}
!132 = distinct !{!132, !"set_offset"}
!133 = !{!134}
!134 = distinct !{!134, !135, !"set_offset: %fat_ptr"}
!135 = distinct !{!135, !"set_offset"}
!136 = !{!137}
!137 = distinct !{!137, !138, !"size_wrapper: argument 0"}
!138 = distinct !{!138, !"size_wrapper"}
!139 = !{!140}
!140 = distinct !{!140, !141, !"set_offset: %fat_ptr"}
!141 = distinct !{!141, !"set_offset"}
!142 = !{!143}
!143 = distinct !{!143, !144, !"size_wrapper: argument 0"}
!144 = distinct !{!144, !"size_wrapper"}
!145 = !{!146}
!146 = distinct !{!146, !147, !"set_offset: %fat_ptr"}
!147 = distinct !{!147, !"set_offset"}
!148 = !{!149}
!149 = distinct !{!149, !150, !"set_offset: %fat_ptr"}
!150 = distinct !{!150, !"set_offset"}
!151 = !{!152}
!152 = distinct !{!152, !153, !"set_offset: %fat_ptr"}
!153 = distinct !{!153, !"set_offset"}
!154 = !{!155}
!155 = distinct !{!155, !156, !"set_offset: %fat_ptr"}
!156 = distinct !{!156, !"set_offset"}
!157 = !{!158}
!158 = distinct !{!158, !159, !"set_offset: %fat_ptr"}
!159 = distinct !{!159, !"set_offset"}
!160 = !{!161}
!161 = distinct !{!161, !162, !"size_wrapper: argument 0"}
!162 = distinct !{!162, !"size_wrapper"}
!163 = !{!164}
!164 = distinct !{!164, !165, !"set_offset: %fat_ptr"}
!165 = distinct !{!165, !"set_offset"}
!166 = !{!167}
!167 = distinct !{!167, !168, !"size_wrapper: argument 0"}
!168 = distinct !{!168, !"size_wrapper"}
!169 = !{!170}
!170 = distinct !{!170, !171, !"set_offset: %fat_ptr"}
!171 = distinct !{!171, !"set_offset"}
!172 = !{!173}
!173 = distinct !{!173, !174, !"set_offset: %fat_ptr"}
!174 = distinct !{!174, !"set_offset"}
!175 = !{!176}
!176 = distinct !{!176, !177, !"size_wrapper: argument 0"}
!177 = distinct !{!177, !"size_wrapper"}
!178 = !{!179}
!179 = distinct !{!179, !180, !"set_offset: %fat_ptr"}
!180 = distinct !{!180, !"set_offset"}
!181 = !{!182}
!182 = distinct !{!182, !183, !"size_wrapper: argument 0"}
!183 = distinct !{!183, !"size_wrapper"}
!184 = !{!185}
!185 = distinct !{!185, !186, !"set_offset: %fat_ptr"}
!186 = distinct !{!186, !"set_offset"}
!187 = !{!188}
!188 = distinct !{!188, !189, !"set_offset: %fat_ptr"}
!189 = distinct !{!189, !"set_offset"}
!190 = !{!191}
!191 = distinct !{!191, !192, !"size_wrapper: argument 0"}
!192 = distinct !{!192, !"size_wrapper"}
!193 = !{!194}
!194 = distinct !{!194, !195, !"set_offset: %fat_ptr"}
!195 = distinct !{!195, !"set_offset"}
!196 = !{!197}
!197 = distinct !{!197, !198, !"set_offset: %fat_ptr"}
!198 = distinct !{!198, !"set_offset"}
!199 = !{!200}
!200 = distinct !{!200, !201, !"size_wrapper: argument 0"}
!201 = distinct !{!201, !"size_wrapper"}
!202 = !{!203}
!203 = distinct !{!203, !204, !"set_offset: %fat_ptr"}
!204 = distinct !{!204, !"set_offset"}
!205 = !{!206}
!206 = distinct !{!206, !207, !"size_wrapper: argument 0"}
!207 = distinct !{!207, !"size_wrapper"}
!208 = !{!209}
!209 = distinct !{!209, !210, !"set_offset: %fat_ptr"}
!210 = distinct !{!210, !"set_offset"}
!211 = !{!212}
!212 = distinct !{!212, !213, !"set_offset: %fat_ptr"}
!213 = distinct !{!213, !"set_offset"}
!214 = !{!215}
!215 = distinct !{!215, !216, !"set_offset: %fat_ptr"}
!216 = distinct !{!216, !"set_offset"}
!217 = !{!218}
!218 = distinct !{!218, !219, !"size_wrapper: argument 0"}
!219 = distinct !{!219, !"size_wrapper"}
!220 = !{!221}
!221 = distinct !{!221, !222, !"set_offset: %fat_ptr"}
!222 = distinct !{!222, !"set_offset"}
!223 = !{!224}
!224 = distinct !{!224, !225, !"size_wrapper: argument 0"}
!225 = distinct !{!225, !"size_wrapper"}
!226 = !{!227}
!227 = distinct !{!227, !228, !"set_offset: %fat_ptr"}
!228 = distinct !{!228, !"set_offset"}
!229 = !{!230}
!230 = distinct !{!230, !231, !"set_offset: %fat_ptr"}
!231 = distinct !{!231, !"set_offset"}
!232 = !{!233}
!233 = distinct !{!233, !234, !"size_wrapper: argument 0"}
!234 = distinct !{!234, !"size_wrapper"}
!235 = !{!236}
!236 = distinct !{!236, !237, !"set_offset: %fat_ptr"}
!237 = distinct !{!237, !"set_offset"}
!238 = !{!239}
!239 = distinct !{!239, !240, !"size_wrapper: argument 0"}
!240 = distinct !{!240, !"size_wrapper"}
!241 = !{!242}
!242 = distinct !{!242, !243, !"set_offset: %fat_ptr"}
!243 = distinct !{!243, !"set_offset"}
!244 = !{!245}
!245 = distinct !{!245, !246, !"set_offset: %fat_ptr"}
!246 = distinct !{!246, !"set_offset"}
!247 = !{!248}
!248 = distinct !{!248, !249, !"set_offset: %fat_ptr"}
!249 = distinct !{!249, !"set_offset"}
!250 = !{!251}
!251 = distinct !{!251, !252, !"size_wrapper: argument 0"}
!252 = distinct !{!252, !"size_wrapper"}
!253 = !{!254}
!254 = distinct !{!254, !255, !"set_offset: %fat_ptr"}
!255 = distinct !{!255, !"set_offset"}
!256 = !{!257}
!257 = distinct !{!257, !258, !"size_wrapper: argument 0"}
!258 = distinct !{!258, !"size_wrapper"}
!259 = !{!260}
!260 = distinct !{!260, !261, !"set_offset: %fat_ptr"}
!261 = distinct !{!261, !"set_offset"}
!262 = !{!263}
!263 = distinct !{!263, !264, !"set_offset: %fat_ptr"}
!264 = distinct !{!264, !"set_offset"}
!265 = !{!266}
!266 = distinct !{!266, !267, !"set_offset: %fat_ptr"}
!267 = distinct !{!267, !"set_offset"}
!268 = !{!269}
!269 = distinct !{!269, !270, !"set_offset: %fat_ptr"}
!270 = distinct !{!270, !"set_offset"}
!271 = !{!272}
!272 = distinct !{!272, !273, !"size_wrapper: argument 0"}
!273 = distinct !{!273, !"size_wrapper"}
!274 = !{!275}
!275 = distinct !{!275, !276, !"set_offset: %fat_ptr"}
!276 = distinct !{!276, !"set_offset"}
!277 = !{!278}
!278 = distinct !{!278, !279, !"size_wrapper: argument 0"}
!279 = distinct !{!279, !"size_wrapper"}
!280 = !{!281}
!281 = distinct !{!281, !282, !"set_offset: %fat_ptr"}
!282 = distinct !{!282, !"set_offset"}
!283 = !{!284}
!284 = distinct !{!284, !285, !"set_offset: %fat_ptr"}
!285 = distinct !{!285, !"set_offset"}
!286 = !{!287}
!287 = distinct !{!287, !288, !"size_wrapper: argument 0"}
!288 = distinct !{!288, !"size_wrapper"}
!289 = !{!290}
!290 = distinct !{!290, !291, !"set_offset: %fat_ptr"}
!291 = distinct !{!291, !"set_offset"}
!292 = !{!293}
!293 = distinct !{!293, !294, !"size_wrapper: argument 0"}
!294 = distinct !{!294, !"size_wrapper"}
!295 = !{!296}
!296 = distinct !{!296, !297, !"set_offset: %fat_ptr"}
!297 = distinct !{!297, !"set_offset"}
!298 = !{!299}
!299 = distinct !{!299, !300, !"set_offset: %fat_ptr"}
!300 = distinct !{!300, !"set_offset"}
!301 = !{!302}
!302 = distinct !{!302, !303, !"set_offset: %fat_ptr"}
!303 = distinct !{!303, !"set_offset"}
!304 = !{!305}
!305 = distinct !{!305, !306, !"set_offset: %fat_ptr"}
!306 = distinct !{!306, !"set_offset"}
!307 = !{!308}
!308 = distinct !{!308, !309, !"set_offset: %fat_ptr"}
!309 = distinct !{!309, !"set_offset"}
!310 = !{!311}
!311 = distinct !{!311, !312, !"set_offset: %fat_ptr"}
!312 = distinct !{!312, !"set_offset"}
!313 = !{!314}
!314 = distinct !{!314, !315, !"set_offset: %fat_ptr"}
!315 = distinct !{!315, !"set_offset"}
!316 = !{!317}
!317 = distinct !{!317, !318, !"set_offset: %fat_ptr"}
!318 = distinct !{!318, !"set_offset"}
!319 = !{!320}
!320 = distinct !{!320, !321, !"set_offset: %fat_ptr"}
!321 = distinct !{!321, !"set_offset"}
!322 = !{!323}
!323 = distinct !{!323, !324, !"set_offset: %fat_ptr"}
!324 = distinct !{!324, !"set_offset"}
!325 = !{!326}
!326 = distinct !{!326, !327, !"set_offset: %fat_ptr"}
!327 = distinct !{!327, !"set_offset"}
!328 = !{!329}
!329 = distinct !{!329, !330, !"set_offset: %fat_ptr"}
!330 = distinct !{!330, !"set_offset"}
!331 = !{!332}
!332 = distinct !{!332, !333, !"set_offset: %fat_ptr"}
!333 = distinct !{!333, !"set_offset"}
!334 = !{!335}
!335 = distinct !{!335, !336, !"size_wrapper: argument 0"}
!336 = distinct !{!336, !"size_wrapper"}
!337 = !{!338}
!338 = distinct !{!338, !339, !"set_offset: %fat_ptr"}
!339 = distinct !{!339, !"set_offset"}
!340 = !{!341}
!341 = distinct !{!341, !342, !"set_offset: %fat_ptr"}
!342 = distinct !{!342, !"set_offset"}
!343 = !{!344}
!344 = distinct !{!344, !345, !"set_offset: %fat_ptr"}
!345 = distinct !{!345, !"set_offset"}
!346 = !{!347}
!347 = distinct !{!347, !348, !"set_offset: %fat_ptr"}
!348 = distinct !{!348, !"set_offset"}
!349 = !{!350}
!350 = distinct !{!350, !351, !"set_offset: %fat_ptr"}
!351 = distinct !{!351, !"set_offset"}
!352 = !{!353}
!353 = distinct !{!353, !354, !"set_offset: %fat_ptr"}
!354 = distinct !{!354, !"set_offset"}
!355 = !{!356}
!356 = distinct !{!356, !357, !"size_wrapper: argument 0"}
!357 = distinct !{!357, !"size_wrapper"}
!358 = !{!359}
!359 = distinct !{!359, !360, !"set_offset: %fat_ptr"}
!360 = distinct !{!360, !"set_offset"}
!361 = !{!362}
!362 = distinct !{!362, !363, !"set_offset: %fat_ptr"}
!363 = distinct !{!363, !"set_offset"}
!364 = !{!365}
!365 = distinct !{!365, !366, !"set_offset: %fat_ptr"}
!366 = distinct !{!366, !"set_offset"}
!367 = !{!368}
!368 = distinct !{!368, !369, !"set_offset: %fat_ptr"}
!369 = distinct !{!369, !"set_offset"}
!370 = !{!371}
!371 = distinct !{!371, !372, !"set_offset: %fat_ptr"}
!372 = distinct !{!372, !"set_offset"}
!373 = !{}
!374 = !{!375}
!375 = distinct !{!375, !376, !"set_offset: %fat_ptr"}
!376 = distinct !{!376, !"set_offset"}
!377 = !{!378}
!378 = distinct !{!378, !379, !"set_offset: %fat_ptr"}
!379 = distinct !{!379, !"set_offset"}
!380 = !{!381}
!381 = distinct !{!381, !382, !"set_offset: %fat_ptr"}
!382 = distinct !{!382, !"set_offset"}
!383 = !{!384}
!384 = distinct !{!384, !385, !"set_offset: %fat_ptr"}
!385 = distinct !{!385, !"set_offset"}
!386 = !{!387}
!387 = distinct !{!387, !388, !"set_offset: %fat_ptr"}
!388 = distinct !{!388, !"set_offset"}
!389 = !{!390}
!390 = distinct !{!390, !391, !"set_offset: %fat_ptr"}
!391 = distinct !{!391, !"set_offset"}
!392 = !{!393}
!393 = distinct !{!393, !394, !"set_offset: %fat_ptr"}
!394 = distinct !{!394, !"set_offset"}
!395 = !{!396}
!396 = distinct !{!396, !397, !"set_offset: %fat_ptr"}
!397 = distinct !{!397, !"set_offset"}
!398 = !{!399}
!399 = distinct !{!399, !400, !"set_offset: %fat_ptr"}
!400 = distinct !{!400, !"set_offset"}
!401 = !{!402}
!402 = distinct !{!402, !403, !"set_offset: %fat_ptr"}
!403 = distinct !{!403, !"set_offset"}
!404 = !{!405}
!405 = distinct !{!405, !406, !"set_offset: %fat_ptr"}
!406 = distinct !{!406, !"set_offset"}
!407 = !{!408}
!408 = distinct !{!408, !409, !"set_offset: %fat_ptr"}
!409 = distinct !{!409, !"set_offset"}
!410 = !{!411}
!411 = distinct !{!411, !412, !"set_offset: %fat_ptr"}
!412 = distinct !{!412, !"set_offset"}
!413 = !{!414}
!414 = distinct !{!414, !415, !"set_offset: %fat_ptr"}
!415 = distinct !{!415, !"set_offset"}
!416 = !{!417}
!417 = distinct !{!417, !418, !"set_offset: %fat_ptr"}
!418 = distinct !{!418, !"set_offset"}
!419 = !{!420}
!420 = distinct !{!420, !421, !"set_offset: %fat_ptr"}
!421 = distinct !{!421, !"set_offset"}
!422 = !{!423}
!423 = distinct !{!423, !424, !"set_offset: %fat_ptr"}
!424 = distinct !{!424, !"set_offset"}
!425 = !{!426}
!426 = distinct !{!426, !427, !"set_offset: %fat_ptr"}
!427 = distinct !{!427, !"set_offset"}
!428 = !{!429}
!429 = distinct !{!429, !430, !"set_offset: %fat_ptr"}
!430 = distinct !{!430, !"set_offset"}
!431 = !{!432}
!432 = distinct !{!432, !433, !"set_offset: %fat_ptr"}
!433 = distinct !{!433, !"set_offset"}
!434 = !{!435}
!435 = distinct !{!435, !436, !"set_offset: %fat_ptr"}
!436 = distinct !{!436, !"set_offset"}
!437 = !{!438}
!438 = distinct !{!438, !439, !"set_offset: %fat_ptr"}
!439 = distinct !{!439, !"set_offset"}
!440 = !{!441}
!441 = distinct !{!441, !442, !"set_offset: %fat_ptr"}
!442 = distinct !{!442, !"set_offset"}
!443 = !{!444}
!444 = distinct !{!444, !445, !"set_offset: %fat_ptr"}
!445 = distinct !{!445, !"set_offset"}
!446 = !{!447}
!447 = distinct !{!447, !448, !"set_offset: %fat_ptr"}
!448 = distinct !{!448, !"set_offset"}
!449 = !{!450}
!450 = distinct !{!450, !451, !"set_offset: %fat_ptr"}
!451 = distinct !{!451, !"set_offset"}
!452 = !{!453}
!453 = distinct !{!453, !454, !"set_offset: %fat_ptr"}
!454 = distinct !{!454, !"set_offset"}
!455 = !{!456}
!456 = distinct !{!456, !457, !"set_offset: %fat_ptr"}
!457 = distinct !{!457, !"set_offset"}
!458 = !{!459}
!459 = distinct !{!459, !460, !"set_offset: %fat_ptr"}
!460 = distinct !{!460, !"set_offset"}
!461 = !{!462}
!462 = distinct !{!462, !463, !"set_offset: %fat_ptr"}
!463 = distinct !{!463, !"set_offset"}
!464 = !{!465}
!465 = distinct !{!465, !466, !"set_offset: %fat_ptr"}
!466 = distinct !{!466, !"set_offset"}
!467 = !{!468}
!468 = distinct !{!468, !469, !"set_offset: %fat_ptr"}
!469 = distinct !{!469, !"set_offset"}
!470 = !{!471}
!471 = distinct !{!471, !472, !"set_offset: %fat_ptr"}
!472 = distinct !{!472, !"set_offset"}
!473 = !{!474}
!474 = distinct !{!474, !475, !"set_offset: %fat_ptr"}
!475 = distinct !{!475, !"set_offset"}
!476 = !{!477}
!477 = distinct !{!477, !478, !"set_offset: %fat_ptr"}
!478 = distinct !{!478, !"set_offset"}
!479 = !{!480}
!480 = distinct !{!480, !481, !"set_offset: %fat_ptr"}
!481 = distinct !{!481, !"set_offset"}
!482 = !{!483}
!483 = distinct !{!483, !484, !"set_offset: %fat_ptr"}
!484 = distinct !{!484, !"set_offset"}
!485 = !{!486}
!486 = distinct !{!486, !487, !"set_offset: %fat_ptr"}
!487 = distinct !{!487, !"set_offset"}
!488 = !{!489}
!489 = distinct !{!489, !490, !"set_offset: %fat_ptr"}
!490 = distinct !{!490, !"set_offset"}
!491 = !{!492}
!492 = distinct !{!492, !493, !"set_offset: %fat_ptr"}
!493 = distinct !{!493, !"set_offset"}
!494 = !{!495}
!495 = distinct !{!495, !496, !"set_offset: %fat_ptr"}
!496 = distinct !{!496, !"set_offset"}
!497 = !{!498}
!498 = distinct !{!498, !499, !"set_offset: %fat_ptr"}
!499 = distinct !{!499, !"set_offset"}
!500 = !{!501}
!501 = distinct !{!501, !502, !"set_offset: %fat_ptr"}
!502 = distinct !{!502, !"set_offset"}
!503 = !{!504}
!504 = distinct !{!504, !505, !"set_offset: %fat_ptr"}
!505 = distinct !{!505, !"set_offset"}
!506 = !{!507}
!507 = distinct !{!507, !508, !"set_offset: %fat_ptr"}
!508 = distinct !{!508, !"set_offset"}
!509 = !{!510}
!510 = distinct !{!510, !511, !"set_offset: %fat_ptr"}
!511 = distinct !{!511, !"set_offset"}
!512 = !{!513}
!513 = distinct !{!513, !514, !"set_offset: %fat_ptr"}
!514 = distinct !{!514, !"set_offset"}
!515 = !{!516}
!516 = distinct !{!516, !517, !"set_offset: %fat_ptr"}
!517 = distinct !{!517, !"set_offset"}
!518 = !{!519}
!519 = distinct !{!519, !520, !"set_offset: %fat_ptr"}
!520 = distinct !{!520, !"set_offset"}
!521 = !{!522}
!522 = distinct !{!522, !523, !"set_offset: %fat_ptr"}
!523 = distinct !{!523, !"set_offset"}
!524 = !{!525}
!525 = distinct !{!525, !526, !"set_offset: %fat_ptr"}
!526 = distinct !{!526, !"set_offset"}
!527 = !{!528}
!528 = distinct !{!528, !529, !"set_offset: %fat_ptr"}
!529 = distinct !{!529, !"set_offset"}
!530 = !{!531}
!531 = distinct !{!531, !532, !"set_offset: %fat_ptr"}
!532 = distinct !{!532, !"set_offset"}
!533 = !{!534}
!534 = distinct !{!534, !535, !"set_offset: %fat_ptr"}
!535 = distinct !{!535, !"set_offset"}
!536 = !{!537}
!537 = distinct !{!537, !538, !"set_offset: %fat_ptr"}
!538 = distinct !{!538, !"set_offset"}
!539 = !{!540}
!540 = distinct !{!540, !541, !"set_offset: %fat_ptr"}
!541 = distinct !{!541, !"set_offset"}
!542 = !{!543}
!543 = distinct !{!543, !544, !"set_offset: %fat_ptr"}
!544 = distinct !{!544, !"set_offset"}
!545 = !{!546}
!546 = distinct !{!546, !547, !"set_offset: %fat_ptr"}
!547 = distinct !{!547, !"set_offset"}
!548 = !{!549}
!549 = distinct !{!549, !550, !"size_wrapper: argument 0"}
!550 = distinct !{!550, !"size_wrapper"}
!551 = !{!552}
!552 = distinct !{!552, !553, !"set_offset: %fat_ptr"}
!553 = distinct !{!553, !"set_offset"}
!554 = !{!555}
!555 = distinct !{!555, !556, !"set_offset: %fat_ptr"}
!556 = distinct !{!556, !"set_offset"}
!557 = !{!558}
!558 = distinct !{!558, !559, !"set_offset: %fat_ptr"}
!559 = distinct !{!559, !"set_offset"}
!560 = !{!561}
!561 = distinct !{!561, !562, !"set_offset: %fat_ptr"}
!562 = distinct !{!562, !"set_offset"}
!563 = !{!564}
!564 = distinct !{!564, !565, !"set_offset: %fat_ptr"}
!565 = distinct !{!565, !"set_offset"}
!566 = !{!567}
!567 = distinct !{!567, !568, !"set_offset: %fat_ptr"}
!568 = distinct !{!568, !"set_offset"}
!569 = !{!570}
!570 = distinct !{!570, !571, !"set_offset: %fat_ptr"}
!571 = distinct !{!571, !"set_offset"}
!572 = !{!573}
!573 = distinct !{!573, !574, !"set_offset: %fat_ptr"}
!574 = distinct !{!574, !"set_offset"}
!575 = !{!576}
!576 = distinct !{!576, !577, !"set_offset: %fat_ptr"}
!577 = distinct !{!577, !"set_offset"}
!578 = !{!579}
!579 = distinct !{!579, !580, !"set_offset: %fat_ptr"}
!580 = distinct !{!580, !"set_offset"}
!581 = !{!582}
!582 = distinct !{!582, !583, !"set_offset: %fat_ptr"}
!583 = distinct !{!583, !"set_offset"}
!584 = !{!585}
!585 = distinct !{!585, !586, !"set_offset: %fat_ptr"}
!586 = distinct !{!586, !"set_offset"}
!587 = !{!588}
!588 = distinct !{!588, !589, !"set_offset: %fat_ptr"}
!589 = distinct !{!589, !"set_offset"}
!590 = !{!591}
!591 = distinct !{!591, !592, !"set_offset: %fat_ptr"}
!592 = distinct !{!592, !"set_offset"}
!593 = !{!594}
!594 = distinct !{!594, !595, !"set_offset: %fat_ptr"}
!595 = distinct !{!595, !"set_offset"}
!596 = !{!597}
!597 = distinct !{!597, !598, !"set_offset: %fat_ptr"}
!598 = distinct !{!598, !"set_offset"}
!599 = !{!600}
!600 = distinct !{!600, !601, !"set_offset: %fat_ptr"}
!601 = distinct !{!601, !"set_offset"}
!602 = !{!603}
!603 = distinct !{!603, !604, !"set_offset: %fat_ptr"}
!604 = distinct !{!604, !"set_offset"}
!605 = !{!606}
!606 = distinct !{!606, !607, !"set_offset: %fat_ptr"}
!607 = distinct !{!607, !"set_offset"}
!608 = !{!609}
!609 = distinct !{!609, !610, !"set_offset: %fat_ptr"}
!610 = distinct !{!610, !"set_offset"}
!611 = !{!612}
!612 = distinct !{!612, !613, !"set_offset: %fat_ptr"}
!613 = distinct !{!613, !"set_offset"}
!614 = !{!615}
!615 = distinct !{!615, !616, !"set_offset: %fat_ptr"}
!616 = distinct !{!616, !"set_offset"}
!617 = !{!618}
!618 = distinct !{!618, !619, !"set_offset: %fat_ptr"}
!619 = distinct !{!619, !"set_offset"}
!620 = !{!621}
!621 = distinct !{!621, !622, !"set_offset: %fat_ptr"}
!622 = distinct !{!622, !"set_offset"}
!623 = !{!624}
!624 = distinct !{!624, !625, !"set_offset: %fat_ptr"}
!625 = distinct !{!625, !"set_offset"}
!626 = !{!627}
!627 = distinct !{!627, !628, !"set_offset: %fat_ptr"}
!628 = distinct !{!628, !"set_offset"}
!629 = !{!630}
!630 = distinct !{!630, !631, !"set_offset: %fat_ptr"}
!631 = distinct !{!631, !"set_offset"}
!632 = !{!633}
!633 = distinct !{!633, !634, !"set_offset: %fat_ptr"}
!634 = distinct !{!634, !"set_offset"}
!635 = !{!636}
!636 = distinct !{!636, !637, !"set_offset: %fat_ptr"}
!637 = distinct !{!637, !"set_offset"}
!638 = !{!639}
!639 = distinct !{!639, !640, !"set_offset: %fat_ptr"}
!640 = distinct !{!640, !"set_offset"}
!641 = !{!642}
!642 = distinct !{!642, !643, !"set_offset: %fat_ptr"}
!643 = distinct !{!643, !"set_offset"}
!644 = !{!645}
!645 = distinct !{!645, !646, !"set_offset: %fat_ptr"}
!646 = distinct !{!646, !"set_offset"}
!647 = !{!648}
!648 = distinct !{!648, !649, !"set_offset: %fat_ptr"}
!649 = distinct !{!649, !"set_offset"}
!650 = !{!651}
!651 = distinct !{!651, !652, !"set_offset: %fat_ptr"}
!652 = distinct !{!652, !"set_offset"}
!653 = !{!654}
!654 = distinct !{!654, !655, !"set_offset: %fat_ptr"}
!655 = distinct !{!655, !"set_offset"}
!656 = !{!657}
!657 = distinct !{!657, !658, !"set_offset: %fat_ptr"}
!658 = distinct !{!658, !"set_offset"}
!659 = !{!660}
!660 = distinct !{!660, !661, !"set_offset: %fat_ptr"}
!661 = distinct !{!661, !"set_offset"}
!662 = !{!663}
!663 = distinct !{!663, !664, !"set_offset: %fat_ptr"}
!664 = distinct !{!664, !"set_offset"}
!665 = !{!666}
!666 = distinct !{!666, !667, !"set_offset: %fat_ptr"}
!667 = distinct !{!667, !"set_offset"}
!668 = !{!669}
!669 = distinct !{!669, !670, !"set_offset: %fat_ptr"}
!670 = distinct !{!670, !"set_offset"}
!671 = !{!672}
!672 = distinct !{!672, !673, !"set_offset: %fat_ptr"}
!673 = distinct !{!673, !"set_offset"}
!674 = !{!675}
!675 = distinct !{!675, !676, !"set_offset: %fat_ptr"}
!676 = distinct !{!676, !"set_offset"}
!677 = !{!678}
!678 = distinct !{!678, !679, !"set_offset: %fat_ptr"}
!679 = distinct !{!679, !"set_offset"}
!680 = !{!681}
!681 = distinct !{!681, !682, !"set_offset: %fat_ptr"}
!682 = distinct !{!682, !"set_offset"}
!683 = !{!684}
!684 = distinct !{!684, !685, !"set_offset: %fat_ptr"}
!685 = distinct !{!685, !"set_offset"}
!686 = !{!687}
!687 = distinct !{!687, !688, !"set_offset: %fat_ptr"}
!688 = distinct !{!688, !"set_offset"}
!689 = !{!690}
!690 = distinct !{!690, !691, !"set_offset: %fat_ptr"}
!691 = distinct !{!691, !"set_offset"}
!692 = !{!693}
!693 = distinct !{!693, !694, !"set_offset: %fat_ptr"}
!694 = distinct !{!694, !"set_offset"}
!695 = !{!696}
!696 = distinct !{!696, !697, !"set_offset: %fat_ptr"}
!697 = distinct !{!697, !"set_offset"}
!698 = !{!699}
!699 = distinct !{!699, !700, !"set_offset: %fat_ptr"}
!700 = distinct !{!700, !"set_offset"}
!701 = !{!702}
!702 = distinct !{!702, !703, !"set_offset: %fat_ptr"}
!703 = distinct !{!703, !"set_offset"}
!704 = !{!705}
!705 = distinct !{!705, !706, !"set_offset: %fat_ptr"}
!706 = distinct !{!706, !"set_offset"}
!707 = !{!708}
!708 = distinct !{!708, !709, !"set_offset: %fat_ptr"}
!709 = distinct !{!709, !"set_offset"}
!710 = !{!711}
!711 = distinct !{!711, !712, !"set_offset: %fat_ptr"}
!712 = distinct !{!712, !"set_offset"}
!713 = !{!714}
!714 = distinct !{!714, !715, !"set_offset: %fat_ptr"}
!715 = distinct !{!715, !"set_offset"}
!716 = !{!717}
!717 = distinct !{!717, !718, !"set_offset: %fat_ptr"}
!718 = distinct !{!718, !"set_offset"}
!719 = !{!720}
!720 = distinct !{!720, !721, !"set_offset: %fat_ptr"}
!721 = distinct !{!721, !"set_offset"}
!722 = !{!723}
!723 = distinct !{!723, !724, !"set_offset: %fat_ptr"}
!724 = distinct !{!724, !"set_offset"}
!725 = !{!726}
!726 = distinct !{!726, !727, !"set_offset: %fat_ptr"}
!727 = distinct !{!727, !"set_offset"}
