import collections;

def i32_hasher(i : i32) -> i32 {
	i = (i + 0x7ed55d16) + (i << 12);
    i = (i bit_xor 0xc761c23c) bit_xor (i >> 19);
    i = (i + 0x165667b1) + (i << 5);
    i = (i + 0xd3a2646c) bit_xor (i << 9);
    i = (i + 0xfd7046c5) + (i << 3);
    i = (i bit_xor 0xb55a4f09) bit_xor (i >> 16);
    return i;
}

def i32_eq(a : i32, b : i32) -> Bool {
	return a == b;
}

class Tombstone {
	def init() {}
}

class Entry[K,V] {
    @key: K
    @value: V | Tombstone
    @hash: i32

    def init(@key: K, @value: V | Tombstone, @hash: i32) {}
    
    def key() -> K { return @key; }
    def value() -> V | Tombstone { return @value; }
    def hash() -> i32 { return @hash; }
}

class HashMap[K,V] extends Iterable2[Pair[K,V]] {
    @entries: Buffer[Entry[K,V] | Nil]
    @capacity: i32  // Track buffer size explicitly
    @size: i32      // Number of actual entries
    @load: i32      // Number of entries including tombstones
    @hasher: (K) -> i32
    @eq: (K, K) -> Bool
    
    def init(@hasher: (K) -> i32, @eq : (K, K) -> Bool) {
        @capacity = 16;  // Start with power of 2 size
        @entries = Buffer[Entry[K,V] | Nil].new(@capacity);
        @size = 0;
        @load = 0;
    }

    def find_slot(key: K, hash: i32) -> i32 {
        i = hash bit_and (@capacity - 1);  // Mask to table size
        while true {
            entry = @entries.[i];
            if entry is Entry[K, V] {
            	if entry.hash() == hash {
                	if @eq.call(entry.key(), key) { return i; }
            	}
            	i = (i + 1) bit_and (@capacity - 1);  // Linear probe
            }
            return i;
        }
    }

    def resize(new_capacity: i32) {
        old_entries = @entries;
        old_capacity = @capacity;
        
        @capacity = new_capacity;
        @entries = Buffer[Entry[K,V] | Nil].new(@capacity);
        @load = 0;
        @size = 0;
        
        i = 0;
        while i < old_capacity {
            entry = old_entries.[i];
            if entry is Entry[K,V] {
                val = entry.value();
                if val is V {
                    self.insert(entry.key(), val);
                }
            }
            i = i + 1;
        }
    }

    def insert(key: K, value: V) {
        // Grow at 70% load factor
        if (@load * 10) / @capacity > 7 {
            self.resize(@capacity * 2);
        }

        hash = @hasher.call(key);
        i = self.find_slot(key, hash);
        entry = @entries.[i];

        if entry is Entry[K, V] {
        	val = entry.value();
	        if val is V {
	            @entries.[i] = Entry[K,V].new(key, value, hash);
	            return;
	        }

	        // Was a tombstone
	        @entries.[i] = Entry[K,V].new(key, value, hash);
	        @size = @size + 1;
	        return;
        }

        @entries.[i] = Entry[K,V].new(key, value, hash);
        @size = @size + 1;
        @load = @load + 1;
    }

    def get(key: K) -> V | Nil {
        hash = @hasher.call(key);
        i = self.find_slot(key, hash);
        entry = @entries.[i];
        
        if entry is Entry[K, V] {
        	val = entry.value();
        	if val is V { return val; }
        }
        return nil;
    }

    def remove(key: K) -> V | Nil {
        hash = @hasher.call(key);
        i = self.find_slot(key, hash);
        entry = @entries.[i];

        if entry is Entry[K, V] {
        	val = entry.value();
        	if val is V {
        		@entries.[i] = Entry[K,V].new(key, Tombstone.new(), hash);
        		@size = @size - 1;
        		return val;
        	}
        }
        return nil;
    }

    def clear() {
        @capacity = 16;
        @entries = Buffer[Entry[K,V] | Nil].new(@capacity);
        @size = 0;
        @load = 0;
    }

    def size() -> i32 { return @size; }

    def entries() -> Buffer[Entry[K,V] | Nil] { return @entries; }
    
    def capacity() -> i32 { return @capacity; }

    def iterator() -> HashMapIterator[K,V] {
        return HashMapIterator[K,V].new(self);
    }
}

class HashMapIterator[K,V] extends Iterator2[Pair[K,V]] {
    @map: HashMap[K,V]
    @index: i32

    def init(@map: HashMap[K,V]) {
        @index = 0;
    }

    def next() -> Pair[K,V] | Nil {
        while @index < @map.capacity() {
            entry = @map.entries().[@index];
            @index = @index + 1;
            
            if entry is Entry[K,V] {
                val = entry.value();
                if val is V {
                    return Pair[K,V].new(entry.key(), val);
                }
            }
        }
        return nil;
    }
}

// Default string hasher
def string_hasher(s: String) -> i32 {
    hash : i32 = 0;
    seed : i32 = 31;
    
    for c in s {
    	cast : i32 = c.byte();
        hash = hash * seed + cast;
    }
    return hash;
}

map = HashMap[i32, i32].new(i32_hasher, i32_eq);
map.insert(5,77);
map.insert(8,34);
map.insert(15,99);
IO.print(map.get(8));