start: statement*

statement: function_def
         | extern_def
         | class_def
         | import_statement ";"
         | var_decl ";"
         | assignment ";"
         | alias ";"
         | if_statement
         | while_statement
         | for_statement
         | return_statement ";"
         | break_statement ";"
         | continue_statement ";"
         | expression_statement
         | block

import_statement: "import" ident ("." ident)*
alias: ALIAS basic_type "=" typ

expression_statement: expression ";"

class_def: CLASS (basic_type | parameterized_type) ["extends" type_list] ["where" type_bound_list] "{" [field_decls] [class_region_constraints] (class_method_def*)? ((method_def | operator_def)*)? "}"
field_decls: (field_decl)+
type_bound_list: type_bound ("," type_bound)*
type_bound: ident "<:" typ

ident_list: ident ("," ident)*

extern_def: ["#["constraint_list"]"] "extern" DEF ident "(" param_list ")" ["->" typ] ["yields" typ]
function_def: ["#["constraint_list"]"] DEF ident "(" param_list ")" ["->" typ] ["yields" typ] block
abstract: "abstract"
method_def: ["#["constraint_list"]"] [abstract] DEF method_name ["[" ident_list "]"] "(" method_param_list ")" ["->" typ] ["yields" typ] block
operator_def: ["#["constraint_list"]"] [abstract] DEF operator ["[" ident_list "]"] "(" method_param_list ")" ["->" typ] ["yields" typ] block
class_method_def: ["#["constraint_list"]"] [abstract] DEF SELF_TYPE "." ident ["[" ident_list "]"] "(" method_param_list ")" ["->" typ] ["yields" typ] block

method_name: (ident | SETTER)

param_list: (param ("," param)*)?
method_param_list: (method_param ("," method_param)*)? -> param_list

class_region_constraints: "regions" "{" constraint_list "}" 
constraint_list: (constraint ("," constraint)*)?
constraint: region_variable LT region_variable
          | region_variable GT region_variable
          | region_variable EQ region_variable
region_variable: ((ident | FIELD) ("." (ident | FIELD))*)? 

method_param: param | field_param
param: ident ":" typ
field_param: FIELD ":" typ -> param

var_decl: ident ":" typ ["=" expression]
field_decl: FIELD ":" typ
assignment: assignable "=" expression

assignable: ident -> identifier
          | FIELD -> identifier
          | "(" assignable ")" -> paren_expr
          | function_call
          | method_call
          | object_creation
          | indexation

if_statement: "if" expression block ("else" block)?
while_statement: "while" expression block
for_statement: "for" ident "in" expression block
return_statement: RETURN [expression]
break_statement: BREAK
continue_statement: CONTINUE

typ: basic_type
    | sum_type
    | parameterized_type
    | function_type

type_list: (typ ("," typ)*)?
type_count: INT "x" typ
basic_type: ident
sum_type: typ "|" typ
parameterized_type: ident "[" (type_list | type_count) "]"
function_type: "(" type_list ")" ["->" typ] ["yields" typ]

block: "{" statement* "}"

expression: logical

logical: and -> logical_single
          | logical OR and

and: comparison -> logical_single
          | and AND comparison -> logical

comparison: arithmetic -> comparison_single
          | comparison NEQ arithmetic
          | comparison EQ arithmetic
          | comparison LT arithmetic
          | comparison GT arithmetic
          | comparison LE arithmetic
          | comparison GE arithmetic
          | comparison ":" arithmetic -> range_literal
          | comparison "is" typ -> type_check

arithmetic: term -> arithmetic_single
          | arithmetic PLUS term
          | arithmetic MINUS term

term: cast -> term_single
    | term TIMES cast -> arithmetic
    | term DIVIDE cast -> arithmetic
    | term MODULO cast -> arithmetic
    | term LSHIFT cast -> arithmetic
    | term RSHIFT cast -> arithmetic
    | term BIT_AND cast -> arithmetic
    | term BIT_OR cast -> arithmetic
    | term BIT_XOR cast -> arithmetic

cast: factor -> cast_single
    | cast AS typ -> as_op

factor: primary -> factor_single
      | MINUS factor -> neg_op
      | NOT factor -> not_op

primary: "(" expression ")" -> paren_expr
       | INT -> int_literal
       | HEX -> hex_literal
       | FLOAT -> float_literal
       | TRUE -> bool_literal
       | FALSE -> bool_literal
       | NIL -> nil_literal
       | STRING -> string_literal
       | function_literal
       | array_literal
       | tuple_literal
       | print_call
       | sizeof_call
       | yield_call
       | assignable

function_literal: "(" param_list ")" ["yields" typ] ARROW block
array_literal: LBRACKET (expression ("," expression)*)? "]"
tuple_literal: "(" expression "," expression ("," expression)* ")"
dictionary_literal: "{" (expression "::" ("," expression "::" expression)*)? "}"
print_call: "print" "(" (expression ("," expression)*)? ")"
sizeof_call: "sizeof" "(" typ ")"
yield_call: YIELD "(" [expression] ")"
function_call: ident "(" (expression ("," expression)*)? ")"
method_call: (primary | parameterized_type) "." ident "(" (expression ("," expression)*)? ")"
object_creation: (CAPITAL_IDENT | parameterized_type) LBRACE (expression ("," expression)*)? "}"
indexation: primary "." "[" expression "]"
ident: CAPITAL_IDENT | LOWERCASE_IDENT

operator: PLUS | MINUS | TIMES | DIVIDE | NEQ | EQ | LE | GE | LT | GT | BRACKETS | BRACKETS_SETTER

ARROW: "=>"
PLUS: "+"
MINUS: "-"
TIMES: "*"
DIVIDE: "/"
MODULO: "%"
LSHIFT: "<<"
RSHIFT: ">>"
BIT_OR: "bit_or"
BIT_AND: "bit_and"
BIT_XOR: "bit_xor"
EQ: "=="
NEQ: "!="
LE: "<="
GE: ">="
LT: "<"
GT: ">"
AS: "as"
NOT: "not"
OR: "or"
AND: "and"
LBRACKET: "["
LBRACE: "{"
RBRACKET: "]"
BRACKETS: "[]"
BRACKETS_SETTER: "[]="
PIPE: "|"
ELIPSIS: "..."
TRUE: "true"
FALSE: "false"
NIL: "nil"
BREAK: "break"
CONTINUE: "continue"
RETURN: "return"
YIELD: "yield"
DEF: "def"
CLASS: "class"
ALIAS: "alias"
SELF_TYPE.3: "Self"
SETTER: /[a-zA-Z][a-zA-Z0-9_]*=/
FIELD: /@[a-zA-Z][a-zA-Z0-9_]*/
CAPITAL_IDENT.2: /[A-Z][a-zA-Z0-9_]*/
LOWERCASE_IDENT: /[a-z][a-zA-Z0-9_]*/
INT:   /[0-9]+(_[0-9]+)*/
HEX:   /0x[0-9a-fA-F]+(_[0-9a-fA-F]+)*/
FLOAT: /[0-9]+(_[0-9]+)*\.[0-9]+(_[0-9]+)*/
STRING: /".*?"/

COMMENT: "//" /[^\n]*/
BLOCK_COMMENT: /\/\*[\s\S]*?\*\//

%import common.WS
%ignore WS
%ignore COMMENT
%ignore BLOCK_COMMENT