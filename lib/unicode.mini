
// A vision for the future evolution of the stdlib

import list;
import indexable;
import range;

extern def capture_backtrace(max_frames : i64, backtrace : Buffer[i64]) -> i64
extern def print_backtrace(backtrace : Buffer[i64], n_frames : i64)

class SizedIterator[T] extends Iterator[T] {

    // how many items are remaining to be returned by .next?
    abstract def remaining() -> i32 {}
}

/*
class YieldWriter[T] extends Writer[T] {
    def write(value : T) yields T? {
        yield(value);
    }
}

class PushIterator[T] extends Iterator[T] {
    @coro : Coroutine[() yields T?]

    def init(source : Iterator[T], writer : Writer[T]) {
        fn = (source : Iterator[T], writer : Writer[T]) => { writer.write_from(source); };
        @coro = Coroutine{fn, source, writer};
    }

    def next() -> T? {
        yielded = @coro.call();
        if yielded is T { return yielded; }
        return nil;
    }
}
*/

// my_ary = [1,2,3];
// byte_yielder = UTF8Encoder{YieldWriter{}};
// utf8_bytes = PushIterator{my_ary.iterator(), byte_yielder};

class Peeker[T] extends Iterator[T] {
    @iterator : Iterator[T]
    @peeked : T?

    regions {
        @elems_reg == @iterator.elems_reg,
        @peeker holds @elems_reg,
        @iterator holds @peeked
    }

    def Self.from_iterator(iterator : Iterator[T]) -> Peeker[T] {
        return Peeker{iterator};
    } ~> { ret.iterator == iterator }

    // No need to wrap if the iterator is already a Peeker
    def Self.from_iterator(iterator : Peeker[T]) -> Peeker[T] {
        return iterator;
    } ~> { ret == iterator }
    
    def init(@iterator : Iterator[T]) {}

    def next() -> T? {
        peeked = @peeked;
        if peeked is Nil { return @iterator.next(); }
        @peeked = nil;
        return peeked;
    } ~> { ret == @peeked }
    def peek() -> T? {
        if @peeked is Nil { @peeked = @iterator.next(); }
        return @peeked;
    } ~> { ret == @peeked }
}

class Representable {
    def to_string() -> String { return "Object"; }
}

class String extends List[Character], Representable {
    @bytes : Buffer[i8]
    @byte_length : i32
    @char_length : i32 // Number of unicode codepoints
    @capacity: i32

    getters @byte_length, @char_length, @capacity

    def Self.empty() -> Self { return Self{}; }

    // STRICT, Failable constructor. Validates input and can yield an error.
    def Self.from_bytes(source_bytes: Collection[i8]) -> String yields InvalidUTF8Error {
        result = String{source_bytes.size()};    // Pre-allocate
        validator = UTF8BytesValidator{result.bytes().writer()};
        validator.write_codepoints_from(source_bytes.iterator());
        return result;
    } ~> { ret.elems_reg holds source_bytes.elems_reg }

    // LOSSY constructor. Never fails, replaces invalid sequences with 'ï¿½'.
    // Consequently, byte length of resultant string may be different than source length
    def Self.from_bytes_lossy(source_bytes: Collection[i8]) -> String {
        result = String{source_bytes.size()};    // Pre-allocate
        validator = UTF8BytesValidator.lossy(result.bytes().writer());
        validator.write_codepoints_from(source_bytes.iterator());
        return result;
    } ~> { ret.elems_reg holds source_bytes.elems_reg }

    def Self.from_char(char : Character) -> String {
        str = String{char.n_bytes()};
        str.codepoints().writer().write(char.codepoint());
        return str;
    }

    def init() {
        @bytes = Buffer[i8].new(1);
        @capacity = 1;
        @byte_length = 0;
        @char_length = 0;
    }
    def init(@capacity : i32) {
        @bytes = Buffer[i8].new(@capacity);
        @byte_length = 0;
        @char_length = 0;
    }
    // Constructor for internal use.
    def init(@bytes : Buffer[i8], @byte_length : i32, @char_length : i32, @capacity : i32) {
    }
    def size() -> i32 { return @char_length; }

    def c_string() -> Buffer[i8] {
        buf = Buffer[i8].new(@byte_length + 1);
        for i in 0..@byte_length { buf.[i] = @bytes.[i]; }
        null = 0 as i8;
        buf.[@byte_length] = null;
        return buf;
    }
    def append(char : Character) -> Self {
        self.writer().write(char);
        return self;
    }
    def extend(other : Iterator[Character]) -> Self {
        self.writer().write_from(other);
        return self;
    }
    def extend(other : Iterable[Character]) -> Self {
        self.writer().write_from(other);
        return self;
    }
    // We know the other string is already valid and don't need to validate
    def extend(other : String) -> Self {
        // We know exactly how many bytes to reserve
        other_b_len = other.byte_length();
        old_b_len = @byte_length;
        new_b_len = old_b_len + other_b_len;
        self.reserve(new_b_len);
        for i in 0..other_b_len {
            self.unchecked_insert(i + old_b_len, other.unchecked_index(i));
        }
        @byte_length = new_b_len;
        @char_length = @char_length + other.size();
        return self;
    }
    def reserve(new_capacity : i32) {
        if new_capacity <= @capacity { return; }
        @capacity = new_capacity;
        old_bytes = @bytes;
        @bytes = Buffer[i8].new(@capacity);
        for i in 0..@byte_length { @bytes.[i] = old_bytes.[i]; }
    } ~> no_alias
    def ==(other : String) -> Bool {
        if @byte_length != other.byte_length() { return false; }
        for i in 0..@byte_length {
            if @bytes.[i] != other.unchecked_index(i) { return false; }
        }
        return true;
    }
    def unchecked_index(x : i32) -> i8 {
        return @bytes.[x];
    }
    def unchecked_insert(x : i32, value : i8) {
        @bytes.[x] = value;
    }
    def copy() -> Self {
        new_buf = Buffer[i8].new(@byte_length);
        for i in 0..@byte_length { new_buf.[i] = @bytes.[i]; }
        return String{new_buf, @byte_length, @char_length, @byte_length};
    }
    def reserve_extra(n : i32) {
        self.reserve(n + @byte_length);
    } ~> no_alias
    def increment_chars(n : i32) {
        @char_length = @char_length + n;
    } ~> no_alias
    def append_byte(byte : i8) {
        new_len = @byte_length + 1;
        self.reserve(new_len);
        @bytes.[@byte_length] = byte;
        @byte_length = new_len;
    } ~> no_alias
    def to_string() -> String {
        return self;
    } ~> { ret == self }
    def codepoints() -> StringCodePoints {
        return StringCodePoints{self};
    } ~> { ret.str == self }
    def bytes() -> StringBytes {
        return StringBytes{self};
    } ~> { ret.str == self }
    def iterator() -> ConstantTimeIterator[Character] {
        return StringIterator{self};
    } ~> { ret.str == self }

}

class StringCodePoints extends List[i32] {
    @str : String

    regions { @elems_reg == @str.elems_reg }

    def Self.empty() -> Self {
        return Self{String.empty()};
    }
    def init(@str : String) {
    }
    def size() -> i32 {
        return @str.char_length();
    }
    def iterator() -> ConstantTimeIterator[i32] {
        return UTF8Decoder{@str.bytes().iterator()};
    }
    def append(x : i32) -> Self {
        self.writer().write(x);
        return self;
    }
    def extend(other : Iterable[i32]) -> Self {
        self.writer().write_from(other);
        return self;
    }
    def writer() -> Writer[i32] {
        return StringCodepointWriter{@str};
    } ~> { ret.string == @str, ret.dest_reg == @elems_reg }
}

class StringBytes extends List[i8] {
    @str : String

    regions { @elems_reg == @str.elems_reg }

    def Self.empty() -> Self {
        return Self{String.empty()};
    }
    def init(@str : String) {
    }
    def size() -> i32 {
        return @str.char_length();
    }
    def iterator() -> ConstantTimeIterator[i8] {
        return StringBytesIterator{@str};
    }
    def append(x : i8) -> Self {
        self.writer().write(x);
        return self;
    }
    def extend(other : Iterable[i8]) -> Self {
        self.writer().write_from(other);
        return self;
    }
    def writer() -> Writer[i8] {
        return StringByteWriter{@str};
    } ~> { ret.string == @str, ret.dest_reg == @elems_reg }

}

// Iterator can trust that the source string is valid.
// Constant-time *with respect to the length of the String*
class StringIterator extends ConstantTimeIterator[Character] {
    @cp_iterator : ConstantTimeIterator[i32]

    def init(str : String) {
        @cp_iterator = str.codepoints().iterator();
    }
    def next() -> Character? {
        next_cp = @cp_iterator.next();
        if next_cp is i32 { return Character{next_cp}; }
        return nil;
    }
}

class StringBytesIterator extends ConstantTimeIterator[i8] {
    @str : String
    @cursor : i32

    def init(@str : String) {
        @cursor = 0;
    }

    def next() -> i8? {
        if @cursor >= @str.byte_length() { return nil; }
        next = @str.unchecked_index(@cursor);
        @cursor = @cursor + 1;
        return next;
    }
}

class StringWriter extends Writer[Character] {
    @string : String
    @encoder : UTF8Encoder

    regions {
        @dest_reg == @encoder.dest_reg,
        @encoder.dest_reg == @string.elems_reg
    }

    def init(@string : String) {
        @encoder = UTF8Encoder{@string.bytes().writer()};
    }

    def write(value : Character) {
        @encoder.write(value.codepoint());
        @string.increment_chars(1);
    }
    // A String has already validated bytes, so we can just write its bytes directly
    def write_from(source : String) -> i32 {
        n_chars = source.char_length();
        @string.bytes().writer().write_from(source.bytes());
        @string.increment_chars(n_chars);
        return n_chars;
    }
}

class StringByteWriter extends Writer[i8] {
	@string : String

    regions { @dest_reg == @string.elems_reg }

	def init(@string : String) {}

	def write(value : i8) {
		@string.append_byte(value);
	}

    // .write_from(bytes) with a single argument will delegate to this override
    def write_from(source : Collection[i8], max_elems : i32) -> i32 {
        n_bytes = source.size();
        if max_elems > n_bytes { max_elems = n_bytes; }
        @string.reserve_extra(max_elems);
        return self.write_from(source.iterator(), max_elems);
    }
}

class StringCodepointWriter extends Writer[i32] {
	@string : String
	@encoder : UTF8Encoder

    regions {
        @dest_reg == @encoder.dest_reg,
        @encoder.dest_reg == @string.elems_reg
    }

	def init(@string : String) {
		@encoder = UTF8Encoder{@string.bytes().writer()};
	}

	def write(value : i32) {
		@encoder.write(value);
		@string.increment_chars(1);
	}
    def write_from(source : Iterator[i32], max_elems : i32) -> i32 {
        n_written = @encoder.write_from(source, max_elems);
        @string.increment_chars(n_written);
        return n_written;
    }
}

class Character {
    @codepoint : i32

    getter @codepoint

    def init(@codepoint : i32) {}

    def ==(other : Character) -> Bool {
        return @codepoint == other.codepoint();
    }
    def n_bytes() -> i32 {
        cp = @codepoint;
        if cp <= 0x7F { return 1; }
        if cp <= 0x7FF { return 2; }
        if cp <= 0xFFFF { return 3; }
        if cp <= 0x10FFFF { return 4; }
        return 3; // For replacement character if codepoint is invalid
    }
}

class UTF8Encoder extends Writer[i32] {
	@writer : Writer[i8]
    @replacement_fn : (Writer[i8])

    regions { @dest_reg == @writer.dest_reg }

    getter @replacement_fn
    setter @replacement_fn

    def Self.lossy(writer : Writer[i8]) -> UTF8Encoder {
        replacement_fn = (writer : Writer[i8]) => {
            writer.write(0xEF as i8);
            writer.write(0xBF as i8);
            writer.write(0xBD as i8);
        };
        return UTF8Encoder{writer, replacement_fn};
    } ~> { ret.writer == writer }

    // Default is lossless, yield Exception on invalid codepoint
    def init(@writer : Writer[i8]) {
        @replacement_fn = (writer : Writer[i8]) => { yield(InvalidUTF8Error{}); return; };
    }

    def init(@writer : Writer[i8], @replacement_fn : (Writer[i8])) {
    }

	def write(value : i32) {
        if value <= 0x7F { // 1-byte
            @writer.write(value as i8);
            return;
        }
        if value <= 0x7FF { // 2-byte
            @writer.write((0xC0 bit_or (value >> 6)) as i8);
            @writer.write((0x80 bit_or (value bit_and 0x3F)) as i8);
            return;
        }
        if value <= 0xFFFF { // 3-byte
            @writer.write((0xE0 bit_or (value >> 12)) as i8);
            @writer.write((0x80 bit_or ((value >> 6) bit_and 0x3F)) as i8);
            @writer.write((0x80 bit_or (value bit_and 0x3F)) as i8);
            return;
        }
        if value <= 0x10FFFF { // 4-byte
            @writer.write((0xF0 bit_or (value >> 18)) as i8);
            @writer.write((0x80 bit_or ((value >> 12) bit_and 0x3F)) as i8);
            @writer.write((0x80 bit_or ((value >> 6) bit_and 0x3F)) as i8);
            @writer.write((0x80 bit_or (value bit_and 0x3F)) as i8);
            return;
        }
        @replacement_fn.call(@writer);
	}

    // optimization: decoder + encoder = byte validator
    def write_from(source : UTF8Decoder, max_elems : i32) -> i32 {
        validator = UTF8BytesValidator{@writer, @replacement_fn};
        return validator.write_codepoints_from(source.peeker(), max_elems);
    } ~> { @dest_reg holds source.peeker.elems_reg }

    // optimization: validator + encoder = encoder
    def write_from(source : UTF8CodepointsValidator, max_elems : i32) -> i32 {
        iterator = source.iterator();
        n_written = 0;
        codepoint = iterator.next();
        while codepoint is i32 and n_written < max_elems {
            if codepoint > 0x10FFFF { codepoint = source.replacement_fn().call(codepoint); }
            self.write(codepoint);
            n_written = n_written + 1;
            codepoint = iterator.next();
        }
        return n_written;
    } ~> { @dest_reg holds source.iterator.elems_reg }
}

class UTF8CodepointsValidator extends Iterator[i32] {
    @iterator : Iterator[i32]
    @replacement_fn : (i32) -> i32

    regions { @elems_reg == @iterator.elems_reg }

    getters @iterator, @replacement_fn
    setter @replacement_fn

    def Self.lossy(iterator : Iterator[i32]) -> UTF8CodepointsValidator {
        replacement_fn = (codepoint : i32) => { 0xFFFD; };
        return UTF8CodepointsValidator{iterator, replacement_fn};
    } ~> { ret.iterator == iterator }

    def init(@iterator : Iterator[i32]) {
        @replacement_fn = (codepoint : i32) => {
            yield(InvalidUTF8Error{});
            return -1;
        };
    }

    def init(@iterator : Iterator[i32], @replacement_fn : (i32) -> i32) {
    }

    def next() -> i32? {
        codepoint = @iterator.next();
        if codepoint is Nil { return nil; }
        if codepoint <= 0x10FFFF { return codepoint; }
        return @replacement_fn.call(codepoint);
    }
}

// seems like a BulkWriter[i8], except the i32 returned is the # of *codepoints* written
class UTF8BytesValidator {
    @writer : Writer[i8]
    @replacement_fn : (Writer[i8])

    getter @replacement_fn
    setter @replacement_fn

    def Self.lossy(writer : Writer[i8]) -> UTF8BytesValidator {
        replacement_fn = (writer : Writer[i8]) => {
            writer.write(0xEF as i8);
            writer.write(0xBF as i8);
            writer.write(0xBD as i8);
        };
        return UTF8BytesValidator{writer, replacement_fn};
    } ~> { ret.writer == writer }

    def init(@writer : Writer[i8]) {
        @replacement_fn = (writer : Writer[i8]) => { yield(InvalidUTF8Error{}); return; };
    }

    def init(@writer : Writer[i8], @replacement_fn : (Writer[i8])) {
    }

    // Re-encode bytes for one codepoint from the byte source into @writer
    def write_codepoints_from(source : Iterator[i8], max_elems : i32) -> i32 {
        peeker = source into Peeker[i8];
        n_written = 0;
        while n_written < max_elems {
            b1 = peeker.next();
            if b1 is Nil { return n_written; }
            tuple = self.process_first_byte(b1 as i32);
            codepoint = tuple.[0];
            bytes_needed = tuple.[1];

            // Check for invalid start byte
            if bytes_needed == 0 {
                @replacement_fn.call(@writer);
                n_written = n_written + 1;
                continue;
            }

            if bytes_needed == 1 {
                @writer.write(b1);
                n_written = n_written + 1;
                continue;
            }

            temp_buf = Buffer[i8].new(4);
            temp_buf.[0] = b1;
            valid_bytes = true;

            for i in 1..bytes_needed {
                b_next = peeker.peek();
                if b_next is Nil { return n_written; }
                if ((b_next as i32) bit_and 0xC0) != 0x80 {
                    valid_bytes = false;
                    break;
                }
                peeker.next();
                temp_buf.[i] = b_next;
                codepoint = (codepoint << 6) bit_or (b_next as i32 bit_and 0x3F);
            }

            if (not valid_bytes) or self.invalid_codepoint(codepoint, bytes_needed) {
                @replacement_fn.call(@writer);
                n_written = n_written + 1;
                continue;
            }

            for i in 0..bytes_needed { @writer.write(temp_buf.[i]); }
            n_written = n_written + 1;
        }
        return n_written;
    } ~> { @writer.dest_reg holds source.elems_reg }

    def write_codepoints_from(source : Iterator[i8]) -> i32 {
        return self.write_codepoints_from(source, i32.max());
    } ~> { @writer.dest_reg holds source.elems_reg }

    def write_codepoints_from(source : Iterable[i8], max_elems : i32) -> i32 {
        return self.write_codepoints_from(source.iterator(), max_elems);
    } ~> { @writer.dest_reg holds source.elems_reg }

    def write_codepoints_from(source : Iterable[i8]) -> i32 {
        return self.write_codepoints_from(source.iterator(), i32.max());
    } ~> { @writer.dest_reg holds source.elems_reg }
}

class UTF8Decoder extends ConstantTimeIterator[i32] {
    @peeker : Peeker[i8]
    @replacement_fn : (i8) -> i32

    regions { @elems_reg == @peeker.elems_reg }

    getters @peeker, @replacement_fn
    setter @replacement_fn

    def Self.lossy(iterator : Iterator[i8]) -> UTF8Decoder {
        replacement_fn = (byte : i8) => { 0xFFFD; };
        return UTF8Decoder{iterator, replacement_fn};
    } ~> { ret.iterator == iterator }

    def init(iterator : Iterator[i8]) {
        @peeker = iterator into Peeker;
        @replacement_fn = (byte : i8) => {
            yield(InvalidUTF8Error{});
            return -1;
        };
    }

    def init(iterator : Iterator[i8], @replacement_fn : (i8) -> i32) {
        @peeker = iterator into Peeker;
    }

    // returns (codepoint, bytes_needed)
    def process_first_byte(b1 : i8) -> Tuple[i32, i32] {
        codepoint = 0;
        bytes_needed = 0;

        // these bit patterns are mutually exclusive
        // LLVM will see that the conditions are disjoint

        if (b1 bit_and 0x80) == 0 { // 0xxxxxxx
            codepoint = b1;
            bytes_needed = 1;
        }
        if (b1 bit_and 0xE0) == 0xC0 { // 110xxxxx
            codepoint = b1 bit_and 0x1F;
            bytes_needed = 2;
        }
        if (b1 bit_and 0xF0) == 0xE0 { // 1110xxxx
            codepoint = b1 bit_and 0x0F;
            bytes_needed = 3;
        }
        if (b1 bit_and 0xF8) == 0xF0 { // 11110xxx
            codepoint = b1 bit_and 0x07;
            bytes_needed = 4;
        }
        return (codepoint, bytes_needed);
    }

    // Check for overlong encodings and other invalid sequences
    def invalid_codepoint(codepoint : i32, bytes_needed : i32) -> Bool {
        return (bytes_needed == 2 and codepoint < 0x80) or
           (bytes_needed == 3 and codepoint < 0x800) or
           (bytes_needed == 4 and codepoint < 0x10000) or
           (codepoint >= 0xD800 and codepoint <= 0xDFFF) or
           (codepoint > 0x10FFFF);
    }

    def next() -> i32? {
        b1 = @peeker.next();
        if b1 is Nil { return nil; }
        b1 = b1 as i32;
        tuple = self.process_first_byte(b1);
        codepoint = tuple.[0];
        bytes_needed = tuple.[1];

        // Check for invalid start byte
        if bytes_needed == 0 { return @replacement_fn.call(b1); }

        for i in 1..bytes_needed {
            b_next = @peeker.peek();
            if b_next is Nil { return nil; }
            b_next = b_next as i32;
            if (b_next bit_and 0xC0) != 0x80 {  // Invalid continuation byte
                return @replacement_fn.call(b1);
            }
            codepoint = (codepoint << 6) bit_or (b_next bit_and 0x3F);
            b_next = @peeker.next();            // Advance, now that known valid
        }
        
        if self.invalid_codepoint(codepoint, bytes_needed) { return @replacement_fn.call(b1); }

        return codepoint;
    }
}

class Stacktrace {
    @stacktrace : Buffer[i64]
    @n_frames : i64

    def init() {
        @stacktrace = Buffer[i64].new(100);
        @n_frames = capture_backtrace(100 as i64, @stacktrace);
    }

    def print() {
        print_backtrace(@stacktrace, @n_frames);
    }

}

class Exception {
    @line_number : i32
    @file_name : String
    @message : String
    @stacktrace : Stacktrace

    def init(@message : String) {
        @line_number = 0;
        @file_name = "";
        @stacktrace = Stacktrace{};
    }
    def init() {
        @line_number = 0;
        @message = "<None>";
        @file_name = "";
        @stacktrace = Stacktrace{};
    }

    def set_info(@line_number : i32, @file_name : String) {}

    def report() {
        print("---------".c_string());
        print("Exception thrown from file".c_string());
        print(@file_name.c_string());
        print("At line".c_string());
        print(@line_number);
        print("With message".c_string());
        self.print_message();
        print("Stack trace:".c_string());
        @stacktrace.print();
        print("---------".c_string());
    }
    def print_message() {
        print(@message.c_string());
    }
}

class InvalidUTF8Error extends Exception {
    def init() {
        @message = "Invalid UTF-8 sequence encountered during string conversion.";
        @line_number = 0;
        @file_name = "";
        @stacktrace = Stacktrace{};
    }
}

class OutOfBounds extends Exception {
    @details : OutOfBoundsDetails?

    def init(bounds : i32, index : i32) {
        @details = OutOfBoundsDetails.new(bounds, index);
        @line_number = 0;
        @file_name = "";
        @message = "An out-of-bounds error occurred while indexing into a collection.";
        @stacktrace = Stacktrace{};
    }
    def print_message() {
        print(@message.c_string());
        details = @details;
        if details is OutOfBoundsDetails { details.report(); }
    }
}

class OutOfBoundsDetails {
    @bounds : i32
    @index : i32
    def init(@bounds : i32, @index : i32) {}
    def report() {
        print("The size of the collection being indexed was".c_string());
        print(@bounds);
        print("The indexing argument was".c_string());
        print(@index);
    }
}

def report_exception(current_coroutine : Coroutine[() -> Exception]) {
    exception = current_coroutine.result();
    if exception is Exception { exception.report(); }
}
