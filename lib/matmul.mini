import std;

// records time in milliseconds
extern def clock() -> i64

// compiles to:
// define i32 @min(i32 %0, i32 %1) {
//   %3 = call i32 @llvm.smin.i32(i32 %0, i32 %1)
//   ret i32 %3
// }
def min(a : i32, b : i32) -> i32 {
    if a < b { return a; }
    return b;
}

// compiles to:
// define <4 x i64> @simd_add(<4 x i64> %0, <4 x i64> %1) {
//   %3 = add <4 x i64> %1, %0
//   ret <4 x i64> %3
// }
def simd_add(a : Tuple[i64, i64, i64, i64], b : Tuple[i64, i64, i64, i64]) -> Tuple[i64, i64, i64, i64] {
    return (a.[0] + b.[0], a.[1] + b.[1], a.[2] + b.[2], a.[3] + b.[3]);
}

// compiles to:
// define <4 x i64> @simd_mul(<4 x i64> %0, <4 x i64> %1) {
//   %3 = mul <4 x i64> %1, %0
//   ret <4 x i64> %3
// }
def simd_mul(a : Tuple[i64, i64, i64, i64], b : Tuple[i64, i64, i64, i64]) -> Tuple[i64, i64, i64, i64] {
    return (a.[0] * b.[0], a.[1] * b.[1], a.[2] * b.[2], a.[3] * b.[3]);
}

// compiles to:
// define i64 @simd_reduce(<4 x i64> %0) {
//   %2 = call i64 @llvm.vector.reduce.add.v4i64(<4 x i64> %0)
//   ret i64 %2
// }
def simd_reduce(a : Tuple[i64, i64, i64, i64]) -> i64 {
    return simd_reduce_inner(a.[0], a.[1], a.[2], a.[3]);
}

// compiles to:
// define i64 @simd_reduce_inner(i64 %0, i64 %1, i64 %2, i64 %3) {
//   %5 = add i64 %1, %0
//   %6 = add i64 %5, %2
//   %7 = add i64 %6, %3
//   ret i64 %7
// }
def simd_reduce_inner(a : i64, b : i64, c : i64, d : i64) -> i64 {
    return a + b + c + d;
}

// simd_reduce compiles to an @llvm.vector.reduce intrinsic but simd_reduce_inner does not, though the former just calls the latter
// This is an interesting LLVM quirk

class Matrix {
    @data : Buffer[i64]
    @rows : i32
    @cols : i32

    def init(@rows : i32, @cols : i32) {
        @data = Buffer[i64].new(@rows * @cols);
    }

    def rows() -> i32 { return @rows; }
    def row_idx() -> Range { return 0:(@rows - 1); }
    def cols() -> i32 { return @cols; }
    def col_idx() -> Range { return 0:(@cols - 1); }
    def data() -> Buffer[i64] { return @data; }

    def set(row : i32, col : i32, value : i64) {
        @data.[col * @rows + row] = value;
    }

    def set_simd(start_row : i32, col : i32, values : Tuple[i64, i64, i64, i64]) {
        data = @data;
        rows = @rows;
        data.[col * rows + start_row + 0] = values.[0];
        data.[col * rows + start_row + 1] = values.[1];
        data.[col * rows + start_row + 2] = values.[2];
        data.[col * rows + start_row + 3] = values.[3];
    }

    def get(row : i32, col : i32) -> i64 {
        return @data.[col * @rows + row];
    }

    def get_simd(start_row : i32, col : i32) -> Tuple[i64, i64, i64, i64] {
        data = @data;
        rows = @rows;
        a = data.[col * rows + start_row + 0];
        b = data.[col * rows + start_row + 1];
        c = data.[col * rows + start_row + 2];
        d = data.[col * rows + start_row + 3];
        return (a, b, c, d);
    }

    def *(other : Matrix) -> Matrix {
        if @cols != other.rows() { yield(Exception.new()); }
        
        result = Matrix.new(@rows, other.cols());
        col_idx = self.col_idx();

        for j in other.col_idx() {
            for k in col_idx {
                b_kj = other.get(k, j);
                if b_kj == 0 { continue; }

                i = 0;
                while i <= @rows - 4 {
                    a_vec = self.get_simd(i, k);
                    b_vec = (b_kj, b_kj, b_kj, b_kj);
                    c_vec = result.get_simd(i, j);
                    new_c_vec = simd_add(c_vec, simd_mul(a_vec, b_vec));
                    result.set_simd(i, j, new_c_vec);
                    i = i + 4;
                }
                
                while i < @rows {
                    result.set(i, j, result.get(i, j) + self.get(i, k) * b_kj);
                    i = i + 1;
                }
            }
        }
        return result;
    }
}

def benchmark_matrix_multiplication() {
    size = 2_000;
    
    matrix1 = Matrix.new(size, size);
    matrix2 = Matrix.new(size, size);
    
    for i in 0:(size - 1) {
        for j in 0:(size - 1) {
            val1 : i64 = (i + j) % 10;
            val2 : i64 = (i - j + 10) % 10;
            matrix1.set(i, j, val1); 
            matrix2.set(i, j, val2);
        }
    }
    
    start_time = clock();
    result = matrix1 * matrix2;
    end_time = clock();
    
    time_taken = end_time - start_time;
    
    IO.print("Matrix multiplication");
    IO.print(size);
    IO.print("x");
    IO.print(size);
    IO.print("Time taken:");
    IO.print(time_taken);
    
    sum = 0;
    for i in 0:(size - 1) { sum = sum + result.get(0, i); }
    IO.print("Sum of first row (for verification):");
    IO.print(sum);
}

benchmark_matrix_multiplication();