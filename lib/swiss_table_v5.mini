import map;
import io;
import array;

// --- Control Byte Constants ---
def empty() -> i8 { return 0 as i8; }
def deleted() -> i8 { return -2 as i8; }
def occupied_mask() -> i8 { return 1 as i8; }
def group_width() -> i32 { return 32; }
def padding() -> i8 { return -1 as i8; }

class Entry[K,V] {
    @hash: i32
    @key: K
    @value: V

    getters @hash, @key, @value

    def init(@key: K, @value: V, @hash: i32) {}

    def to_pair() -> Pair[K, V] {
        return Pair{@key, @value};
    } ~> { ret.first == @key, ret.second == @value }
}

class SwissTable[K, V] extends HashMap[K, V] {
    @entries: Buffer[Entry[K,V]?]
    @metadata: Buffer[i8]
    @entries_len: i32
    @size: i32
    @hasher: (K) -> i32
    @eq: (K, K) -> Bool

    getters @size, @entries_len

    def Self.h2_to_control(hash: i32) -> i8 {
        h2_6bit = (hash >> 26) as i8;
        return (h2_6bit << 1) bit_or occupied_mask();
    }

    def Self.min_capacity() -> i32 {
        return group_width() * 4;
    }

    def init(@hasher: (K) -> i32, @eq: (K, K) -> Bool) {
        // Minimum capacity must be >= group_width for SIMD loads
        initial_capacity = Self.min_capacity();
        // Allocate extra group for safe SIMD loads near end
        padded_capacity = initial_capacity + group_width();
        
        @entries = Buffer[Entry[K,V]?].new(padded_capacity);
        @metadata = Buffer[i8].new(padded_capacity);
        @entries_len = initial_capacity;
        @size = 0;
        for i in initial_capacity..padded_capacity {
            @metadata.[i] = padding();
        }
    }

    def find_slot(key: K, hash: i32) -> i32 {
        mask = @entries_len - 1;
        h2 = Self.h2_to_control(hash);
        probe = hash bit_and mask;
        tombstone = -1;
        metadata = @metadata;

        // Scalar load to check first candidate slot
        first_metadata = metadata.[probe];
        if first_metadata == empty() { return probe; }
        if first_metadata == h2 {
            entry = @entries.[probe];
            if entry is Entry[K,V] {
                if entry.hash() == hash and @eq.call(entry.key(), key) {
                    return probe;
                }
            }
        }

        // first one was not it, start probing
        probe = probe + 1;
        h2_splat = 32 of h2;
        zero_splat = 32 of empty();
        one_splat = 32 of occupied_mask();

        while true {
            indices = 32 from probe;
            group = metadata.[indices];

            // --- H2 matches (no bounds check: -1 can't match h2) ---
            h2_matches = group == h2_splat;
            i = cttz(h2_matches);
            while i < group_width() {
                slot = probe + i;
                entry = @entries.[slot];
                if entry is Entry[K,V] {
                    if entry.hash() == hash and @eq.call(entry.key(), key) {
                        return slot;
                    }
                }
                h2_matches = blsr(h2_matches);
                i = cttz(h2_matches);
            }

            // --- Empty (no bounds check: -1 â‰  0) ---
            empty_matches = group == zero_splat;
            i = cttz(empty_matches);
            if i < group_width() {
                if tombstone >= 0 { return tombstone; }
                return probe + i;
            }

            // --- First tombstone (no bounds check: -1 has LSB=1) ---
            if tombstone < 0 {
                lsb = group bit_and one_splat;
                deleted_matches = lsb == zero_splat;
                i = cttz(deleted_matches);
                if i < group_width() {
                    tombstone = probe + i;
                }
            }

            probe = (probe + group_width()) bit_and mask;
        }
    }

    def find_empty_slot(hash: i32) -> i32 {
        mask = @entries_len - 1;
        probe = hash bit_and mask;
        metadata = @metadata;

        // Scalar load to check first candidate slot
        if metadata.[probe] == empty() { return probe; }
        probe = probe + 1;

        zero_splat = 32 of empty();
        one_splat = 32 of occupied_mask();

        while true {
            group = metadata.[32 from probe];

            lsb = group bit_and one_splat;
            sentinel_matches = lsb == zero_splat;

            i = cttz(sentinel_matches);
            if i < group_width() { return probe + i; }

            probe = (probe + group_width()) bit_and mask;
        }
    }

    def insert(key: K, value: V) {
        self.ensure_capacity(@size + 1);
        hash = @hasher.call(key);
        slot = self.find_slot(key, hash);

        is_new = (@metadata.[slot] bit_and occupied_mask()) == 0;
        if is_new { @size = @size + 1; }

        @metadata.[slot] = Self.h2_to_control(hash);
        @entries.[slot] = Entry{key, value, hash};
    }

    def get(key: K) -> V? {
        if @size == 0 { return nil; }
        hash = @hasher.call(key);
        slot = self.find_slot(key, hash);

        if (@metadata.[slot] bit_and occupied_mask()) == 0 { return nil; }

        entry = @entries.[slot];
        if entry is Nil { return nil; }
        return entry.value();
    }

    def remove(key: K) -> V? {
        if @size == 0 { return nil; }
        hash = @hasher.call(key);
        slot = self.find_slot(key, hash);

        if (@metadata.[slot] bit_and occupied_mask()) == 0 { return nil; }

        entry = @entries.[slot];
        if entry is Nil { return nil; }

        val = entry.value();
        @metadata.[slot] = deleted();
        @entries.[slot] = nil;
        @size = @size - 1;
        return val;
    }

    def ensure_capacity(required: i32) {
        if required <= (@entries_len * 7) / 8 { return; }

        new_capacity = @entries_len * 2;
        min_capacity = Self.min_capacity();
        if new_capacity < min_capacity { new_capacity = min_capacity; }
        self.resize(new_capacity);
    }

    def resize(new_capacity: i32) {
        old_entries = @entries;
        old_metadata = @metadata;
        old_len = @entries_len;

        // Allocate with padding for safe SIMD loads
        padded_capacity = new_capacity + group_width();
        @entries = Buffer[Entry[K,V]?].new(padded_capacity);
        @metadata = Buffer[i8].new(padded_capacity);
        @entries_len = new_capacity;
        @size = 0;

        for i in new_capacity..padded_capacity {
            @metadata.[i] = padding();
        }

        for i in 0..old_len {
            if (old_metadata.[i] bit_and occupied_mask()) == 0 { continue; }
            entry = old_entries.[i];
            if entry is Nil { continue; }

            slot = self.find_empty_slot(entry.hash());
            @entries.[slot] = entry;
            @metadata.[slot] = Self.h2_to_control(entry.hash());
            @size = @size + 1;
        }
    }

    def clear() {
        initial_capacity = Self.min_capacity();
        padded_capacity = initial_capacity + group_width();
        @entries = Buffer[Entry[K,V]?].new(padded_capacity);
        @metadata = Buffer[i8].new(padded_capacity);
        @entries_len = initial_capacity;
        @size = 0;

        for i in initial_capacity..padded_capacity {
            @metadata.[i] = padding();
        }
    }

    // return (new_cursor, next_entry) in buffer starting at position of input cursor
    def scan_next(start_cursor: i32) -> Pair[i32, Pair[K,V]]? {
        meta = @metadata;
        entries = @entries;

        if start_cursor >= @entries_len { return nil; }

        for cursor in start_cursor..@entries_len {
            if (meta.[cursor] bit_and occupied_mask()) == 0 { continue; }
            entry = entries.[cursor];
            if entry is Nil { continue; }
            return Pair{cursor + 1, entry.to_pair()};
        }
        return nil;
    } ~> { ret holds @elems_reg }

    def iterator() -> SwissTableIterator[K,V] {
        return SwissTableIterator{self};
    } ~> { ret.map == self }

}

class SwissTableIterator[K,V] extends Iterator[Pair[K,V]] {
    @map : SwissTable[K,V]
    @cursor: i32

    regions { @elems_reg == @map.elems_reg }

    def init(@map : SwissTable[K,V]) {
        @cursor = 0;
    }

    def next() -> Pair[K, V]? {
        tuple_or_nil = @map.scan_next(@cursor);
        if tuple_or_nil is Nil { return nil; }
        (@cursor, pair) = tuple_or_nil;
        return pair;
    }
}