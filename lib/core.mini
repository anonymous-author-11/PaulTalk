import stack;
import indexable;
import range;

extern def capture_backtrace(max_frames : i64, backtrace : Buffer[i64]) -> i64
extern def print_backtrace(backtrace : Buffer[i64], n_frames : i64)

class SizedIterator[T] extends Iterator[T] {

    // how many items are remaining to be returned by .next?
    abstract def remaining() -> i32 {}
}

class UTF8 {

    // returns (codepoint_seed, bytes_needed)
    def Self.classify_lead(b1 : i32) -> Tuple[i32, i32] {

        // these bit patterns are mutually exclusive
        // LLVM will see that the conditions are disjoint

        if (b1 bit_and 0x80) == 0 { return (b1, 1); } // 0xxxxxxx
        if (b1 bit_and 0xE0) == 0xC0 { return (b1 bit_and 0x1F, 2); } // 110xxxxx
        if (b1 bit_and 0xF0) == 0xE0 { return (b1 bit_and 0x0F, 3); } // 1110xxxx
        if (b1 bit_and 0xF8) == 0xF0 { return (b1 bit_and 0x07, 4); } // 11110xxx
        return (0, 0);
    }

    def Self.is_continuation(b : i32) -> Bool {
        return (b bit_and 0xC0) == 0x80;
    }

    def Self.accumulate(codepoint : i32, b_next : i32) -> i32 {
        return (codepoint << 6) bit_or (b_next bit_and 0x3F);
    }

    // Check for overlong encodings and other invalid sequences
    def Self.is_valid_codepoint(codepoint : i32, bytes_needed : i32) -> Bool {
        return (bytes_needed != 2 or codepoint >= 0x80) and
           (bytes_needed != 3 or codepoint >= 0x800) and
           (bytes_needed != 4 or codepoint >= 0x10000) and
           (codepoint < 0xD800 or codepoint > 0xDFFF) and
           (codepoint <= 0x10FFFF);
    }

    // Returns 0 for invalid codepoints.
    def Self.encoded_width(codepoint : i32) -> i32 {
        if codepoint <= 0x7F { return 1; }
        if codepoint <= 0x7FF { return 2; }
        if codepoint <= 0xFFFF { return 3; }
        if codepoint <= 0x10FFFF { return 4; }
        return 0;
    }

    def Self.is_ascii_whitespace(byte : i8) -> Bool {
        if byte == (32 as i8) { return true; }
        if byte == (9 as i8) { return true; }
        if byte == (10 as i8) { return true; }
        if byte == (11 as i8) { return true; }
        if byte == (12 as i8) { return true; }
        if byte == (13 as i8) { return true; }
        return false;
    }
}

/*
class YieldWriter[T] extends Writer[T] {
    def write(value : T) yields T? {
        yield(value);
    }
}

class PushIterator[T] extends Iterator[T] {
    @coro : Coroutine[() yields T?]

    def init(source : Iterator[T], writer : Writer[T]) {
        fn = (source : Iterator[T], writer : Writer[T]) => { writer.write_from(source); };
        @coro = Coroutine{fn, source, writer};
    }

    def next() -> T? {
        yielded = @coro.call();
        if yielded is T { return yielded; }
        return nil;
    }
}
*/

// my_ary = [1,2,3];
// byte_yielder = UTF8Encoder{YieldWriter{}};
// utf8_bytes = PushIterator{my_ary.iterator(), byte_yielder};

class Peeker[T] extends Iterator[T] {
    @iterator : Iterator[T]
    @peeked : T?

    regions {
        @elems_reg == @iterator.elems_reg,
        @peeker holds @elems_reg,
        @iterator holds @peeked
    }

    def Self.from_iterator(iterator : Iterator[T]) -> Peeker[T] {
        return Peeker{iterator};
    } ~> { ret.iterator == iterator }

    // No need to wrap if the iterator is already a Peeker
    def Self.from_iterator(iterator : Peeker[T]) -> Peeker[T] {
        return iterator;
    } ~> { ret == iterator }
    
    def init(@iterator : Iterator[T]) {}

    def next() -> T? {
        peeked = @peeked;
        if peeked is Nil { return @iterator.next(); }
        @peeked = nil;
        return peeked;
    } ~> { ret == @peeked }
    def peek() -> T? {
        if @peeked is Nil { @peeked = @iterator.next(); }
        return @peeked;
    } ~> { ret == @peeked }
}

class Representable {
    def repr() -> String { return "Object"; }
}

class String extends List[Character], Representable {
    @bytes : Buffer[i8]
    @byte_length : i32
    @char_length : i32 // Number of unicode codepoints
    @capacity: i32

    getters @byte_length, @char_length, @capacity

    def Self.empty() -> Self { return Self{}; }

    def Self.from_iterable(iterable : Iterable[Character]) -> Self {
        return Self.empty().extend(iterable);
    }

    // STRICT, Failable constructor. Validates input and can yield an error.
    def Self.from_bytes(source_bytes: Collection[i8]) -> String yields InvalidUTF8Error {
        result = String{source_bytes.size()};    // Pre-allocate
        validator = UTF8BytesValidator{result.bytes().writer()};
        validator.write_codepoints_from(source_bytes.iterator());
        return result;
    } ~> { ret.elems_reg holds source_bytes.elems_reg }

    // LOSSY constructor. Never fails, replaces invalid sequences with 'ï¿½'.
    // Consequently, byte length of resultant string may be different than source length
    def Self.from_bytes_lossy(source_bytes: Collection[i8]) -> String {
        result = String{source_bytes.size()};    // Pre-allocate
        validator = UTF8BytesValidator.lossy(result.bytes().writer());
        validator.write_codepoints_from(source_bytes.iterator());
        return result;
    } ~> { ret.elems_reg holds source_bytes.elems_reg }

    def Self.from_char(char : Character) -> String {
        str = String{char.n_bytes()};
        str.codepoints().writer().write(char.codepoint());
        return str;
    }

    def init() {
        @bytes = Buffer[i8].new(1);
        @capacity = 1;
        @byte_length = 0;
        @char_length = 0;
    }
    def init(@capacity : i32) {
        @bytes = Buffer[i8].new(@capacity);
        @byte_length = 0;
        @char_length = 0;
    }
    // Constructor for internal use.
    def init(@bytes : Buffer[i8], @byte_length : i32, @char_length : i32, @capacity : i32) {
    }
    def size() -> i32 { return @char_length; }

    def c_string() -> Buffer[i8] {
        buf = Buffer[i8].new(@byte_length + 1);
        for i in 0..@byte_length { buf.[i] = @bytes.[i]; }
        null = 0 as i8;
        buf.[@byte_length] = null;
        return buf;
    } ~> no_alias
    def append(x : Character) -> Self {
        self.writer().write(x);
        return self;
    }
    def extend(other : Iterator[Character]) -> Self {
        self.writer().write_from(other);
        return self;
    }
    def extend(other : Iterable[Character]) -> Self {
        self.writer().write_from(other);
        return self;
    }
    // We know the other string is already valid and don't need to validate
    def extend(other : String) -> Self {
        // We know exactly how many bytes to reserve
        other_b_len = other.byte_length();
        old_b_len = @byte_length;
        new_b_len = old_b_len + other_b_len;
        self.reserve(new_b_len);
        for i in 0..other_b_len {
            self.unchecked_insert(i + old_b_len, other.unchecked_index(i));
        }
        @byte_length = new_b_len;
        @char_length = @char_length + other.size();
        return self;
    }
    def reserve(new_capacity : i32) {
        if new_capacity <= @capacity { return; }
        @capacity = new_capacity;
        old_bytes = @bytes;
        @bytes = Buffer[i8].new(@capacity);
        for i in 0..@byte_length { @bytes.[i] = old_bytes.[i]; }
    } ~> no_alias
    def ==(other : String) -> Bool {
        if @byte_length != other.byte_length() { return false; }
        for i in 0..@byte_length {
            if @bytes.[i] != other.unchecked_index(i) { return false; }
        }
        return true;
    }
    def !=(other : String) -> Bool {
        if @byte_length != other.byte_length() { return true; }
        for i in 0..@byte_length {
            if @bytes.[i] != other.unchecked_index(i) { return true; }
        }
        return false;
    }
    def starts_with(prefix : String) -> Bool {
        prefix_len = prefix.byte_length();
        if prefix_len > @byte_length { return false; }
        return self.bytes_match_at(prefix, 0);
    }
    def ends_with(suffix : String) -> Bool {
        suffix_len = suffix.byte_length();
        if suffix_len > @byte_length { return false; }
        offset = @byte_length - suffix_len;
        return self.bytes_match_at(suffix, offset);
    }
    def bytes_match_at(needle : String, start : i32) -> Bool {
        needle_len = needle.byte_length();
        for i in 0..needle_len {
            if @bytes.[start + i] != needle.unchecked_index(i) { return false; }
        }
        return true;
    } ~> no_alias
    def byte_index_of(needle : String) -> i32? {
        needle_len = needle.byte_length();
        if needle_len == 0 { return 0; }
        if needle_len > @byte_length { return nil; }
        last_start = @byte_length - needle_len;
        for start in 0..(last_start + 1) {
            if self.bytes_match_at(needle, start) { return start; }
        }
        return nil;
    }
    def contains(needle : String) -> Bool {
        return self.byte_index_of(needle) is i32;
    }
    def lead_whitespace() -> i32 {
        for i in 0..@byte_length {
            if not UTF8.is_ascii_whitespace(@bytes.[i]) { return i; }
        }
        return @byte_length;
    }
    def trail_whitespace() -> i32 {
        for i in 0..@byte_length {
            idx = @byte_length - i - 1;
            if not UTF8.is_ascii_whitespace(@bytes.[idx]) { return i; }
        }
        return @byte_length;
    }
    def trim_start() -> String {
        start = self.lead_whitespace();
        slice_len = @byte_length - start;
        copied = Buffer[i8].new(slice_len);
        for i in 0..slice_len { copied.[i] = @bytes.[start + i]; }
        chars = @char_length - start;
        return String{copied, slice_len, chars, slice_len};
    }
    def trim_end() -> String {
        removed = self.trail_whitespace();
        end_exclusive = @byte_length - removed;
        copied = Buffer[i8].new(end_exclusive);
        for i in 0..end_exclusive { copied.[i] = @bytes.[i]; }
        chars = @char_length - removed;
        return String{copied, end_exclusive, chars, end_exclusive};
    }
    def trim() -> String {
        start = self.lead_whitespace();
        trail_whitespace = self.trail_whitespace();
        end_exclusive = @byte_length - trail_whitespace;
        if end_exclusive < start { end_exclusive = start; }
        slice_len = end_exclusive - start;
        copied = Buffer[i8].new(slice_len);
        for i in 0..slice_len { copied.[i] = @bytes.[start + i]; }
        removed = start + trail_whitespace;
        if removed > @char_length { removed = @char_length; }
        chars = @char_length - removed;
        return String{copied, slice_len, chars, slice_len};
    }
    def repeat(times : i32) -> String {
        if times <= 0 { return String.empty(); }
        result = String{@byte_length * times};
        repeat_index = 0;
        while repeat_index < times {
            result.extend(self);
            repeat_index = repeat_index + 1;
        }
        return result;
    }
    def join(parts : Iterable[String]) -> String {
        iterator = parts.iterator();
        first_part = iterator.next();
        if first_part is not String { return String.empty(); }
        result = String{first_part.byte_length()};
        result.extend(first_part);
        next_part = iterator.next();
        while next_part is String {
            result.extend(self);
            result.extend(next_part);
            next_part = iterator.next();
        }
        return result;
    }
    def split(delimiter : String) -> Iterable[String] {
        return SplitString{self, delimiter};
    }
    def unchecked_index(x : i32) -> i8 {
        return @bytes.[x];
    }
    def unchecked_insert(x : i32, value : i8) {
        @bytes.[x] = value;
    }
    def copy() -> Self {
        new_buf = Buffer[i8].new(@byte_length);
        for i in 0..@byte_length { new_buf.[i] = @bytes.[i]; }
        return String{new_buf, @byte_length, @char_length, @byte_length};
    }
    def reserve_extra(n : i32) {
        self.reserve(n + @byte_length);
    } ~> no_alias
    def increment_chars(n : i32) {
        @char_length = @char_length + n;
    } ~> no_alias
    def append_byte(byte : i8) {
        new_len = @byte_length + 1;
        if new_len > @capacity {
            grown_capacity = @capacity * 2;
            if grown_capacity < new_len { grown_capacity = new_len; }
            self.reserve(grown_capacity);
        }
        @bytes.[@byte_length] = byte;
        @byte_length = new_len;
    } ~> no_alias
    def repr() -> String {
        return self;
    } ~> { ret == self }
    def codepoints() -> StringCodePoints {
        return StringCodePoints{self};
    } ~> { ret.str == self }
    def bytes() -> StringBytes {
        return StringBytes{self};
    } ~> { ret.str == self }
    def iterator() -> ConstantTimeIterator[Character] {
        return StringIterator{self};
    } ~> { ret.str == self }
    def writer() -> StringWriter {
        return StringWriter{self};
    } ~> { ret.string == self }

}

class SplitString extends Iterable[String] {
    @source : String
    @delimiter : String

    def init(@source : String, @delimiter : String) {}

    def iterator() -> SplitStringIterator {
        return SplitStringIterator{@source, @delimiter};
    } ~> { ret.source == @source, ret.delimiter == @delimiter }
}

class SplitStringIterator extends Iterator[String] {
    @source : String
    @delimiter : String
    @cursor : i32
    @done : Bool

    def init(@source : String, @delimiter : String) {
        @cursor = 0;
        @done = false;
    }

    def build_segment(start : i32, end_exclusive : i32) -> String {
        n_bytes = end_exclusive - start;
        bytes = Buffer[i8].new(n_bytes);
        n_chars = 0;

        i = 0;
        while i < n_bytes {
            byte = @source.unchecked_index(start + i);
            bytes.[i] = byte;
            if not UTF8.is_continuation(byte as i32) { n_chars = n_chars + 1; }
            i = i + 1;
        }

        return String{bytes, n_bytes, n_chars, n_bytes};
    } ~> no_alias

    def find_delimiter(last_start : i32) -> i32? {
        scan = @cursor;
        while scan <= last_start {
            if @source.bytes_match_at(@delimiter, scan) { return scan; }
            scan = scan + 1;
        }
        return nil;
    } ~> no_alias

    def next() -> String? {
        if @done { return nil; }

        source_len = @source.byte_length();
        delimiter_len = @delimiter.byte_length();
        if delimiter_len == 0 {
            @done = true;
            return self.build_segment(0, source_len);
        }

        start = @cursor;
        if start > source_len {
            @done = true;
            return nil;
        }

        last_start = source_len - delimiter_len;
        next_delimiter = self.find_delimiter(last_start);
        if next_delimiter is i32 {
            @cursor = next_delimiter + delimiter_len;
            return self.build_segment(start, next_delimiter);
        }

        @done = true;
        return self.build_segment(start, source_len);
    }
}

class StringCodePoints extends List[i32] {
    @str : String

    regions { @elems_reg == @str.elems_reg }

    def Self.empty() -> Self {
        return Self{String.empty()};
    }
    def Self.from_iterable(iterable : Iterable[i32]) -> Self {
        return Self.empty().extend(iterable);
    }
    def init(@str : String) {
    }
    def size() -> i32 {
        return @str.char_length();
    }
    def iterator() -> ConstantTimeIterator[i32] {
        return UTF8Decoder{@str.bytes().iterator()};
    }
    def append(x : i32) -> Self {
        self.writer().write(x);
        return self;
    }
    def extend(other : Iterable[i32]) -> Self {
        self.writer().write_from(other);
        return self;
    }
    def writer() -> Writer[i32] {
        return StringCodepointWriter{@str};
    } ~> { ret.string == @str, ret.dest_reg == @elems_reg }
}

class StringBytes extends List[i8] {
    @str : String

    regions { @elems_reg == @str.elems_reg }

    def Self.empty() -> Self {
        return Self{String.empty()};
    }
    def Self.from_iterable(iterable : Iterable[i8]) -> Self {
        return Self.empty().extend(iterable);
    }
    def init(@str : String) {
    }
    def size() -> i32 {
        return @str.byte_length();
    }
    def iterator() -> ConstantTimeIterator[i8] {
        return StringBytesIterator{@str};
    }
    def append(x : i8) -> Self {
        self.writer().write(x);
        return self;
    }
    def extend(other : Iterable[i8]) -> Self {
        self.writer().write_from(other);
        return self;
    }
    def writer() -> Writer[i8] {
        return StringByteWriter{@str};
    } ~> { ret.string == @str, ret.dest_reg == @elems_reg }

}

// Iterator can trust that the source string is valid.
// Constant-time *with respect to the length of the String*
class StringIterator extends ConstantTimeIterator[Character] {
    @cp_iterator : ConstantTimeIterator[i32]

    def init(str : String) {
        @cp_iterator = str.codepoints().iterator();
    }
    def next() -> Character? {
        next_cp = @cp_iterator.next();
        if next_cp is i32 { return Character{next_cp}; }
        return nil;
    }
}

class StringBytesIterator extends ConstantTimeIterator[i8] {
    @str : String
    @cursor : i32

    def init(@str : String) {
        @cursor = 0;
    }

    def next() -> i8? {
        if @cursor >= @str.byte_length() { return nil; }
        next = @str.unchecked_index(@cursor);
        @cursor = @cursor + 1;
        return next;
    }
}

class StringWriter extends Writer[Character] {
    @string : String
    @encoder : UTF8Encoder

    regions {
        @dest_reg == @encoder.dest_reg,
        @encoder.dest_reg == @string.elems_reg
    }

    def init(@string : String) {
        @encoder = UTF8Encoder{@string.bytes().writer()};
    }

    def write(value : Character) {
        @string.reserve_extra(value.n_bytes());
        @encoder.write(value.codepoint());
        @string.increment_chars(1);
    }
    // Avoid repeated reserve/copy while encoding known-size collections.
    def write_from(source : Collection[Character], max_elems : i32) -> i32 {
        n_chars = source.size();
        if max_elems > n_chars { max_elems = n_chars; }
        @string.reserve_extra(n_chars * 4);
        return self.write_from(source.iterator(), max_elems);
    }
    // A String has already validated bytes, so we can just write its bytes directly
    def write_from(source : String) -> i32 {
        n_chars = source.char_length();
        @string.bytes().writer().write_from(source.bytes());
        @string.increment_chars(n_chars);
        return n_chars;
    }
}

class StringByteWriter extends Writer[i8] {
	@string : String

    regions { @dest_reg == @string.elems_reg }

	def init(@string : String) {}

	def write(value : i8) {
		@string.append_byte(value);
	}

    // .write_from(bytes) with a single argument will delegate to this override
    def write_from(source : Collection[i8], max_elems : i32) -> i32 {
        n_bytes = source.size();
        if max_elems > n_bytes { max_elems = n_bytes; }
        @string.reserve_extra(max_elems);
        return self.write_from(source.iterator(), max_elems);
    }
}

class StringCodepointWriter extends Writer[i32] {
	@string : String
	@encoder : UTF8Encoder

    regions {
        @dest_reg == @encoder.dest_reg,
        @encoder.dest_reg == @string.elems_reg
    }

	def init(@string : String) {
		@encoder = UTF8Encoder{@string.bytes().writer()};
	}

	def write(value : i32) {
        width = UTF8.encoded_width(value);
        if width == 0 { width = 3; }
        @string.reserve_extra(width);
		@encoder.write(value);
		@string.increment_chars(1);
	}
    def write_from(source : Iterator[i32], max_elems : i32) -> i32 {
        n_written = @encoder.write_from(source, max_elems);
        @string.increment_chars(n_written);
        return n_written;
    }
}

class Character {
    @codepoint : i32

    getter @codepoint

    def init(@codepoint : i32) {}

    def ==(other : Character) -> Bool {
        return @codepoint == other.codepoint();
    }
    def n_bytes() -> i32 {
        width = UTF8.encoded_width(@codepoint);
        if width == 0 { return 3; } // Use replacement width for invalid codepoints
        return width;
    }
}

class UTF8Encoder extends Writer[i32] {
	@writer : Writer[i8]
    @replacement_fn : (Writer[i8])

    regions { @dest_reg == @writer.dest_reg }

    getter @replacement_fn
    setter @replacement_fn

    def Self.lossy(writer : Writer[i8]) -> UTF8Encoder {
        replacement_fn = (writer : Writer[i8]) => {
            writer.write(0xEF as i8);
            writer.write(0xBF as i8);
            writer.write(0xBD as i8);
        };
        return UTF8Encoder{writer, replacement_fn};
    } ~> { ret.writer == writer }

    // Default is lossless, yield Exception on invalid codepoint
    def init(@writer : Writer[i8]) {
        @replacement_fn = (writer : Writer[i8]) => { yield(InvalidUTF8Error{}); return; };
    }

    def init(@writer : Writer[i8], @replacement_fn : (Writer[i8])) {
    }

	def write(value : i32) {
        width = UTF8.encoded_width(value);
        if width == 1 { // 1-byte
            @writer.write(value as i8);
            return;
        }
        if width == 2 { // 2-byte
            @writer.write((0xC0 bit_or (value >> 6)) as i8);
            @writer.write((0x80 bit_or (value bit_and 0x3F)) as i8);
            return;
        }
        if width == 3 { // 3-byte
            @writer.write((0xE0 bit_or (value >> 12)) as i8);
            @writer.write((0x80 bit_or ((value >> 6) bit_and 0x3F)) as i8);
            @writer.write((0x80 bit_or (value bit_and 0x3F)) as i8);
            return;
        }
        if width == 4 { // 4-byte
            @writer.write((0xF0 bit_or (value >> 18)) as i8);
            @writer.write((0x80 bit_or ((value >> 12) bit_and 0x3F)) as i8);
            @writer.write((0x80 bit_or ((value >> 6) bit_and 0x3F)) as i8);
            @writer.write((0x80 bit_or (value bit_and 0x3F)) as i8);
            return;
        }
        @replacement_fn.call(@writer);
	}

    // optimization: decoder + encoder = byte validator
    def write_from(source : UTF8Decoder, max_elems : i32) -> i32 {
        validator = UTF8BytesValidator{@writer, @replacement_fn};
        return validator.write_codepoints_from(source.peeker(), max_elems);
    } ~> { @dest_reg holds source.peeker.elems_reg }

    // optimization: validator + encoder = encoder
    def write_from(source : UTF8CodepointsValidator, max_elems : i32) -> i32 {
        iterator = source.iterator();
        n_written = 0;
        codepoint = iterator.next();
        while codepoint is i32 and n_written < max_elems {
            if codepoint > 0x10FFFF { codepoint = source.replacement_fn().call(codepoint); }
            self.write(codepoint);
            n_written = n_written + 1;
            codepoint = iterator.next();
        }
        return n_written;
    } ~> { @dest_reg holds source.iterator.elems_reg }
}

class UTF8CodepointsValidator extends Iterator[i32] {
    @iterator : Iterator[i32]
    @replacement_fn : (i32) -> i32

    regions { @elems_reg == @iterator.elems_reg }

    getters @iterator, @replacement_fn
    setter @replacement_fn

    def Self.lossy(iterator : Iterator[i32]) -> UTF8CodepointsValidator {
        replacement_fn = (codepoint : i32) => { 0xFFFD; };
        return UTF8CodepointsValidator{iterator, replacement_fn};
    } ~> { ret.iterator == iterator }

    def init(@iterator : Iterator[i32]) {
        @replacement_fn = (codepoint : i32) => {
            yield(InvalidUTF8Error{});
            return -1;
        };
    }

    def init(@iterator : Iterator[i32], @replacement_fn : (i32) -> i32) {
    }

    def next() -> i32? {
        codepoint = @iterator.next();
        if codepoint is Nil { return nil; }
        if codepoint <= 0x10FFFF { return codepoint; }
        return @replacement_fn.call(codepoint);
    }
}

// seems like a BulkWriter[i8], except the i32 returned is the # of *codepoints* written
class UTF8BytesValidator {
    @writer : Writer[i8]
    @replacement_fn : (Writer[i8])

    getter @replacement_fn
    setter @replacement_fn

    def Self.lossy(writer : Writer[i8]) -> UTF8BytesValidator {
        replacement_fn = (writer : Writer[i8]) => {
            writer.write(0xEF as i8);
            writer.write(0xBF as i8);
            writer.write(0xBD as i8);
        };
        return UTF8BytesValidator{writer, replacement_fn};
    } ~> { ret.writer == writer }

    def init(@writer : Writer[i8]) {
        @replacement_fn = (writer : Writer[i8]) => { yield(InvalidUTF8Error{}); return; };
    }

    def init(@writer : Writer[i8], @replacement_fn : (Writer[i8])) {
    }

    // Re-encode bytes for one codepoint from the byte source into @writer
    def write_codepoints_from(source : Iterator[i8], max_elems : i32) -> i32 {
        peeker = source into Peeker[i8];
        n_written = 0;
        while n_written < max_elems {
            b1 = peeker.next();
            if b1 is Nil { return n_written; }
            tuple = UTF8.classify_lead(b1 as i32);
            codepoint = tuple.[0];
            bytes_needed = tuple.[1];

            // Check for invalid start byte
            if bytes_needed == 0 {
                @replacement_fn.call(@writer);
                n_written = n_written + 1;
                continue;
            }

            if bytes_needed == 1 {
                @writer.write(b1);
                n_written = n_written + 1;
                continue;
            }

            temp_buf = Buffer[i8].new(4);
            temp_buf.[0] = b1;
            valid_bytes = true;

            for i in 1..bytes_needed {
                b_next = peeker.peek();
                if b_next is Nil { return n_written; }
                b_next_i32 = b_next as i32;
                if not UTF8.is_continuation(b_next_i32) {
                    valid_bytes = false;
                    break;
                }
                peeker.next();
                temp_buf.[i] = b_next;
                codepoint = UTF8.accumulate(codepoint, b_next_i32);
            }

            if (not valid_bytes) or (not UTF8.is_valid_codepoint(codepoint, bytes_needed)) {
                @replacement_fn.call(@writer);
                n_written = n_written + 1;
                continue;
            }

            for i in 0..bytes_needed { @writer.write(temp_buf.[i]); }
            n_written = n_written + 1;
        }
        return n_written;
    } ~> { @writer.dest_reg holds source.elems_reg }

    def write_codepoints_from(source : Iterator[i8]) -> i32 {
        return self.write_codepoints_from(source, i32.max());
    } ~> { @writer.dest_reg holds source.elems_reg }

    def write_codepoints_from(source : Iterable[i8], max_elems : i32) -> i32 {
        return self.write_codepoints_from(source.iterator(), max_elems);
    } ~> { @writer.dest_reg holds source.elems_reg }

    def write_codepoints_from(source : Iterable[i8]) -> i32 {
        return self.write_codepoints_from(source.iterator(), i32.max());
    } ~> { @writer.dest_reg holds source.elems_reg }
}

class UTF8Decoder extends ConstantTimeIterator[i32] {
    @peeker : Peeker[i8]
    @replacement_fn : (i8) -> i32

    regions { @elems_reg == @peeker.elems_reg }

    getters @peeker, @replacement_fn
    setter @replacement_fn

    def Self.lossy(iterator : Iterator[i8]) -> UTF8Decoder {
        replacement_fn = (byte : i8) => { 0xFFFD; };
        return UTF8Decoder{iterator, replacement_fn};
    } ~> { ret.iterator == iterator }

    def init(iterator : Iterator[i8]) {
        @peeker = iterator into Peeker[i8];
        @replacement_fn = (byte : i8) => {
            yield(InvalidUTF8Error{});
            return -1;
        };
    }

    def init(iterator : Iterator[i8], @replacement_fn : (i8) -> i32) {
        @peeker = iterator into Peeker[i8];
    }

    def next() -> i32? {
        b1 = @peeker.next();
        if b1 is Nil { return nil; }
        b1 = b1 as i32;
        tuple = UTF8.classify_lead(b1);
        codepoint = tuple.[0];
        bytes_needed = tuple.[1];

        // Check for invalid start byte
        if bytes_needed == 0 { return @replacement_fn.call(b1 as i8); }

        for i in 1..bytes_needed {
            b_next = @peeker.peek();
            if b_next is Nil { return nil; }
            b_next = b_next as i32;
            if not UTF8.is_continuation(b_next) { // Invalid continuation byte
                return @replacement_fn.call(b1 as i8);
            }
            codepoint = UTF8.accumulate(codepoint, b_next);
            b_next = @peeker.next();            // Advance, now that known valid
        }
        
        if not UTF8.is_valid_codepoint(codepoint, bytes_needed) { return @replacement_fn.call(b1 as i8); }

        return codepoint;
    }
}

class Stacktrace {
    @stacktrace : Buffer[i64]
    @n_frames : i64

    def init() {
        @stacktrace = Buffer[i64].new(100);
        @n_frames = capture_backtrace(100 as i64, @stacktrace);
    }

    def print() {
        print_backtrace(@stacktrace, @n_frames);
    }

}

class Exception {
    @line_number : i32
    @file_name : String
    @message : String
    @stacktrace : Stacktrace

    def init(@message : String) {
        @line_number = 0;
        @file_name = "";
        @stacktrace = Stacktrace{};
    }
    def init() {
        @line_number = 0;
        @message = "<None>";
        @file_name = "";
        @stacktrace = Stacktrace{};
    }

    def set_info(@line_number : i32, @file_name : String) {}

    def report() {
        print("---------".c_string());
        print("Exception thrown from file".c_string());
        print(@file_name.c_string());
        print("At line".c_string());
        print(@line_number);
        print("With message".c_string());
        self.print_message();
        print("Stack trace:".c_string());
        @stacktrace.print();
        print("---------".c_string());
    }
    def print_message() {
        print(@message.c_string());
    }
}

class InvalidUTF8Error extends Exception {
    def init() {
        @message = "Invalid UTF-8 sequence encountered during string conversion.";
        @line_number = 0;
        @file_name = "";
        @stacktrace = Stacktrace{};
    }
}

class OutOfBounds extends Exception {
    @details : OutOfBoundsDetails?

    def init(bounds : i32, index : i32) {
        @details = OutOfBoundsDetails.new(bounds, index);
        @line_number = 0;
        @file_name = "";
        @message = "An out-of-bounds error occurred while indexing into a collection.";
        @stacktrace = Stacktrace{};
    }
    def print_message() {
        print(@message.c_string());
        details = @details;
        if details is OutOfBoundsDetails { details.report(); }
    }
}

class OutOfBoundsDetails {
    @bounds : i32
    @index : i32
    def init(@bounds : i32, @index : i32) {}
    def report() {
        print("The size of the collection being indexed was".c_string());
        print(@bounds);
        print("The indexing argument was".c_string());
        print(@index);
    }
}

def report_exception(current_coroutine : Coroutine[() -> Exception]) {
    exception = current_coroutine.result();
    if exception is Exception { exception.report(); }
}
