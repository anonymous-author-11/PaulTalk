import std;

alias Map = SwissTable;

extern def clock() -> i64

class PRNG {
    @seed: i32
    def init(initial_seed: i32) {
        if initial_seed <= 0 {
            @seed = 1;
            return;
        }
        @seed = initial_seed bit_and 0x7FFFFFFF;
    }
    def next() -> i32 {
        a = 1103515245;
        c = 12345;
        @seed = (@seed * a + c) bit_and 0x7FFFFFFF;
        return @seed;
    }
}

def shuffle(arr: Array[i32], n: i32, rng: PRNG) {
    i = n - 1;
    while i > 0 {
        j = rng.next() % (i + 1);
        if j < 0 { j = j * -1; }
        tmp = arr.unchecked_index(i);
        arr.unchecked_insert(i, arr.unchecked_index(j));
        arr.unchecked_insert(j, tmp);
        i = i - 1;
    }
}

def print_benchmark_result(test_name: String, n: i32, duration: i64) {
    IO.print(test_name);
    IO.print("  Operations: "); IO.print(n);
    IO.print("  Total Time: "); IO.print(duration); IO.print(" ms");
    if n > 0 {
        ns_per_op = (duration * 1_000_000) / n;
        IO.print("  Time/Op:    ~"); IO.print(ns_per_op); IO.print(" ns");
    }
}

def benchmark_insert_sequential(n: i32) {
    map = Map[i32, i32].new(i32_hasher, i32_eq);
    start_time: i64 = clock();
    i = 0;
    while i < n {
        map.insert(i, i + 1);
        i = i + 1;
    }
    end_time: i64 = clock();

    verification_passed = true;
    if n > 0 {
        last_val = map.get(n - 1);
        if last_val is Nil { verification_passed = false; }
        if last_val is i32 { if last_val != n { verification_passed = false; } }
        if map.size() != n { verification_passed = false; }
    } else {
        if map.size() != 0 { verification_passed = false; }
    }
    print_benchmark_result("Insert Sequential", n, end_time - start_time);
    IO.print("    Verification: ");
    if verification_passed { IO.print("PASS"); } else { IO.print("FAIL"); }
}

def benchmark_insert_random(n: i32) {
    map = Map[i32, i32].new(i32_hasher, i32_eq);
    rng = PRNG.new(123);
    keys_to_insert = Array[i32].new(n);
    
    temp_map_for_size_check = Map[i32, Bool].new(i32_hasher, i32_eq);
    i = 0;
    while i < n {
        key = rng.next();
        keys_to_insert.unchecked_insert(i, key);
        temp_map_for_size_check.insert(key, true);
        i = i + 1;
    }
    expected_size = temp_map_for_size_check.size();
    
    // Shuffle insertion order
    shuffle(keys_to_insert, n, PRNG.new(777));

    start_time: i64 = clock();
    i = 0;
    while i < n {
        key = keys_to_insert.unchecked_index(i);
        map.insert(key, key + 1);
        i = i + 1;
    }
    end_time: i64 = clock();

    verification_passed = true;
    if n > 0 {
        actual_size = map.size();
        if actual_size != expected_size {
            verification_passed = false;
        }
    } else {
        if map.size() != 0 { verification_passed = false; }
    }
    print_benchmark_result("Insert Random", n, end_time - start_time);
    IO.print("    Verification: ");
    if verification_passed { IO.print("PASS"); } else { IO.print("FAIL"); }
    IO.print("    (Expected unique size: "); IO.print(expected_size); IO.print(")");
}

def benchmark_get_sequential(n: i32) {
    map = Map[i32, i32].new(i32_hasher, i32_eq);
    expected_sum: i64 = 0;
    i = 0;
    while i < n {
        value_to_insert = i + 1;
        map.insert(i, value_to_insert);
        expected_sum = expected_sum + value_to_insert;
        i = i + 1;
    }

    start_time: i64 = clock();
    actual_sum: i64 = 0;
    i = 0;
    while i < n {
        val = map.get(i);
        if val is i32 {
            actual_sum = actual_sum + val;
        }
        i = i + 1;
    }
    end_time: i64 = clock();

    verification_passed = actual_sum == expected_sum;
    print_benchmark_result("Get Sequential", n, end_time - start_time);
    IO.print("    Verification: "); if verification_passed { IO.print("PASS"); } else { IO.print("FAIL"); }
}

def benchmark_get_random(n: i32) {
    map = Map[i32, i32].new(i32_hasher, i32_eq);
    keys = Array[i32].new(n);
    rng = PRNG.new(999);
    expected_sum: i64 = 0;
    
    i = 0;
    while i < n {
        keys.unchecked_insert(i, i);
        value = i + 1;
        map.insert(i, value);
        expected_sum = expected_sum + value;
        i = i + 1;
    }
    
    // Shuffle for true random access pattern
    shuffle(keys, n, rng);

    start_time: i64 = clock();
    actual_sum: i64 = 0;
    i = 0;
    while i < n {
        key = keys.unchecked_index(i);
        val = map.get(key);
        if val is i32 { actual_sum = actual_sum + val; }
        i = i + 1;
    }
    end_time: i64 = clock();
    
    verification_passed = actual_sum == expected_sum;
    print_benchmark_result("Get Random", n, end_time - start_time);
    IO.print("    Verification: "); if verification_passed { IO.print("PASS"); } else { IO.print("FAIL"); }
}

def benchmark_get_miss(n: i32) {
    map = Map[i32, i32].new(i32_hasher, i32_eq);
    rng_setup = PRNG.new(789);
    rng_miss = PRNG.new(987);
    
    temp_map_for_setup = Map[i32, Bool].new(i32_hasher, i32_eq);
    keys_added_count = 0;
    attempts = 0;
    max_attempts_setup = n * 10;

    while keys_added_count < n and attempts < max_attempts_setup {
        key = rng_setup.next();
        if temp_map_for_setup.get(key) is Nil {
            map.insert(key, key + 1);
            temp_map_for_setup.insert(key, true);
            keys_added_count = keys_added_count + 1;
        }
        attempts = attempts + 1;
    }

    keys_to_miss = Array[i32].new(n);
    miss_keys_generated = 0;
    attempts = 0;
    max_attempts_miss = n * 20;

    while miss_keys_generated < n and attempts < max_attempts_miss {
        key = rng_miss.next();
        if temp_map_for_setup.get(key) is Nil {
            keys_to_miss.unchecked_insert(miss_keys_generated, key);
            miss_keys_generated = miss_keys_generated + 1;
        }
        attempts = attempts + 1;
    }

    if miss_keys_generated < n {
        IO.print("Warning: Could only generate "); IO.print(miss_keys_generated); IO.print(" guaranteed miss keys.");
        n = miss_keys_generated;
    }

    // Shuffle miss keys too
    shuffle(keys_to_miss, n, PRNG.new(555));

    start_time: i64 = clock();
    miss_count = 0;
    hit_count = 0;
    i = 0;
    while i < n {
        key = keys_to_miss.unchecked_index(i);
        if map.get(key) is Nil { miss_count = miss_count + 1; }
        else { hit_count = hit_count + 1; }
        i = i + 1;
    }
    end_time: i64 = clock();

    verification_passed = true;
    if n > 0 {
        if (hit_count * 100 / n) >= 5 { verification_passed = false; }
    } else {
        if hit_count != 0 { verification_passed = false; }
    }

    print_benchmark_result("Get Miss", n, end_time - start_time);
    IO.print("    Verification: "); if verification_passed { IO.print("PASS"); } else { IO.print("FAIL"); }
    IO.print("    (Misses: "); IO.print(miss_count); IO.print(", Hits: "); IO.print(hit_count); IO.print(")");
}

def benchmark_remove_random(n: i32) {
    map = Map[i32, i32].new(i32_hasher, i32_eq);
    rng = PRNG.new(101112);
    keys_to_remove = Array[i32].new(n);
    
    temp_map_keys = Map[i32, Bool].new(i32_hasher, i32_eq);
    keys_added_count = 0;
    attempts = 0;
    max_attempts = n * 10;

    while keys_added_count < n and attempts < max_attempts {
        key = rng.next();
        if temp_map_keys.get(key) is Nil {
            map.insert(key, key + 1);
            keys_to_remove.unchecked_insert(keys_added_count, key);
            temp_map_keys.insert(key, true);
            keys_added_count = keys_added_count + 1;
        }
        attempts = attempts + 1;
    }

    if keys_added_count < n {
        IO.print("Warning: Could only generate "); IO.print(keys_added_count); IO.print(" unique keys for remove test.");
        n = keys_added_count;
    }

    // Shuffle removal order
    shuffle(keys_to_remove, n, PRNG.new(888));

    start_time: i64 = clock();
    remove_count = 0;
    i = 0;
    while i < n {
        key = keys_to_remove.unchecked_index(i);
        val = map.remove(key);
        if val is i32 {
            remove_count = remove_count + 1;
        }
        i = i + 1;
    }
    end_time: i64 = clock();

    verification_passed = remove_count == n and map.size() == 0;
    
    print_benchmark_result("Remove Random", n, end_time - start_time);
    IO.print("    Verification: "); if verification_passed { IO.print("PASS"); } else { IO.print("FAIL"); }
    IO.print("    (Items removed: "); IO.print(remove_count); IO.print(")");
}

IO.print("--- Map Benchmarks ---");
n = 1_500_000;

benchmark_insert_sequential(n);
benchmark_insert_random(n);
benchmark_get_sequential(n);
benchmark_get_random(n);
benchmark_get_miss(n);
benchmark_remove_random(n);

IO.print("--- Benchmarks Complete ---");