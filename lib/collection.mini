import iteration;

class Collection[T] extends Iterable[T] {

    abstract def size() -> i32 {}

    def is_empty() -> Bool {
        return self.size() == 0;
    }

    def contains(target : T, eq : (T, T) -> Bool) -> Bool {
        for item in self {
            if eq.call(item, target) { return true; }
        }
        return false;
    }

    // Iterable.filter is *not* overridden because the size of a filtered collection cannot be known prior to iterating

    def enumerate() -> Collection[Pair[i32, T]] {
        return EnumeratedCollection{self};
    }
    
    def map[U](f : (T) -> U) -> Collection[U] {
        return MappedCollection{self, f};
    }
    
    def chain(other : Collection[T]) -> Collection[T] {
        return ChainedCollection{self, other};
    }
    
    def interleave(other : Collection[T]) -> Collection[T] {
        return InterleavedCollection{self, other};
    }
    
    def zip[U](other : Collection[U]) -> Collection[Pair[T, U]] {
        return ZippedCollection{self, other};
    }
    
    def product[U](other : Collection[U]) -> Collection[Pair[T, U]] {
        return ProductCollection{self, other};
    }
}

class EnumeratedCollection[T] extends Collection[Pair[i32, T]] {
    @iterable : Collection[T]

    regions { @elems_reg == @iterable.elems_reg }

    def init(@iterable : Collection[T]) {
    }
    def size() -> i32 {
    	return @iterable.size();
    }
    def iterator() -> Enumerator[T] {
        return Enumerator{@iterable.iterator()};
    } ~> { ret.iterator holds @iterable }
}

class MappedCollection[T, U] extends Collection[U] {
    @iterable : Collection[T]
    @f : (T) -> U

    regions { @elems_reg == @iterable.elems_reg }

    def init(@iterable : Collection[T], @f : (T) -> U) {
    }
    def size() -> i32 {
    	return @iterable.size();
    }
    def iterator() -> Mapper[T, U] {
        return Mapper{@iterable.iterator(), @f};
    } ~> { ret.f == @f, ret.iterator holds @iterable }
}

class ChainedCollection[T] extends Collection[T] {
    @first : Collection[T]
    @second : Collection[T]

    regions { @elems_reg holds (@first.elems_reg, @second.elems_reg) }

    def init(@first : Collection[T], @second : Collection[T]) {
    }
    def size() -> i32 {
    	return @first.size() + @second.size();
    }
    def iterator() -> Chainer[T] {
        return Chainer{@first.iterator(), @second.iterator()};
    } ~> {
        ret.second.elems_reg == @second.elems_reg,
        ret.first.elems_reg == @first.elems_reg,
        ret.second holds @second,
        ret.first holds @first
    }
}

class InterleavedCollection[T] extends Collection[T] {
    @first : Collection[T]
    @second : Collection[T]

    regions { @elems_reg holds (@first.elems_reg, @second.elems_reg) }

    def init(@first : Collection[T], @second : Collection[T]) {
    }
    def size() -> i32 {
    	return @first.size() + @second.size();
    }
    def iterator() -> Interleaver[T] {
        return Interleaver{@first.iterator(), @second.iterator()};
    } ~> {
        ret.second.elems_reg == @second.elems_reg,
        ret.first.elems_reg == @first.elems_reg,
        ret.second holds @second,
        ret.first holds @first
    }
}

class ZippedCollection[T, U] extends Collection[Pair[T, U]] {
    @first : Collection[T]
    @second : Collection[U]

    regions { @elems_reg holds (@first.elems_reg, @second.elems_reg) }

    def init(@first : Collection[T], @second : Collection[U]) {
    }
    def size() -> i32 {
    	first_size = @first.size();
    	second_size = @second.size();
    	if first_size < second_size { return first_size; }
    	return second_size;
    }
    def iterator() -> Zipper[T, U] {
        return Zipper{@first.iterator(), @second.iterator()};
    } ~> {
        ret.second.elems_reg == @second.elems_reg,
        ret.first.elems_reg == @first.elems_reg,
        ret.second holds @second,
        ret.first holds @first
    }
}

class ProductCollection[T, U] extends Collection[Pair[T, U]] {
    @first : Collection[T]
    @second : Collection[U]

    regions { @elems_reg holds (@first.elems_reg, @second.elems_reg) }

    def init(@first : Collection[T], @second : Collection[U]) {
    }
    def size() -> i32 {
    	return @first.size() * @second.size();
    }
    def iterator() -> Productizer[T, U] {
        return Productizer{@first.iterator(), @second};
    } ~> {
        ret.second == @second, 
        ret.first_iterator.elems_reg == @first.elems_reg,
        ret.current_first holds @first.elems_reg,
        ret.first_iterator holds @first
    }
}
