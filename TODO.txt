DONE:

- Intrinsics [check!]
- Make sure overloading works with unions [check!]
	- Need to do wrapping/unwrapping around concrete method call [check!]
	- Need a way of getting vptr and offset for union passed in [check!]
- make sure ambiguous overloads handled at type checking time [check!]
- Class methods [check!]
	- Syntactically distinguish capitalized recievers [check!]
	- Define class methods with Self.method [check!]
	- statically known vtable [check!]
- Operator overloading [check!]
- Line numbers for errors [check!]
- Move from scf to cf for while and if statements [check!]
	- Implement ExecuteRegion [check!]
- Replace scope.operations with Block [check!]
- Break and continue [check!]
- Early / multiple returns [check!]
- Parentheses in conditions optional [check!]
- Compile with mypyc [check!]
- Implement buffer type [check!]
- Ensure assignments with method calls on fields is working properly [check!]
- Arrays for builtin types [check!]
- Array literal syntax [check!]
	- Initialize with pre-filled buffer [check!]
- Allow overloads of differing arity (different behavior for each) [check!]
	- do behavior naming based on arity [check!]
- Setup exception landing pad for uncaught yields [check!]
- Change coroutine_resume to do quick pointer switch [check!]
- Place coroutine on its own stack [check!]
- Allow return statements in methods with no return value [check!]
	- Syntactically allow [check!]
	- Incorporate in type checking [check!]
	- Incorporate in lowering [check!]
- Implement logical or/and [check!]
	- In parser [check!]
	- In binary op [check!]
	- Refactor BinaryOp [check!]
	- Correct precedence [check!]
- Refactor AST [check!]
- Statically dispatch class methods when arguments are builtin types [check!] [reverted]
- rename to .call() instead of .resume() [check!]
- Enforce capitalization norms [check!]
	- no capitalized function or method names [check!]
	- class names must be uppercase [check!]
- Use underscores for internal names and disallow them for the user [check!]
- Self type [check!]
- Implement i64 and i128 [check!]
- Implement extensions from i32 to i64 [check!]
- Ensure that there is a return statement in a function that declares a return value [check!]
- Implement casts from integers to floats [check!]
- Modules [check!]
	- Import statements [check!]
	- Load classes and functions from another file [check!]
	- Codegen functions and classes [check!]
- Start creating standard library [check!]
- Range literals [check!]
- For/in loops [check!]
- Extern declarations [check!]
- Add comments [check!]
- Pretty-printing types [check!]
- Implement proper strings [check!]
- Empty array literals [check!]
- Get rid of second phase of lowering [check!]
- Provide compilation options [check!]
- Remove global variables [check!]
- Enable transitive imports [check!]
- Implement type aliases [check!]
- implement c3 linearization [check!]
- Field access via indirection [check!]
- Properly get type sizes for allocation [check!]
- Use fat ptr offset for calls and field accesses [check!]
- Add inheritance! [check!]
- Make every class inherit from Object [check!]
- Allow invoking inherited methods [check!]
- Mark LUB and subtype_test as pure [check!]
- Tune compiler passes [check!]
- Upcasting and autocasting [check!]
	- Modify offset value [check!]
	- Need mapping from each class to its ancestors [check!]
- Get rid of null-termination of strings [check!]
- Enforce rules on overriding [check!]
- Disallow redefinition of fields [check!]
- Abstract methods [check!]
	- Illegal to instantiate a class with any abstract methods [check!]
	- Abstract methods do not have bodies [check!]
- Decouple offset procurement from method call [check!]
- Type check unions with objects in them [check!]
	- Use actual subtype test rather than vptr equality [check!]
- Clean up class/method call lowering [check!]
- Ensure that floats and ints have value semantics [check!]
- Make mangled names deterministic [check!]
- Prevent duplicate codegen of files [check!]
- Use VirtualAlloc and VirtualFree with coroutine [check!]
	- Commit 8mb and page in on fault [check!]
- Disallow referring to 'self' in init [check!]
- Make subtype checks for value types vptr equality [check!]
- Null safety for uninitialized members [check!]
	- By disallowing references to self and checking types at end of init method [check!]
- Ensure that fields in parameter lists match types with their declarations [check!]
- Do not inherit init methods which are not consistent with field types [check!]
	- I.e. does not initialize non-nil field [check!]
- first class functions [check!]
	- Implicit return and infer return type [check!]
	- anon = (a : i32, b : i32) => { a + b }; [check!]
	- Function type annotations (i32, i32) -> i32 [check!]
- Allow writing function type with no return type [check!]
- Disallow directly calling abstract class methods [check!]
- Implement proper name shadowing for classes and functions [check!]
	- Disallow duplicate classes in same file/module [check!]
	- Make sure that transitive imports are handled properly [check!]
- Figure out a way to handle C's i8 -> i32 return vals [check!]
- Implement creating, opening, reading and writing files [check!]
- Pass in two selves for method calls [check!]
- Refactor coro_create to Coroutine.new() [check!]
	- Allow referring to non-anonymous functions by their name [check!]
	- Have coro_create take an identifier [check!]
	- Fix nested anonymous functions [check!]
- Pass initial args at coroutine creation time [check!]
	- Pass in custom arg_passer rather than custom trampoline [check!]
	- Store arg_passer in coroutine [check!]
	- Use the end of the coroutine on the stack as the arg buffer [check!]
	- We generate special arg_passer and buffer_filler functions for each coroutine [check!]
	- Coroutines need to carry their call/yield/return types in their type [check!]
- Figure out how coroutine returns should work [check!]
	- Probably best to have a .result() method [check!]
	- Implement .result() [check!]
	- Convert to union [check!]
- Passing coroutine arguments with call/yield [check!]
	- Rewrite yield to be an expression [check!]
	- Add yield type annotation for literals [check!]
	- Cast before yield [check!]
- Add generators and IntIterable.map() [check!]
- Figure out makeshift type annotation for coroutines [check!]
	- Put in subtyping rules for functions and coroutines [check!]
- We need to move iteration logic into the condition scope [check!]
	- This means that it will no longer be a simple expression [check!]
	- However, it will still be a single block [check!]
- Implement hex literals [check!]
- Require that unitialized variables be nullable types [check!]
- Coroutine type should reflect call parameters [check!]
- Add a tuple type [check!]
	- Add to IR [check!]
	- Add to grammar [check!]
	- Add to AST [check!]
	- Add indexing [check!]
	- Add type annotation [check!]
	- Add subtyping rules [check!]
- Ideally we don't have to codegen all imports [check!]
	- Codegen only interfaces for imported files [check!]
- Remove use of 'schema' [check!]
- Add type parameters to grammar [check!]
- Add type parameters to FatPtr type [check!]
- Add type parameters to ClassDef [check!]
- Shouldn't need to initialize nilable members with nil [check!]
- Have exceptions store the file and line number of where they were thrown from [check!]
	- And an error message as well [check!]
	- Store file name along with line number in every AST node [check!]
- Simplify casting [check!]
- Add boxing and unboxing functionality [check!]
- store the size_in_bytes (gep calculated) in the vtable prelude [check!]
- Add store_in_buffer and from_buffer primitives [check!]
- Shift direct_supertypes to types rather than strings [check!]
- Shift .ancestors() and .my_ordering() froms string to types and classdefs [check]
- Add TypeParameter to dialect [check!]
- Add type inference for generic methods [check!]
- Check method arguments based on instantiated type [check!]
- Fix loads and stores of aggregates [check!]
- Add explicit type bounds to the grammar [check!]
- Add generic parameters to class definition grammar [check!]
	- Will need to recast inheritance list in terms of types rather than names [check!]
	- T is implicitly T <: Object [check!]
	- Add a slot for type paramters to FatPtr [check!]
- Get basic generics working [check!] [woohoo!]
- Explore extending instantiated generics [check!]
	- Easy enough to pass the supertype list through the alias filter [check!]
- Reabstraction thunks [check!]
- Change unions to use first word for vptr [check!]
- Fix coroutine bugs [check!]
- Change unwrap to recursively unwrap [check!]
- Shrink FatPtr unions to 224 bits [check!]
- Store compile-time known strings in globals and use memcpy to assign [check!]
- Fix bugs [check!]
- Convert union-with-nil typecheck to vptr equality [check!]
- Shift TypeParameter to { ptr, i160 } interface [check!]
- Zero cost generics! [check!]
- Overhaul dispatch system to use predicate dispatch [check!]
- Refactor casting [check!]
- Add tuple subtyping rules [check!]
- Implement tuple casting [check!]
- Add method type parameters [check!]
	- Add to the grammar [check!]
	- Incorporate in type checking [check!]
- Fix buffer indexation [check!]
- Two-stage specialization/casting: intra-behavior and between overrides [check!]
- Drop overridden methods from behaviors [check!]
	- Handle casts of parameters and return values [check!]
	- Unify so special logic in dispatch not needed [check!]
	- Will also remove special logic from instantiation [check!]
- Switch to { ptr, i128, i32 } interface [check!]
	- Need to address places where used interchangeably with Union [check!]
- Clean up override system
	- is_override_of method [check!]
	- use for minimizing behaviors [check!]
	- use for broad return type [check!]
- Each method knows about what method definitions it overrides [check!]
	- And can interpret their types in their defining class's scope [check!]
	- Should be calculated prior to behaviors and vtables; used in their construction [check!]
	- Store a list of overridden definitions [check!]
	- Methods also define their broad parameter and return types [check!]
- Inheriting from an instantiated generic should alias with the concrete type, not a bounded parameter [check!]
	- We will need to track for each method those methods it specializes [check!]
- Remove superfluous methods from behaviors and vtables [check!]
- Set offsets on TypeParameters [check!]
	- Upon boxing and upon casting [check!]
- Allow method calls on instances of TypeParameter [check!]
- Implement type parameters constraints [check!]
	- Need to actually use the offset field [check!]
- Cast type parameters to their bounds [check!]
- Add fields for type parameters [check!]
- Store concrete type parameters on object creation [check!]
- Set stored type parameters as invariant [check!]
- Pass type fields from self to new [check!]
- Create global type lists along with getters [check!]
- Have fixed type getters return immediate global [check!]
- Take fixed types out of fields() and change offsets accordingly [check!]
- Have to reform getterdef to reflect nested nature of parameterizations [check!]
- Creating a global for a parameterization needs to be recursive [check!]
- Implement parameterization infrastructure [check!]
- Store type parameters as fields and access via vtable [check!]
	- Organize type parameter overloads for each class [check!]
	- Produce parameterizations for each instance [check!]
- Move type parameters back to { ptr, i160 } interface [check!]
- Add logic for retrieving types from stored parameterizations [check!]
	- Where is the U in Pair[Pair[T, U], T] ? [check!]
	- How do we map that to indices [0, 1] [check!]
	- Op call with indices to retrieve type [check!]
- Pass method-scoped type parameters into methods [check!]
	- Add them onto the beginning of the signature [check!]
	- On method call, create parameterizations and pass them in [check!]
	- Nice how the new infrastructure covers this [check!]
	- Add method-scoped type parameters to ambient types and operands [check!]
- Pass types from method context to new [check!]
- Pass class-scoped parameterizations into class methods [check!]
	- Probably after the normal passed parameterizations [check!]
- We need a mapping between types available to init() and type fields [check!]
- Move reabstraction to trampolines [check!]
	- Add llvm.nest attributes to wrapping functions [check!]
	- Use llvm.init.trampoline and llvm.adjust.trampoline intrinsics [check!]
	- Mark malloc as executable with VirtualProtect [check!]
- Remove memcpy from string assignment; use long integers instead [check!]
- Bitwise operations for integers [check!]
- Move alloca hoisting to llvm pass [check!]
- Add compiler error tests [check!]
- Start moving lowering patterns to PDL [check!]
- Get native constraints and rewrites working [check!]
- Add end-to-end test [check!]
- Try to allocate from a memory region [check!]
	- Ensure noalias works [check!]
- Fix reverted PDL patterns (paramsarray, paramsindexation, new) [check!]
- Store imports as graph rather than set [check!]
- Implement lifetime constraints and points-to analysis [check!]
- Add class-scope region constraints to grammar [check!]
	- Fix up class def grammar [check!]
	- Add dot-syntax to the constraints grammar [check!]
- Handle abstract regions, not as fields [check!]
	- Separate from fields in parsing [check!]
	- Add a regions tuple to ClassDef [check!]
	- Have a .all_regions() method which handles inherited regions [check!]
- Add class-scoped constraints to method constraints [check!]
	- Add constraints to ClassDef [check!]
	- Add .all_constraints() to ClassDef [check!]
	- After checking override validity [check!]
	- Only to instance method constraints [check!]
- Be sure to include constraints from overloads of overidden methods [check!]
- Translate behavior constraints arg numbering to new granular constraints [check!]
- On object creation, add class constraints to caller points-to graph [check!]
	- Including standard fields > self constraints [check!]
	- Or just implicitly add class constraints to init [check!]
	- Be sure to map names to the context [check!]
- Elements do need to live in the same region for buffer [check!]
	- Create an elems_reg pseudo-region for buffer [check!]
- Work on mapping field constraints for method calls [check!]
- Also check for null ptr on nil check [check!]
- Fix FancyPair [check!]
- Need to fix access of specialized fields [check!]
	- Right, this is why I was thinking about generating setters [check!]
- See if hash compiles now [check!]
	- no, because of problem below [check!]
- Implement a hash table [check!]
- Figure out relationship between Any, Object, Nil [check!]
	- Need for Foo[Bar | Nil] and for T <: Any [check!]
	- Make nil its own ancestor [check!]
- Simplify behavior signature [check!]
- Enable machine outlining [check!]
- Move string handling to vector<i8> [check!]
- Need to focus on assignments to method calls [check!]
	- Translate into calls to setter methods [check!]
	- Add setter methods to grammar properly [check!]
	- Setter methods should take one parameter [check!]
	- Except for index-setter which should take two [check!]
- Write a size_in_bytes function for each class; store in vtable prelude [check!]
	- Should be passed a ptr to a parameterization of itself [check!]
	- Then passes nested parameterizations to their own type size functions [check!]
	- But still needs to know how to add up the results of recursive calls [check!]
	- Returns an i64 [check!]
	- Properly handles alignment [check!]
- Have a _box_ method in every type's vtable [check!]
- Null-terminate parameterizations [check!]
- Write a special _size_ method for union and tuple [check!]
- Add an _unbox_ method for every type as well [check!]
- Need to simultaneously change getter/setter/new to dynamically size generic fields [check!]
- Correctly retrieve pameterizations from passed arrays [check!]
- Move alloca hoisting to PDL [check!]
- Disallow method type parameters having same name as class type parameters [check!]
- Fix Zero-as-nil [check!]
	- We need to add null checks to method dispatch as well [check!]
	- Use "zeroed" instead of "uninitialized" for bump_malloc [check!]
- Handle simplifying intersections between type parameters and builtin types [check!]
	- Settled for a hack where if an intersection has a single builtin non-Any type it simplifies to that type [check!]
- Setting offset to Any is a no-op [check!]
- Write wrappers for box, unbox, size, getters, setters [check!]
	- Will help uninlined optimization [check!]
- Buffer indexation bug [check!]
	- Need to split out buffer_get and buffer_set ops [check!]
	- Can't return a pointer to the actual slot in the buffer [check!]
- We should rework how parameterizations are retrieved [check!]
	- Shouldn't generate parameterizations just to throw them away [check!]
	- Ideal interface: get_parameterization(type) [check!]
	- Cache previously generated parameterizations [check!]
- Properly do type checks of type parameters [check!]
	- Start just one layer deep, don't worry about nested parameters [check!]
	- Even for this I should want to rework parameterizations [check!]
- Allow underscores in numbers [check!]
- I should be allowed to do "if [expression] is T" [check!]
- I should be allowed to do ClassMethodCall with parameterized receiver [check!]
- Lazy logical ops [check!]
- Separate out _size_ and _data_size_ methods [check!]
	- Rename current _size_ methods to _data_size_ [check!]
	- Use the same wrapper for both [check!]
	- Use _data_size_ on instance creation [check!]
	- Use _size_ for everything else [check!]
- Generic buffer size and indexing [check!]
	- First just change bufferindexationop to take a dynamic type size [check!]
	- Change createbuffer to take dynamic size as well [check!]
	- For buffer creation we will need to get type size from ambient parameterizations [check!]
	- Retrieve parameterization and use its size_fn for creation and indexation [check!]
	- Need to modify create, buffer_get, and buffer_set concurrently [check!]
	- Unbox into buffer and box out of buffer [check!]
- Use Checkflag on method dispatch checks instead of raw SubtypeTest [check!]
	- Will use simple pointer equality checks for builtin types [check!]
- Add file name to error messages [check!]
- Rewrite the standard library with generics [check!]
- Shift array and range literals to new generics [check!]
	- Will need to do buffer optimization first for array [check!]
	- And to do buffer optimization we need stored type parameters [check!]
	- Which we do now have [check!]
- Write FileSystem utilities [check!]
- Figure out more sane integer casting mechanics [check!]
	- Maybe an 'as' operator [check!]
- Make sure abstract methods don't override concrete methods [check!]
- Make aliases smarter [check!]
	- I should be able to do "alias Map = CuckooMap;" [check!]
	- This should make Map[i32, String] equivalent to CuckooMap[i32, String] [check!]
- Allow array literals to be of any type [check!]
- Optimize individual .ll files before linking [check]
- Clean up compilation of files with no main() or no specified outfile [check!]
	- Stop early if no -o flag [check!]
	- Stop early if .obj outfile [check!]
	- Don't emit main function if no outfile [check!]
	- Emit empty main function if specified outfile and no toplevel code [check!]
	- Avoid duplicate main functions [check!]
- Make .lib archives of .bc files and link --only-needed [check!]
- Move lowering logic in core_dialect to pre-type-lowering passes [check!]
	- Move type_id to type.symbol() [check!]
	- CastOp [check!]
	- Remove CastAssignOp [check!]
	- TupleCastOp [check!]
- Make parsing way faster [check!]
- Better error for incorrectly parameterized reciever [check!]
	- I.e. Array.new instead of Array[i32].new [check!]
- Add multi-line comments [check!]
	- To grammar [check!]
	- To syntax highlighting [check!]
- We should distinguish between the input/output *paths* and the input/output *filenames* [check!]
	- And we should create the output directory if it doesn't exist [check!]
	- Add option for build directory; default to current directory [check!]
	- All files other than the output file should be created into optional 'build' directory [check!]
		- in.mlir, out.mlir, bitcode file, out_reg2mem.ll, out_optimized.ll, sometimes .obj file [check!]
- We can store hashes of source files in the build dir [check!]
	- Incremental recompilation [check!]
- Use paths rather than filenames for imports [check!]
	- Check that the file exists among the avaiable directories [check!]
	- Identify the file with a particular path [check!]
- Build system [check!]
	- The compile command should take in
		- The directory for the final product [check!]
		- The directory to produce temporary files in [check!]
	- The compiler should also know about all included directories [check!]
		- In environment variables plus ./lib directories [check!]
- If compiling an exe, the obj should go in 'build'; if compiling an obj, into the out-directory [check!]
- 0compile will create and pass in source, build, and output directories to the compiler [check!]
- Package management [check!]
	- Search upwards until you find a manifest [check!]
	- Use a simple accessible file format for the manifest (YAML) [check!]
- Write a 0install xml feed for the compiler itself [check!]
- Translate OS and arch to 0install names [check!]
- Use the ptalk xml feed within 0compile [check!]
- Allow .yml or .yaml for the manifest [check!]
- Put hashes and bitcodes in their own folders within the build dir [check!]
- We should auto-include core instead of builtins, so that setup_landing_pad works correctly [check!]
- 'ptalk upgrade' is cleaner than using the feed uri [check!]
- ptalk --help / ptalk --version [check!]
- Try compiling with /O2 /Ob3 via Nuitka [check!]
- Implement heterogenous-width and integer-float binary operations [check!]
- Get rid of Ptr type and split into Int and Float types [check!]
- Special case "if buffer is Nil" to check for C nullptr [check!]
	- Special case in TypeCheck [check!]
	- Need to ensure intersection of Buffer & Nil doesn't reduce to Nothing [check!]

- Releases 0.1.*
	- Works on any Windows x86_64 machine (other people's computers) [check!]
	- You can download ptalk.exe and run it out-of-the-box [check!]
	- Available commands should be 'ptalk compile [args]' and 'ptalk build' [check!]
	- Avoid Windows marking it as malware [check!]
		- Use --standalone instead of --onefile [check!]
	- Make sure the ptalk-build proxy deletes temporary directories [check!]
	- The GPG key signing needs to be more portable [check!]
		- Using pgpy [check!]
	- The Github API token needs to be portable as well [check!]
		- Just use an environment variable [check!]
		- Add a message saying how to use [check!]
	- Bundle the stdlib in data_files [check!]
		- So that invocations of 'ptalk compile' can use it [check!]
	- Should the user 0install the compiler? [check!]
		- If so, we need an xml feed with implementations for versions [check!]
	- You can import PaulTalk libraries from Github using the manifest.yaml [check!]

- Releases 0.2.*
	- Add more functionality to the ptalk command [check!]
		- Like 'help', 'version', 'update' [check!]
		- Better error messages. [check!]
	- Use argparse [check!]
	- Fix coroutine trampoline [check!]

- Releases 0.3.*
	- Package sublime syntax file [check!]
	- Refactor compiler driver [check!]
	- Do all MLIR lowering in parallel [check!]
	- Fix bump_malloc [check!]
	- Lazily constructed exception messages [check!] [reverted in 0.4.*]

TODO:

- Why are extern defs apparently not imported?
	- Because they aren't added to scope.functions

- Records: why not?
	- Idea: casting between these works seamlessly, unlike tuples
	- Their allocated size is dynamic
	- Blocker: Indexing would need to run specialized code to calculate the offset
- Nested loops take WAY too long to type check
	- It's exponential time complexity
	- Need to cache results of typeflow for each loop
- We do not properly account for break/continue in typeflow
	- We should probably move to a cfg
	- What if I did something ad hoc
	- Store all "exits" from the loop
	- For each exit, store the type and symbol tables
	- After the branch, union all the exits
	- This is a little over-conservative (breaks can't go back to the start of the loop)
	- What about cast-assigning before breaks/continue's?
- I really want type narrowing in alternative branches
	- And 'is not' syntax
	- And narrowing within logical and/or ops
	- And 'while' with a type check condition not polluting the main path
- Snprintf can convert things to string representations
- I should be able to declare variadic extern defs
	- e.g. "extern def printf(Buffer[i8], ...) -> i32"
- Why does it crash at O0?
- GEP inbounds could help optimization on dynamic geps
- I should add real type checking for call/yield

- Release 0.4.0
	- Put .gitignore * in build dir [check!]
	- We don't have to do codegen to discover the dependency graph [check!]
		- We separate typeflow and codegen [check!]
		- Then get the dependency graph from typeflow [check!]
	- Arguably Bool should be its own type, not Integer(1) [check!]
	- In debug mode we should skip optimizing entirely [check!]
	- capture_backtrace and print_backtrace for Windows and POSIX [check!]
	- Mark yielded exceptions as cold and outline in hot-cold split [check!]
	- Correct line numbers for implicit 'include core;' [check!]
	- Constructor ergonomics upgrades [check!]
		- I'd like to be able to type Pair{5, 6} instead of Pair[i32, i32].new(5, 6) [check!]
		- Shorter braces constructor syntax [check!]
		- Basic constructor type parameter deduction [check!]
	- Make sure function names / identifiers don't conflict with type aliases [check!]
	- I could special-case Buffer & Nil to not narrow to Nothing [check!]
	- Probably better to special-case in Branch.narrow [check!]
	- Lower homogenous integer/float tuple to vector [check!]
	- I'd like to be able to say '(0, 0, 0, 0) as Tuple[i64, i64, i64, i64]' [check!]
	- Allow subtyping between integers of different widths [check!]
	- Enable Tuple[4 x i64] syntax [check!]
	- Buffer doesn't need to take an i32; it could take any kind of integer up to i64 really [check!]
		- For creation, indexing [check!]
	- Needs_lowering should account for changed dependencies [check!]
	- Check that tuples are same length in subtype test [check!]
	- Should have a BuildDirectory class [check!]
	- Change range literal from colon to ellipses [check!]
		- There was a parsing conflict with function literals
		- LALR(1) can only look forward one token
		- is (x:y) a range or the start of a function literal?
	- Add exclusive range literal [check!]
	- Concatenate the hashes of dependencies [check!]
	- Enable arithmetic on arbitrary matching tuples [check!]
	- Could do something very clever for treating tuples as iterables [check!]
	- Create an array with the buffer literally being the tuple [check!]
	- Because the array is merely an implementation detail, it can't escape [check!]
	- Have a utility to convert tuple to stack-allocated buffer [check!]
	- Fix ancestors of non-parameterized class with baked-in type parameters [check]
	- Define scope.matches for union types [check!]
	- Move switch-like utils.py functions into type definitions
	- I need to reform "broad param types" [check!]
		- The point is to handle type parameters
		- When type parameters are specialized, they can get smaller
		- We need the ABI of overriding functions to be comptabible with the overridden
		- So we need to track the "broad" signature of specialized overrides
	- Need to alias method-scoped type parameters in overrides [check!]
	- Make bitcodes concurrently [check!]
	- Index setter shouldn't be hardcoded to one index [check!]

- Release 0.4.1
	- Add stdlib to include path [check!]
	- Fix debug mode (use O1 again) [check!]
	- Better error message for type mismatch in range literal [check!]
	- Fixed stacktraces by removing 'nounwind' attribute [check!]

- Release 0.4.2
	- I'd like to be able to do mat[i,j] = val; [check!]

- Release 0.5.*
	- Allow iterating over heterogenous tuples [check!]
		- Convert to Array of union of element types [check!]
	- Hi, mid, lo dialects
		- Split dialect into multiple files [check!]
		- Use lo dialect in patterns.mlir
		- Hi dialect versions will do wrapping and unwrapping
	- Unsigned integers
		- Should probably split out Integer and Float first [check!]
		- Any u[width] can be converted to an i[2*width] or larger [check!]
		- Cannot convert from signed to unsigned except for literals [check!]
		- Literals can be converted to unsigned, conditional on their value [check!]
		- Int-Int binary ops extend the shorter one [check!]
		- Int-Float binary ops convert the int to float [check!]
		- Arithetic with literals should not promote to the larger width [check!]
			- Instead, we should set the literal width to the non-literal width [check!]
		- In LLVM, signedness is a property of operations, not types
		- What ops care about signedness?
			- Division (udiv vs sdiv) [check!]
			- Modulo (urem vs srem) [check!]
			- Shifts treat rhs as unsigned [check!]
			- lshr for unsigned lhs, ashr for signed lhs [check!]
			- sitofp, uitofp, extsi, extui [check!]
			- Comparisons (icmp) [check!]
		- I should want a hi.arithmetic which dispatches based on hi types [check!]
			- Do I want mid.arithmetic as well?
			- If I ever want to change overflow semantics
	- UTF-8 strings
		- Character as codepoint (not grapheme cluster)
		- All strings must be valid UTF-8
		- No indexing operation (not constant time)
	- Does just adding dependencies to the path work?
		- The source_dirs collection should be ordered, not a set [check!]
		- Add the dependency folder to an env variable named for the package
		- Then prepend the name of that env variable to the PTALK_PATH
		- We can report import name conflicts. But can we instead resolve them?
		- Local dependencies should override external ones
		- Only conflicts between external dependencies should cause errors
	- Fully commit to the rename from MiniLang to PaulTalk
		- File name extensions: .mini -> .ptk
		- MLIR dialect: mini. -> mid.
	- 'ptalk build init [name]' could create a minimal manifest.yaml in the cwd

- Stdlib plan
	- ReverseIterator[T] has a .prev() method
	- SkipIterator[T] could have .next(n) and .prev(n) methods
	- Collection[T] extends Iterable[T]
		- def size() -> i32
	- Indexable[I, V, T] extends Collection[T] where I <: Equatable
		- def [](index : I) -> V
		- def iterator() -> SkipIterator[U]
		- Map[K, V] extends Indexable[K, V, V]
	- Sequence[T] extends Iterable[T] where T <: Comparable

- LTO Learnings
	- lld-link much more usable than ld.lld
	- My IR works with aarch64 target triple
	- My IR fails with x86_64 target triple
	- Unnamed_addr means the address is not sementically meaningful
		- Can use for behaviors, offset tables
	- LTO is not worth it!
		- The optimization pipeline is strictly worse
		- It gets imports wrong for indirect calls
		- It only parallelizes at module granularity
	- MLIR is natively multithreaded!
		- Which would be great to leverage
		- Could we store files as .mlir instead of .bc?
			- No, that would take too much time to optimize every time
		- Otherwise, what's even the advantage?
			- For your recompile list, you can put all of them in one big .mlir file
			- Then all the mlir commands can process them all in parallel
	- LTO partitioning is based on !type metadata

- What do I really need for 1.0.0?
	- A way to distribute and adopt code (packages) [check!]
		- Ideally use something existing and portable [check!]
		- I like 0install and think I should adapt it [check!]
		- I'd need to write some wrappers around it [check!]
		- I'd like to be able to use GitHub repos as packages [check!]
		- Security and verification mechanisms
	- Namespacing is even more necessary with packages
	- Determine what kind of file/directory structure is expected [check!]
	- Able to cast builtins to generic bounds
		- Addable / Subtractable / etc.
		- Hashable
		- Representable
		- Equatable, Comparable
	- Region memory management
		- Liveness analysis
			- Two backward passes over AST
		- Allocating from regions
		- Storing region ptrs in fatptrs
			- Probably must require that generic fields be in the same region as 'self'
			- Because they might not be fatptrs in which case they can't carry a region
			- This will leave the third word free for small-struct-optimization thankfully
			- And generic method parameters should have to be bound to something with a region
		- Aliasing rules for first class functions, coroutines, polymorphic constructors
			- Just conservatively alias them all. Spare none of them.
	- Support 3 major platforms (Windows, iOS, Linux)
		- Have specialized utils.ll files for different platforms [check!]
		- And the main utils.ll calls OS-agnostic wrappers [check!]
		- Trampoline object file also needs to have multiple versions
			- Or just generate it during compilation
		- Make sure the compiler filesystem handling is portable
		- Link the C stdlib
		- What is the object file / executable extension?
		- Standalone-opt and debugir usage, ugh
	- You have to get ahead of breaking changes, esp. ABI
		- Function / coroutine base_typ
		- Behavior ABI wrt overloads
			- Need to create an artificial override of methods in behavior with mismatched interface
		- Already planned ahead for delegate passing
		- Are strings Unicode or bytes? (very important for 1.0.0!)
			- Should be Unicode (UTF-8)
	- A less meager stdlib
		- Set, LinkedList
		- JSON?
	- A way to read program arguments (argc, argv)
		- Make it a nice interface
		- argv() -> Indexable[i32, String]
	- Stack traces for exceptions

- Tighten up return type inference for function literals
	- You can't have a bare return and a return value in the same literal
	- Should we disallow all return statements in literals?
	- That's actually smart-- only one implicit return allowed
- Overloading *functions*
	- Reuse the Behavior code as much as possible
	- Only functions in the same file should count as overloads?
- Where clauses for method type parameters
- Should i32 be a subtype of i64?
	- It can be trivially cast to it, so I don't see why not
- Cast literals when passing as arguments
- Implement user-exposed getters
	- Shouldn't be technically difficult
	- Will significantly improve ergonomics
	- Especially now with lifetime annotations
	- May actually technically be more efficient
	- Not needing to cast self twice
- Add multi-line strings
- Split MLIR dialect into hi, mid, and lo dialects
	- hi will use PaulTalk types
	- types will be lowered in hi -> mid
	- lo will only lower to other dialects
- Refactor to use lo.call in PDL
- Add T? syntax for T | Nil
- Improve namespacing
	- Right now import order implicitly resolves conflicts
	- Instead one should have to explicitly disambiguate conflicts
	- Should only have to disambiguate if an ambiguous entity is actually used
	- Dot syntax for namespacing
- Putting coroutine yields and returns in the same slot is asking for bugs
- Add 'of' syntax for array literals
	- [] of String
	- [1, 2, 3] of i32 | f64
- Make aliases even smarter
	- "alias Foo[A] = Bar[A, i32];"
	- This is more complex
- Should ensure that all branches must return if return value declared

- Do less work for imports
	- Type-check specific imports on-demand rather than upfront
	- Decrease work done in interface_codegen
	- std.mini should compile near instantly
- Implement Records
	- Will require a utility method for finding field offsets for generic records
- Dispatch on parameterizations
	- Would need to pass parameterizations into the behavior call
- Make intrinsics better
	- Let me have periods in extern def names
	- Externally declare intrinsics
	- Extern def llvm.sqrt.i64(x : i64) -> i64
- Add asserts
	- There's mlir functionality (cf.assert) for this
	- Compile to llvm.assume in release; branch to abort in debug
- Add assumes for unions of builtins?
	- vptr must be equal to one of a set of possible
- Figure out why I had to split Entry constructor into two and if it can be fixed
- Maybe create offset & hash table separately and just give names to typedef
	- Question is whether they need passed-through information
	- If they do, split them off; otherwise, keep bundled
	- Then only have to pass getter, box, and subtype fn names to typeptrs
- Polymorphic construction could just be conservatively aliased
	- i.e. T.new(a, b, c) or Self.new(a, b, c)
	- Very interesting idea
- I really want to get generics fully working first
	- Would really like for fields to be specialized size [check!]
	- Will make field offsets more complicated [check!]
	- On instance creation, store a mapping from formal offsets to real offsets
	- Or even just store the sizes of the unbaked types
	- 8 bits per size, add to invariant section
- Will need to apply class region constraints upon downcast
	- Do we actually?
	- What about automatic downcast upon multi-dispatch?
- Conservatively alias parameters for first-class functions
- Implement more precise lifetimes for tuples
	- Use .1, .2, .3 pseudo-fields
- Make sure regions and fields don't have conflicting names
- Minimize number of behaviors
	- Do we really need to generate all-new behaviors for every new subclass?
	- Why not just new behaviors for the ones that have actually changed?
- Reduce number of redundant type fields
- Think about how actually to handle union type parameters
- Implement type parameter deduction from init()
- Make sure that type bounds are applied generally
	- What does this mean?
- Figure out signature compatibility of overrides of generic parameters
- Figure out a way to get methods into builtin vtables
	- Define intrinsics for operations on boxed interfaces
	- PrimitiveDef subtype of ClassDef?
- Allow multiple type checks in one condition
- Add tuple destructuring
- Check for mismatched yield types
- Allow capturing class methods
	- Will introduce A.b syntax
	- A.b will also denote module-qualified names
- Shift Functions and Coroutines to FatPtr interface [ABI breaking]
	- Store the fptr in the second word
- Narrow alternate path in branches
	- The main motivation is to be able to pare off nil with "while x is Nil { yield(Exception); }"
	- If the condition of a while is a type check then that type can be pared off after the loop
	- We know that some intersections are uninhabitable (especially with nil)
	- Therefore we know that 'if x is Nil' implies that it is non-nil in the other branch
	- We know the intersection of a union with a negation of one of its members
- Make sure that c3 linearization interacts properly with imports
- When call is statically known, narrow result types
	- Casting is needed (from behavior return type to narrowed return type)
	- If the intersection of the argument/parameter types is uninhabitable, that overload is ruled out
- Skip behavior call when all arguments are builtin types
- Both coroutines and funcs should inherit Callable[-T, +U]
- Actually free coroutine stacks
- Rewrite in PDL!
	- Block / region transformation needs to happen prior
	- Then textual substitution can happen after

# --- Known Bugs ---

- Method.overridden_methods() probably has a subtle bug
	- Which I've hidden for now by mandating that abstract methods not override concrete ones
- I have a feeling that the current handling of tuples is not strictly correct
	- In particular, casting Tuple[i32, i32] | Nil to Tuple[Any, Any] | Nil will be incorrect
	- Generally subtyping between value types of different size is fraught
- Interface codegenning a method may create a signature mismatch with the original due to different behavior signatures
- There's a bug in lowering early returns in else clauses [fixed!]
- Casting to/from Object in unions is not correct [fixed!]
- .all() is clearly not correct [fixed!]
- Declaring a variable without assigning to it is buggy [fixed!]
- Must distinguish union and tuple types in lowering [fixed!]
- Union sizing may not be technically correct for tuples because of padding
- Blocked matmul always fails
- If I compile with -O0 it hangs
	- Seems to be related to loading fatptr as { ptr, i160 }
	- Plausibly related to type legalization in llc
	- I believe it is that i128 and above is supposed to be 16-bit aligned
	- So I should move TypeParameter and union to something like { ptr, [20 x i8] }
	- Or maybe use something janky like {ptr, i64, i64, ... (however many) ..., i[rest] }

# --- Problems ---

- Think about how multiple dispatch works with function types
	- Or more generally, how inheritance order precedence applies to type parameters
	- For Pair[+T, +U], which of Pair[Fish, Crocodile], and Pair[Shark, Reptile] is more specific for Pair[Shark, Crocodile] ?
	- We could go based on textual order, making Pair[Shark, Reptile] more specific
	- This would in principle allow (and incentivize) people to be intentional about the ordering of generic parameters
	- A function needs to store its type parameters
- The central idea is that within a confusable set, there exists a natural ordering of types
- If any two types in a confusable set have incompatible inheritence orders, then there is no order
- Rather than saying two methods are confusable if, for each pair of parameters, there exists a common subtype, we ought to say
	- That two methods are confusable if it not *illegal* for there to be a common subtype for each pair of parameters
- Currently, if an argument is passed which is a subtype of multiple parameter types, the dispatch will be arbitrary
- We will need to be able to perform runtime subtype checks of parameterized types
- This subtype test will be stored in the parameterized type's vtable
- The subtype test will probably take a parameter for the number of type parameters
- GLB with intersection types
	- GLB includes two intersections of each pair (of classes) in the set of types for the parameter
	- These intersections can be split into overlapping subsets representing different consistent hierarchies
	- Intersections not in the same subset are guaranteed to be mutually exclusive possibilities
	- Mutually exclusive possibilities can be checked consecutively with early exit
	- Intersections within a subset agree on the precedence of the types, and can be checked consecutively with early exit
	- Type narrowing implies that there will be variables whose static type is an intersection
- Runtime subtyping tests for unions in overload
	- We may actually want to disallow unions in parameter types
	- This is because a union multiply inherits without specifying its inheritance order
	- Alternatively, we can treat the textual order of the union as semantically relevant
- Delegation
	- We could pass TWO self pointers into all methods [check!]
	- Need to provide a named field for each delegatee
	- Normal initialization rules will apply
	- Need to synthesize forwarding methods which use open recursion
	- Should not inherit init method from delegates
	- Field accesses do not use open recursion because fields cannot be overridden
	- Allow only a single reference-type delegate
		- This would ensure that there is no duplication of fields
		- Still allows for multiple Struct delegates
		- This seems reasonable-- a struct delegate is basically just inheritance with preconstruction
		- Is there any reason to be able to refer to a struct delegate directly?
		- Just seems like a hack to not have to override constructors
		- Also we can't actually not inherit init methods for delegates
	- Alternatively, disallow multiple delegates with conflicting fields
		- There are still issues with methods
		- Could disallow all ambiguity between delegates
- Constructors
	- There's the Self.new() design choice to work with
	- I'd like to be able to define constructor overloads which return subtypes
	- T.alloc could return Uninitialized[T], which has one method, init
	- Uninitialized[T].init() -> T
	- Uninitialized would need to be a builtin type that forwards .init() calls

# --- Possibilities ---

- Assume call return value offsets
- Expect reciever static types

- Generic tuple creation and indexing
	- Would have to use dynamic allocas
	- Hoisting dynamic allocas would require hoisting their inputs
	- Or guaranteeing that their inputs are in the entry block (easier)
	- Need to ensure that these dynamic allocas are inlineable
	- Making them arrays might help to enable inlining
	- Should probably use llvm.stacksave and llvm.stackrestore
	- Would have to pass and return as pointers

- You could inline context switches by breaking functions into sections upon yields and calls
	- Would require significant ingenuity
	- Would significantly improve optimizations across context switches
	- Would need to maintain live variables across yields and calls
	- Probably best to leverage existing facilities for tracking live variables
	- Idea: use MLIR OpenMP outlining pass to outline coroutine continuations and pass live variables
	- Then just textually replace call @____kmpc_fork_call(ptr @outlined, args) with call @outlined(args)
- Lower loops without break/continue to scf.for or omp.loop constructs
	- Would interfere with mlir-opt mem2reg (but not sroa?)
- Freelist of coroutine stacks?
	- Ring buffer LIFO stack
	- Fixed capacity
	- Much faster than VirtualAlloc
- Memory regions
	- Abstract memory regions
		- Abstract associated regions
			- Abstract bounded polymorphic associated regions
	- Will probably need to store ptrs to virtual regions in fields
		- Wait, why? Do we actually?
		- Or store a method in the vtable that can retrieve the virtual region
	- Unclear if boxed types will need to carry regions

- Manual memory management combines four questions
	- When memory gets allocated and deallocated
	- Where objects are stored in memory
		- Which objects are near each other
	- How objects are stored in memory
		- How they are laid out
	- Semiautomatic memory management removes some of these choices from the programmer
		- You decide how objects are laid out, and can impose some constraints on where
		- The compiler decides when memory is allocated and deallocated

- Inheriting from Sentinel (or do Struct types solve this)
- Bare 'yield();' should yield the coroutine itself? or nil?
- Specifying that a class cannot be inherited alongside another class
- Recursive aliases?
- Propagate type information backwards?
	- Probably just in certain easy circumstances
- Enable copying of coroutines
	- Would have to copy the whole stack
	- Would also have to know the actual stack size
	- Which, if we stored the top of the stack in the coroutine, would be easy

# --- later on ---

- FFI
- Struct Types
	- How much would struct types actually entail?
	- virtual calls resolve to static calls
	- allocated on stack
	- value semantics
	- subtype test is vptr equality
	- this seems fairly straightforward?
	- Except that value semantics for self is immensely complicated
	- How to pass self to virtual calls requires change
	- Basically requires generating a struct version of the class
	- Unclear how methods will even work
		- When self is passed as variable, it is copied
		- When self is passed as receiver, it is by ref
		- Would have to box self whenever passed as variable
	- Must be boxed to be used in place of ref version?
- Regions
- Generics
	- Store type T as implicit member, use to construct instances of T
	- No monomorphization
	- Implicit conversion to type constraint (by default Any)
	- Small buffer optimization for small struct types
	- Variadic generics
	- Roadmap
		- start with simplistic runtime subtype checks
		- migrate builtin generic types to uniform interface
		- start with invariance for subtyping
		- start by implementing the magic buffer methods for existing types
		- what's important is that these methods are available in the vtable
		- Maybe I should start by making everything a subtype of Object
- Multithreading
	- Can't use RAII for scoped mutexes
	- But manually locked and unlocked mutexes are fine

class Uninitialized[T] {
	@allocated : T
	def init() -> T {
		@allocated.init();
	}
}

class Object {
	def Self.from_data_buffer(buf : Buffer[i8], start_index : i32) -> Self {
		return magic_from_data_buffer(buf, start_index, Self.size_in_bytes());
	}
	def Self.size_in_bytes() -> i32 {
		return magic_size_in_bytes(self);
	}
	def place_in_buffer(buffer : Buffer[i8], start_index : i32) {
		magic_place_into_buffer(self, buffer, start_index);
	}
}

class Array[T] {

	@buffer : Buffer[T]
	@size : i32
	@capacity : i32

	@T : Type	// implicit type member

	def init[T] (@buffer : Buffer[T], @size : i32, @capacity : i32) {
		// @T implicitly initialized with [T]
	}
	def [](i : i32) -> T {
		return T.from_data_buffer(@buffer, T.size_in_bytes() * i);
	}
}

consider a signature that takes a function of type f : Function[i32, Animal]
since functions are covariant in return type and contravariant in argument type, a function of type Function[i32, Shark] should be able to be passed in
can the offset be appropriately set?
it may actually be more correct when the type parameter is passed in by the call and not at instantiation
or at least the type parameter has to be updated upon upcast
in which case is there even any difference?
	- cost of upcast
	- storage cost of extra member
	- indirection cost of obtaining type member
	- there's more to this...

the offset cannot be known statically unless it is carried as a member
