; ModuleID = 'LLVMDialectModule'
source_filename = "LLVMDialectModule"

@i32_string = linkonce_odr constant [4 x i8] c"%d\0A\00"
@i64_string = linkonce_odr constant [6 x i8] c"%lld\0A\00"
@float_string = linkonce_odr constant [4 x i8] c"%f\0A\00"
@string_string = linkonce_odr constant [4 x i8] c"%s\0A\00"
@bool_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @bool_typ, ptr @any_typ]
@bool_typ_offset_tbl = constant [4 x i32] [i32 10, i32 0, i32 10, i32 10]
@bool_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 5801531371504802705, i64 -6890414739692804531, i64 3], [7 x ptr] [ptr @subtype_test, ptr @bool_typ_hashtbl, ptr @bool_typ_offset_tbl, ptr @_data_size_bool_typ, ptr @_box_bool_typ, ptr @_unbox_bool_typ, ptr @_data_size_bool_typ], [0 x ptr] undef }
@i1_typ_hashtbl = constant [4 x ptr] [ptr @i1_typ, ptr @Object, ptr null, ptr @any_typ]
@i1_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@i1_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 5644681103848239369, i64 7806250045001483857, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i1_typ_hashtbl, ptr @i1_typ_offset_tbl, ptr @_data_size_i1_typ, ptr @_box_i1_typ, ptr @_unbox_i1_typ, ptr @_data_size_i1_typ], [0 x ptr] undef }
@i8_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @i8_typ, ptr null]
@i8_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@i8_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 2582149688529881115, i64 2432902523919705845, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i8_typ_hashtbl, ptr @i8_typ_offset_tbl, ptr @_data_size_i8_typ, ptr @_box_i8_typ, ptr @_unbox_i8_typ, ptr @_data_size_i8_typ], [0 x ptr] undef }
@i32_typ_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr null, ptr @Object, ptr @i32_typ]
@i32_typ_offset_tbl = constant [4 x i32] [i32 10, i32 0, i32 10, i32 10]
@i32_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -2253724949814257982, i64 -1479625198054376817, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i32_typ_hashtbl, ptr @i32_typ_offset_tbl, ptr @_data_size_i32_typ, ptr @_box_i32_typ, ptr @_unbox_i32_typ, ptr @_data_size_i32_typ], [0 x ptr] undef }
@i64_typ_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @Object, ptr @i64_typ, ptr null]
@i64_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@i64_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -7469797244461771922, i64 -2245073852995719311, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i64_typ_hashtbl, ptr @i64_typ_offset_tbl, ptr @_data_size_i64_typ, ptr @_box_i64_typ, ptr @_unbox_i64_typ, ptr @_data_size_i64_typ], [0 x ptr] undef }
@i128_typ_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @Object, ptr @i128_typ, ptr null]
@i128_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@i128_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -8755878215469463641, i64 7626179702395018193, i64 3], [7 x ptr] [ptr @subtype_test, ptr @i128_typ_hashtbl, ptr @i128_typ_offset_tbl, ptr @_data_size_i128_typ, ptr @_box_i128_typ, ptr @_unbox_i128_typ, ptr @_data_size_i128_typ], [0 x ptr] undef }
@f64_typ_hashtbl = constant [4 x ptr] [ptr null, ptr @f64_typ, ptr @any_typ, ptr @Object]
@f64_typ_offset_tbl = constant [4 x i32] [i32 0, i32 10, i32 10, i32 10]
@f64_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -757315540097298781, i64 -6073611639076035451, i64 3], [7 x ptr] [ptr @subtype_test, ptr @f64_typ_hashtbl, ptr @f64_typ_offset_tbl, ptr @_data_size_f64_typ, ptr @_box_f64_typ, ptr @_unbox_f64_typ, ptr @_data_size_f64_typ], [0 x ptr] undef }
@nil_typ_hashtbl = constant [2 x ptr] [ptr @nil_typ, ptr @any_typ]
@nil_typ_offset_tbl = constant [2 x i32] [i32 10, i32 10]
@nil_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -5126806859456325683, i64 2980030334565781337, i64 1], [7 x ptr] [ptr @subtype_test, ptr @nil_typ_hashtbl, ptr @nil_typ_offset_tbl, ptr @_data_size_nil_typ, ptr @_box_nil_typ, ptr @_unbox_nil_typ, ptr @_data_size_nil_typ], [0 x ptr] undef }
@any_typ_hashtbl = constant [1 x ptr] [ptr @any_typ]
@any_typ_offset_tbl = constant [1 x i32] [i32 10]
@any_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3084208142191802847, i64 4982413686040955927, i64 0], [7 x ptr] [ptr @subtype_test, ptr @any_typ_hashtbl, ptr @any_typ_offset_tbl, ptr @_data_size_any_typ, ptr @_box_Default, ptr @_unbox_Default, ptr @_data_size_any_typ], [0 x ptr] undef }
@nothing_typ_hashtbl = constant [4 x ptr] [ptr null, ptr @Object, ptr @nothing_typ, ptr @any_typ]
@nothing_typ_offset_tbl = constant [4 x i32] [i32 0, i32 10, i32 10, i32 10]
@nothing_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -3334456163433371378, i64 -1294679179994773215, i64 3], [7 x ptr] [ptr @subtype_test, ptr @nothing_typ_hashtbl, ptr @nothing_typ_offset_tbl, ptr @_data_size_nothing_typ, ptr @_box_nothing_typ, ptr @_unbox_nothing_typ, ptr @_data_size_nothing_typ], [0 x ptr] undef }
@coroutine_typ_hashtbl = constant [4 x ptr] [ptr null, ptr @Object, ptr @any_typ, ptr @coroutine_typ]
@coroutine_typ_offset_tbl = constant [4 x i32] [i32 0, i32 10, i32 10, i32 10]
@coroutine_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 7194361020959218064, i64 -666217722223510241, i64 3], [7 x ptr] [ptr @subtype_test, ptr @coroutine_typ_hashtbl, ptr @coroutine_typ_offset_tbl, ptr @_data_size_coroutine_typ, ptr @_box_coroutine_typ, ptr @_unbox_coroutine_typ, ptr @_data_size_coroutine_typ], [0 x ptr] undef }
@function_typ_hashtbl = constant [4 x ptr] [ptr @function_typ, ptr null, ptr @any_typ, ptr @Object]
@function_typ_offset_tbl = constant [4 x i32] [i32 10, i32 0, i32 10, i32 10]
@function_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 7927147055246173914, i64 -8206090698155028145, i64 3], [7 x ptr] [ptr @subtype_test, ptr @function_typ_hashtbl, ptr @function_typ_offset_tbl, ptr @_data_size_function_typ, ptr @_box_function_typ, ptr @_unbox_function_typ, ptr @_data_size_function_typ], [0 x ptr] undef }
@buffer_typ_hashtbl = constant [4 x ptr] [ptr @buffer_typ, ptr @Object, ptr @any_typ, ptr null]
@buffer_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 10, i32 0]
@buffer_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -318192747195410237, i64 -4014318827516495109, i64 3], [7 x ptr] [ptr @subtype_test, ptr @buffer_typ_hashtbl, ptr @buffer_typ_offset_tbl, ptr @_data_size_buffer_typ, ptr @_box_buffer_typ, ptr @_unbox_buffer_typ, ptr @_data_size_buffer_typ], [0 x ptr] undef }
@tuple_typ_hashtbl = constant [4 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr @tuple_typ]
@tuple_typ_offset_tbl = constant [4 x i32] [i32 10, i32 0, i32 10, i32 10]
@tuple_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3422634369532007740, i64 -9011363593858450915, i64 3], [7 x ptr] [ptr @subtype_test, ptr @tuple_typ_hashtbl, ptr @tuple_typ_offset_tbl, ptr @_data_size_tuple_typ, ptr @_box_tuple_typ, ptr @_unbox_tuple_typ, ptr @_data_size_tuple_typ], [0 x ptr] undef }
@union_typ_hashtbl = constant [4 x ptr] [ptr @union_typ, ptr @Object, ptr null, ptr @any_typ]
@union_typ_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 0, i32 10]
@union_typ = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -7543233778997666740, i64 2838083000064402307, i64 3], [7 x ptr] [ptr @subtype_test, ptr @union_typ_hashtbl, ptr @union_typ_offset_tbl, ptr @_data_size_union_typ, ptr @_box_union_typ, ptr @_unbox_union_typ, ptr @_data_size_union_typ], [0 x ptr] undef }
@Object_hashtbl = constant [2 x ptr] [ptr @any_typ, ptr @Object]
@Object_offset_tbl = constant [2 x i32] [i32 10, i32 10]
@Object = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3282773614056351330, i64 -5487398976753710109, i64 1], [7 x ptr] [ptr @subtype_test, ptr @Object_hashtbl, ptr @Object_offset_tbl, ptr @_data_size_Object, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }

declare i32 @printf(ptr, ...)

declare ptr @bump_malloc(i64)

declare void @free(ptr)

declare void @setup_landing_pad()

declare void @anoint_trampoline(ptr)

declare ptr @adjust_trampoline(ptr)

declare ptr @coroutine_create(ptr, ptr)

declare void @arg_passer(ptr)

declare void @arg_buffer_filler(ptr)

declare void @coroutine_yield(ptr)

declare void @coroutine_yield_cold(ptr)

declare ptr @get_current_coroutine()

declare i32 @get_offset(ptr, ptr)

declare void @assume_offset(ptr, ptr)

declare { ptr, i160 } @_box_Default(ptr, ptr)

declare void @_unbox_Default({ ptr, i160 }, ptr, ptr)

declare { i64, i64 } @_size_Default(ptr)

declare void @_unbox_union_typ({ ptr, i160 }, ptr, ptr)

declare { i64, i64 } @_data_size_tuple_typ(ptr)

declare { i64, i64 } @_data_size_union_typ(ptr)

declare i1 @subtype_test(i64, i64, i64, i64, ptr)

declare i1 @subtype_test_wrapper(ptr, i64, i64, i64, i64, ptr)

declare { i64, i64 } @size_wrapper(ptr, ptr)

declare ptr @typegetter_wrapper(ptr, ptr)

declare { ptr, i160 } @box_wrapper(ptr, ptr, ptr)

declare void @unbox_wrapper(ptr, { ptr, i160 }, ptr, ptr)

declare ptr @behavior_wrapper(ptr, { ptr, ptr, ptr, i32 }, ptr)

declare ptr @class_behavior_wrapper(ptr, ptr)

declare void @coroutine_call(ptr)

define { i64, i64 } @_data_size_Object(ptr %0) {
  ret { i64, i64 } { i64 0, i64 1 }
}

define { i64, i64 } @_data_size_bool_typ(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, i1 }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, i1 }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = urem i64 ptrtoint (ptr getelementptr (i1, ptr null, i32 1) to i64), %3
  %5 = icmp eq i64 %4, 0
  %6 = sub i64 %3, %4
  %7 = select i1 %5, i64 0, i64 %6
  %8 = add i64 ptrtoint (ptr getelementptr (i1, ptr null, i32 1) to i64), %7
  %9 = insertvalue { i64, i64 } undef, i64 %8, 0
  %10 = insertvalue { i64, i64 } %9, i64 %3, 1
  ret { i64, i64 } %10
}

define { ptr, i160 } @_box_bool_typ(ptr %0, ptr %1) {
  %3 = alloca { ptr, i160 }, align 8
  %4 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 1
  store ptr @bool_typ, ptr %3, align 8
  %5 = call { i64, i64 } @size_wrapper(ptr @_data_size_bool_typ, ptr %1)
  %6 = extractvalue { i64, i64 } %5, 0
  %7 = icmp sle i64 %6, 16
  br i1 %7, label %10, label %8

8:                                                ; preds = %2
  %9 = call ptr @bump_malloc(i64 %6)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %9, ptr %0, i64 %6, i1 false)
  store ptr %9, ptr %4, align 8
  br label %11

10:                                               ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %0, i64 %6, i1 false)
  br label %11

11:                                               ; preds = %10, %8
  %12 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = insertvalue { ptr, i160 } undef, ptr %13, 0
  %15 = load i160, ptr %4, align 4
  %16 = insertvalue { ptr, i160 } %14, i160 %15, 1
  ret { ptr, i160 } %16
}

define void @_unbox_bool_typ({ ptr, i160 } %0, ptr %1, ptr %2) {
  %4 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %0, ptr %4, align 8
  %5 = getelementptr { ptr, i160 }, ptr %4, i32 0, i32 1
  %6 = load ptr, ptr %5, align 8
  %7 = call { i64, i64 } @size_wrapper(ptr @_data_size_bool_typ, ptr %1)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = icmp sle i64 %8, 16
  %10 = select i1 %9, ptr %5, ptr %6
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %10, i64 %8, i1 false)
  ret void
}

define { i64, i64 } @_data_size_i1_typ(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, i1 }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, i1 }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = urem i64 ptrtoint (ptr getelementptr (i1, ptr null, i32 1) to i64), %3
  %5 = icmp eq i64 %4, 0
  %6 = sub i64 %3, %4
  %7 = select i1 %5, i64 0, i64 %6
  %8 = add i64 ptrtoint (ptr getelementptr (i1, ptr null, i32 1) to i64), %7
  %9 = insertvalue { i64, i64 } undef, i64 %8, 0
  %10 = insertvalue { i64, i64 } %9, i64 %3, 1
  ret { i64, i64 } %10
}

define { ptr, i160 } @_box_i1_typ(ptr %0, ptr %1) {
  %3 = alloca { ptr, i160 }, align 8
  %4 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 1
  store ptr @i1_typ, ptr %3, align 8
  %5 = call { i64, i64 } @size_wrapper(ptr @_data_size_i1_typ, ptr %1)
  %6 = extractvalue { i64, i64 } %5, 0
  %7 = icmp sle i64 %6, 16
  br i1 %7, label %10, label %8

8:                                                ; preds = %2
  %9 = call ptr @bump_malloc(i64 %6)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %9, ptr %0, i64 %6, i1 false)
  store ptr %9, ptr %4, align 8
  br label %11

10:                                               ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %0, i64 %6, i1 false)
  br label %11

11:                                               ; preds = %10, %8
  %12 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = insertvalue { ptr, i160 } undef, ptr %13, 0
  %15 = load i160, ptr %4, align 4
  %16 = insertvalue { ptr, i160 } %14, i160 %15, 1
  ret { ptr, i160 } %16
}

define void @_unbox_i1_typ({ ptr, i160 } %0, ptr %1, ptr %2) {
  %4 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %0, ptr %4, align 8
  %5 = getelementptr { ptr, i160 }, ptr %4, i32 0, i32 1
  %6 = load ptr, ptr %5, align 8
  %7 = call { i64, i64 } @size_wrapper(ptr @_data_size_i1_typ, ptr %1)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = icmp sle i64 %8, 16
  %10 = select i1 %9, ptr %5, ptr %6
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %10, i64 %8, i1 false)
  ret void
}

define { i64, i64 } @_data_size_i8_typ(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, i8 }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, i8 }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = urem i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %3
  %5 = icmp eq i64 %4, 0
  %6 = sub i64 %3, %4
  %7 = select i1 %5, i64 0, i64 %6
  %8 = add i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %7
  %9 = insertvalue { i64, i64 } undef, i64 %8, 0
  %10 = insertvalue { i64, i64 } %9, i64 %3, 1
  ret { i64, i64 } %10
}

define { ptr, i160 } @_box_i8_typ(ptr %0, ptr %1) {
  %3 = alloca { ptr, i160 }, align 8
  %4 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 1
  store ptr @i8_typ, ptr %3, align 8
  %5 = call { i64, i64 } @size_wrapper(ptr @_data_size_i8_typ, ptr %1)
  %6 = extractvalue { i64, i64 } %5, 0
  %7 = icmp sle i64 %6, 16
  br i1 %7, label %10, label %8

8:                                                ; preds = %2
  %9 = call ptr @bump_malloc(i64 %6)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %9, ptr %0, i64 %6, i1 false)
  store ptr %9, ptr %4, align 8
  br label %11

10:                                               ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %0, i64 %6, i1 false)
  br label %11

11:                                               ; preds = %10, %8
  %12 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = insertvalue { ptr, i160 } undef, ptr %13, 0
  %15 = load i160, ptr %4, align 4
  %16 = insertvalue { ptr, i160 } %14, i160 %15, 1
  ret { ptr, i160 } %16
}

define void @_unbox_i8_typ({ ptr, i160 } %0, ptr %1, ptr %2) {
  %4 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %0, ptr %4, align 8
  %5 = getelementptr { ptr, i160 }, ptr %4, i32 0, i32 1
  %6 = load ptr, ptr %5, align 8
  %7 = call { i64, i64 } @size_wrapper(ptr @_data_size_i8_typ, ptr %1)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = icmp sle i64 %8, 16
  %10 = select i1 %9, ptr %5, ptr %6
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %10, i64 %8, i1 false)
  ret void
}

define { i64, i64 } @_data_size_i32_typ(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %3
  %5 = icmp eq i64 %4, 0
  %6 = sub i64 %3, %4
  %7 = select i1 %5, i64 0, i64 %6
  %8 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %7
  %9 = insertvalue { i64, i64 } undef, i64 %8, 0
  %10 = insertvalue { i64, i64 } %9, i64 %3, 1
  ret { i64, i64 } %10
}

define { ptr, i160 } @_box_i32_typ(ptr %0, ptr %1) {
  %3 = alloca { ptr, i160 }, align 8
  %4 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 1
  store ptr @i32_typ, ptr %3, align 8
  %5 = call { i64, i64 } @size_wrapper(ptr @_data_size_i32_typ, ptr %1)
  %6 = extractvalue { i64, i64 } %5, 0
  %7 = icmp sle i64 %6, 16
  br i1 %7, label %10, label %8

8:                                                ; preds = %2
  %9 = call ptr @bump_malloc(i64 %6)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %9, ptr %0, i64 %6, i1 false)
  store ptr %9, ptr %4, align 8
  br label %11

10:                                               ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %0, i64 %6, i1 false)
  br label %11

11:                                               ; preds = %10, %8
  %12 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = insertvalue { ptr, i160 } undef, ptr %13, 0
  %15 = load i160, ptr %4, align 4
  %16 = insertvalue { ptr, i160 } %14, i160 %15, 1
  ret { ptr, i160 } %16
}

define void @_unbox_i32_typ({ ptr, i160 } %0, ptr %1, ptr %2) {
  %4 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %0, ptr %4, align 8
  %5 = getelementptr { ptr, i160 }, ptr %4, i32 0, i32 1
  %6 = load ptr, ptr %5, align 8
  %7 = call { i64, i64 } @size_wrapper(ptr @_data_size_i32_typ, ptr %1)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = icmp sle i64 %8, 16
  %10 = select i1 %9, ptr %5, ptr %6
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %10, i64 %8, i1 false)
  ret void
}

define { i64, i64 } @_data_size_i64_typ(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, i64 }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, i64 }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = urem i64 ptrtoint (ptr getelementptr (i64, ptr null, i32 1) to i64), %3
  %5 = icmp eq i64 %4, 0
  %6 = sub i64 %3, %4
  %7 = select i1 %5, i64 0, i64 %6
  %8 = add i64 ptrtoint (ptr getelementptr (i64, ptr null, i32 1) to i64), %7
  %9 = insertvalue { i64, i64 } undef, i64 %8, 0
  %10 = insertvalue { i64, i64 } %9, i64 %3, 1
  ret { i64, i64 } %10
}

define { ptr, i160 } @_box_i64_typ(ptr %0, ptr %1) {
  %3 = alloca { ptr, i160 }, align 8
  %4 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 1
  store ptr @i64_typ, ptr %3, align 8
  %5 = call { i64, i64 } @size_wrapper(ptr @_data_size_i64_typ, ptr %1)
  %6 = extractvalue { i64, i64 } %5, 0
  %7 = icmp sle i64 %6, 16
  br i1 %7, label %10, label %8

8:                                                ; preds = %2
  %9 = call ptr @bump_malloc(i64 %6)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %9, ptr %0, i64 %6, i1 false)
  store ptr %9, ptr %4, align 8
  br label %11

10:                                               ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %0, i64 %6, i1 false)
  br label %11

11:                                               ; preds = %10, %8
  %12 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = insertvalue { ptr, i160 } undef, ptr %13, 0
  %15 = load i160, ptr %4, align 4
  %16 = insertvalue { ptr, i160 } %14, i160 %15, 1
  ret { ptr, i160 } %16
}

define void @_unbox_i64_typ({ ptr, i160 } %0, ptr %1, ptr %2) {
  %4 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %0, ptr %4, align 8
  %5 = getelementptr { ptr, i160 }, ptr %4, i32 0, i32 1
  %6 = load ptr, ptr %5, align 8
  %7 = call { i64, i64 } @size_wrapper(ptr @_data_size_i64_typ, ptr %1)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = icmp sle i64 %8, 16
  %10 = select i1 %9, ptr %5, ptr %6
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %10, i64 %8, i1 false)
  ret void
}

define { i64, i64 } @_data_size_i128_typ(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, i128 }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, i128 }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = urem i64 ptrtoint (ptr getelementptr (i128, ptr null, i32 1) to i64), %3
  %5 = icmp eq i64 %4, 0
  %6 = sub i64 %3, %4
  %7 = select i1 %5, i64 0, i64 %6
  %8 = add i64 ptrtoint (ptr getelementptr (i128, ptr null, i32 1) to i64), %7
  %9 = insertvalue { i64, i64 } undef, i64 %8, 0
  %10 = insertvalue { i64, i64 } %9, i64 %3, 1
  ret { i64, i64 } %10
}

define { ptr, i160 } @_box_i128_typ(ptr %0, ptr %1) {
  %3 = alloca { ptr, i160 }, align 8
  %4 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 1
  store ptr @i128_typ, ptr %3, align 8
  %5 = call { i64, i64 } @size_wrapper(ptr @_data_size_i128_typ, ptr %1)
  %6 = extractvalue { i64, i64 } %5, 0
  %7 = icmp sle i64 %6, 16
  br i1 %7, label %10, label %8

8:                                                ; preds = %2
  %9 = call ptr @bump_malloc(i64 %6)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %9, ptr %0, i64 %6, i1 false)
  store ptr %9, ptr %4, align 8
  br label %11

10:                                               ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %0, i64 %6, i1 false)
  br label %11

11:                                               ; preds = %10, %8
  %12 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = insertvalue { ptr, i160 } undef, ptr %13, 0
  %15 = load i160, ptr %4, align 4
  %16 = insertvalue { ptr, i160 } %14, i160 %15, 1
  ret { ptr, i160 } %16
}

define void @_unbox_i128_typ({ ptr, i160 } %0, ptr %1, ptr %2) {
  %4 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %0, ptr %4, align 8
  %5 = getelementptr { ptr, i160 }, ptr %4, i32 0, i32 1
  %6 = load ptr, ptr %5, align 8
  %7 = call { i64, i64 } @size_wrapper(ptr @_data_size_i128_typ, ptr %1)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = icmp sle i64 %8, 16
  %10 = select i1 %9, ptr %5, ptr %6
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %10, i64 %8, i1 false)
  ret void
}

define { i64, i64 } @_data_size_f64_typ(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, double }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, double }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = urem i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), %3
  %5 = icmp eq i64 %4, 0
  %6 = sub i64 %3, %4
  %7 = select i1 %5, i64 0, i64 %6
  %8 = add i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), %7
  %9 = insertvalue { i64, i64 } undef, i64 %8, 0
  %10 = insertvalue { i64, i64 } %9, i64 %3, 1
  ret { i64, i64 } %10
}

define { ptr, i160 } @_box_f64_typ(ptr %0, ptr %1) {
  %3 = alloca { ptr, i160 }, align 8
  %4 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 1
  store ptr @f64_typ, ptr %3, align 8
  %5 = call { i64, i64 } @size_wrapper(ptr @_data_size_f64_typ, ptr %1)
  %6 = extractvalue { i64, i64 } %5, 0
  %7 = icmp sle i64 %6, 16
  br i1 %7, label %10, label %8

8:                                                ; preds = %2
  %9 = call ptr @bump_malloc(i64 %6)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %9, ptr %0, i64 %6, i1 false)
  store ptr %9, ptr %4, align 8
  br label %11

10:                                               ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %0, i64 %6, i1 false)
  br label %11

11:                                               ; preds = %10, %8
  %12 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = insertvalue { ptr, i160 } undef, ptr %13, 0
  %15 = load i160, ptr %4, align 4
  %16 = insertvalue { ptr, i160 } %14, i160 %15, 1
  ret { ptr, i160 } %16
}

define void @_unbox_f64_typ({ ptr, i160 } %0, ptr %1, ptr %2) {
  %4 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %0, ptr %4, align 8
  %5 = getelementptr { ptr, i160 }, ptr %4, i32 0, i32 1
  %6 = load ptr, ptr %5, align 8
  %7 = call { i64, i64 } @size_wrapper(ptr @_data_size_f64_typ, ptr %1)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = icmp sle i64 %8, 16
  %10 = select i1 %9, ptr %5, ptr %6
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %10, i64 %8, i1 false)
  ret void
}

define { i64, i64 } @_data_size_nil_typ(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, [0 x i8] }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, [0 x i8] }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = urem i64 ptrtoint (ptr getelementptr ([0 x i8], ptr null, i32 1) to i64), %3
  %5 = icmp eq i64 %4, 0
  %6 = sub i64 %3, %4
  %7 = select i1 %5, i64 0, i64 %6
  %8 = add i64 ptrtoint (ptr getelementptr ([0 x i8], ptr null, i32 1) to i64), %7
  %9 = insertvalue { i64, i64 } undef, i64 %8, 0
  %10 = insertvalue { i64, i64 } %9, i64 %3, 1
  ret { i64, i64 } %10
}

define { ptr, i160 } @_box_nil_typ(ptr %0, ptr %1) {
  %3 = alloca { ptr, i160 }, align 8
  %4 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 1
  store ptr @nil_typ, ptr %3, align 8
  %5 = call { i64, i64 } @size_wrapper(ptr @_data_size_nil_typ, ptr %1)
  %6 = extractvalue { i64, i64 } %5, 0
  %7 = icmp sle i64 %6, 16
  br i1 %7, label %10, label %8

8:                                                ; preds = %2
  %9 = call ptr @bump_malloc(i64 %6)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %9, ptr %0, i64 %6, i1 false)
  store ptr %9, ptr %4, align 8
  br label %11

10:                                               ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %0, i64 %6, i1 false)
  br label %11

11:                                               ; preds = %10, %8
  %12 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = insertvalue { ptr, i160 } undef, ptr %13, 0
  %15 = load i160, ptr %4, align 4
  %16 = insertvalue { ptr, i160 } %14, i160 %15, 1
  ret { ptr, i160 } %16
}

define void @_unbox_nil_typ({ ptr, i160 } %0, ptr %1, ptr %2) {
  %4 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %0, ptr %4, align 8
  %5 = getelementptr { ptr, i160 }, ptr %4, i32 0, i32 1
  %6 = load ptr, ptr %5, align 8
  %7 = call { i64, i64 } @size_wrapper(ptr @_data_size_nil_typ, ptr %1)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = icmp sle i64 %8, 16
  %10 = select i1 %9, ptr %5, ptr %6
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %10, i64 %8, i1 false)
  ret void
}

define { i64, i64 } @_data_size_any_typ(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = urem i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %3
  %5 = icmp eq i64 %4, 0
  %6 = sub i64 %3, %4
  %7 = select i1 %5, i64 0, i64 %6
  %8 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %7
  %9 = insertvalue { i64, i64 } undef, i64 %8, 0
  %10 = insertvalue { i64, i64 } %9, i64 %3, 1
  ret { i64, i64 } %10
}

define { i64, i64 } @_data_size_nothing_typ(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, [0 x i8] }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, [0 x i8] }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = urem i64 ptrtoint (ptr getelementptr ([0 x i8], ptr null, i32 1) to i64), %3
  %5 = icmp eq i64 %4, 0
  %6 = sub i64 %3, %4
  %7 = select i1 %5, i64 0, i64 %6
  %8 = add i64 ptrtoint (ptr getelementptr ([0 x i8], ptr null, i32 1) to i64), %7
  %9 = insertvalue { i64, i64 } undef, i64 %8, 0
  %10 = insertvalue { i64, i64 } %9, i64 %3, 1
  ret { i64, i64 } %10
}

define { ptr, i160 } @_box_nothing_typ(ptr %0, ptr %1) {
  %3 = alloca { ptr, i160 }, align 8
  %4 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 1
  store ptr @nothing_typ, ptr %3, align 8
  %5 = call { i64, i64 } @size_wrapper(ptr @_data_size_nothing_typ, ptr %1)
  %6 = extractvalue { i64, i64 } %5, 0
  %7 = icmp sle i64 %6, 16
  br i1 %7, label %10, label %8

8:                                                ; preds = %2
  %9 = call ptr @bump_malloc(i64 %6)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %9, ptr %0, i64 %6, i1 false)
  store ptr %9, ptr %4, align 8
  br label %11

10:                                               ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %0, i64 %6, i1 false)
  br label %11

11:                                               ; preds = %10, %8
  %12 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = insertvalue { ptr, i160 } undef, ptr %13, 0
  %15 = load i160, ptr %4, align 4
  %16 = insertvalue { ptr, i160 } %14, i160 %15, 1
  ret { ptr, i160 } %16
}

define void @_unbox_nothing_typ({ ptr, i160 } %0, ptr %1, ptr %2) {
  %4 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %0, ptr %4, align 8
  %5 = getelementptr { ptr, i160 }, ptr %4, i32 0, i32 1
  %6 = load ptr, ptr %5, align 8
  %7 = call { i64, i64 } @size_wrapper(ptr @_data_size_nothing_typ, ptr %1)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = icmp sle i64 %8, 16
  %10 = select i1 %9, ptr %5, ptr %6
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %10, i64 %8, i1 false)
  ret void
}

define { i64, i64 } @_data_size_coroutine_typ(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = urem i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), %3
  %5 = icmp eq i64 %4, 0
  %6 = sub i64 %3, %4
  %7 = select i1 %5, i64 0, i64 %6
  %8 = add i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), %7
  %9 = insertvalue { i64, i64 } undef, i64 %8, 0
  %10 = insertvalue { i64, i64 } %9, i64 %3, 1
  ret { i64, i64 } %10
}

define { ptr, i160 } @_box_coroutine_typ(ptr %0, ptr %1) {
  %3 = alloca { ptr, i160 }, align 8
  %4 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 1
  store ptr @coroutine_typ, ptr %3, align 8
  %5 = call { i64, i64 } @size_wrapper(ptr @_data_size_coroutine_typ, ptr %1)
  %6 = extractvalue { i64, i64 } %5, 0
  %7 = icmp sle i64 %6, 16
  br i1 %7, label %10, label %8

8:                                                ; preds = %2
  %9 = call ptr @bump_malloc(i64 %6)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %9, ptr %0, i64 %6, i1 false)
  store ptr %9, ptr %4, align 8
  br label %11

10:                                               ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %0, i64 %6, i1 false)
  br label %11

11:                                               ; preds = %10, %8
  %12 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = insertvalue { ptr, i160 } undef, ptr %13, 0
  %15 = load i160, ptr %4, align 4
  %16 = insertvalue { ptr, i160 } %14, i160 %15, 1
  ret { ptr, i160 } %16
}

define void @_unbox_coroutine_typ({ ptr, i160 } %0, ptr %1, ptr %2) {
  %4 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %0, ptr %4, align 8
  %5 = getelementptr { ptr, i160 }, ptr %4, i32 0, i32 1
  %6 = load ptr, ptr %5, align 8
  %7 = call { i64, i64 } @size_wrapper(ptr @_data_size_coroutine_typ, ptr %1)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = icmp sle i64 %8, 16
  %10 = select i1 %9, ptr %5, ptr %6
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %10, i64 %8, i1 false)
  ret void
}

define { i64, i64 } @_data_size_function_typ(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = urem i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), %3
  %5 = icmp eq i64 %4, 0
  %6 = sub i64 %3, %4
  %7 = select i1 %5, i64 0, i64 %6
  %8 = add i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), %7
  %9 = insertvalue { i64, i64 } undef, i64 %8, 0
  %10 = insertvalue { i64, i64 } %9, i64 %3, 1
  ret { i64, i64 } %10
}

define { ptr, i160 } @_box_function_typ(ptr %0, ptr %1) {
  %3 = alloca { ptr, i160 }, align 8
  %4 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 1
  store ptr @function_typ, ptr %3, align 8
  %5 = call { i64, i64 } @size_wrapper(ptr @_data_size_function_typ, ptr %1)
  %6 = extractvalue { i64, i64 } %5, 0
  %7 = icmp sle i64 %6, 16
  br i1 %7, label %10, label %8

8:                                                ; preds = %2
  %9 = call ptr @bump_malloc(i64 %6)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %9, ptr %0, i64 %6, i1 false)
  store ptr %9, ptr %4, align 8
  br label %11

10:                                               ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %0, i64 %6, i1 false)
  br label %11

11:                                               ; preds = %10, %8
  %12 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = insertvalue { ptr, i160 } undef, ptr %13, 0
  %15 = load i160, ptr %4, align 4
  %16 = insertvalue { ptr, i160 } %14, i160 %15, 1
  ret { ptr, i160 } %16
}

define void @_unbox_function_typ({ ptr, i160 } %0, ptr %1, ptr %2) {
  %4 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %0, ptr %4, align 8
  %5 = getelementptr { ptr, i160 }, ptr %4, i32 0, i32 1
  %6 = load ptr, ptr %5, align 8
  %7 = call { i64, i64 } @size_wrapper(ptr @_data_size_function_typ, ptr %1)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = icmp sle i64 %8, 16
  %10 = select i1 %9, ptr %5, ptr %6
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %10, i64 %8, i1 false)
  ret void
}

define { i64, i64 } @_data_size_buffer_typ(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = urem i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), %3
  %5 = icmp eq i64 %4, 0
  %6 = sub i64 %3, %4
  %7 = select i1 %5, i64 0, i64 %6
  %8 = add i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), %7
  %9 = insertvalue { i64, i64 } undef, i64 %8, 0
  %10 = insertvalue { i64, i64 } %9, i64 %3, 1
  ret { i64, i64 } %10
}

define { ptr, i160 } @_box_buffer_typ(ptr %0, ptr %1) {
  %3 = alloca { ptr, i160 }, align 8
  %4 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 1
  store ptr @buffer_typ, ptr %3, align 8
  %5 = call { i64, i64 } @size_wrapper(ptr @_data_size_buffer_typ, ptr %1)
  %6 = extractvalue { i64, i64 } %5, 0
  %7 = icmp sle i64 %6, 16
  br i1 %7, label %10, label %8

8:                                                ; preds = %2
  %9 = call ptr @bump_malloc(i64 %6)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %9, ptr %0, i64 %6, i1 false)
  store ptr %9, ptr %4, align 8
  br label %11

10:                                               ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %0, i64 %6, i1 false)
  br label %11

11:                                               ; preds = %10, %8
  %12 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = insertvalue { ptr, i160 } undef, ptr %13, 0
  %15 = load i160, ptr %4, align 4
  %16 = insertvalue { ptr, i160 } %14, i160 %15, 1
  ret { ptr, i160 } %16
}

define void @_unbox_buffer_typ({ ptr, i160 } %0, ptr %1, ptr %2) {
  %4 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %0, ptr %4, align 8
  %5 = getelementptr { ptr, i160 }, ptr %4, i32 0, i32 1
  %6 = load ptr, ptr %5, align 8
  %7 = call { i64, i64 } @size_wrapper(ptr @_data_size_buffer_typ, ptr %1)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = icmp sle i64 %8, 16
  %10 = select i1 %9, ptr %5, ptr %6
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %10, i64 %8, i1 false)
  ret void
}

define { ptr, i160 } @_box_tuple_typ(ptr %0, ptr %1) {
  %3 = alloca { ptr, i160 }, align 8
  %4 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 1
  store ptr @tuple_typ, ptr %3, align 8
  %5 = call { i64, i64 } @size_wrapper(ptr @_data_size_tuple_typ, ptr %1)
  %6 = extractvalue { i64, i64 } %5, 0
  %7 = icmp sle i64 %6, 16
  br i1 %7, label %10, label %8

8:                                                ; preds = %2
  %9 = call ptr @bump_malloc(i64 %6)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %9, ptr %0, i64 %6, i1 false)
  store ptr %9, ptr %4, align 8
  br label %11

10:                                               ; preds = %2
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %0, i64 %6, i1 false)
  br label %11

11:                                               ; preds = %10, %8
  %12 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = insertvalue { ptr, i160 } undef, ptr %13, 0
  %15 = load i160, ptr %4, align 4
  %16 = insertvalue { ptr, i160 } %14, i160 %15, 1
  ret { ptr, i160 } %16
}

define void @_unbox_tuple_typ({ ptr, i160 } %0, ptr %1, ptr %2) {
  %4 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %0, ptr %4, align 8
  %5 = getelementptr { ptr, i160 }, ptr %4, i32 0, i32 1
  %6 = load ptr, ptr %5, align 8
  %7 = call { i64, i64 } @size_wrapper(ptr @_data_size_tuple_typ, ptr %1)
  %8 = extractvalue { i64, i64 } %7, 0
  %9 = icmp sle i64 %8, 16
  %10 = select i1 %9, ptr %5, ptr %6
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %10, i64 %8, i1 false)
  ret void
}

define { ptr, i160 } @_box_union_typ(ptr %0, ptr %1) {
  %3 = alloca { ptr, i160 }, align 8
  %4 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 1
  store ptr @union_typ, ptr %3, align 8
  %5 = call { i64, i64 } @size_wrapper(ptr @_data_size_union_typ, ptr %1)
  %6 = extractvalue { i64, i64 } %5, 0
  %7 = icmp eq i64 %6, 32
  br i1 %7, label %8, label %14

8:                                                ; preds = %2
  %9 = getelementptr { ptr, i160 }, ptr %0, i32 0, i32 0
  %10 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 0
  %11 = load ptr, ptr %9, align 8
  store ptr %11, ptr %10, align 8
  %12 = getelementptr { ptr, i160 }, ptr %0, i32 0, i32 1
  %13 = load i160, ptr %12, align 4
  store i160 %13, ptr %4, align 4
  br label %19

14:                                               ; preds = %2
  %15 = icmp sle i64 %6, 16
  br i1 %15, label %18, label %16

16:                                               ; preds = %14
  %17 = call ptr @bump_malloc(i64 %6)
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %17, ptr %0, i64 %6, i1 false)
  store ptr %17, ptr %4, align 8
  br label %19

18:                                               ; preds = %14
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %0, i64 %6, i1 false)
  br label %19

19:                                               ; preds = %8, %18, %16
  %20 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 0
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, i160 } undef, ptr %21, 0
  %23 = load i160, ptr %4, align 4
  %24 = insertvalue { ptr, i160 } %22, i160 %23, 1
  ret { ptr, i160 } %24
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.inline.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #0

attributes #0 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0}

!0 = !{i32 2, !"Debug Info Version", i32 3}
// -----
; ModuleID = 'LLVMDialectModule'
source_filename = "LLVMDialectModule"

%bool_typ = type opaque
%i1_typ = type opaque
%i8_typ = type opaque
%i32_typ = type opaque
%i64_typ = type opaque
%i128_typ = type opaque
%f64_typ = type opaque
%nil_typ = type opaque
%any_typ = type opaque
%nothing_typ = type opaque
%coroutine_typ = type opaque
%function_typ = type opaque
%buffer_typ = type opaque
%tuple_typ = type opaque
%union_typ = type opaque
%Object = type opaque

@_parameterization_Bool = linkonce_odr constant [2 x ptr] [ptr @bool_typ, ptr null]
@_parameterization_i32 = linkonce_odr constant [2 x ptr] [ptr @i32_typ, ptr null]
@i32_string = linkonce_odr constant [4 x i8] c"%d\0A\00"
@i64_string = linkonce_odr constant [6 x i8] c"%lld\0A\00"
@float_string = linkonce_odr constant [4 x i8] c"%f\0A\00"
@string_string = linkonce_odr constant [4 x i8] c"%s\0A\00"
@bool_typ = external constant %bool_typ
@i1_typ = external constant %i1_typ
@i8_typ = external constant %i8_typ
@i32_typ = external constant %i32_typ
@i64_typ = external constant %i64_typ
@i128_typ = external constant %i128_typ
@f64_typ = external constant %f64_typ
@nil_typ = external constant %nil_typ
@any_typ = external constant %any_typ
@nothing_typ = external constant %nothing_typ
@coroutine_typ = external constant %coroutine_typ
@function_typ = external constant %function_typ
@buffer_typ = external constant %buffer_typ
@tuple_typ = external constant %tuple_typ
@union_typ = external constant %union_typ
@Object = external constant %Object
@Pair_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr null, ptr @Pair, ptr @Object]
@Pair_offset_tbl = constant [4 x i32] [i32 10, i32 0, i32 10, i32 24]
@Pair = constant { [3 x i64], [7 x ptr], [14 x ptr] } { [3 x i64] [i64 9197944775169318296, i64 -6956338889397019333, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Pair_hashtbl, ptr @Pair_offset_tbl, ptr @_data_size_Pair, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [14 x ptr] [ptr @Pair_field_Pair_0, ptr @Pair_field_Pair_1, ptr @Pair_field_first, ptr @Pair_field_second, ptr @Pair_B_first_, ptr @Pair_B_second_, ptr @Pair_B__set_first_valueT, ptr @Pair_B__set_second_valueU, ptr @Pair_B_init_firstT_secondU, ptr @Pair_first_, ptr @Pair_second_, ptr @Pair__set_first_valueT, ptr @Pair__set_second_valueU, ptr @Pair_init_firstT_secondU] }
@Iterator_hashtbl = constant [4 x ptr] [ptr null, ptr @Object, ptr @any_typ, ptr @Iterator]
@Iterator_offset_tbl = constant [4 x i32] [i32 0, i32 13, i32 10, i32 10]
@Iterator = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 8673632051301757104, i64 -3176955204965301329, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Iterator_hashtbl, ptr @Iterator_offset_tbl, ptr @_data_size_Iterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@Iterable_hashtbl = constant [4 x ptr] [ptr @Iterable, ptr null, ptr @Object, ptr @any_typ]
@Iterable_offset_tbl = constant [4 x i32] [i32 10, i32 0, i32 35, i32 10]
@Iterable = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 3037712219555723519, i64 1199690265535424989, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Iterable_hashtbl, ptr @Iterable_offset_tbl, ptr @_data_size_Iterable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@ConstantTimeIterator_hashtbl = constant [4 x ptr] [ptr @Iterator, ptr @any_typ, ptr @ConstantTimeIterator, ptr @Object]
@ConstantTimeIterator_offset_tbl = constant [4 x i32] [i32 13, i32 10, i32 10, i32 16]
@ConstantTimeIterator = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 7049076106841707882, i64 7093088126402684887, i64 3], [7 x ptr] [ptr @subtype_test, ptr @ConstantTimeIterator_hashtbl, ptr @ConstantTimeIterator_offset_tbl, ptr @_data_size_ConstantTimeIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@CoroIterator_hashtbl = constant [4 x ptr] [ptr @Iterator, ptr @Object, ptr @CoroIterator, ptr @any_typ]
@CoroIterator_offset_tbl = constant [4 x i32] [i32 16, i32 19, i32 10, i32 10]
@CoroIterator = constant { [3 x i64], [7 x ptr], [9 x ptr] } { [3 x i64] [i64 -2576637928336402481, i64 -5916317424623733355, i64 3], [7 x ptr] [ptr @subtype_test, ptr @CoroIterator_hashtbl, ptr @CoroIterator_offset_tbl, ptr @_data_size_CoroIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [9 x ptr] [ptr @CoroIterator_field_CoroIterator_0, ptr @CoroIterator_field_coro, ptr @CoroIterator_B_init_coroCoroutine_to_Nothing, ptr @CoroIterator_B_next_, ptr @CoroIterator_init_coroCoroutine_to_Nothing, ptr @CoroIterator_next_, ptr @CoroIterator_field_CoroIterator_0, ptr @CoroIterator_B_next_, ptr @CoroIterator_next_] }
@Enumerated_hashtbl = constant [4 x ptr] [ptr @Object, ptr @Iterable, ptr @Enumerated, ptr @any_typ]
@Enumerated_offset_tbl = constant [4 x i32] [i32 64, i32 39, i32 10, i32 10]
@Enumerated = constant { [3 x i64], [7 x ptr], [54 x ptr] } { [3 x i64] [i64 6044713360068526275, i64 -5552614183019370665, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Enumerated_hashtbl, ptr @Enumerated_offset_tbl, ptr @_data_size_Enumerated, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [54 x ptr] [ptr @Enumerated_field_Enumerated_0, ptr @Enumerated_field_Enumerated_1, ptr @Enumerated_field_iterable, ptr @Enumerated_B_init_iterableIterableT, ptr @Enumerated_B_iterator_, ptr @Enumerated_B_each_fFunctionT_to_Nothing, ptr @Enumerated_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Enumerated_B_all_fFunctionT_to_Bool, ptr @Enumerated_B_any_fFunctionT_to_Bool, ptr @Enumerated_B_enumerate_, ptr @Enumerated_B_map_fFunctionT_to_U, ptr @Enumerated_B_filter_fFunctionT_to_Bool, ptr @Enumerated_B_chain_otherIterableT, ptr @Enumerated_B_interleave_otherIterableT, ptr @Enumerated_B_zip_otherIterableU, ptr @Enumerated_B_product_otherIterableU, ptr @Enumerated_init_iterableIterableT, ptr @Enumerated_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Enumerated_field_Enumerated_1, ptr @Enumerated_B_iterator_, ptr @Enumerated_B_each_fFunctionT_to_Nothing, ptr @Enumerated_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Enumerated_B_all_fFunctionT_to_Bool, ptr @Enumerated_B_any_fFunctionT_to_Bool, ptr @Enumerated_B_enumerate_, ptr @Enumerated_B_map_fFunctionT_to_U, ptr @Enumerated_B_filter_fFunctionT_to_Bool, ptr @Enumerated_B_chain_otherIterableT, ptr @Enumerated_B_interleave_otherIterableT, ptr @Enumerated_B_zip_otherIterableU, ptr @Enumerated_B_product_otherIterableU, ptr @Enumerated_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@Enumerator_hashtbl = constant [4 x ptr] [ptr @Enumerator, ptr @Object, ptr @Iterator, ptr @any_typ]
@Enumerator_offset_tbl = constant [4 x i32] [i32 10, i32 21, i32 18, i32 10]
@Enumerator = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -3435222131909153872, i64 431463437643106883, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Enumerator_hashtbl, ptr @Enumerator_offset_tbl, ptr @_data_size_Enumerator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @Enumerator_field_Enumerator_0, ptr @Enumerator_field_Enumerator_1, ptr @Enumerator_field_iterator, ptr @Enumerator_field_index, ptr @Enumerator_B_init_iteratorIteratorT, ptr @Enumerator_B_next_, ptr @Enumerator_init_iteratorIteratorT, ptr @Enumerator_next_, ptr @Enumerator_field_Enumerator_1, ptr @Enumerator_B_next_, ptr @Enumerator_next_] }
@Mapped_hashtbl = constant [4 x ptr] [ptr @Iterable, ptr @any_typ, ptr @Mapped, ptr @Object]
@Mapped_offset_tbl = constant [4 x i32] [i32 40, i32 10, i32 10, i32 65]
@Mapped = constant { [3 x i64], [7 x ptr], [55 x ptr] } { [3 x i64] [i64 638460123129944711, i64 -7313859614462349033, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Mapped_hashtbl, ptr @Mapped_offset_tbl, ptr @_data_size_Mapped, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [55 x ptr] [ptr @Mapped_field_Mapped_0, ptr @Mapped_field_Mapped_1, ptr @Mapped_field_iterable, ptr @Mapped_field_f, ptr @Mapped_B_init_iterableIterableT_fFunctionT_to_U, ptr @Mapped_B_iterator_, ptr @Mapped_B_each_fFunctionT_to_Nothing, ptr @Mapped_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Mapped_B_all_fFunctionT_to_Bool, ptr @Mapped_B_any_fFunctionT_to_Bool, ptr @Mapped_B_enumerate_, ptr @Mapped_B_map_fFunctionT_to_U, ptr @Mapped_B_filter_fFunctionT_to_Bool, ptr @Mapped_B_chain_otherIterableT, ptr @Mapped_B_interleave_otherIterableT, ptr @Mapped_B_zip_otherIterableU, ptr @Mapped_B_product_otherIterableU, ptr @Mapped_init_iterableIterableT_fFunctionT_to_U, ptr @Mapped_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Mapped_field_Mapped_1, ptr @Mapped_B_iterator_, ptr @Mapped_B_each_fFunctionT_to_Nothing, ptr @Mapped_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Mapped_B_all_fFunctionT_to_Bool, ptr @Mapped_B_any_fFunctionT_to_Bool, ptr @Mapped_B_enumerate_, ptr @Mapped_B_map_fFunctionT_to_U, ptr @Mapped_B_filter_fFunctionT_to_Bool, ptr @Mapped_B_chain_otherIterableT, ptr @Mapped_B_interleave_otherIterableT, ptr @Mapped_B_zip_otherIterableU, ptr @Mapped_B_product_otherIterableU, ptr @Mapped_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@Mapper_hashtbl = constant [4 x ptr] [ptr @Mapper, ptr @any_typ, ptr @Object, ptr @Iterator]
@Mapper_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 21, i32 18]
@Mapper = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -7249237032859699974, i64 4630566721686777991, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Mapper_hashtbl, ptr @Mapper_offset_tbl, ptr @_data_size_Mapper, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @Mapper_field_Mapper_0, ptr @Mapper_field_Mapper_1, ptr @Mapper_field_iterator, ptr @Mapper_field_f, ptr @Mapper_B_init_iteratorIteratorT_fFunctionT_to_U, ptr @Mapper_B_next_, ptr @Mapper_init_iteratorIteratorT_fFunctionT_to_U, ptr @Mapper_next_, ptr @Mapper_field_Mapper_1, ptr @Mapper_B_next_, ptr @Mapper_next_] }
@Filtered_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @Filtered, ptr @Iterable, ptr @Object]
@Filtered_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 39, i32 64]
@Filtered = constant { [3 x i64], [7 x ptr], [54 x ptr] } { [3 x i64] [i64 -1080024301579294453, i64 6072822413717028023, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Filtered_hashtbl, ptr @Filtered_offset_tbl, ptr @_data_size_Filtered, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [54 x ptr] [ptr @Filtered_field_Filtered_0, ptr @Filtered_field_iterable, ptr @Filtered_field_f, ptr @Filtered_B_init_iterableIterableT_fFunctionT_to_Bool, ptr @Filtered_B_iterator_, ptr @Filtered_B_each_fFunctionT_to_Nothing, ptr @Filtered_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Filtered_B_all_fFunctionT_to_Bool, ptr @Filtered_B_any_fFunctionT_to_Bool, ptr @Filtered_B_enumerate_, ptr @Filtered_B_map_fFunctionT_to_U, ptr @Filtered_B_filter_fFunctionT_to_Bool, ptr @Filtered_B_chain_otherIterableT, ptr @Filtered_B_interleave_otherIterableT, ptr @Filtered_B_zip_otherIterableU, ptr @Filtered_B_product_otherIterableU, ptr @Filtered_init_iterableIterableT_fFunctionT_to_Bool, ptr @Filtered_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Filtered_field_Filtered_0, ptr @Filtered_B_iterator_, ptr @Filtered_B_each_fFunctionT_to_Nothing, ptr @Filtered_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Filtered_B_all_fFunctionT_to_Bool, ptr @Filtered_B_any_fFunctionT_to_Bool, ptr @Filtered_B_enumerate_, ptr @Filtered_B_map_fFunctionT_to_U, ptr @Filtered_B_filter_fFunctionT_to_Bool, ptr @Filtered_B_chain_otherIterableT, ptr @Filtered_B_interleave_otherIterableT, ptr @Filtered_B_zip_otherIterableU, ptr @Filtered_B_product_otherIterableU, ptr @Filtered_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@Filterer_hashtbl = constant [4 x ptr] [ptr @Filterer, ptr @any_typ, ptr @Iterator, ptr @Object]
@Filterer_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 17, i32 20]
@Filterer = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 3681499794063910215, i64 6692347854825431563, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Filterer_hashtbl, ptr @Filterer_offset_tbl, ptr @_data_size_Filterer, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @Filterer_field_Filterer_0, ptr @Filterer_field_iterator, ptr @Filterer_field_f, ptr @Filterer_B_init_iteratorIteratorT_fFunctionT_to_Bool, ptr @Filterer_B_next_, ptr @Filterer_init_iteratorIteratorT_fFunctionT_to_Bool, ptr @Filterer_next_, ptr @Filterer_field_Filterer_0, ptr @Filterer_B_next_, ptr @Filterer_next_] }
@Chained_hashtbl = constant [4 x ptr] [ptr @Chained, ptr @Iterable, ptr @any_typ, ptr @Object]
@Chained_offset_tbl = constant [4 x i32] [i32 10, i32 39, i32 10, i32 64]
@Chained = constant { [3 x i64], [7 x ptr], [54 x ptr] } { [3 x i64] [i64 -4211902305383154752, i64 -828426289965925825, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Chained_hashtbl, ptr @Chained_offset_tbl, ptr @_data_size_Chained, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [54 x ptr] [ptr @Chained_field_Chained_0, ptr @Chained_field_first, ptr @Chained_field_second, ptr @Chained_B_init_firstIterableT_secondIterableT, ptr @Chained_B_iterator_, ptr @Chained_B_each_fFunctionT_to_Nothing, ptr @Chained_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Chained_B_all_fFunctionT_to_Bool, ptr @Chained_B_any_fFunctionT_to_Bool, ptr @Chained_B_enumerate_, ptr @Chained_B_map_fFunctionT_to_U, ptr @Chained_B_filter_fFunctionT_to_Bool, ptr @Chained_B_chain_otherIterableT, ptr @Chained_B_interleave_otherIterableT, ptr @Chained_B_zip_otherIterableU, ptr @Chained_B_product_otherIterableU, ptr @Chained_init_firstIterableT_secondIterableT, ptr @Chained_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Chained_field_Chained_0, ptr @Chained_B_iterator_, ptr @Chained_B_each_fFunctionT_to_Nothing, ptr @Chained_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Chained_B_all_fFunctionT_to_Bool, ptr @Chained_B_any_fFunctionT_to_Bool, ptr @Chained_B_enumerate_, ptr @Chained_B_map_fFunctionT_to_U, ptr @Chained_B_filter_fFunctionT_to_Bool, ptr @Chained_B_chain_otherIterableT, ptr @Chained_B_interleave_otherIterableT, ptr @Chained_B_zip_otherIterableU, ptr @Chained_B_product_otherIterableU, ptr @Chained_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@Chainer_hashtbl = constant [4 x ptr] [ptr @Chainer, ptr @Object, ptr @any_typ, ptr @Iterator]
@Chainer_offset_tbl = constant [4 x i32] [i32 10, i32 21, i32 10, i32 18]
@Chainer = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 1602305534081450710, i64 -4721462593412335651, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Chainer_hashtbl, ptr @Chainer_offset_tbl, ptr @_data_size_Chainer, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @Chainer_field_Chainer_0, ptr @Chainer_field_first, ptr @Chainer_field_second, ptr @Chainer_field_on_first, ptr @Chainer_B_init_firstIteratorT_secondIteratorT, ptr @Chainer_B_next_, ptr @Chainer_init_firstIteratorT_secondIteratorT, ptr @Chainer_next_, ptr @Chainer_field_Chainer_0, ptr @Chainer_B_next_, ptr @Chainer_next_] }
@Interleaved_hashtbl = constant [4 x ptr] [ptr @Interleaved, ptr @Iterable, ptr @any_typ, ptr @Object]
@Interleaved_offset_tbl = constant [4 x i32] [i32 10, i32 39, i32 10, i32 64]
@Interleaved = constant { [3 x i64], [7 x ptr], [54 x ptr] } { [3 x i64] [i64 1225269988638598324, i64 8595497538055228037, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Interleaved_hashtbl, ptr @Interleaved_offset_tbl, ptr @_data_size_Interleaved, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [54 x ptr] [ptr @Interleaved_field_Interleaved_0, ptr @Interleaved_field_first, ptr @Interleaved_field_second, ptr @Interleaved_B_init_firstIterableT_secondIterableT, ptr @Interleaved_B_iterator_, ptr @Interleaved_B_each_fFunctionT_to_Nothing, ptr @Interleaved_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Interleaved_B_all_fFunctionT_to_Bool, ptr @Interleaved_B_any_fFunctionT_to_Bool, ptr @Interleaved_B_enumerate_, ptr @Interleaved_B_map_fFunctionT_to_U, ptr @Interleaved_B_filter_fFunctionT_to_Bool, ptr @Interleaved_B_chain_otherIterableT, ptr @Interleaved_B_interleave_otherIterableT, ptr @Interleaved_B_zip_otherIterableU, ptr @Interleaved_B_product_otherIterableU, ptr @Interleaved_init_firstIterableT_secondIterableT, ptr @Interleaved_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Interleaved_field_Interleaved_0, ptr @Interleaved_B_iterator_, ptr @Interleaved_B_each_fFunctionT_to_Nothing, ptr @Interleaved_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Interleaved_B_all_fFunctionT_to_Bool, ptr @Interleaved_B_any_fFunctionT_to_Bool, ptr @Interleaved_B_enumerate_, ptr @Interleaved_B_map_fFunctionT_to_U, ptr @Interleaved_B_filter_fFunctionT_to_Bool, ptr @Interleaved_B_chain_otherIterableT, ptr @Interleaved_B_interleave_otherIterableT, ptr @Interleaved_B_zip_otherIterableU, ptr @Interleaved_B_product_otherIterableU, ptr @Interleaved_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@Interleaver_hashtbl = constant [4 x ptr] [ptr @Iterator, ptr @any_typ, ptr @Interleaver, ptr @Object]
@Interleaver_offset_tbl = constant [4 x i32] [i32 18, i32 10, i32 10, i32 21]
@Interleaver = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -325516585209011365, i64 3626999898176559509, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Interleaver_hashtbl, ptr @Interleaver_offset_tbl, ptr @_data_size_Interleaver, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @Interleaver_field_Interleaver_0, ptr @Interleaver_field_first, ptr @Interleaver_field_second, ptr @Interleaver_field_on_first, ptr @Interleaver_B_init_firstIteratorT_secondIteratorT, ptr @Interleaver_B_next_, ptr @Interleaver_init_firstIteratorT_secondIteratorT, ptr @Interleaver_next_, ptr @Interleaver_field_Interleaver_0, ptr @Interleaver_B_next_, ptr @Interleaver_next_] }
@Zipped_hashtbl = constant [4 x ptr] [ptr @Zipped, ptr @Iterable, ptr @Object, ptr @any_typ]
@Zipped_offset_tbl = constant [4 x i32] [i32 10, i32 41, i32 66, i32 10]
@Zipped = constant { [3 x i64], [7 x ptr], [56 x ptr] } { [3 x i64] [i64 7357168971761641759, i64 9182128195676406833, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Zipped_hashtbl, ptr @Zipped_offset_tbl, ptr @_data_size_Zipped, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [56 x ptr] [ptr @Zipped_field_Zipped_0, ptr @Zipped_field_Zipped_1, ptr @Zipped_field_Zipped_2, ptr @Zipped_field_first, ptr @Zipped_field_second, ptr @Zipped_B_init_firstIterableT_secondIterableU, ptr @Zipped_B_iterator_, ptr @Zipped_B_each_fFunctionT_to_Nothing, ptr @Zipped_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Zipped_B_all_fFunctionT_to_Bool, ptr @Zipped_B_any_fFunctionT_to_Bool, ptr @Zipped_B_enumerate_, ptr @Zipped_B_map_fFunctionT_to_U, ptr @Zipped_B_filter_fFunctionT_to_Bool, ptr @Zipped_B_chain_otherIterableT, ptr @Zipped_B_interleave_otherIterableT, ptr @Zipped_B_zip_otherIterableU, ptr @Zipped_B_product_otherIterableU, ptr @Zipped_init_firstIterableT_secondIterableU, ptr @Zipped_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Zipped_field_Zipped_2, ptr @Zipped_B_iterator_, ptr @Zipped_B_each_fFunctionT_to_Nothing, ptr @Zipped_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Zipped_B_all_fFunctionT_to_Bool, ptr @Zipped_B_any_fFunctionT_to_Bool, ptr @Zipped_B_enumerate_, ptr @Zipped_B_map_fFunctionT_to_U, ptr @Zipped_B_filter_fFunctionT_to_Bool, ptr @Zipped_B_chain_otherIterableT, ptr @Zipped_B_interleave_otherIterableT, ptr @Zipped_B_zip_otherIterableU, ptr @Zipped_B_product_otherIterableU, ptr @Zipped_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@Zipper_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @Zipper, ptr @Object, ptr @Iterator]
@Zipper_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 22, i32 19]
@Zipper = constant { [3 x i64], [7 x ptr], [12 x ptr] } { [3 x i64] [i64 -502732402311247874, i64 8595218044392504371, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Zipper_hashtbl, ptr @Zipper_offset_tbl, ptr @_data_size_Zipper, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [12 x ptr] [ptr @Zipper_field_Zipper_0, ptr @Zipper_field_Zipper_1, ptr @Zipper_field_Zipper_2, ptr @Zipper_field_first, ptr @Zipper_field_second, ptr @Zipper_B_init_firstIteratorT_secondIteratorU, ptr @Zipper_B_next_, ptr @Zipper_init_firstIteratorT_secondIteratorU, ptr @Zipper_next_, ptr @Zipper_field_Zipper_2, ptr @Zipper_B_next_, ptr @Zipper_next_] }
@Products_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @Iterable, ptr @Products]
@Products_offset_tbl = constant [4 x i32] [i32 66, i32 10, i32 41, i32 10]
@Products = constant { [3 x i64], [7 x ptr], [56 x ptr] } { [3 x i64] [i64 3952308882273721422, i64 -8237977143931068659, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Products_hashtbl, ptr @Products_offset_tbl, ptr @_data_size_Products, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [56 x ptr] [ptr @Products_field_Products_0, ptr @Products_field_Products_1, ptr @Products_field_Products_2, ptr @Products_field_first, ptr @Products_field_second, ptr @Products_B_init_firstIterableT_secondIterableU, ptr @Products_B_iterator_, ptr @Products_B_each_fFunctionT_to_Nothing, ptr @Products_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Products_B_all_fFunctionT_to_Bool, ptr @Products_B_any_fFunctionT_to_Bool, ptr @Products_B_enumerate_, ptr @Products_B_map_fFunctionT_to_U, ptr @Products_B_filter_fFunctionT_to_Bool, ptr @Products_B_chain_otherIterableT, ptr @Products_B_interleave_otherIterableT, ptr @Products_B_zip_otherIterableU, ptr @Products_B_product_otherIterableU, ptr @Products_init_firstIterableT_secondIterableU, ptr @Products_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Products_field_Products_2, ptr @Products_B_iterator_, ptr @Products_B_each_fFunctionT_to_Nothing, ptr @Products_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Products_B_all_fFunctionT_to_Bool, ptr @Products_B_any_fFunctionT_to_Bool, ptr @Products_B_enumerate_, ptr @Products_B_map_fFunctionT_to_U, ptr @Products_B_filter_fFunctionT_to_Bool, ptr @Products_B_chain_otherIterableT, ptr @Products_B_interleave_otherIterableT, ptr @Products_B_zip_otherIterableU, ptr @Products_B_product_otherIterableU, ptr @Products_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Iterable_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@Productizer_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @Productizer, ptr @Iterator]
@Productizer_offset_tbl = constant [4 x i32] [i32 24, i32 10, i32 10, i32 21]
@Productizer = constant { [3 x i64], [7 x ptr], [14 x ptr] } { [3 x i64] [i64 -4237829454682536209, i64 -1295330238902462611, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Productizer_hashtbl, ptr @Productizer_offset_tbl, ptr @_data_size_Productizer, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [14 x ptr] [ptr @Productizer_field_Productizer_0, ptr @Productizer_field_Productizer_1, ptr @Productizer_field_Productizer_2, ptr @Productizer_field_first_iterator, ptr @Productizer_field_second_iterator, ptr @Productizer_field_second, ptr @Productizer_field_current_first, ptr @Productizer_B_init_first_iteratorIteratorT_secondIterableU, ptr @Productizer_B_next_, ptr @Productizer_init_first_iteratorIteratorT_secondIterableU, ptr @Productizer_next_, ptr @Productizer_field_Productizer_2, ptr @Productizer_B_next_, ptr @Productizer_next_] }
@Pair_field_first = internal constant { ptr, ptr } { ptr @Pair_getter_first, ptr @Pair_setter_first }
@Pair_field_second = internal constant { ptr, ptr } { ptr @Pair_getter_second, ptr @Pair_setter_second }
@CoroIterator_field_coro = internal constant { ptr, ptr } { ptr @CoroIterator_getter_coro, ptr @CoroIterator_setter_coro }
@Enumerated_field_iterable = internal constant { ptr, ptr } { ptr @Enumerated_getter_iterable, ptr @Enumerated_setter_iterable }
@Enumerator_field_iterator = internal constant { ptr, ptr } { ptr @Enumerator_getter_iterator, ptr @Enumerator_setter_iterator }
@Enumerator_field_index = internal constant { ptr, ptr } { ptr @Enumerator_getter_index, ptr @Enumerator_setter_index }
@Mapped_field_iterable = internal constant { ptr, ptr } { ptr @Mapped_getter_iterable, ptr @Mapped_setter_iterable }
@Mapped_field_f = internal constant { ptr, ptr } { ptr @Mapped_getter_f, ptr @Mapped_setter_f }
@Mapper_field_iterator = internal constant { ptr, ptr } { ptr @Mapper_getter_iterator, ptr @Mapper_setter_iterator }
@Mapper_field_f = internal constant { ptr, ptr } { ptr @Mapper_getter_f, ptr @Mapper_setter_f }
@Filtered_field_iterable = internal constant { ptr, ptr } { ptr @Filtered_getter_iterable, ptr @Filtered_setter_iterable }
@Filtered_field_f = internal constant { ptr, ptr } { ptr @Filtered_getter_f, ptr @Filtered_setter_f }
@Filterer_field_iterator = internal constant { ptr, ptr } { ptr @Filterer_getter_iterator, ptr @Filterer_setter_iterator }
@Filterer_field_f = internal constant { ptr, ptr } { ptr @Filterer_getter_f, ptr @Filterer_setter_f }
@Chained_field_first = internal constant { ptr, ptr } { ptr @Chained_getter_first, ptr @Chained_setter_first }
@Chained_field_second = internal constant { ptr, ptr } { ptr @Chained_getter_second, ptr @Chained_setter_second }
@Chainer_field_first = internal constant { ptr, ptr } { ptr @Chainer_getter_first, ptr @Chainer_setter_first }
@Chainer_field_second = internal constant { ptr, ptr } { ptr @Chainer_getter_second, ptr @Chainer_setter_second }
@Chainer_field_on_first = internal constant { ptr, ptr } { ptr @Chainer_getter_on_first, ptr @Chainer_setter_on_first }
@Interleaved_field_first = internal constant { ptr, ptr } { ptr @Interleaved_getter_first, ptr @Interleaved_setter_first }
@Interleaved_field_second = internal constant { ptr, ptr } { ptr @Interleaved_getter_second, ptr @Interleaved_setter_second }
@Interleaver_field_first = internal constant { ptr, ptr } { ptr @Interleaver_getter_first, ptr @Interleaver_setter_first }
@Interleaver_field_second = internal constant { ptr, ptr } { ptr @Interleaver_getter_second, ptr @Interleaver_setter_second }
@Interleaver_field_on_first = internal constant { ptr, ptr } { ptr @Interleaver_getter_on_first, ptr @Interleaver_setter_on_first }
@Zipped_field_first = internal constant { ptr, ptr } { ptr @Zipped_getter_first, ptr @Zipped_setter_first }
@Zipped_field_second = internal constant { ptr, ptr } { ptr @Zipped_getter_second, ptr @Zipped_setter_second }
@Zipper_field_first = internal constant { ptr, ptr } { ptr @Zipper_getter_first, ptr @Zipper_setter_first }
@Zipper_field_second = internal constant { ptr, ptr } { ptr @Zipper_getter_second, ptr @Zipper_setter_second }
@Products_field_first = internal constant { ptr, ptr } { ptr @Products_getter_first, ptr @Products_setter_first }
@Products_field_second = internal constant { ptr, ptr } { ptr @Products_getter_second, ptr @Products_setter_second }
@Productizer_field_first_iterator = internal constant { ptr, ptr } { ptr @Productizer_getter_first_iterator, ptr @Productizer_setter_first_iterator }
@Productizer_field_second_iterator = internal constant { ptr, ptr } { ptr @Productizer_getter_second_iterator, ptr @Productizer_setter_second_iterator }
@Productizer_field_second = internal constant { ptr, ptr } { ptr @Productizer_getter_second, ptr @Productizer_setter_second }
@Productizer_field_current_first = internal constant { ptr, ptr } { ptr @Productizer_getter_current_first, ptr @Productizer_setter_current_first }

declare i32 @printf(ptr, ...)

declare ptr @bump_malloc(i64)

declare void @free(ptr)

declare void @setup_landing_pad()

declare void @anoint_trampoline(ptr)

declare ptr @adjust_trampoline(ptr)

declare ptr @coroutine_create(ptr, ptr)

declare void @arg_passer(ptr)

declare void @arg_buffer_filler(ptr)

declare void @coroutine_yield(ptr)

declare void @coroutine_yield_cold(ptr)

declare ptr @get_current_coroutine()

declare i32 @get_offset(ptr, ptr)

declare void @assume_offset(ptr, ptr)

declare { ptr, i160 } @_box_Default(ptr, ptr)

declare void @_unbox_Default({ ptr, i160 }, ptr, ptr)

declare { i64, i64 } @_size_Default(ptr)

declare void @_unbox_union_typ({ ptr, i160 }, ptr, ptr)

declare { i64, i64 } @_data_size_tuple_typ(ptr)

declare { i64, i64 } @_data_size_union_typ(ptr)

declare i1 @subtype_test(i64, i64, i64, i64, ptr)

declare i1 @subtype_test_wrapper(ptr, i64, i64, i64, i64, ptr)

declare { i64, i64 } @size_wrapper(ptr, ptr)

declare ptr @typegetter_wrapper(ptr, ptr)

declare { ptr, i160 } @box_wrapper(ptr, ptr, ptr)

declare void @unbox_wrapper(ptr, { ptr, i160 }, ptr, ptr)

declare ptr @behavior_wrapper(ptr, { ptr, ptr, ptr, i32 }, ptr)

declare ptr @class_behavior_wrapper(ptr, ptr)

declare void @coroutine_call(ptr)

define { i64, i64 } @_data_size_Pair(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %10
  %12 = getelementptr ptr, ptr %0, i32 1
  %13 = load ptr, ptr %12, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr ptr, ptr %14, i32 9
  %16 = load ptr, ptr %15, align 8
  %17 = call { i64, i64 } @size_wrapper(ptr %16, ptr %13)
  %18 = extractvalue { i64, i64 } %17, 0
  %19 = extractvalue { i64, i64 } %17, 1
  %20 = icmp ugt i64 %19, %5
  %21 = select i1 %20, i64 %19, i64 %5
  %22 = urem i64 %11, %19
  %23 = icmp eq i64 %22, 0
  %24 = sub i64 %19, %22
  %25 = select i1 %23, i64 0, i64 %24
  %26 = add i64 %18, %25
  %27 = add i64 %11, %26
  %28 = getelementptr ptr, ptr %0, i32 2
  %29 = load ptr, ptr %28, align 8
  %30 = load ptr, ptr %29, align 8
  %31 = getelementptr ptr, ptr %30, i32 9
  %32 = load ptr, ptr %31, align 8
  %33 = call { i64, i64 } @size_wrapper(ptr %32, ptr %29)
  %34 = extractvalue { i64, i64 } %33, 0
  %35 = extractvalue { i64, i64 } %33, 1
  %36 = icmp ugt i64 %35, %21
  %37 = select i1 %36, i64 %35, i64 %21
  %38 = urem i64 %27, %35
  %39 = icmp eq i64 %38, 0
  %40 = sub i64 %35, %38
  %41 = select i1 %39, i64 0, i64 %40
  %42 = add i64 %34, %41
  %43 = add i64 %27, %42
  %44 = urem i64 %43, %37
  %45 = icmp eq i64 %44, 0
  %46 = sub i64 %37, %44
  %47 = select i1 %45, i64 0, i64 %46
  %48 = add i64 %43, %47
  %49 = insertvalue { i64, i64 } undef, i64 %48, 0
  %50 = insertvalue { i64, i64 } %49, i64 %37, 1
  ret { i64, i64 } %50
}

define ptr @Pair_field_Pair_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define ptr @Pair_field_Pair_1(ptr %0) {
  %2 = getelementptr ptr, ptr %0, i32 1
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

define { ptr, i160 } @Pair_getter_first(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = load ptr, ptr %0, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr ptr, ptr %9, i32 9
  %11 = load ptr, ptr %10, align 8
  %12 = call { i64, i64 } @size_wrapper(ptr %11, ptr %8)
  %13 = extractvalue { i64, i64 } %12, 1
  %14 = urem i64 %7, %13
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 %13, %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 %7, %17
  %19 = getelementptr i8, ptr %0, i64 %18
  %20 = load ptr, ptr %0, align 8
  %21 = load ptr, ptr %20, align 8
  %22 = getelementptr ptr, ptr %21, i32 7
  %23 = load ptr, ptr %22, align 8
  %24 = call { ptr, i160 } @box_wrapper(ptr %23, ptr %19, ptr %20)
  ret { ptr, i160 } %24
}

define void @Pair_setter_first(ptr %0, { ptr, i160 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = load ptr, ptr %0, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr ptr, ptr %10, i32 9
  %12 = load ptr, ptr %11, align 8
  %13 = call { i64, i64 } @size_wrapper(ptr %12, ptr %9)
  %14 = extractvalue { i64, i64 } %13, 1
  %15 = urem i64 %8, %14
  %16 = icmp eq i64 %15, 0
  %17 = sub i64 %14, %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add i64 %8, %18
  %20 = getelementptr i8, ptr %0, i64 %19
  %21 = load ptr, ptr %0, align 8
  %22 = load ptr, ptr %21, align 8
  %23 = getelementptr ptr, ptr %22, i32 8
  %24 = load ptr, ptr %23, align 8
  call void @unbox_wrapper(ptr %24, { ptr, i160 } %1, ptr %21, ptr %20)
  ret void
}

define { ptr, i160 } @Pair_getter_second(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = load ptr, ptr %0, align 8
  %9 = load ptr, ptr %8, align 8
  %10 = getelementptr ptr, ptr %9, i32 9
  %11 = load ptr, ptr %10, align 8
  %12 = call { i64, i64 } @size_wrapper(ptr %11, ptr %8)
  %13 = extractvalue { i64, i64 } %12, 0
  %14 = extractvalue { i64, i64 } %12, 1
  %15 = urem i64 %7, %14
  %16 = icmp eq i64 %15, 0
  %17 = sub i64 %14, %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add i64 %13, %18
  %20 = add i64 %7, %19
  %21 = getelementptr ptr, ptr %0, i32 1
  %22 = load ptr, ptr %21, align 8
  %23 = load ptr, ptr %22, align 8
  %24 = getelementptr ptr, ptr %23, i32 9
  %25 = load ptr, ptr %24, align 8
  %26 = call { i64, i64 } @size_wrapper(ptr %25, ptr %22)
  %27 = extractvalue { i64, i64 } %26, 1
  %28 = urem i64 %20, %27
  %29 = icmp eq i64 %28, 0
  %30 = sub i64 %27, %28
  %31 = select i1 %29, i64 0, i64 %30
  %32 = add i64 %20, %31
  %33 = getelementptr i8, ptr %0, i64 %32
  %34 = load ptr, ptr %21, align 8
  %35 = load ptr, ptr %34, align 8
  %36 = getelementptr ptr, ptr %35, i32 7
  %37 = load ptr, ptr %36, align 8
  %38 = call { ptr, i160 } @box_wrapper(ptr %37, ptr %33, ptr %34)
  ret { ptr, i160 } %38
}

define void @Pair_setter_second(ptr %0, { ptr, i160 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = load ptr, ptr %0, align 8
  %10 = load ptr, ptr %9, align 8
  %11 = getelementptr ptr, ptr %10, i32 9
  %12 = load ptr, ptr %11, align 8
  %13 = call { i64, i64 } @size_wrapper(ptr %12, ptr %9)
  %14 = extractvalue { i64, i64 } %13, 0
  %15 = extractvalue { i64, i64 } %13, 1
  %16 = urem i64 %8, %15
  %17 = icmp eq i64 %16, 0
  %18 = sub i64 %15, %16
  %19 = select i1 %17, i64 0, i64 %18
  %20 = add i64 %14, %19
  %21 = add i64 %8, %20
  %22 = getelementptr ptr, ptr %0, i32 1
  %23 = load ptr, ptr %22, align 8
  %24 = load ptr, ptr %23, align 8
  %25 = getelementptr ptr, ptr %24, i32 9
  %26 = load ptr, ptr %25, align 8
  %27 = call { i64, i64 } @size_wrapper(ptr %26, ptr %23)
  %28 = extractvalue { i64, i64 } %27, 1
  %29 = urem i64 %21, %28
  %30 = icmp eq i64 %29, 0
  %31 = sub i64 %28, %29
  %32 = select i1 %30, i64 0, i64 %31
  %33 = add i64 %21, %32
  %34 = getelementptr i8, ptr %0, i64 %33
  %35 = load ptr, ptr %22, align 8
  %36 = load ptr, ptr %35, align 8
  %37 = getelementptr ptr, ptr %36, i32 8
  %38 = load ptr, ptr %37, align 8
  call void @unbox_wrapper(ptr %38, { ptr, i160 } %1, ptr %35, ptr %34)
  ret void
}

define { ptr, i160 } @Pair_first_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @Pair)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 112, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 2
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr { ptr, ptr }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = call { ptr, i160 } %27(ptr %19) #1
  %29 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %28, ptr %29, align 8
  %30 = alloca i160, align 8
  %31 = alloca ptr, align 8
  %32 = getelementptr { ptr, i160 }, ptr %29, i32 0, i32 0
  %33 = load ptr, ptr %32, align 8
  store ptr %33, ptr %31, align 8
  %34 = getelementptr { ptr, i160 }, ptr %29, i32 0, i32 1
  %35 = load i160, ptr %34, align 4
  store i160 %35, ptr %30, align 4
  %36 = alloca i160, align 8
  %37 = alloca ptr, align 8
  %38 = load ptr, ptr %31, align 8
  store ptr %38, ptr %37, align 8
  %39 = load i160, ptr %30, align 4
  store i160 %39, ptr %36, align 4
  %40 = load ptr, ptr %37, align 8
  %41 = insertvalue { ptr, i160 } undef, ptr %40, 0
  %42 = load i160, ptr %36, align 4
  %43 = insertvalue { ptr, i160 } %41, i160 %42, 1
  ret { ptr, i160 } %43
}

define ptr @Pair_B_first_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 9, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [14 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { ptr, i160 } @Pair_second_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @Pair)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 112, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 3
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr { ptr, ptr }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = call { ptr, i160 } %27(ptr %19) #1
  %29 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %28, ptr %29, align 8
  %30 = alloca i160, align 8
  %31 = alloca ptr, align 8
  %32 = getelementptr { ptr, i160 }, ptr %29, i32 0, i32 0
  %33 = load ptr, ptr %32, align 8
  store ptr %33, ptr %31, align 8
  %34 = getelementptr { ptr, i160 }, ptr %29, i32 0, i32 1
  %35 = load i160, ptr %34, align 4
  store i160 %35, ptr %30, align 4
  %36 = alloca i160, align 8
  %37 = alloca ptr, align 8
  %38 = load ptr, ptr %31, align 8
  store ptr %38, ptr %37, align 8
  %39 = load i160, ptr %30, align 4
  store i160 %39, ptr %36, align 4
  %40 = load ptr, ptr %37, align 8
  %41 = insertvalue { ptr, i160 } undef, ptr %40, 0
  %42 = load i160, ptr %36, align 4
  %43 = insertvalue { ptr, i160 } %41, i160 %42, 1
  ret { ptr, i160 } %43
}

define ptr @Pair_B_second_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 10, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [14 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define void @Pair__set_first_valueT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, i160 } %3) {
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %5, align 8
  %6 = alloca i32, align 4
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %7, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %8, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %9, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = call i32 @get_offset(ptr %18, ptr @Pair)
  store i32 %19, ptr %6, align 4
  %20 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %3, ptr %20, align 8
  %21 = alloca i160, align 8
  %22 = alloca ptr, align 8
  %23 = getelementptr { ptr, i160 }, ptr %20, i32 0, i32 0
  %24 = load ptr, ptr %23, align 8
  store ptr %24, ptr %22, align 8
  %25 = getelementptr { ptr, i160 }, ptr %20, i32 0, i32 1
  %26 = load i160, ptr %25, align 4
  store i160 %26, ptr %21, align 4
  %27 = alloca i160, align 8
  %28 = alloca ptr, align 8
  %29 = load ptr, ptr %22, align 8
  store ptr %29, ptr %28, align 8
  %30 = load i160, ptr %21, align 4
  store i160 %30, ptr %27, align 4
  %31 = load ptr, ptr %8, align 8
  %32 = load ptr, ptr %7, align 8
  %33 = call ptr @llvm.invariant.start.p0(i64 112, ptr %32)
  %34 = load i32, ptr %6, align 4
  %35 = getelementptr ptr, ptr %32, i32 %34
  %36 = getelementptr ptr, ptr %35, i32 2
  %37 = load ptr, ptr %36, align 8
  %38 = getelementptr { ptr, ptr }, ptr %37, i32 0, i32 1
  %39 = load ptr, ptr %38, align 8
  %40 = load ptr, ptr %28, align 8
  %41 = insertvalue { ptr, i160 } undef, ptr %40, 0
  %42 = load i160, ptr %27, align 4
  %43 = insertvalue { ptr, i160 } %41, i160 %42, 1
  call void %39(ptr %31, { ptr, i160 } %43) #2
  ret void
}

define ptr @Pair_B__set_first_valueT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @any_typ, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @any_typ to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 11, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [14 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define void @Pair__set_second_valueU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, i160 } %3) {
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %5, align 8
  %6 = alloca i32, align 4
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %7, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %8, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %9, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = call i32 @get_offset(ptr %18, ptr @Pair)
  store i32 %19, ptr %6, align 4
  %20 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %3, ptr %20, align 8
  %21 = alloca i160, align 8
  %22 = alloca ptr, align 8
  %23 = getelementptr { ptr, i160 }, ptr %20, i32 0, i32 0
  %24 = load ptr, ptr %23, align 8
  store ptr %24, ptr %22, align 8
  %25 = getelementptr { ptr, i160 }, ptr %20, i32 0, i32 1
  %26 = load i160, ptr %25, align 4
  store i160 %26, ptr %21, align 4
  %27 = alloca i160, align 8
  %28 = alloca ptr, align 8
  %29 = load ptr, ptr %22, align 8
  store ptr %29, ptr %28, align 8
  %30 = load i160, ptr %21, align 4
  store i160 %30, ptr %27, align 4
  %31 = load ptr, ptr %8, align 8
  %32 = load ptr, ptr %7, align 8
  %33 = call ptr @llvm.invariant.start.p0(i64 112, ptr %32)
  %34 = load i32, ptr %6, align 4
  %35 = getelementptr ptr, ptr %32, i32 %34
  %36 = getelementptr ptr, ptr %35, i32 3
  %37 = load ptr, ptr %36, align 8
  %38 = getelementptr { ptr, ptr }, ptr %37, i32 0, i32 1
  %39 = load ptr, ptr %38, align 8
  %40 = load ptr, ptr %28, align 8
  %41 = insertvalue { ptr, i160 } undef, ptr %40, 0
  %42 = load i160, ptr %27, align 4
  %43 = insertvalue { ptr, i160 } %41, i160 %42, 1
  call void %39(ptr %31, { ptr, i160 } %43) #2
  ret void
}

define ptr @Pair_B__set_second_valueU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @any_typ, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @any_typ to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 12, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [14 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define void @Pair_init_firstT_secondU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, i160 } %3, { ptr, i160 } %4) {
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %6, align 8
  %7 = alloca i32, align 4
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = alloca ptr, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %8, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 1
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %9, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 2
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %10, align 8
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  store i32 %18, ptr %7, align 4
  %19 = load ptr, ptr %8, align 8
  %20 = call i32 @get_offset(ptr %19, ptr @Pair)
  store i32 %20, ptr %7, align 4
  %21 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %3, ptr %21, align 8
  %22 = alloca i160, align 8
  %23 = alloca ptr, align 8
  %24 = getelementptr { ptr, i160 }, ptr %21, i32 0, i32 0
  %25 = load ptr, ptr %24, align 8
  store ptr %25, ptr %23, align 8
  %26 = getelementptr { ptr, i160 }, ptr %21, i32 0, i32 1
  %27 = load i160, ptr %26, align 4
  store i160 %27, ptr %22, align 4
  %28 = alloca i160, align 8
  %29 = alloca ptr, align 8
  %30 = load ptr, ptr %23, align 8
  store ptr %30, ptr %29, align 8
  %31 = load i160, ptr %22, align 4
  store i160 %31, ptr %28, align 4
  %32 = load ptr, ptr %9, align 8
  %33 = load ptr, ptr %8, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 112, ptr %33)
  %35 = load i32, ptr %7, align 4
  %36 = getelementptr ptr, ptr %33, i32 %35
  %37 = getelementptr ptr, ptr %36, i32 2
  %38 = load ptr, ptr %37, align 8
  %39 = getelementptr { ptr, ptr }, ptr %38, i32 0, i32 1
  %40 = load ptr, ptr %39, align 8
  %41 = load ptr, ptr %29, align 8
  %42 = insertvalue { ptr, i160 } undef, ptr %41, 0
  %43 = load i160, ptr %28, align 4
  %44 = insertvalue { ptr, i160 } %42, i160 %43, 1
  call void %40(ptr %32, { ptr, i160 } %44) #2
  %45 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %4, ptr %45, align 8
  %46 = alloca i160, align 8
  %47 = alloca ptr, align 8
  %48 = getelementptr { ptr, i160 }, ptr %45, i32 0, i32 0
  %49 = load ptr, ptr %48, align 8
  store ptr %49, ptr %47, align 8
  %50 = getelementptr { ptr, i160 }, ptr %45, i32 0, i32 1
  %51 = load i160, ptr %50, align 4
  store i160 %51, ptr %46, align 4
  %52 = alloca i160, align 8
  %53 = alloca ptr, align 8
  %54 = load ptr, ptr %47, align 8
  store ptr %54, ptr %53, align 8
  %55 = load i160, ptr %46, align 4
  store i160 %55, ptr %52, align 4
  %56 = load ptr, ptr %9, align 8
  %57 = load ptr, ptr %8, align 8
  %58 = call ptr @llvm.invariant.start.p0(i64 112, ptr %57)
  %59 = load i32, ptr %7, align 4
  %60 = getelementptr ptr, ptr %57, i32 %59
  %61 = getelementptr ptr, ptr %60, i32 3
  %62 = load ptr, ptr %61, align 8
  %63 = getelementptr { ptr, ptr }, ptr %62, i32 0, i32 1
  %64 = load ptr, ptr %63, align 8
  %65 = load ptr, ptr %53, align 8
  %66 = insertvalue { ptr, i160 } undef, ptr %65, 0
  %67 = load i160, ptr %52, align 4
  %68 = insertvalue { ptr, i160 } %66, i160 %67, 1
  call void %64(ptr %56, { ptr, i160 } %68) #2
  ret void
}

define ptr @Pair_B_init_firstT_secondU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @any_typ, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @any_typ to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 1
  %22 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 2
  %23 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 0
  %24 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 1
  %25 = load i64, ptr %21, align 4
  %26 = load i64, ptr %22, align 4
  %27 = load ptr, ptr %23, align 8
  %28 = load ptr, ptr %24, align 8
  %29 = load i64, ptr @any_typ, align 4
  %30 = call i1 @subtype_test_wrapper(ptr %27, i64 %26, i64 %25, i64 %29, i64 ptrtoint (ptr @any_typ to i64), ptr %28)
  %31 = zext i1 %30 to i8
  store i8 %31, ptr %3, align 1
  store i32 13, ptr %6, align 4
  %32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %33 = load i32, ptr %6, align 4
  %34 = getelementptr [14 x ptr], ptr %32, i32 0, i32 %33
  %35 = getelementptr ptr, ptr %34, i32 10
  %36 = load ptr, ptr %35, align 8
  ret ptr %36
}

define { i64, i64 } @_data_size_Iterator(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %3
  %5 = icmp eq i64 %4, 0
  %6 = sub i64 %3, %4
  %7 = select i1 %5, i64 0, i64 %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = insertvalue { i64, i64 } undef, i64 %8, 0
  %10 = insertvalue { i64, i64 } %9, i64 %3, 1
  ret { i64, i64 } %10
}

define ptr @Iterator_field_Iterator_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define ptr @Iterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 2, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [3 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { i64, i64 } @_data_size_Iterable(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %3
  %5 = icmp eq i64 %4, 0
  %6 = sub i64 %3, %4
  %7 = select i1 %5, i64 0, i64 %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = insertvalue { i64, i64 } undef, i64 %8, 0
  %10 = insertvalue { i64, i64 } %9, i64 %3, 1
  ret { i64, i64 } %10
}

define ptr @Iterable_field_Iterable_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define ptr @Iterable_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 13, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [25 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define void @Iterable_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr } %3) {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca {}, align 8
  %7 = alloca { ptr, i160 }, align 8
  %8 = alloca i1, align 1
  %9 = alloca i1, align 1
  %10 = alloca i1, align 1
  %11 = alloca i160, align 8
  %12 = alloca ptr, align 8
  %13 = alloca i160, align 8
  %14 = alloca ptr, align 8
  %15 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %15, align 8
  %16 = alloca i32, align 4
  %17 = alloca ptr, align 8
  %18 = alloca ptr, align 8
  %19 = alloca ptr, align 8
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 0
  %21 = load ptr, ptr %20, align 8
  store ptr %21, ptr %19, align 8
  %22 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 1
  %23 = load ptr, ptr %22, align 8
  store ptr %23, ptr %18, align 8
  %24 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 2
  %25 = load ptr, ptr %24, align 8
  store ptr %25, ptr %17, align 8
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 3
  %27 = load i32, ptr %26, align 4
  store i32 %27, ptr %16, align 4
  %28 = load ptr, ptr %19, align 8
  %29 = call i32 @get_offset(ptr %28, ptr @Iterable)
  store i32 %29, ptr %16, align 4
  %30 = alloca ptr, align 8
  store { ptr } %3, ptr %30, align 8
  %31 = load ptr, ptr %19, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = load ptr, ptr %18, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %33, 1
  %35 = load ptr, ptr %17, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr %35, 2
  %37 = load i32, ptr %16, align 4
  %38 = insertvalue { ptr, ptr, ptr, i32 } %36, i32 %37, 3
  %39 = alloca [0 x ptr], align 8
  %40 = call ptr @llvm.invariant.start.p0(i64 0, ptr %39)
  %41 = call ptr @llvm.invariant.start.p0(i64 200, ptr %31)
  %42 = getelementptr ptr, ptr %31, i32 %37
  %43 = getelementptr ptr, ptr %42, i32 1
  %44 = load ptr, ptr %43, align 8
  %45 = alloca {}, align 8
  %46 = call ptr @behavior_wrapper(ptr %44, { ptr, ptr, ptr, i32 } %38, ptr %45)
  %47 = call { ptr, ptr, ptr, i32 } %46({ ptr, ptr, ptr, i32 } %38, { ptr, ptr, ptr, i32 } %38, ptr %39)
  %48 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %47, ptr %48, align 8
  %49 = alloca i32, align 4
  %50 = alloca ptr, align 8
  %51 = alloca ptr, align 8
  %52 = alloca ptr, align 8
  %53 = getelementptr { ptr, ptr, ptr, i32 }, ptr %48, i32 0, i32 0
  %54 = load ptr, ptr %53, align 8
  store ptr %54, ptr %52, align 8
  %55 = getelementptr { ptr, ptr, ptr, i32 }, ptr %48, i32 0, i32 1
  %56 = load ptr, ptr %55, align 8
  store ptr %56, ptr %51, align 8
  %57 = getelementptr { ptr, ptr, ptr, i32 }, ptr %48, i32 0, i32 2
  %58 = load ptr, ptr %57, align 8
  store ptr %58, ptr %50, align 8
  %59 = getelementptr { ptr, ptr, ptr, i32 }, ptr %48, i32 0, i32 3
  %60 = load i32, ptr %59, align 4
  store i32 %60, ptr %49, align 4
  %61 = load ptr, ptr %52, align 8
  %62 = call i32 @get_offset(ptr %61, ptr @Iterator)
  store i32 %62, ptr %49, align 4
  %63 = alloca i32, align 4
  %64 = alloca ptr, align 8
  %65 = alloca ptr, align 8
  %66 = alloca ptr, align 8
  %67 = load ptr, ptr %52, align 8
  store ptr %67, ptr %66, align 8
  %68 = load ptr, ptr %51, align 8
  store ptr %68, ptr %65, align 8
  %69 = load ptr, ptr %50, align 8
  store ptr %69, ptr %64, align 8
  %70 = load i32, ptr %49, align 4
  store i32 %70, ptr %63, align 4
  br label %71

71:                                               ; preds = %115, %4
  %72 = load ptr, ptr %66, align 8
  %73 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %72, 0
  %74 = load ptr, ptr %65, align 8
  %75 = insertvalue { ptr, ptr, ptr, i32 } %73, ptr %74, 1
  %76 = load ptr, ptr %64, align 8
  %77 = insertvalue { ptr, ptr, ptr, i32 } %75, ptr %76, 2
  %78 = load i32, ptr %63, align 4
  %79 = insertvalue { ptr, ptr, ptr, i32 } %77, i32 %78, 3
  %80 = call ptr @llvm.invariant.start.p0(i64 0, ptr %5)
  %81 = call ptr @llvm.invariant.start.p0(i64 24, ptr %72)
  %82 = getelementptr ptr, ptr %72, i32 %78
  %83 = getelementptr ptr, ptr %82, i32 1
  %84 = load ptr, ptr %83, align 8
  %85 = call ptr @behavior_wrapper(ptr %84, { ptr, ptr, ptr, i32 } %79, ptr %6)
  %86 = call { ptr, i160 } %85({ ptr, ptr, ptr, i32 } %79, { ptr, ptr, ptr, i32 } %79, ptr %5)
  store { ptr, i160 } %86, ptr %7, align 8
  store i8 0, ptr %8, align 1
  %87 = load ptr, ptr %7, align 8
  %88 = ptrtoint ptr %87 to i64
  %89 = icmp eq i64 %88, ptrtoint (ptr @nil_typ to i64)
  %90 = icmp eq i64 %88, 0
  %91 = or i1 %89, %90
  %92 = zext i1 %91 to i8
  store i8 %92, ptr %9, align 1
  %93 = load i8, ptr %8, align 1
  %94 = trunc i8 %93 to i1
  %95 = load i8, ptr %9, align 1
  %96 = trunc i8 %95 to i1
  %97 = icmp eq i1 %94, %96
  %98 = zext i1 %97 to i8
  store i8 %98, ptr %10, align 1
  %99 = load i8, ptr %10, align 1
  %100 = trunc i8 %99 to i1
  br i1 %100, label %101, label %115

101:                                              ; preds = %71
  %102 = getelementptr { ptr, i160 }, ptr %7, i32 0, i32 0
  %103 = load ptr, ptr %102, align 8
  store ptr %103, ptr %12, align 8
  %104 = getelementptr { ptr, i160 }, ptr %7, i32 0, i32 1
  %105 = load i160, ptr %104, align 4
  store i160 %105, ptr %11, align 4
  %106 = load ptr, ptr %12, align 8
  store ptr %106, ptr %14, align 8
  %107 = load i160, ptr %11, align 4
  store i160 %107, ptr %13, align 4
  %108 = load ptr, ptr %14, align 8
  %109 = insertvalue { ptr, i160 } undef, ptr %108, 0
  %110 = load i160, ptr %13, align 4
  %111 = insertvalue { ptr, i160 } %109, i160 %110, 1
  %112 = load ptr, ptr %30, align 8
  call void %112({ ptr, i160 } %111)
  %113 = load ptr, ptr %12, align 8
  store ptr %113, ptr %102, align 8
  %114 = load i160, ptr %11, align 4
  store i160 %114, ptr %104, align 4
  br label %115

115:                                              ; preds = %101, %71
  br i1 %100, label %71, label %116

116:                                              ; preds = %115
  ret void
}

define ptr @Iterable_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 14, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [25 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define { ptr, i160 } @Iterable_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, i160 } %3, { ptr } %4) {
  %6 = alloca [0 x ptr], align 8
  %7 = alloca {}, align 8
  %8 = alloca { ptr, i160 }, align 8
  %9 = alloca i1, align 1
  %10 = alloca i1, align 1
  %11 = alloca i1, align 1
  %12 = alloca i160, align 8
  %13 = alloca ptr, align 8
  %14 = alloca i160, align 8
  %15 = alloca ptr, align 8
  %16 = alloca i160, align 8
  %17 = alloca ptr, align 8
  %18 = alloca { ptr, i160 }, align 8
  %19 = alloca i160, align 8
  %20 = alloca ptr, align 8
  %21 = alloca i160, align 8
  %22 = alloca ptr, align 8
  %23 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %23, align 8
  %24 = alloca i32, align 4
  %25 = alloca ptr, align 8
  %26 = alloca ptr, align 8
  %27 = alloca ptr, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %23, i32 0, i32 0
  %29 = load ptr, ptr %28, align 8
  store ptr %29, ptr %27, align 8
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %23, i32 0, i32 1
  %31 = load ptr, ptr %30, align 8
  store ptr %31, ptr %26, align 8
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %23, i32 0, i32 2
  %33 = load ptr, ptr %32, align 8
  store ptr %33, ptr %25, align 8
  %34 = getelementptr { ptr, ptr, ptr, i32 }, ptr %23, i32 0, i32 3
  %35 = load i32, ptr %34, align 4
  store i32 %35, ptr %24, align 4
  %36 = load ptr, ptr %27, align 8
  %37 = call i32 @get_offset(ptr %36, ptr @Iterable)
  store i32 %37, ptr %24, align 4
  %38 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %3, ptr %38, align 8
  %39 = alloca i160, align 8
  %40 = alloca ptr, align 8
  %41 = getelementptr { ptr, i160 }, ptr %38, i32 0, i32 0
  %42 = load ptr, ptr %41, align 8
  store ptr %42, ptr %40, align 8
  %43 = getelementptr { ptr, i160 }, ptr %38, i32 0, i32 1
  %44 = load i160, ptr %43, align 4
  store i160 %44, ptr %39, align 4
  %45 = alloca ptr, align 8
  store { ptr } %4, ptr %45, align 8
  %46 = load ptr, ptr %27, align 8
  %47 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %46, 0
  %48 = load ptr, ptr %26, align 8
  %49 = insertvalue { ptr, ptr, ptr, i32 } %47, ptr %48, 1
  %50 = load ptr, ptr %25, align 8
  %51 = insertvalue { ptr, ptr, ptr, i32 } %49, ptr %50, 2
  %52 = load i32, ptr %24, align 4
  %53 = insertvalue { ptr, ptr, ptr, i32 } %51, i32 %52, 3
  %54 = alloca [0 x ptr], align 8
  %55 = call ptr @llvm.invariant.start.p0(i64 0, ptr %54)
  %56 = call ptr @llvm.invariant.start.p0(i64 200, ptr %46)
  %57 = getelementptr ptr, ptr %46, i32 %52
  %58 = getelementptr ptr, ptr %57, i32 1
  %59 = load ptr, ptr %58, align 8
  %60 = alloca {}, align 8
  %61 = call ptr @behavior_wrapper(ptr %59, { ptr, ptr, ptr, i32 } %53, ptr %60)
  %62 = call { ptr, ptr, ptr, i32 } %61({ ptr, ptr, ptr, i32 } %53, { ptr, ptr, ptr, i32 } %53, ptr %54)
  %63 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %62, ptr %63, align 8
  %64 = alloca i32, align 4
  %65 = alloca ptr, align 8
  %66 = alloca ptr, align 8
  %67 = alloca ptr, align 8
  %68 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 0
  %69 = load ptr, ptr %68, align 8
  store ptr %69, ptr %67, align 8
  %70 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 1
  %71 = load ptr, ptr %70, align 8
  store ptr %71, ptr %66, align 8
  %72 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 2
  %73 = load ptr, ptr %72, align 8
  store ptr %73, ptr %65, align 8
  %74 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 3
  %75 = load i32, ptr %74, align 4
  store i32 %75, ptr %64, align 4
  %76 = load ptr, ptr %67, align 8
  %77 = call i32 @get_offset(ptr %76, ptr @Iterator)
  store i32 %77, ptr %64, align 4
  %78 = alloca i32, align 4
  %79 = alloca ptr, align 8
  %80 = alloca ptr, align 8
  %81 = alloca ptr, align 8
  %82 = load ptr, ptr %67, align 8
  store ptr %82, ptr %81, align 8
  %83 = load ptr, ptr %66, align 8
  store ptr %83, ptr %80, align 8
  %84 = load ptr, ptr %65, align 8
  store ptr %84, ptr %79, align 8
  %85 = load i32, ptr %64, align 4
  store i32 %85, ptr %78, align 4
  br label %86

86:                                               ; preds = %143, %5
  %87 = load ptr, ptr %81, align 8
  %88 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %87, 0
  %89 = load ptr, ptr %80, align 8
  %90 = insertvalue { ptr, ptr, ptr, i32 } %88, ptr %89, 1
  %91 = load ptr, ptr %79, align 8
  %92 = insertvalue { ptr, ptr, ptr, i32 } %90, ptr %91, 2
  %93 = load i32, ptr %78, align 4
  %94 = insertvalue { ptr, ptr, ptr, i32 } %92, i32 %93, 3
  %95 = call ptr @llvm.invariant.start.p0(i64 0, ptr %6)
  %96 = call ptr @llvm.invariant.start.p0(i64 24, ptr %87)
  %97 = getelementptr ptr, ptr %87, i32 %93
  %98 = getelementptr ptr, ptr %97, i32 1
  %99 = load ptr, ptr %98, align 8
  %100 = call ptr @behavior_wrapper(ptr %99, { ptr, ptr, ptr, i32 } %94, ptr %7)
  %101 = call { ptr, i160 } %100({ ptr, ptr, ptr, i32 } %94, { ptr, ptr, ptr, i32 } %94, ptr %6)
  store { ptr, i160 } %101, ptr %8, align 8
  store i8 0, ptr %9, align 1
  %102 = load ptr, ptr %8, align 8
  %103 = ptrtoint ptr %102 to i64
  %104 = icmp eq i64 %103, ptrtoint (ptr @nil_typ to i64)
  %105 = icmp eq i64 %103, 0
  %106 = or i1 %104, %105
  %107 = zext i1 %106 to i8
  store i8 %107, ptr %10, align 1
  %108 = load i8, ptr %9, align 1
  %109 = trunc i8 %108 to i1
  %110 = load i8, ptr %10, align 1
  %111 = trunc i8 %110 to i1
  %112 = icmp eq i1 %109, %111
  %113 = zext i1 %112 to i8
  store i8 %113, ptr %11, align 1
  %114 = load i8, ptr %11, align 1
  %115 = trunc i8 %114 to i1
  br i1 %115, label %116, label %143

116:                                              ; preds = %86
  %117 = getelementptr { ptr, i160 }, ptr %8, i32 0, i32 0
  %118 = load ptr, ptr %117, align 8
  store ptr %118, ptr %13, align 8
  %119 = getelementptr { ptr, i160 }, ptr %8, i32 0, i32 1
  %120 = load i160, ptr %119, align 4
  store i160 %120, ptr %12, align 4
  %121 = load ptr, ptr %40, align 8
  store ptr %121, ptr %15, align 8
  %122 = load i160, ptr %39, align 4
  store i160 %122, ptr %14, align 4
  %123 = load ptr, ptr %15, align 8
  %124 = insertvalue { ptr, i160 } undef, ptr %123, 0
  %125 = load i160, ptr %14, align 4
  %126 = insertvalue { ptr, i160 } %124, i160 %125, 1
  %127 = load ptr, ptr %13, align 8
  store ptr %127, ptr %17, align 8
  %128 = load i160, ptr %12, align 4
  store i160 %128, ptr %16, align 4
  %129 = load ptr, ptr %17, align 8
  %130 = insertvalue { ptr, i160 } undef, ptr %129, 0
  %131 = load i160, ptr %16, align 4
  %132 = insertvalue { ptr, i160 } %130, i160 %131, 1
  %133 = load ptr, ptr %45, align 8
  %134 = call { ptr, i160 } %133({ ptr, i160 } %126, { ptr, i160 } %132)
  store { ptr, i160 } %134, ptr %18, align 8
  %135 = load ptr, ptr %13, align 8
  store ptr %135, ptr %117, align 8
  %136 = load i160, ptr %12, align 4
  store i160 %136, ptr %119, align 4
  %137 = getelementptr { ptr, i160 }, ptr %18, i32 0, i32 0
  %138 = load ptr, ptr %137, align 8
  store ptr %138, ptr %20, align 8
  %139 = getelementptr { ptr, i160 }, ptr %18, i32 0, i32 1
  %140 = load i160, ptr %139, align 4
  store i160 %140, ptr %19, align 4
  %141 = load ptr, ptr %20, align 8
  store ptr %141, ptr %40, align 8
  %142 = load i160, ptr %19, align 4
  store i160 %142, ptr %39, align 4
  br label %143

143:                                              ; preds = %116, %86
  br i1 %115, label %86, label %144

144:                                              ; preds = %143
  %145 = load ptr, ptr %40, align 8
  store ptr %145, ptr %22, align 8
  %146 = load i160, ptr %39, align 4
  store i160 %146, ptr %21, align 4
  %147 = load ptr, ptr %22, align 8
  %148 = insertvalue { ptr, i160 } undef, ptr %147, 0
  %149 = load i160, ptr %21, align 4
  %150 = insertvalue { ptr, i160 } %148, i160 %149, 1
  ret { ptr, i160 } %150
}

define ptr @Iterable_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @any_typ, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @any_typ to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = ptrtoint ptr %20 to i64
  %22 = icmp eq i64 %21, ptrtoint (ptr @function_typ to i64)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 15, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [25 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define i1 @Iterable_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr } %3) {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca {}, align 8
  %7 = alloca { ptr, i160 }, align 8
  %8 = alloca i1, align 1
  %9 = alloca i1, align 1
  %10 = alloca i1, align 1
  %11 = alloca i160, align 8
  %12 = alloca ptr, align 8
  %13 = alloca i1, align 1
  %14 = alloca i160, align 8
  %15 = alloca ptr, align 8
  %16 = alloca i1, align 1
  %17 = alloca i1, align 1
  %18 = alloca i1, align 1
  %19 = alloca i1, align 1
  %20 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %20, align 8
  %21 = alloca i32, align 4
  %22 = alloca ptr, align 8
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  store ptr %26, ptr %24, align 8
  %27 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 1
  %28 = load ptr, ptr %27, align 8
  store ptr %28, ptr %23, align 8
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 2
  %30 = load ptr, ptr %29, align 8
  store ptr %30, ptr %22, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 3
  %32 = load i32, ptr %31, align 4
  store i32 %32, ptr %21, align 4
  %33 = load ptr, ptr %24, align 8
  %34 = call i32 @get_offset(ptr %33, ptr @Iterable)
  store i32 %34, ptr %21, align 4
  %35 = alloca ptr, align 8
  store { ptr } %3, ptr %35, align 8
  %36 = load ptr, ptr %24, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %36, 0
  %38 = load ptr, ptr %23, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %38, 1
  %40 = load ptr, ptr %22, align 8
  %41 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %40, 2
  %42 = load i32, ptr %21, align 4
  %43 = insertvalue { ptr, ptr, ptr, i32 } %41, i32 %42, 3
  %44 = alloca [0 x ptr], align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 0, ptr %44)
  %46 = call ptr @llvm.invariant.start.p0(i64 200, ptr %36)
  %47 = getelementptr ptr, ptr %36, i32 %42
  %48 = getelementptr ptr, ptr %47, i32 1
  %49 = load ptr, ptr %48, align 8
  %50 = alloca {}, align 8
  %51 = call ptr @behavior_wrapper(ptr %49, { ptr, ptr, ptr, i32 } %43, ptr %50)
  %52 = call { ptr, ptr, ptr, i32 } %51({ ptr, ptr, ptr, i32 } %43, { ptr, ptr, ptr, i32 } %43, ptr %44)
  %53 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %52, ptr %53, align 8
  %54 = alloca i32, align 4
  %55 = alloca ptr, align 8
  %56 = alloca ptr, align 8
  %57 = alloca ptr, align 8
  %58 = getelementptr { ptr, ptr, ptr, i32 }, ptr %53, i32 0, i32 0
  %59 = load ptr, ptr %58, align 8
  store ptr %59, ptr %57, align 8
  %60 = getelementptr { ptr, ptr, ptr, i32 }, ptr %53, i32 0, i32 1
  %61 = load ptr, ptr %60, align 8
  store ptr %61, ptr %56, align 8
  %62 = getelementptr { ptr, ptr, ptr, i32 }, ptr %53, i32 0, i32 2
  %63 = load ptr, ptr %62, align 8
  store ptr %63, ptr %55, align 8
  %64 = getelementptr { ptr, ptr, ptr, i32 }, ptr %53, i32 0, i32 3
  %65 = load i32, ptr %64, align 4
  store i32 %65, ptr %54, align 4
  %66 = load ptr, ptr %57, align 8
  %67 = call i32 @get_offset(ptr %66, ptr @Iterator)
  store i32 %67, ptr %54, align 4
  %68 = alloca i32, align 4
  %69 = alloca ptr, align 8
  %70 = alloca ptr, align 8
  %71 = alloca ptr, align 8
  %72 = load ptr, ptr %57, align 8
  store ptr %72, ptr %71, align 8
  %73 = load ptr, ptr %56, align 8
  store ptr %73, ptr %70, align 8
  %74 = load ptr, ptr %55, align 8
  store ptr %74, ptr %69, align 8
  %75 = load i32, ptr %54, align 4
  store i32 %75, ptr %68, align 4
  br label %76

76:                                               ; preds = %142, %4
  %77 = load ptr, ptr %71, align 8
  %78 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %77, 0
  %79 = load ptr, ptr %70, align 8
  %80 = insertvalue { ptr, ptr, ptr, i32 } %78, ptr %79, 1
  %81 = load ptr, ptr %69, align 8
  %82 = insertvalue { ptr, ptr, ptr, i32 } %80, ptr %81, 2
  %83 = load i32, ptr %68, align 4
  %84 = insertvalue { ptr, ptr, ptr, i32 } %82, i32 %83, 3
  %85 = call ptr @llvm.invariant.start.p0(i64 0, ptr %5)
  %86 = call ptr @llvm.invariant.start.p0(i64 24, ptr %77)
  %87 = getelementptr ptr, ptr %77, i32 %83
  %88 = getelementptr ptr, ptr %87, i32 1
  %89 = load ptr, ptr %88, align 8
  %90 = call ptr @behavior_wrapper(ptr %89, { ptr, ptr, ptr, i32 } %84, ptr %6)
  %91 = call { ptr, i160 } %90({ ptr, ptr, ptr, i32 } %84, { ptr, ptr, ptr, i32 } %84, ptr %5)
  store { ptr, i160 } %91, ptr %7, align 8
  store i8 0, ptr %8, align 1
  %92 = load ptr, ptr %7, align 8
  %93 = ptrtoint ptr %92 to i64
  %94 = icmp eq i64 %93, ptrtoint (ptr @nil_typ to i64)
  %95 = icmp eq i64 %93, 0
  %96 = or i1 %94, %95
  %97 = zext i1 %96 to i8
  store i8 %97, ptr %9, align 1
  %98 = load i8, ptr %8, align 1
  %99 = trunc i8 %98 to i1
  %100 = load i8, ptr %9, align 1
  %101 = trunc i8 %100 to i1
  %102 = icmp eq i1 %99, %101
  %103 = zext i1 %102 to i8
  store i8 %103, ptr %10, align 1
  %104 = load i8, ptr %10, align 1
  %105 = trunc i8 %104 to i1
  %106 = xor i1 %105, true
  %107 = zext i1 %106 to i8
  %108 = select i1 %105, ptr %18, ptr %19
  br i1 %105, label %109, label %137

109:                                              ; preds = %76
  %110 = getelementptr { ptr, i160 }, ptr %7, i32 0, i32 0
  %111 = load ptr, ptr %110, align 8
  store ptr %111, ptr %12, align 8
  %112 = getelementptr { ptr, i160 }, ptr %7, i32 0, i32 1
  %113 = load i160, ptr %112, align 4
  store i160 %113, ptr %11, align 4
  store i8 0, ptr %13, align 1
  %114 = load ptr, ptr %12, align 8
  store ptr %114, ptr %15, align 8
  %115 = load i160, ptr %11, align 4
  store i160 %115, ptr %14, align 4
  %116 = load ptr, ptr %15, align 8
  %117 = insertvalue { ptr, i160 } undef, ptr %116, 0
  %118 = load i160, ptr %14, align 4
  %119 = insertvalue { ptr, i160 } %117, i160 %118, 1
  %120 = load ptr, ptr %35, align 8
  %121 = call i1 %120({ ptr, i160 } %119)
  %122 = zext i1 %121 to i8
  store i8 %122, ptr %16, align 1
  %123 = load i8, ptr %13, align 1
  %124 = trunc i8 %123 to i1
  %125 = load i8, ptr %16, align 1
  %126 = trunc i8 %125 to i1
  %127 = icmp eq i1 %124, %126
  %128 = zext i1 %127 to i8
  store i8 %128, ptr %17, align 1
  %129 = load i8, ptr %17, align 1
  %130 = trunc i8 %129 to i1
  %131 = xor i1 %130, true
  %132 = zext i1 %131 to i32
  br i1 %130, label %133, label %134

133:                                              ; preds = %109
  br label %137

134:                                              ; preds = %109
  %135 = load ptr, ptr %12, align 8
  store ptr %135, ptr %110, align 8
  %136 = load i160, ptr %11, align 4
  store i160 %136, ptr %112, align 4
  br label %137

137:                                              ; preds = %133, %134, %76
  %138 = phi i32 [ %132, %134 ], [ %132, %133 ], [ 0, %76 ]
  br label %139

139:                                              ; preds = %137
  br label %140

140:                                              ; preds = %139
  %141 = trunc i32 %138 to i1
  br i1 %141, label %142, label %143

142:                                              ; preds = %140
  br label %76

143:                                              ; preds = %140
  store i8 %107, ptr %108, align 1
  %144 = load i8, ptr %108, align 1
  %145 = trunc i8 %144 to i1
  ret i1 %145
}

define ptr @Iterable_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 16, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [25 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define i1 @Iterable_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr } %3) {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca {}, align 8
  %7 = alloca { ptr, i160 }, align 8
  %8 = alloca i1, align 1
  %9 = alloca i1, align 1
  %10 = alloca i1, align 1
  %11 = alloca i160, align 8
  %12 = alloca ptr, align 8
  %13 = alloca i160, align 8
  %14 = alloca ptr, align 8
  %15 = alloca i1, align 1
  %16 = alloca i1, align 1
  %17 = alloca i1, align 1
  %18 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %18, align 8
  %19 = alloca i32, align 4
  %20 = alloca ptr, align 8
  %21 = alloca ptr, align 8
  %22 = alloca ptr, align 8
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %18, i32 0, i32 0
  %24 = load ptr, ptr %23, align 8
  store ptr %24, ptr %22, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %18, i32 0, i32 1
  %26 = load ptr, ptr %25, align 8
  store ptr %26, ptr %21, align 8
  %27 = getelementptr { ptr, ptr, ptr, i32 }, ptr %18, i32 0, i32 2
  %28 = load ptr, ptr %27, align 8
  store ptr %28, ptr %20, align 8
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %18, i32 0, i32 3
  %30 = load i32, ptr %29, align 4
  store i32 %30, ptr %19, align 4
  %31 = load ptr, ptr %22, align 8
  %32 = call i32 @get_offset(ptr %31, ptr @Iterable)
  store i32 %32, ptr %19, align 4
  %33 = alloca ptr, align 8
  store { ptr } %3, ptr %33, align 8
  %34 = load ptr, ptr %22, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %34, 0
  %36 = load ptr, ptr %21, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %36, 1
  %38 = load ptr, ptr %20, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %38, 2
  %40 = load i32, ptr %19, align 4
  %41 = insertvalue { ptr, ptr, ptr, i32 } %39, i32 %40, 3
  %42 = alloca [0 x ptr], align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 0, ptr %42)
  %44 = call ptr @llvm.invariant.start.p0(i64 200, ptr %34)
  %45 = getelementptr ptr, ptr %34, i32 %40
  %46 = getelementptr ptr, ptr %45, i32 1
  %47 = load ptr, ptr %46, align 8
  %48 = alloca {}, align 8
  %49 = call ptr @behavior_wrapper(ptr %47, { ptr, ptr, ptr, i32 } %41, ptr %48)
  %50 = call { ptr, ptr, ptr, i32 } %49({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr %42)
  %51 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %50, ptr %51, align 8
  %52 = alloca i32, align 4
  %53 = alloca ptr, align 8
  %54 = alloca ptr, align 8
  %55 = alloca ptr, align 8
  %56 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 0
  %57 = load ptr, ptr %56, align 8
  store ptr %57, ptr %55, align 8
  %58 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 1
  %59 = load ptr, ptr %58, align 8
  store ptr %59, ptr %54, align 8
  %60 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 2
  %61 = load ptr, ptr %60, align 8
  store ptr %61, ptr %53, align 8
  %62 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 3
  %63 = load i32, ptr %62, align 4
  store i32 %63, ptr %52, align 4
  %64 = load ptr, ptr %55, align 8
  %65 = call i32 @get_offset(ptr %64, ptr @Iterator)
  store i32 %65, ptr %52, align 4
  %66 = alloca i32, align 4
  %67 = alloca ptr, align 8
  %68 = alloca ptr, align 8
  %69 = alloca ptr, align 8
  %70 = load ptr, ptr %55, align 8
  store ptr %70, ptr %69, align 8
  %71 = load ptr, ptr %54, align 8
  store ptr %71, ptr %68, align 8
  %72 = load ptr, ptr %53, align 8
  store ptr %72, ptr %67, align 8
  %73 = load i32, ptr %52, align 4
  store i32 %73, ptr %66, align 4
  br label %74

74:                                               ; preds = %133, %4
  %75 = load ptr, ptr %69, align 8
  %76 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %75, 0
  %77 = load ptr, ptr %68, align 8
  %78 = insertvalue { ptr, ptr, ptr, i32 } %76, ptr %77, 1
  %79 = load ptr, ptr %67, align 8
  %80 = insertvalue { ptr, ptr, ptr, i32 } %78, ptr %79, 2
  %81 = load i32, ptr %66, align 4
  %82 = insertvalue { ptr, ptr, ptr, i32 } %80, i32 %81, 3
  %83 = call ptr @llvm.invariant.start.p0(i64 0, ptr %5)
  %84 = call ptr @llvm.invariant.start.p0(i64 24, ptr %75)
  %85 = getelementptr ptr, ptr %75, i32 %81
  %86 = getelementptr ptr, ptr %85, i32 1
  %87 = load ptr, ptr %86, align 8
  %88 = call ptr @behavior_wrapper(ptr %87, { ptr, ptr, ptr, i32 } %82, ptr %6)
  %89 = call { ptr, i160 } %88({ ptr, ptr, ptr, i32 } %82, { ptr, ptr, ptr, i32 } %82, ptr %5)
  store { ptr, i160 } %89, ptr %7, align 8
  store i8 0, ptr %8, align 1
  %90 = load ptr, ptr %7, align 8
  %91 = ptrtoint ptr %90 to i64
  %92 = icmp eq i64 %91, ptrtoint (ptr @nil_typ to i64)
  %93 = icmp eq i64 %91, 0
  %94 = or i1 %92, %93
  %95 = zext i1 %94 to i8
  store i8 %95, ptr %9, align 1
  %96 = load i8, ptr %8, align 1
  %97 = trunc i8 %96 to i1
  %98 = load i8, ptr %9, align 1
  %99 = trunc i8 %98 to i1
  %100 = icmp eq i1 %97, %99
  %101 = zext i1 %100 to i8
  store i8 %101, ptr %10, align 1
  %102 = load i8, ptr %10, align 1
  %103 = trunc i8 %102 to i1
  %104 = zext i1 %103 to i8
  %105 = select i1 %103, ptr %16, ptr %17
  br i1 %103, label %106, label %128

106:                                              ; preds = %74
  %107 = getelementptr { ptr, i160 }, ptr %7, i32 0, i32 0
  %108 = load ptr, ptr %107, align 8
  store ptr %108, ptr %12, align 8
  %109 = getelementptr { ptr, i160 }, ptr %7, i32 0, i32 1
  %110 = load i160, ptr %109, align 4
  store i160 %110, ptr %11, align 4
  %111 = load ptr, ptr %12, align 8
  store ptr %111, ptr %14, align 8
  %112 = load i160, ptr %11, align 4
  store i160 %112, ptr %13, align 4
  %113 = load ptr, ptr %14, align 8
  %114 = insertvalue { ptr, i160 } undef, ptr %113, 0
  %115 = load i160, ptr %13, align 4
  %116 = insertvalue { ptr, i160 } %114, i160 %115, 1
  %117 = load ptr, ptr %33, align 8
  %118 = call i1 %117({ ptr, i160 } %116)
  %119 = zext i1 %118 to i8
  store i8 %119, ptr %15, align 1
  %120 = load i8, ptr %15, align 1
  %121 = trunc i8 %120 to i1
  %122 = xor i1 %121, true
  %123 = zext i1 %122 to i32
  br i1 %121, label %124, label %125

124:                                              ; preds = %106
  br label %128

125:                                              ; preds = %106
  %126 = load ptr, ptr %12, align 8
  store ptr %126, ptr %107, align 8
  %127 = load i160, ptr %11, align 4
  store i160 %127, ptr %109, align 4
  br label %128

128:                                              ; preds = %124, %125, %74
  %129 = phi i32 [ %123, %125 ], [ %123, %124 ], [ 0, %74 ]
  br label %130

130:                                              ; preds = %128
  br label %131

131:                                              ; preds = %130
  %132 = trunc i32 %129 to i1
  br i1 %132, label %133, label %134

133:                                              ; preds = %131
  br label %74

134:                                              ; preds = %131
  store i8 %104, ptr %105, align 1
  %135 = load i8, ptr %105, align 1
  %136 = trunc i8 %135 to i1
  ret i1 %136
}

define ptr @Iterable_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 17, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [25 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define { ptr, ptr, ptr, i32 } @Iterable_enumerate_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @Iterable)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 200, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = load ptr, ptr %23, align 8
  %25 = call ptr @typegetter_wrapper(ptr %24, ptr %19)
  %26 = load ptr, ptr %7, align 8
  %27 = load ptr, ptr %6, align 8
  %28 = call ptr @llvm.invariant.start.p0(i64 200, ptr %27)
  %29 = load i32, ptr %5, align 4
  %30 = getelementptr ptr, ptr %27, i32 %29
  %31 = load ptr, ptr %30, align 8
  %32 = call ptr @typegetter_wrapper(ptr %31, ptr %26)
  %33 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([4 x ptr], ptr null, i32 1) to i64))
  %34 = getelementptr [4 x ptr], ptr %33, i32 0, i32 2
  store ptr %32, ptr %34, align 8
  %35 = getelementptr [4 x ptr], ptr %33, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %35, align 8
  %36 = getelementptr [4 x ptr], ptr %33, i32 0, i32 3
  store ptr null, ptr %36, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 24, ptr %33)
  store ptr @Pair, ptr %33, align 8
  %38 = alloca [3 x ptr], align 8
  store ptr @Enumerated, ptr %38, align 8
  %39 = getelementptr ptr, ptr %38, i32 1
  store ptr %25, ptr %39, align 8
  %40 = getelementptr ptr, ptr %38, i32 2
  store ptr %33, ptr %40, align 8
  %41 = load ptr, ptr %38, align 8
  %42 = getelementptr ptr, ptr %41, i32 6
  %43 = load ptr, ptr %42, align 8
  %44 = call { i64, i64 } @size_wrapper(ptr %43, ptr %38)
  %45 = extractvalue { i64, i64 } %44, 0
  %46 = call ptr @bump_malloc(i64 %45)
  store ptr %25, ptr %46, align 8
  %47 = getelementptr ptr, ptr %46, i32 1
  store ptr %33, ptr %47, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 16, ptr %46)
  %49 = alloca i32, align 4
  %50 = alloca ptr, align 8
  %51 = alloca ptr, align 8
  %52 = alloca ptr, align 8
  store ptr @Enumerated, ptr %52, align 8
  store ptr %46, ptr %51, align 8
  store i32 10, ptr %49, align 4
  %53 = alloca i32, align 4
  %54 = alloca ptr, align 8
  %55 = alloca ptr, align 8
  %56 = alloca ptr, align 8
  %57 = load ptr, ptr %6, align 8
  store ptr %57, ptr %56, align 8
  %58 = load ptr, ptr %7, align 8
  store ptr %58, ptr %55, align 8
  %59 = load ptr, ptr %8, align 8
  store ptr %59, ptr %54, align 8
  %60 = load i32, ptr %5, align 4
  store i32 %60, ptr %53, align 4
  %61 = load ptr, ptr %56, align 8
  %62 = call i32 @get_offset(ptr %61, ptr @Iterable)
  store i32 %62, ptr %53, align 4
  %63 = load ptr, ptr %56, align 8
  %64 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %63, 0
  %65 = load ptr, ptr %55, align 8
  %66 = insertvalue { ptr, ptr, ptr, i32 } %64, ptr %65, 1
  %67 = load ptr, ptr %54, align 8
  %68 = insertvalue { ptr, ptr, ptr, i32 } %66, ptr %67, 2
  %69 = load i32, ptr %53, align 4
  %70 = insertvalue { ptr, ptr, ptr, i32 } %68, i32 %69, 3
  %71 = load ptr, ptr %52, align 8
  %72 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %71, 0
  %73 = load ptr, ptr %51, align 8
  %74 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr %73, 1
  %75 = load ptr, ptr %50, align 8
  %76 = insertvalue { ptr, ptr, ptr, i32 } %74, ptr %75, 2
  %77 = load i32, ptr %49, align 4
  %78 = insertvalue { ptr, ptr, ptr, i32 } %76, i32 %77, 3
  %79 = load ptr, ptr %7, align 8
  %80 = load ptr, ptr %6, align 8
  %81 = call ptr @llvm.invariant.start.p0(i64 200, ptr %80)
  %82 = load i32, ptr %5, align 4
  %83 = getelementptr ptr, ptr %80, i32 %82
  %84 = load ptr, ptr %83, align 8
  %85 = call ptr @typegetter_wrapper(ptr %84, ptr %79)
  %86 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %87 = getelementptr [3 x ptr], ptr %86, i32 0, i32 1
  store ptr %85, ptr %87, align 8
  %88 = getelementptr [3 x ptr], ptr %86, i32 0, i32 2
  store ptr null, ptr %88, align 8
  %89 = call ptr @llvm.invariant.start.p0(i64 16, ptr %86)
  store ptr @Iterable, ptr %86, align 8
  %90 = alloca [1 x ptr], align 8
  %91 = getelementptr [1 x ptr], ptr %90, i32 0, i32 0
  store ptr %86, ptr %91, align 8
  %92 = call ptr @llvm.invariant.start.p0(i64 1, ptr %90)
  %93 = call ptr @llvm.invariant.start.p0(i64 432, ptr %71)
  %94 = getelementptr ptr, ptr %71, i32 %77
  %95 = getelementptr ptr, ptr %94, i32 3
  %96 = load ptr, ptr %95, align 8
  %97 = alloca { ptr }, align 8
  %98 = getelementptr { ptr }, ptr %97, i32 0, i32 0
  store ptr %63, ptr %98, align 8
  %99 = call ptr @behavior_wrapper(ptr %96, { ptr, ptr, ptr, i32 } %78, ptr %97)
  call void %99({ ptr, ptr, ptr, i32 } %78, { ptr, ptr, ptr, i32 } %78, ptr %90, { ptr, ptr, ptr, i32 } %70)
  %100 = alloca i32, align 4
  %101 = alloca ptr, align 8
  %102 = alloca ptr, align 8
  %103 = alloca ptr, align 8
  %104 = load ptr, ptr %52, align 8
  store ptr %104, ptr %103, align 8
  %105 = load ptr, ptr %51, align 8
  store ptr %105, ptr %102, align 8
  %106 = load ptr, ptr %50, align 8
  store ptr %106, ptr %101, align 8
  %107 = load i32, ptr %49, align 4
  store i32 %107, ptr %100, align 4
  %108 = load ptr, ptr %103, align 8
  %109 = call i32 @get_offset(ptr %108, ptr @Iterable)
  store i32 %109, ptr %100, align 4
  %110 = load ptr, ptr %103, align 8
  %111 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %110, 0
  %112 = load ptr, ptr %102, align 8
  %113 = insertvalue { ptr, ptr, ptr, i32 } %111, ptr %112, 1
  %114 = load ptr, ptr %101, align 8
  %115 = insertvalue { ptr, ptr, ptr, i32 } %113, ptr %114, 2
  %116 = load i32, ptr %100, align 4
  %117 = insertvalue { ptr, ptr, ptr, i32 } %115, i32 %116, 3
  ret { ptr, ptr, ptr, i32 } %117
}

define ptr @Iterable_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 18, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [25 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { ptr, ptr, ptr, i32 } @Iterable_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr } %3) {
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %5, align 8
  %6 = alloca i32, align 4
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %7, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %8, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %9, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = call i32 @get_offset(ptr %18, ptr @Iterable)
  store i32 %19, ptr %6, align 4
  %20 = alloca ptr, align 8
  store { ptr } %3, ptr %20, align 8
  %21 = load ptr, ptr %8, align 8
  %22 = load ptr, ptr %7, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 200, ptr %22)
  %24 = load i32, ptr %6, align 4
  %25 = getelementptr ptr, ptr %22, i32 %24
  %26 = load ptr, ptr %25, align 8
  %27 = call ptr @typegetter_wrapper(ptr %26, ptr %21)
  %28 = load ptr, ptr %2, align 8
  %29 = getelementptr [1 x ptr], ptr %28, i32 0, i32 1
  %30 = load ptr, ptr %29, align 8
  %31 = alloca [3 x ptr], align 8
  store ptr @Mapped, ptr %31, align 8
  %32 = getelementptr ptr, ptr %31, i32 1
  store ptr %27, ptr %32, align 8
  %33 = getelementptr ptr, ptr %31, i32 2
  store ptr %30, ptr %33, align 8
  %34 = load ptr, ptr %31, align 8
  %35 = getelementptr ptr, ptr %34, i32 6
  %36 = load ptr, ptr %35, align 8
  %37 = call { i64, i64 } @size_wrapper(ptr %36, ptr %31)
  %38 = extractvalue { i64, i64 } %37, 0
  %39 = call ptr @bump_malloc(i64 %38)
  store ptr %27, ptr %39, align 8
  %40 = getelementptr ptr, ptr %39, i32 1
  store ptr %30, ptr %40, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 16, ptr %39)
  %42 = alloca i32, align 4
  %43 = alloca ptr, align 8
  %44 = alloca ptr, align 8
  %45 = alloca ptr, align 8
  store ptr @Mapped, ptr %45, align 8
  store ptr %39, ptr %44, align 8
  store i32 10, ptr %42, align 4
  %46 = alloca i32, align 4
  %47 = alloca ptr, align 8
  %48 = alloca ptr, align 8
  %49 = alloca ptr, align 8
  %50 = load ptr, ptr %7, align 8
  store ptr %50, ptr %49, align 8
  %51 = load ptr, ptr %8, align 8
  store ptr %51, ptr %48, align 8
  %52 = load ptr, ptr %9, align 8
  store ptr %52, ptr %47, align 8
  %53 = load i32, ptr %6, align 4
  store i32 %53, ptr %46, align 4
  %54 = load ptr, ptr %49, align 8
  %55 = call i32 @get_offset(ptr %54, ptr @Iterable)
  store i32 %55, ptr %46, align 4
  %56 = load ptr, ptr %49, align 8
  %57 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %56, 0
  %58 = load ptr, ptr %48, align 8
  %59 = insertvalue { ptr, ptr, ptr, i32 } %57, ptr %58, 1
  %60 = load ptr, ptr %47, align 8
  %61 = insertvalue { ptr, ptr, ptr, i32 } %59, ptr %60, 2
  %62 = load i32, ptr %46, align 4
  %63 = insertvalue { ptr, ptr, ptr, i32 } %61, i32 %62, 3
  %64 = load ptr, ptr %20, align 8
  %65 = insertvalue { ptr } undef, ptr %64, 0
  %66 = load ptr, ptr %45, align 8
  %67 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %66, 0
  %68 = load ptr, ptr %44, align 8
  %69 = insertvalue { ptr, ptr, ptr, i32 } %67, ptr %68, 1
  %70 = load ptr, ptr %43, align 8
  %71 = insertvalue { ptr, ptr, ptr, i32 } %69, ptr %70, 2
  %72 = load i32, ptr %42, align 4
  %73 = insertvalue { ptr, ptr, ptr, i32 } %71, i32 %72, 3
  %74 = load ptr, ptr %8, align 8
  %75 = load ptr, ptr %7, align 8
  %76 = call ptr @llvm.invariant.start.p0(i64 200, ptr %75)
  %77 = load i32, ptr %6, align 4
  %78 = getelementptr ptr, ptr %75, i32 %77
  %79 = load ptr, ptr %78, align 8
  %80 = call ptr @typegetter_wrapper(ptr %79, ptr %74)
  %81 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %82 = getelementptr [3 x ptr], ptr %81, i32 0, i32 1
  store ptr %80, ptr %82, align 8
  %83 = getelementptr [3 x ptr], ptr %81, i32 0, i32 2
  store ptr null, ptr %83, align 8
  %84 = call ptr @llvm.invariant.start.p0(i64 16, ptr %81)
  store ptr @Iterable, ptr %81, align 8
  %85 = load ptr, ptr %2, align 8
  %86 = getelementptr [1 x ptr], ptr %85, i32 0, i32 1
  %87 = load ptr, ptr %86, align 8
  %88 = load ptr, ptr %8, align 8
  %89 = load ptr, ptr %7, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 200, ptr %89)
  %91 = load i32, ptr %6, align 4
  %92 = getelementptr ptr, ptr %89, i32 %91
  %93 = load ptr, ptr %92, align 8
  %94 = call ptr @typegetter_wrapper(ptr %93, ptr %88)
  %95 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([4 x ptr], ptr null, i32 1) to i64))
  %96 = getelementptr [4 x ptr], ptr %95, i32 0, i32 2
  store ptr %94, ptr %96, align 8
  %97 = getelementptr [4 x ptr], ptr %95, i32 0, i32 1
  store ptr %87, ptr %97, align 8
  %98 = getelementptr [4 x ptr], ptr %95, i32 0, i32 3
  store ptr null, ptr %98, align 8
  %99 = call ptr @llvm.invariant.start.p0(i64 24, ptr %95)
  store ptr @function_typ, ptr %95, align 8
  %100 = alloca [2 x ptr], align 8
  %101 = getelementptr [2 x ptr], ptr %100, i32 0, i32 0
  store ptr %81, ptr %101, align 8
  %102 = getelementptr [2 x ptr], ptr %100, i32 0, i32 1
  store ptr %95, ptr %102, align 8
  %103 = call ptr @llvm.invariant.start.p0(i64 4, ptr %100)
  %104 = call ptr @llvm.invariant.start.p0(i64 440, ptr %66)
  %105 = getelementptr ptr, ptr %66, i32 %72
  %106 = getelementptr ptr, ptr %105, i32 4
  %107 = load ptr, ptr %106, align 8
  %108 = alloca { ptr, ptr }, align 8
  %109 = getelementptr { ptr, ptr }, ptr %108, i32 0, i32 0
  store ptr %56, ptr %109, align 8
  %110 = getelementptr { ptr, ptr }, ptr %108, i32 0, i32 1
  store ptr @function_typ, ptr %110, align 8
  %111 = call ptr @behavior_wrapper(ptr %107, { ptr, ptr, ptr, i32 } %73, ptr %108)
  call void %111({ ptr, ptr, ptr, i32 } %73, { ptr, ptr, ptr, i32 } %73, ptr %100, { ptr, ptr, ptr, i32 } %63, { ptr } %65)
  %112 = alloca i32, align 4
  %113 = alloca ptr, align 8
  %114 = alloca ptr, align 8
  %115 = alloca ptr, align 8
  %116 = load ptr, ptr %45, align 8
  store ptr %116, ptr %115, align 8
  %117 = load ptr, ptr %44, align 8
  store ptr %117, ptr %114, align 8
  %118 = load ptr, ptr %43, align 8
  store ptr %118, ptr %113, align 8
  %119 = load i32, ptr %42, align 4
  store i32 %119, ptr %112, align 4
  %120 = load ptr, ptr %115, align 8
  %121 = call i32 @get_offset(ptr %120, ptr @Iterable)
  store i32 %121, ptr %112, align 4
  %122 = load ptr, ptr %115, align 8
  %123 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %122, 0
  %124 = load ptr, ptr %114, align 8
  %125 = insertvalue { ptr, ptr, ptr, i32 } %123, ptr %124, 1
  %126 = load ptr, ptr %113, align 8
  %127 = insertvalue { ptr, ptr, ptr, i32 } %125, ptr %126, 2
  %128 = load i32, ptr %112, align 4
  %129 = insertvalue { ptr, ptr, ptr, i32 } %127, i32 %128, 3
  ret { ptr, ptr, ptr, i32 } %129
}

define ptr @Iterable_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 50, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [25 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define { ptr, ptr, ptr, i32 } @Iterable_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr } %3) {
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %5, align 8
  %6 = alloca i32, align 4
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %7, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %8, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %9, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = call i32 @get_offset(ptr %18, ptr @Iterable)
  store i32 %19, ptr %6, align 4
  %20 = alloca ptr, align 8
  store { ptr } %3, ptr %20, align 8
  %21 = load ptr, ptr %8, align 8
  %22 = load ptr, ptr %7, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 200, ptr %22)
  %24 = load i32, ptr %6, align 4
  %25 = getelementptr ptr, ptr %22, i32 %24
  %26 = load ptr, ptr %25, align 8
  %27 = call ptr @typegetter_wrapper(ptr %26, ptr %21)
  %28 = alloca [2 x ptr], align 8
  store ptr @Filtered, ptr %28, align 8
  %29 = getelementptr ptr, ptr %28, i32 1
  store ptr %27, ptr %29, align 8
  %30 = load ptr, ptr %28, align 8
  %31 = getelementptr ptr, ptr %30, i32 6
  %32 = load ptr, ptr %31, align 8
  %33 = call { i64, i64 } @size_wrapper(ptr %32, ptr %28)
  %34 = extractvalue { i64, i64 } %33, 0
  %35 = call ptr @bump_malloc(i64 %34)
  store ptr %27, ptr %35, align 8
  %36 = call ptr @llvm.invariant.start.p0(i64 8, ptr %35)
  %37 = alloca i32, align 4
  %38 = alloca ptr, align 8
  %39 = alloca ptr, align 8
  %40 = alloca ptr, align 8
  store ptr @Filtered, ptr %40, align 8
  store ptr %35, ptr %39, align 8
  store i32 10, ptr %37, align 4
  %41 = alloca i32, align 4
  %42 = alloca ptr, align 8
  %43 = alloca ptr, align 8
  %44 = alloca ptr, align 8
  %45 = load ptr, ptr %7, align 8
  store ptr %45, ptr %44, align 8
  %46 = load ptr, ptr %8, align 8
  store ptr %46, ptr %43, align 8
  %47 = load ptr, ptr %9, align 8
  store ptr %47, ptr %42, align 8
  %48 = load i32, ptr %6, align 4
  store i32 %48, ptr %41, align 4
  %49 = load ptr, ptr %44, align 8
  %50 = call i32 @get_offset(ptr %49, ptr @Iterable)
  store i32 %50, ptr %41, align 4
  %51 = load ptr, ptr %44, align 8
  %52 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %51, 0
  %53 = load ptr, ptr %43, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } %52, ptr %53, 1
  %55 = load ptr, ptr %42, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %55, 2
  %57 = load i32, ptr %41, align 4
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, i32 %57, 3
  %59 = load ptr, ptr %20, align 8
  %60 = insertvalue { ptr } undef, ptr %59, 0
  %61 = load ptr, ptr %40, align 8
  %62 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %61, 0
  %63 = load ptr, ptr %39, align 8
  %64 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %63, 1
  %65 = load ptr, ptr %38, align 8
  %66 = insertvalue { ptr, ptr, ptr, i32 } %64, ptr %65, 2
  %67 = load i32, ptr %37, align 4
  %68 = insertvalue { ptr, ptr, ptr, i32 } %66, i32 %67, 3
  %69 = load ptr, ptr %8, align 8
  %70 = load ptr, ptr %7, align 8
  %71 = call ptr @llvm.invariant.start.p0(i64 200, ptr %70)
  %72 = load i32, ptr %6, align 4
  %73 = getelementptr ptr, ptr %70, i32 %72
  %74 = load ptr, ptr %73, align 8
  %75 = call ptr @typegetter_wrapper(ptr %74, ptr %69)
  %76 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %77 = getelementptr [3 x ptr], ptr %76, i32 0, i32 1
  store ptr %75, ptr %77, align 8
  %78 = getelementptr [3 x ptr], ptr %76, i32 0, i32 2
  store ptr null, ptr %78, align 8
  %79 = call ptr @llvm.invariant.start.p0(i64 16, ptr %76)
  store ptr @Iterable, ptr %76, align 8
  %80 = load ptr, ptr %8, align 8
  %81 = load ptr, ptr %7, align 8
  %82 = call ptr @llvm.invariant.start.p0(i64 200, ptr %81)
  %83 = load i32, ptr %6, align 4
  %84 = getelementptr ptr, ptr %81, i32 %83
  %85 = load ptr, ptr %84, align 8
  %86 = call ptr @typegetter_wrapper(ptr %85, ptr %80)
  %87 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([4 x ptr], ptr null, i32 1) to i64))
  %88 = getelementptr [4 x ptr], ptr %87, i32 0, i32 2
  store ptr %86, ptr %88, align 8
  %89 = getelementptr [4 x ptr], ptr %87, i32 0, i32 1
  store ptr @_parameterization_Bool, ptr %89, align 8
  %90 = getelementptr [4 x ptr], ptr %87, i32 0, i32 3
  store ptr null, ptr %90, align 8
  %91 = call ptr @llvm.invariant.start.p0(i64 24, ptr %87)
  store ptr @function_typ, ptr %87, align 8
  %92 = alloca [2 x ptr], align 8
  %93 = getelementptr [2 x ptr], ptr %92, i32 0, i32 0
  store ptr %76, ptr %93, align 8
  %94 = getelementptr [2 x ptr], ptr %92, i32 0, i32 1
  store ptr %87, ptr %94, align 8
  %95 = call ptr @llvm.invariant.start.p0(i64 4, ptr %92)
  %96 = call ptr @llvm.invariant.start.p0(i64 432, ptr %61)
  %97 = getelementptr ptr, ptr %61, i32 %67
  %98 = getelementptr ptr, ptr %97, i32 3
  %99 = load ptr, ptr %98, align 8
  %100 = alloca { ptr, ptr }, align 8
  %101 = getelementptr { ptr, ptr }, ptr %100, i32 0, i32 0
  store ptr %51, ptr %101, align 8
  %102 = getelementptr { ptr, ptr }, ptr %100, i32 0, i32 1
  store ptr @function_typ, ptr %102, align 8
  %103 = call ptr @behavior_wrapper(ptr %99, { ptr, ptr, ptr, i32 } %68, ptr %100)
  call void %103({ ptr, ptr, ptr, i32 } %68, { ptr, ptr, ptr, i32 } %68, ptr %92, { ptr, ptr, ptr, i32 } %58, { ptr } %60)
  %104 = alloca i32, align 4
  %105 = alloca ptr, align 8
  %106 = alloca ptr, align 8
  %107 = alloca ptr, align 8
  %108 = load ptr, ptr %40, align 8
  store ptr %108, ptr %107, align 8
  %109 = load ptr, ptr %39, align 8
  store ptr %109, ptr %106, align 8
  %110 = load ptr, ptr %38, align 8
  store ptr %110, ptr %105, align 8
  %111 = load i32, ptr %37, align 4
  store i32 %111, ptr %104, align 4
  %112 = load ptr, ptr %107, align 8
  %113 = call i32 @get_offset(ptr %112, ptr @Iterable)
  store i32 %113, ptr %104, align 4
  %114 = load ptr, ptr %107, align 8
  %115 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %114, 0
  %116 = load ptr, ptr %106, align 8
  %117 = insertvalue { ptr, ptr, ptr, i32 } %115, ptr %116, 1
  %118 = load ptr, ptr %105, align 8
  %119 = insertvalue { ptr, ptr, ptr, i32 } %117, ptr %118, 2
  %120 = load i32, ptr %104, align 4
  %121 = insertvalue { ptr, ptr, ptr, i32 } %119, i32 %120, 3
  ret { ptr, ptr, ptr, i32 } %121
}

define ptr @Iterable_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 20, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [25 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define { ptr, ptr, ptr, i32 } @Iterable_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3) {
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %5, align 8
  %6 = alloca i32, align 4
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %7, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %8, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %9, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = call i32 @get_offset(ptr %18, ptr @Iterable)
  store i32 %19, ptr %6, align 4
  %20 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %20, align 8
  %21 = alloca i32, align 4
  %22 = alloca ptr, align 8
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  store ptr %26, ptr %24, align 8
  %27 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 1
  %28 = load ptr, ptr %27, align 8
  store ptr %28, ptr %23, align 8
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 2
  %30 = load ptr, ptr %29, align 8
  store ptr %30, ptr %22, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 3
  %32 = load i32, ptr %31, align 4
  store i32 %32, ptr %21, align 4
  %33 = load ptr, ptr %24, align 8
  %34 = call i32 @get_offset(ptr %33, ptr @Iterable)
  store i32 %34, ptr %21, align 4
  %35 = load ptr, ptr %8, align 8
  %36 = load ptr, ptr %7, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 200, ptr %36)
  %38 = load i32, ptr %6, align 4
  %39 = getelementptr ptr, ptr %36, i32 %38
  %40 = load ptr, ptr %39, align 8
  %41 = call ptr @typegetter_wrapper(ptr %40, ptr %35)
  %42 = alloca [2 x ptr], align 8
  store ptr @Chained, ptr %42, align 8
  %43 = getelementptr ptr, ptr %42, i32 1
  store ptr %41, ptr %43, align 8
  %44 = load ptr, ptr %42, align 8
  %45 = getelementptr ptr, ptr %44, i32 6
  %46 = load ptr, ptr %45, align 8
  %47 = call { i64, i64 } @size_wrapper(ptr %46, ptr %42)
  %48 = extractvalue { i64, i64 } %47, 0
  %49 = call ptr @bump_malloc(i64 %48)
  store ptr %41, ptr %49, align 8
  %50 = call ptr @llvm.invariant.start.p0(i64 8, ptr %49)
  %51 = alloca i32, align 4
  %52 = alloca ptr, align 8
  %53 = alloca ptr, align 8
  %54 = alloca ptr, align 8
  store ptr @Chained, ptr %54, align 8
  store ptr %49, ptr %53, align 8
  store i32 10, ptr %51, align 4
  %55 = alloca i32, align 4
  %56 = alloca ptr, align 8
  %57 = alloca ptr, align 8
  %58 = alloca ptr, align 8
  %59 = load ptr, ptr %7, align 8
  store ptr %59, ptr %58, align 8
  %60 = load ptr, ptr %8, align 8
  store ptr %60, ptr %57, align 8
  %61 = load ptr, ptr %9, align 8
  store ptr %61, ptr %56, align 8
  %62 = load i32, ptr %6, align 4
  store i32 %62, ptr %55, align 4
  %63 = load ptr, ptr %58, align 8
  %64 = call i32 @get_offset(ptr %63, ptr @Iterable)
  store i32 %64, ptr %55, align 4
  %65 = load ptr, ptr %58, align 8
  %66 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %65, 0
  %67 = load ptr, ptr %57, align 8
  %68 = insertvalue { ptr, ptr, ptr, i32 } %66, ptr %67, 1
  %69 = load ptr, ptr %56, align 8
  %70 = insertvalue { ptr, ptr, ptr, i32 } %68, ptr %69, 2
  %71 = load i32, ptr %55, align 4
  %72 = insertvalue { ptr, ptr, ptr, i32 } %70, i32 %71, 3
  %73 = alloca i32, align 4
  %74 = alloca ptr, align 8
  %75 = alloca ptr, align 8
  %76 = alloca ptr, align 8
  %77 = load ptr, ptr %24, align 8
  store ptr %77, ptr %76, align 8
  %78 = load ptr, ptr %23, align 8
  store ptr %78, ptr %75, align 8
  %79 = load ptr, ptr %22, align 8
  store ptr %79, ptr %74, align 8
  %80 = load i32, ptr %21, align 4
  store i32 %80, ptr %73, align 4
  %81 = load ptr, ptr %76, align 8
  %82 = call i32 @get_offset(ptr %81, ptr @Iterable)
  store i32 %82, ptr %73, align 4
  %83 = load ptr, ptr %76, align 8
  %84 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %83, 0
  %85 = load ptr, ptr %75, align 8
  %86 = insertvalue { ptr, ptr, ptr, i32 } %84, ptr %85, 1
  %87 = load ptr, ptr %74, align 8
  %88 = insertvalue { ptr, ptr, ptr, i32 } %86, ptr %87, 2
  %89 = load i32, ptr %73, align 4
  %90 = insertvalue { ptr, ptr, ptr, i32 } %88, i32 %89, 3
  %91 = load ptr, ptr %54, align 8
  %92 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %91, 0
  %93 = load ptr, ptr %53, align 8
  %94 = insertvalue { ptr, ptr, ptr, i32 } %92, ptr %93, 1
  %95 = load ptr, ptr %52, align 8
  %96 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr %95, 2
  %97 = load i32, ptr %51, align 4
  %98 = insertvalue { ptr, ptr, ptr, i32 } %96, i32 %97, 3
  %99 = load ptr, ptr %8, align 8
  %100 = load ptr, ptr %7, align 8
  %101 = call ptr @llvm.invariant.start.p0(i64 200, ptr %100)
  %102 = load i32, ptr %6, align 4
  %103 = getelementptr ptr, ptr %100, i32 %102
  %104 = load ptr, ptr %103, align 8
  %105 = call ptr @typegetter_wrapper(ptr %104, ptr %99)
  %106 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %107 = getelementptr [3 x ptr], ptr %106, i32 0, i32 1
  store ptr %105, ptr %107, align 8
  %108 = getelementptr [3 x ptr], ptr %106, i32 0, i32 2
  store ptr null, ptr %108, align 8
  %109 = call ptr @llvm.invariant.start.p0(i64 16, ptr %106)
  store ptr @Iterable, ptr %106, align 8
  %110 = load ptr, ptr %8, align 8
  %111 = load ptr, ptr %7, align 8
  %112 = call ptr @llvm.invariant.start.p0(i64 200, ptr %111)
  %113 = load i32, ptr %6, align 4
  %114 = getelementptr ptr, ptr %111, i32 %113
  %115 = load ptr, ptr %114, align 8
  %116 = call ptr @typegetter_wrapper(ptr %115, ptr %110)
  %117 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %118 = getelementptr [3 x ptr], ptr %117, i32 0, i32 1
  store ptr %116, ptr %118, align 8
  %119 = getelementptr [3 x ptr], ptr %117, i32 0, i32 2
  store ptr null, ptr %119, align 8
  %120 = call ptr @llvm.invariant.start.p0(i64 16, ptr %117)
  store ptr @Iterable, ptr %117, align 8
  %121 = alloca [2 x ptr], align 8
  %122 = getelementptr [2 x ptr], ptr %121, i32 0, i32 0
  store ptr %106, ptr %122, align 8
  %123 = getelementptr [2 x ptr], ptr %121, i32 0, i32 1
  store ptr %117, ptr %123, align 8
  %124 = call ptr @llvm.invariant.start.p0(i64 4, ptr %121)
  %125 = call ptr @llvm.invariant.start.p0(i64 432, ptr %91)
  %126 = getelementptr ptr, ptr %91, i32 %97
  %127 = getelementptr ptr, ptr %126, i32 3
  %128 = load ptr, ptr %127, align 8
  %129 = alloca { ptr, ptr }, align 8
  %130 = getelementptr { ptr, ptr }, ptr %129, i32 0, i32 0
  store ptr %65, ptr %130, align 8
  %131 = getelementptr { ptr, ptr }, ptr %129, i32 0, i32 1
  store ptr %83, ptr %131, align 8
  %132 = call ptr @behavior_wrapper(ptr %128, { ptr, ptr, ptr, i32 } %98, ptr %129)
  call void %132({ ptr, ptr, ptr, i32 } %98, { ptr, ptr, ptr, i32 } %98, ptr %121, { ptr, ptr, ptr, i32 } %72, { ptr, ptr, ptr, i32 } %90)
  %133 = alloca i32, align 4
  %134 = alloca ptr, align 8
  %135 = alloca ptr, align 8
  %136 = alloca ptr, align 8
  %137 = load ptr, ptr %54, align 8
  store ptr %137, ptr %136, align 8
  %138 = load ptr, ptr %53, align 8
  store ptr %138, ptr %135, align 8
  %139 = load ptr, ptr %52, align 8
  store ptr %139, ptr %134, align 8
  %140 = load i32, ptr %51, align 4
  store i32 %140, ptr %133, align 4
  %141 = load ptr, ptr %136, align 8
  %142 = call i32 @get_offset(ptr %141, ptr @Iterable)
  store i32 %142, ptr %133, align 4
  %143 = load ptr, ptr %136, align 8
  %144 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %143, 0
  %145 = load ptr, ptr %135, align 8
  %146 = insertvalue { ptr, ptr, ptr, i32 } %144, ptr %145, 1
  %147 = load ptr, ptr %134, align 8
  %148 = insertvalue { ptr, ptr, ptr, i32 } %146, ptr %147, 2
  %149 = load i32, ptr %133, align 4
  %150 = insertvalue { ptr, ptr, ptr, i32 } %148, i32 %149, 3
  ret { ptr, ptr, ptr, i32 } %150
}

define ptr @Iterable_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 21, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [25 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define { ptr, ptr, ptr, i32 } @Iterable_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3) {
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %5, align 8
  %6 = alloca i32, align 4
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %7, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %8, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %9, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = call i32 @get_offset(ptr %18, ptr @Iterable)
  store i32 %19, ptr %6, align 4
  %20 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %20, align 8
  %21 = alloca i32, align 4
  %22 = alloca ptr, align 8
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  store ptr %26, ptr %24, align 8
  %27 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 1
  %28 = load ptr, ptr %27, align 8
  store ptr %28, ptr %23, align 8
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 2
  %30 = load ptr, ptr %29, align 8
  store ptr %30, ptr %22, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 3
  %32 = load i32, ptr %31, align 4
  store i32 %32, ptr %21, align 4
  %33 = load ptr, ptr %24, align 8
  %34 = call i32 @get_offset(ptr %33, ptr @Iterable)
  store i32 %34, ptr %21, align 4
  %35 = load ptr, ptr %8, align 8
  %36 = load ptr, ptr %7, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 200, ptr %36)
  %38 = load i32, ptr %6, align 4
  %39 = getelementptr ptr, ptr %36, i32 %38
  %40 = load ptr, ptr %39, align 8
  %41 = call ptr @typegetter_wrapper(ptr %40, ptr %35)
  %42 = alloca [2 x ptr], align 8
  store ptr @Interleaved, ptr %42, align 8
  %43 = getelementptr ptr, ptr %42, i32 1
  store ptr %41, ptr %43, align 8
  %44 = load ptr, ptr %42, align 8
  %45 = getelementptr ptr, ptr %44, i32 6
  %46 = load ptr, ptr %45, align 8
  %47 = call { i64, i64 } @size_wrapper(ptr %46, ptr %42)
  %48 = extractvalue { i64, i64 } %47, 0
  %49 = call ptr @bump_malloc(i64 %48)
  store ptr %41, ptr %49, align 8
  %50 = call ptr @llvm.invariant.start.p0(i64 8, ptr %49)
  %51 = alloca i32, align 4
  %52 = alloca ptr, align 8
  %53 = alloca ptr, align 8
  %54 = alloca ptr, align 8
  store ptr @Interleaved, ptr %54, align 8
  store ptr %49, ptr %53, align 8
  store i32 10, ptr %51, align 4
  %55 = alloca i32, align 4
  %56 = alloca ptr, align 8
  %57 = alloca ptr, align 8
  %58 = alloca ptr, align 8
  %59 = load ptr, ptr %7, align 8
  store ptr %59, ptr %58, align 8
  %60 = load ptr, ptr %8, align 8
  store ptr %60, ptr %57, align 8
  %61 = load ptr, ptr %9, align 8
  store ptr %61, ptr %56, align 8
  %62 = load i32, ptr %6, align 4
  store i32 %62, ptr %55, align 4
  %63 = load ptr, ptr %58, align 8
  %64 = call i32 @get_offset(ptr %63, ptr @Iterable)
  store i32 %64, ptr %55, align 4
  %65 = load ptr, ptr %58, align 8
  %66 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %65, 0
  %67 = load ptr, ptr %57, align 8
  %68 = insertvalue { ptr, ptr, ptr, i32 } %66, ptr %67, 1
  %69 = load ptr, ptr %56, align 8
  %70 = insertvalue { ptr, ptr, ptr, i32 } %68, ptr %69, 2
  %71 = load i32, ptr %55, align 4
  %72 = insertvalue { ptr, ptr, ptr, i32 } %70, i32 %71, 3
  %73 = alloca i32, align 4
  %74 = alloca ptr, align 8
  %75 = alloca ptr, align 8
  %76 = alloca ptr, align 8
  %77 = load ptr, ptr %24, align 8
  store ptr %77, ptr %76, align 8
  %78 = load ptr, ptr %23, align 8
  store ptr %78, ptr %75, align 8
  %79 = load ptr, ptr %22, align 8
  store ptr %79, ptr %74, align 8
  %80 = load i32, ptr %21, align 4
  store i32 %80, ptr %73, align 4
  %81 = load ptr, ptr %76, align 8
  %82 = call i32 @get_offset(ptr %81, ptr @Iterable)
  store i32 %82, ptr %73, align 4
  %83 = load ptr, ptr %76, align 8
  %84 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %83, 0
  %85 = load ptr, ptr %75, align 8
  %86 = insertvalue { ptr, ptr, ptr, i32 } %84, ptr %85, 1
  %87 = load ptr, ptr %74, align 8
  %88 = insertvalue { ptr, ptr, ptr, i32 } %86, ptr %87, 2
  %89 = load i32, ptr %73, align 4
  %90 = insertvalue { ptr, ptr, ptr, i32 } %88, i32 %89, 3
  %91 = load ptr, ptr %54, align 8
  %92 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %91, 0
  %93 = load ptr, ptr %53, align 8
  %94 = insertvalue { ptr, ptr, ptr, i32 } %92, ptr %93, 1
  %95 = load ptr, ptr %52, align 8
  %96 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr %95, 2
  %97 = load i32, ptr %51, align 4
  %98 = insertvalue { ptr, ptr, ptr, i32 } %96, i32 %97, 3
  %99 = load ptr, ptr %8, align 8
  %100 = load ptr, ptr %7, align 8
  %101 = call ptr @llvm.invariant.start.p0(i64 200, ptr %100)
  %102 = load i32, ptr %6, align 4
  %103 = getelementptr ptr, ptr %100, i32 %102
  %104 = load ptr, ptr %103, align 8
  %105 = call ptr @typegetter_wrapper(ptr %104, ptr %99)
  %106 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %107 = getelementptr [3 x ptr], ptr %106, i32 0, i32 1
  store ptr %105, ptr %107, align 8
  %108 = getelementptr [3 x ptr], ptr %106, i32 0, i32 2
  store ptr null, ptr %108, align 8
  %109 = call ptr @llvm.invariant.start.p0(i64 16, ptr %106)
  store ptr @Iterable, ptr %106, align 8
  %110 = load ptr, ptr %8, align 8
  %111 = load ptr, ptr %7, align 8
  %112 = call ptr @llvm.invariant.start.p0(i64 200, ptr %111)
  %113 = load i32, ptr %6, align 4
  %114 = getelementptr ptr, ptr %111, i32 %113
  %115 = load ptr, ptr %114, align 8
  %116 = call ptr @typegetter_wrapper(ptr %115, ptr %110)
  %117 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %118 = getelementptr [3 x ptr], ptr %117, i32 0, i32 1
  store ptr %116, ptr %118, align 8
  %119 = getelementptr [3 x ptr], ptr %117, i32 0, i32 2
  store ptr null, ptr %119, align 8
  %120 = call ptr @llvm.invariant.start.p0(i64 16, ptr %117)
  store ptr @Iterable, ptr %117, align 8
  %121 = alloca [2 x ptr], align 8
  %122 = getelementptr [2 x ptr], ptr %121, i32 0, i32 0
  store ptr %106, ptr %122, align 8
  %123 = getelementptr [2 x ptr], ptr %121, i32 0, i32 1
  store ptr %117, ptr %123, align 8
  %124 = call ptr @llvm.invariant.start.p0(i64 4, ptr %121)
  %125 = call ptr @llvm.invariant.start.p0(i64 432, ptr %91)
  %126 = getelementptr ptr, ptr %91, i32 %97
  %127 = getelementptr ptr, ptr %126, i32 3
  %128 = load ptr, ptr %127, align 8
  %129 = alloca { ptr, ptr }, align 8
  %130 = getelementptr { ptr, ptr }, ptr %129, i32 0, i32 0
  store ptr %65, ptr %130, align 8
  %131 = getelementptr { ptr, ptr }, ptr %129, i32 0, i32 1
  store ptr %83, ptr %131, align 8
  %132 = call ptr @behavior_wrapper(ptr %128, { ptr, ptr, ptr, i32 } %98, ptr %129)
  call void %132({ ptr, ptr, ptr, i32 } %98, { ptr, ptr, ptr, i32 } %98, ptr %121, { ptr, ptr, ptr, i32 } %72, { ptr, ptr, ptr, i32 } %90)
  %133 = alloca i32, align 4
  %134 = alloca ptr, align 8
  %135 = alloca ptr, align 8
  %136 = alloca ptr, align 8
  %137 = load ptr, ptr %54, align 8
  store ptr %137, ptr %136, align 8
  %138 = load ptr, ptr %53, align 8
  store ptr %138, ptr %135, align 8
  %139 = load ptr, ptr %52, align 8
  store ptr %139, ptr %134, align 8
  %140 = load i32, ptr %51, align 4
  store i32 %140, ptr %133, align 4
  %141 = load ptr, ptr %136, align 8
  %142 = call i32 @get_offset(ptr %141, ptr @Iterable)
  store i32 %142, ptr %133, align 4
  %143 = load ptr, ptr %136, align 8
  %144 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %143, 0
  %145 = load ptr, ptr %135, align 8
  %146 = insertvalue { ptr, ptr, ptr, i32 } %144, ptr %145, 1
  %147 = load ptr, ptr %134, align 8
  %148 = insertvalue { ptr, ptr, ptr, i32 } %146, ptr %147, 2
  %149 = load i32, ptr %133, align 4
  %150 = insertvalue { ptr, ptr, ptr, i32 } %148, i32 %149, 3
  ret { ptr, ptr, ptr, i32 } %150
}

define ptr @Iterable_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 22, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [25 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define { ptr, ptr, ptr, i32 } @Iterable_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3) {
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %5, align 8
  %6 = alloca i32, align 4
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %7, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %8, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %9, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = call i32 @get_offset(ptr %18, ptr @Iterable)
  store i32 %19, ptr %6, align 4
  %20 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %20, align 8
  %21 = alloca i32, align 4
  %22 = alloca ptr, align 8
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  store ptr %26, ptr %24, align 8
  %27 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 1
  %28 = load ptr, ptr %27, align 8
  store ptr %28, ptr %23, align 8
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 2
  %30 = load ptr, ptr %29, align 8
  store ptr %30, ptr %22, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 3
  %32 = load i32, ptr %31, align 4
  store i32 %32, ptr %21, align 4
  %33 = load ptr, ptr %24, align 8
  %34 = call i32 @get_offset(ptr %33, ptr @Iterable)
  store i32 %34, ptr %21, align 4
  %35 = load ptr, ptr %8, align 8
  %36 = load ptr, ptr %7, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 200, ptr %36)
  %38 = load i32, ptr %6, align 4
  %39 = getelementptr ptr, ptr %36, i32 %38
  %40 = load ptr, ptr %39, align 8
  %41 = call ptr @typegetter_wrapper(ptr %40, ptr %35)
  %42 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %42, align 8
  %43 = getelementptr { ptr, ptr, ptr, i32 }, ptr %42, i32 0, i32 1
  %44 = load ptr, ptr %43, align 8
  %45 = load ptr, ptr %42, align 8
  %46 = call ptr @llvm.invariant.start.p0(i64 200, ptr %45)
  %47 = getelementptr { ptr, ptr, ptr, i32 }, ptr %42, i32 0, i32 3
  %48 = load i32, ptr %47, align 4
  %49 = getelementptr ptr, ptr %45, i32 %48
  %50 = load ptr, ptr %49, align 8
  %51 = call ptr @typegetter_wrapper(ptr %50, ptr %44)
  %52 = load ptr, ptr %8, align 8
  %53 = load ptr, ptr %7, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 200, ptr %53)
  %55 = load i32, ptr %6, align 4
  %56 = getelementptr ptr, ptr %53, i32 %55
  %57 = load ptr, ptr %56, align 8
  %58 = call ptr @typegetter_wrapper(ptr %57, ptr %52)
  %59 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %59, align 8
  %60 = getelementptr { ptr, ptr, ptr, i32 }, ptr %59, i32 0, i32 1
  %61 = load ptr, ptr %60, align 8
  %62 = load ptr, ptr %59, align 8
  %63 = call ptr @llvm.invariant.start.p0(i64 200, ptr %62)
  %64 = getelementptr { ptr, ptr, ptr, i32 }, ptr %59, i32 0, i32 3
  %65 = load i32, ptr %64, align 4
  %66 = getelementptr ptr, ptr %62, i32 %65
  %67 = load ptr, ptr %66, align 8
  %68 = call ptr @typegetter_wrapper(ptr %67, ptr %61)
  %69 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([4 x ptr], ptr null, i32 1) to i64))
  %70 = getelementptr [4 x ptr], ptr %69, i32 0, i32 2
  store ptr %68, ptr %70, align 8
  %71 = getelementptr [4 x ptr], ptr %69, i32 0, i32 1
  store ptr %58, ptr %71, align 8
  %72 = getelementptr [4 x ptr], ptr %69, i32 0, i32 3
  store ptr null, ptr %72, align 8
  %73 = call ptr @llvm.invariant.start.p0(i64 24, ptr %69)
  store ptr @Pair, ptr %69, align 8
  %74 = alloca [4 x ptr], align 8
  store ptr @Zipped, ptr %74, align 8
  %75 = getelementptr ptr, ptr %74, i32 1
  store ptr %41, ptr %75, align 8
  %76 = getelementptr ptr, ptr %74, i32 2
  store ptr %51, ptr %76, align 8
  %77 = getelementptr ptr, ptr %74, i32 3
  store ptr %69, ptr %77, align 8
  %78 = load ptr, ptr %74, align 8
  %79 = getelementptr ptr, ptr %78, i32 6
  %80 = load ptr, ptr %79, align 8
  %81 = call { i64, i64 } @size_wrapper(ptr %80, ptr %74)
  %82 = extractvalue { i64, i64 } %81, 0
  %83 = call ptr @bump_malloc(i64 %82)
  store ptr %41, ptr %83, align 8
  %84 = getelementptr ptr, ptr %83, i32 1
  store ptr %51, ptr %84, align 8
  %85 = getelementptr ptr, ptr %83, i32 2
  store ptr %69, ptr %85, align 8
  %86 = call ptr @llvm.invariant.start.p0(i64 24, ptr %83)
  %87 = alloca i32, align 4
  %88 = alloca ptr, align 8
  %89 = alloca ptr, align 8
  %90 = alloca ptr, align 8
  store ptr @Zipped, ptr %90, align 8
  store ptr %83, ptr %89, align 8
  store i32 10, ptr %87, align 4
  %91 = alloca i32, align 4
  %92 = alloca ptr, align 8
  %93 = alloca ptr, align 8
  %94 = alloca ptr, align 8
  %95 = load ptr, ptr %7, align 8
  store ptr %95, ptr %94, align 8
  %96 = load ptr, ptr %8, align 8
  store ptr %96, ptr %93, align 8
  %97 = load ptr, ptr %9, align 8
  store ptr %97, ptr %92, align 8
  %98 = load i32, ptr %6, align 4
  store i32 %98, ptr %91, align 4
  %99 = load ptr, ptr %94, align 8
  %100 = call i32 @get_offset(ptr %99, ptr @Iterable)
  store i32 %100, ptr %91, align 4
  %101 = load ptr, ptr %94, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %101, 0
  %103 = load ptr, ptr %93, align 8
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, ptr %103, 1
  %105 = load ptr, ptr %92, align 8
  %106 = insertvalue { ptr, ptr, ptr, i32 } %104, ptr %105, 2
  %107 = load i32, ptr %91, align 4
  %108 = insertvalue { ptr, ptr, ptr, i32 } %106, i32 %107, 3
  %109 = alloca i32, align 4
  %110 = alloca ptr, align 8
  %111 = alloca ptr, align 8
  %112 = alloca ptr, align 8
  %113 = load ptr, ptr %24, align 8
  store ptr %113, ptr %112, align 8
  %114 = load ptr, ptr %23, align 8
  store ptr %114, ptr %111, align 8
  %115 = load ptr, ptr %22, align 8
  store ptr %115, ptr %110, align 8
  %116 = load i32, ptr %21, align 4
  store i32 %116, ptr %109, align 4
  %117 = load ptr, ptr %112, align 8
  %118 = call i32 @get_offset(ptr %117, ptr @Iterable)
  store i32 %118, ptr %109, align 4
  %119 = load ptr, ptr %112, align 8
  %120 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %119, 0
  %121 = load ptr, ptr %111, align 8
  %122 = insertvalue { ptr, ptr, ptr, i32 } %120, ptr %121, 1
  %123 = load ptr, ptr %110, align 8
  %124 = insertvalue { ptr, ptr, ptr, i32 } %122, ptr %123, 2
  %125 = load i32, ptr %109, align 4
  %126 = insertvalue { ptr, ptr, ptr, i32 } %124, i32 %125, 3
  %127 = load ptr, ptr %90, align 8
  %128 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %127, 0
  %129 = load ptr, ptr %89, align 8
  %130 = insertvalue { ptr, ptr, ptr, i32 } %128, ptr %129, 1
  %131 = load ptr, ptr %88, align 8
  %132 = insertvalue { ptr, ptr, ptr, i32 } %130, ptr %131, 2
  %133 = load i32, ptr %87, align 4
  %134 = insertvalue { ptr, ptr, ptr, i32 } %132, i32 %133, 3
  %135 = load ptr, ptr %8, align 8
  %136 = load ptr, ptr %7, align 8
  %137 = call ptr @llvm.invariant.start.p0(i64 200, ptr %136)
  %138 = load i32, ptr %6, align 4
  %139 = getelementptr ptr, ptr %136, i32 %138
  %140 = load ptr, ptr %139, align 8
  %141 = call ptr @typegetter_wrapper(ptr %140, ptr %135)
  %142 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %143 = getelementptr [3 x ptr], ptr %142, i32 0, i32 1
  store ptr %141, ptr %143, align 8
  %144 = getelementptr [3 x ptr], ptr %142, i32 0, i32 2
  store ptr null, ptr %144, align 8
  %145 = call ptr @llvm.invariant.start.p0(i64 16, ptr %142)
  store ptr @Iterable, ptr %142, align 8
  %146 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %146, align 8
  %147 = getelementptr { ptr, ptr, ptr, i32 }, ptr %146, i32 0, i32 1
  %148 = load ptr, ptr %147, align 8
  %149 = load ptr, ptr %146, align 8
  %150 = call ptr @llvm.invariant.start.p0(i64 200, ptr %149)
  %151 = getelementptr { ptr, ptr, ptr, i32 }, ptr %146, i32 0, i32 3
  %152 = load i32, ptr %151, align 4
  %153 = getelementptr ptr, ptr %149, i32 %152
  %154 = load ptr, ptr %153, align 8
  %155 = call ptr @typegetter_wrapper(ptr %154, ptr %148)
  %156 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %157 = getelementptr [3 x ptr], ptr %156, i32 0, i32 1
  store ptr %155, ptr %157, align 8
  %158 = getelementptr [3 x ptr], ptr %156, i32 0, i32 2
  store ptr null, ptr %158, align 8
  %159 = call ptr @llvm.invariant.start.p0(i64 16, ptr %156)
  store ptr @Iterable, ptr %156, align 8
  %160 = alloca [2 x ptr], align 8
  %161 = getelementptr [2 x ptr], ptr %160, i32 0, i32 0
  store ptr %142, ptr %161, align 8
  %162 = getelementptr [2 x ptr], ptr %160, i32 0, i32 1
  store ptr %156, ptr %162, align 8
  %163 = call ptr @llvm.invariant.start.p0(i64 4, ptr %160)
  %164 = call ptr @llvm.invariant.start.p0(i64 448, ptr %127)
  %165 = getelementptr ptr, ptr %127, i32 %133
  %166 = getelementptr ptr, ptr %165, i32 5
  %167 = load ptr, ptr %166, align 8
  %168 = alloca { ptr, ptr }, align 8
  %169 = getelementptr { ptr, ptr }, ptr %168, i32 0, i32 0
  store ptr %101, ptr %169, align 8
  %170 = getelementptr { ptr, ptr }, ptr %168, i32 0, i32 1
  store ptr %119, ptr %170, align 8
  %171 = call ptr @behavior_wrapper(ptr %167, { ptr, ptr, ptr, i32 } %134, ptr %168)
  call void %171({ ptr, ptr, ptr, i32 } %134, { ptr, ptr, ptr, i32 } %134, ptr %160, { ptr, ptr, ptr, i32 } %108, { ptr, ptr, ptr, i32 } %126)
  %172 = alloca i32, align 4
  %173 = alloca ptr, align 8
  %174 = alloca ptr, align 8
  %175 = alloca ptr, align 8
  %176 = load ptr, ptr %90, align 8
  store ptr %176, ptr %175, align 8
  %177 = load ptr, ptr %89, align 8
  store ptr %177, ptr %174, align 8
  %178 = load ptr, ptr %88, align 8
  store ptr %178, ptr %173, align 8
  %179 = load i32, ptr %87, align 4
  store i32 %179, ptr %172, align 4
  %180 = load ptr, ptr %175, align 8
  %181 = call i32 @get_offset(ptr %180, ptr @Iterable)
  store i32 %181, ptr %172, align 4
  %182 = load ptr, ptr %175, align 8
  %183 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %182, 0
  %184 = load ptr, ptr %174, align 8
  %185 = insertvalue { ptr, ptr, ptr, i32 } %183, ptr %184, 1
  %186 = load ptr, ptr %173, align 8
  %187 = insertvalue { ptr, ptr, ptr, i32 } %185, ptr %186, 2
  %188 = load i32, ptr %172, align 4
  %189 = insertvalue { ptr, ptr, ptr, i32 } %187, i32 %188, 3
  ret { ptr, ptr, ptr, i32 } %189
}

define ptr @Iterable_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 52, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [25 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define { ptr, ptr, ptr, i32 } @Iterable_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3) {
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %5, align 8
  %6 = alloca i32, align 4
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %7, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %8, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %9, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = call i32 @get_offset(ptr %18, ptr @Iterable)
  store i32 %19, ptr %6, align 4
  %20 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %20, align 8
  %21 = alloca i32, align 4
  %22 = alloca ptr, align 8
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  store ptr %26, ptr %24, align 8
  %27 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 1
  %28 = load ptr, ptr %27, align 8
  store ptr %28, ptr %23, align 8
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 2
  %30 = load ptr, ptr %29, align 8
  store ptr %30, ptr %22, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 3
  %32 = load i32, ptr %31, align 4
  store i32 %32, ptr %21, align 4
  %33 = load ptr, ptr %24, align 8
  %34 = call i32 @get_offset(ptr %33, ptr @Iterable)
  store i32 %34, ptr %21, align 4
  %35 = load ptr, ptr %8, align 8
  %36 = load ptr, ptr %7, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 200, ptr %36)
  %38 = load i32, ptr %6, align 4
  %39 = getelementptr ptr, ptr %36, i32 %38
  %40 = load ptr, ptr %39, align 8
  %41 = call ptr @typegetter_wrapper(ptr %40, ptr %35)
  %42 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %42, align 8
  %43 = getelementptr { ptr, ptr, ptr, i32 }, ptr %42, i32 0, i32 1
  %44 = load ptr, ptr %43, align 8
  %45 = load ptr, ptr %42, align 8
  %46 = call ptr @llvm.invariant.start.p0(i64 200, ptr %45)
  %47 = getelementptr { ptr, ptr, ptr, i32 }, ptr %42, i32 0, i32 3
  %48 = load i32, ptr %47, align 4
  %49 = getelementptr ptr, ptr %45, i32 %48
  %50 = load ptr, ptr %49, align 8
  %51 = call ptr @typegetter_wrapper(ptr %50, ptr %44)
  %52 = load ptr, ptr %8, align 8
  %53 = load ptr, ptr %7, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 200, ptr %53)
  %55 = load i32, ptr %6, align 4
  %56 = getelementptr ptr, ptr %53, i32 %55
  %57 = load ptr, ptr %56, align 8
  %58 = call ptr @typegetter_wrapper(ptr %57, ptr %52)
  %59 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %59, align 8
  %60 = getelementptr { ptr, ptr, ptr, i32 }, ptr %59, i32 0, i32 1
  %61 = load ptr, ptr %60, align 8
  %62 = load ptr, ptr %59, align 8
  %63 = call ptr @llvm.invariant.start.p0(i64 200, ptr %62)
  %64 = getelementptr { ptr, ptr, ptr, i32 }, ptr %59, i32 0, i32 3
  %65 = load i32, ptr %64, align 4
  %66 = getelementptr ptr, ptr %62, i32 %65
  %67 = load ptr, ptr %66, align 8
  %68 = call ptr @typegetter_wrapper(ptr %67, ptr %61)
  %69 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([4 x ptr], ptr null, i32 1) to i64))
  %70 = getelementptr [4 x ptr], ptr %69, i32 0, i32 2
  store ptr %68, ptr %70, align 8
  %71 = getelementptr [4 x ptr], ptr %69, i32 0, i32 1
  store ptr %58, ptr %71, align 8
  %72 = getelementptr [4 x ptr], ptr %69, i32 0, i32 3
  store ptr null, ptr %72, align 8
  %73 = call ptr @llvm.invariant.start.p0(i64 24, ptr %69)
  store ptr @Pair, ptr %69, align 8
  %74 = alloca [4 x ptr], align 8
  store ptr @Products, ptr %74, align 8
  %75 = getelementptr ptr, ptr %74, i32 1
  store ptr %41, ptr %75, align 8
  %76 = getelementptr ptr, ptr %74, i32 2
  store ptr %51, ptr %76, align 8
  %77 = getelementptr ptr, ptr %74, i32 3
  store ptr %69, ptr %77, align 8
  %78 = load ptr, ptr %74, align 8
  %79 = getelementptr ptr, ptr %78, i32 6
  %80 = load ptr, ptr %79, align 8
  %81 = call { i64, i64 } @size_wrapper(ptr %80, ptr %74)
  %82 = extractvalue { i64, i64 } %81, 0
  %83 = call ptr @bump_malloc(i64 %82)
  store ptr %41, ptr %83, align 8
  %84 = getelementptr ptr, ptr %83, i32 1
  store ptr %51, ptr %84, align 8
  %85 = getelementptr ptr, ptr %83, i32 2
  store ptr %69, ptr %85, align 8
  %86 = call ptr @llvm.invariant.start.p0(i64 24, ptr %83)
  %87 = alloca i32, align 4
  %88 = alloca ptr, align 8
  %89 = alloca ptr, align 8
  %90 = alloca ptr, align 8
  store ptr @Products, ptr %90, align 8
  store ptr %83, ptr %89, align 8
  store i32 10, ptr %87, align 4
  %91 = alloca i32, align 4
  %92 = alloca ptr, align 8
  %93 = alloca ptr, align 8
  %94 = alloca ptr, align 8
  %95 = load ptr, ptr %7, align 8
  store ptr %95, ptr %94, align 8
  %96 = load ptr, ptr %8, align 8
  store ptr %96, ptr %93, align 8
  %97 = load ptr, ptr %9, align 8
  store ptr %97, ptr %92, align 8
  %98 = load i32, ptr %6, align 4
  store i32 %98, ptr %91, align 4
  %99 = load ptr, ptr %94, align 8
  %100 = call i32 @get_offset(ptr %99, ptr @Iterable)
  store i32 %100, ptr %91, align 4
  %101 = load ptr, ptr %94, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %101, 0
  %103 = load ptr, ptr %93, align 8
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, ptr %103, 1
  %105 = load ptr, ptr %92, align 8
  %106 = insertvalue { ptr, ptr, ptr, i32 } %104, ptr %105, 2
  %107 = load i32, ptr %91, align 4
  %108 = insertvalue { ptr, ptr, ptr, i32 } %106, i32 %107, 3
  %109 = alloca i32, align 4
  %110 = alloca ptr, align 8
  %111 = alloca ptr, align 8
  %112 = alloca ptr, align 8
  %113 = load ptr, ptr %24, align 8
  store ptr %113, ptr %112, align 8
  %114 = load ptr, ptr %23, align 8
  store ptr %114, ptr %111, align 8
  %115 = load ptr, ptr %22, align 8
  store ptr %115, ptr %110, align 8
  %116 = load i32, ptr %21, align 4
  store i32 %116, ptr %109, align 4
  %117 = load ptr, ptr %112, align 8
  %118 = call i32 @get_offset(ptr %117, ptr @Iterable)
  store i32 %118, ptr %109, align 4
  %119 = load ptr, ptr %112, align 8
  %120 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %119, 0
  %121 = load ptr, ptr %111, align 8
  %122 = insertvalue { ptr, ptr, ptr, i32 } %120, ptr %121, 1
  %123 = load ptr, ptr %110, align 8
  %124 = insertvalue { ptr, ptr, ptr, i32 } %122, ptr %123, 2
  %125 = load i32, ptr %109, align 4
  %126 = insertvalue { ptr, ptr, ptr, i32 } %124, i32 %125, 3
  %127 = load ptr, ptr %90, align 8
  %128 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %127, 0
  %129 = load ptr, ptr %89, align 8
  %130 = insertvalue { ptr, ptr, ptr, i32 } %128, ptr %129, 1
  %131 = load ptr, ptr %88, align 8
  %132 = insertvalue { ptr, ptr, ptr, i32 } %130, ptr %131, 2
  %133 = load i32, ptr %87, align 4
  %134 = insertvalue { ptr, ptr, ptr, i32 } %132, i32 %133, 3
  %135 = load ptr, ptr %8, align 8
  %136 = load ptr, ptr %7, align 8
  %137 = call ptr @llvm.invariant.start.p0(i64 200, ptr %136)
  %138 = load i32, ptr %6, align 4
  %139 = getelementptr ptr, ptr %136, i32 %138
  %140 = load ptr, ptr %139, align 8
  %141 = call ptr @typegetter_wrapper(ptr %140, ptr %135)
  %142 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %143 = getelementptr [3 x ptr], ptr %142, i32 0, i32 1
  store ptr %141, ptr %143, align 8
  %144 = getelementptr [3 x ptr], ptr %142, i32 0, i32 2
  store ptr null, ptr %144, align 8
  %145 = call ptr @llvm.invariant.start.p0(i64 16, ptr %142)
  store ptr @Iterable, ptr %142, align 8
  %146 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %146, align 8
  %147 = getelementptr { ptr, ptr, ptr, i32 }, ptr %146, i32 0, i32 1
  %148 = load ptr, ptr %147, align 8
  %149 = load ptr, ptr %146, align 8
  %150 = call ptr @llvm.invariant.start.p0(i64 200, ptr %149)
  %151 = getelementptr { ptr, ptr, ptr, i32 }, ptr %146, i32 0, i32 3
  %152 = load i32, ptr %151, align 4
  %153 = getelementptr ptr, ptr %149, i32 %152
  %154 = load ptr, ptr %153, align 8
  %155 = call ptr @typegetter_wrapper(ptr %154, ptr %148)
  %156 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %157 = getelementptr [3 x ptr], ptr %156, i32 0, i32 1
  store ptr %155, ptr %157, align 8
  %158 = getelementptr [3 x ptr], ptr %156, i32 0, i32 2
  store ptr null, ptr %158, align 8
  %159 = call ptr @llvm.invariant.start.p0(i64 16, ptr %156)
  store ptr @Iterable, ptr %156, align 8
  %160 = alloca [2 x ptr], align 8
  %161 = getelementptr [2 x ptr], ptr %160, i32 0, i32 0
  store ptr %142, ptr %161, align 8
  %162 = getelementptr [2 x ptr], ptr %160, i32 0, i32 1
  store ptr %156, ptr %162, align 8
  %163 = call ptr @llvm.invariant.start.p0(i64 4, ptr %160)
  %164 = call ptr @llvm.invariant.start.p0(i64 448, ptr %127)
  %165 = getelementptr ptr, ptr %127, i32 %133
  %166 = getelementptr ptr, ptr %165, i32 5
  %167 = load ptr, ptr %166, align 8
  %168 = alloca { ptr, ptr }, align 8
  %169 = getelementptr { ptr, ptr }, ptr %168, i32 0, i32 0
  store ptr %101, ptr %169, align 8
  %170 = getelementptr { ptr, ptr }, ptr %168, i32 0, i32 1
  store ptr %119, ptr %170, align 8
  %171 = call ptr @behavior_wrapper(ptr %167, { ptr, ptr, ptr, i32 } %134, ptr %168)
  call void %171({ ptr, ptr, ptr, i32 } %134, { ptr, ptr, ptr, i32 } %134, ptr %160, { ptr, ptr, ptr, i32 } %108, { ptr, ptr, ptr, i32 } %126)
  %172 = alloca i32, align 4
  %173 = alloca ptr, align 8
  %174 = alloca ptr, align 8
  %175 = alloca ptr, align 8
  %176 = load ptr, ptr %90, align 8
  store ptr %176, ptr %175, align 8
  %177 = load ptr, ptr %89, align 8
  store ptr %177, ptr %174, align 8
  %178 = load ptr, ptr %88, align 8
  store ptr %178, ptr %173, align 8
  %179 = load i32, ptr %87, align 4
  store i32 %179, ptr %172, align 4
  %180 = load ptr, ptr %175, align 8
  %181 = call i32 @get_offset(ptr %180, ptr @Iterable)
  store i32 %181, ptr %172, align 4
  %182 = load ptr, ptr %175, align 8
  %183 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %182, 0
  %184 = load ptr, ptr %174, align 8
  %185 = insertvalue { ptr, ptr, ptr, i32 } %183, ptr %184, 1
  %186 = load ptr, ptr %173, align 8
  %187 = insertvalue { ptr, ptr, ptr, i32 } %185, ptr %186, 2
  %188 = load i32, ptr %172, align 4
  %189 = insertvalue { ptr, ptr, ptr, i32 } %187, i32 %188, 3
  ret { ptr, ptr, ptr, i32 } %189
}

define ptr @Iterable_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 53, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [25 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define { i64, i64 } @_data_size_ConstantTimeIterator(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %3
  %5 = icmp eq i64 %4, 0
  %6 = sub i64 %3, %4
  %7 = select i1 %5, i64 0, i64 %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = insertvalue { i64, i64 } undef, i64 %8, 0
  %10 = insertvalue { i64, i64 } %9, i64 %3, 1
  ret { i64, i64 } %10
}

define ptr @ConstantTimeIterator_field_ConstantTimeIterator_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define ptr @ConstantTimeIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 2, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [6 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { i64, i64 } @_data_size_CoroIterator(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %10
  %12 = urem i64 %11, %5
  %13 = icmp eq i64 %12, 0
  %14 = sub i64 %5, %12
  %15 = select i1 %13, i64 0, i64 %14
  %16 = add i64 %11, %15
  %17 = insertvalue { i64, i64 } undef, i64 %16, 0
  %18 = insertvalue { i64, i64 } %17, i64 %5, 1
  ret { i64, i64 } %18
}

define ptr @CoroIterator_field_CoroIterator_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define { ptr } @CoroIterator_getter_coro(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = getelementptr i8, ptr %0, i64 %6
  %8 = getelementptr { ptr }, ptr %7, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr } undef, ptr %9, 0
  ret { ptr } %10
}

define void @CoroIterator_setter_coro(ptr %0, { ptr } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = getelementptr i8, ptr %0, i64 %7
  %9 = alloca ptr, align 8
  store { ptr } %1, ptr %9, align 8
  %10 = getelementptr { ptr }, ptr %8, i32 0, i32 0
  %11 = load ptr, ptr %9, align 8
  store ptr %11, ptr %10, align 8
  ret void
}

define void @CoroIterator_init_coroCoroutine_to_Nothing({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr } %3) {
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %5, align 8
  %6 = alloca i32, align 4
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %7, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %8, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %9, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = call i32 @get_offset(ptr %18, ptr @CoroIterator)
  store i32 %19, ptr %6, align 4
  %20 = alloca ptr, align 8
  store { ptr } %3, ptr %20, align 8
  %21 = load ptr, ptr %8, align 8
  %22 = load ptr, ptr %7, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 72, ptr %22)
  %24 = load i32, ptr %6, align 4
  %25 = getelementptr ptr, ptr %22, i32 %24
  %26 = getelementptr ptr, ptr %25, i32 1
  %27 = load ptr, ptr %26, align 8
  %28 = getelementptr { ptr, ptr }, ptr %27, i32 0, i32 1
  %29 = load ptr, ptr %28, align 8
  %30 = load ptr, ptr %20, align 8
  %31 = insertvalue { ptr } undef, ptr %30, 0
  call void %29(ptr %21, { ptr } %31) #2
  ret void
}

define ptr @CoroIterator_B_init_coroCoroutine_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @coroutine_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 4, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [9 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define { ptr, i160 } @CoroIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @CoroIterator)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 72, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 1
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr { ptr, ptr }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = call { ptr } %27(ptr %19) #1
  %29 = alloca ptr, align 8
  store { ptr } %28, ptr %29, align 8
  %30 = load ptr, ptr %29, align 8
  call void @coroutine_call(ptr %30)
  %31 = getelementptr { ptr, [3 x ptr], ptr, i1, { ptr, i160 } }, ptr %30, i32 0, i32 4
  %32 = getelementptr { ptr, i160 }, ptr %31, i32 0, i32 0
  %33 = load ptr, ptr %32, align 8
  %34 = insertvalue { ptr, i160 } undef, ptr %33, 0
  %35 = getelementptr { ptr, i160 }, ptr %31, i32 0, i32 1
  %36 = load i160, ptr %35, align 4
  %37 = insertvalue { ptr, i160 } %34, i160 %36, 1
  %38 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %37, ptr %38, align 8
  %39 = getelementptr { ptr, i160 }, ptr %38, i32 0, i32 0
  %40 = load ptr, ptr %39, align 8
  %41 = insertvalue { ptr, i160 } undef, ptr %40, 0
  %42 = getelementptr { ptr, i160 }, ptr %38, i32 0, i32 1
  %43 = load i160, ptr %42, align 4
  %44 = insertvalue { ptr, i160 } %41, i160 %43, 1
  ret { ptr, i160 } %44
}

define ptr @CoroIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 5, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [9 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { i64, i64 } @_data_size_Enumerated(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %10
  %12 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %5
  %13 = select i1 %12, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %5
  %14 = urem i64 %11, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %17
  %19 = add i64 %11, %18
  %20 = urem i64 %19, %13
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 %13, %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = add i64 %19, %23
  %25 = insertvalue { i64, i64 } undef, i64 %24, 0
  %26 = insertvalue { i64, i64 } %25, i64 %13, 1
  ret { i64, i64 } %26
}

define ptr @Enumerated_field_Enumerated_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define ptr @Enumerated_field_Enumerated_1(ptr %0) {
  %2 = getelementptr ptr, ptr %0, i32 1
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

define { ptr, ptr, ptr, i32 } @Enumerated_getter_iterable(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %7, %11
  %13 = getelementptr i8, ptr %0, i64 %12
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %15, 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 1
  %18 = load ptr, ptr %17, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %18, 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 2
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %21, 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 3
  %24 = load i32, ptr %23, align 4
  %25 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %24, 3
  ret { ptr, ptr, ptr, i32 } %25
}

define void @Enumerated_setter_iterable(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %8, %12
  %14 = getelementptr i8, ptr %0, i64 %13
  %15 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %15, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 0
  %18 = load ptr, ptr %16, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 1
  %21 = load ptr, ptr %19, align 8
  store ptr %21, ptr %20, align 8
  %22 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 2
  %24 = load ptr, ptr %22, align 8
  store ptr %24, ptr %23, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 3
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 3
  %27 = load i32, ptr %25, align 4
  store i32 %27, ptr %26, align 4
  ret void
}

define void @Enumerated_init_iterableIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3) {
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %5, align 8
  %6 = alloca i32, align 4
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %7, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %8, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %9, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = call i32 @get_offset(ptr %18, ptr @Enumerated)
  store i32 %19, ptr %6, align 4
  %20 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %20, align 8
  %21 = alloca i32, align 4
  %22 = alloca ptr, align 8
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  store ptr %26, ptr %24, align 8
  %27 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 1
  %28 = load ptr, ptr %27, align 8
  store ptr %28, ptr %23, align 8
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 2
  %30 = load ptr, ptr %29, align 8
  store ptr %30, ptr %22, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 3
  %32 = load i32, ptr %31, align 4
  store i32 %32, ptr %21, align 4
  %33 = load ptr, ptr %24, align 8
  %34 = call i32 @get_offset(ptr %33, ptr @Iterable)
  store i32 %34, ptr %21, align 4
  %35 = alloca i32, align 4
  %36 = alloca ptr, align 8
  %37 = alloca ptr, align 8
  %38 = alloca ptr, align 8
  %39 = load ptr, ptr %24, align 8
  store ptr %39, ptr %38, align 8
  %40 = load ptr, ptr %23, align 8
  store ptr %40, ptr %37, align 8
  %41 = load ptr, ptr %22, align 8
  store ptr %41, ptr %36, align 8
  %42 = load i32, ptr %21, align 4
  store i32 %42, ptr %35, align 4
  %43 = load ptr, ptr %38, align 8
  %44 = call i32 @get_offset(ptr %43, ptr @Iterable)
  store i32 %44, ptr %35, align 4
  %45 = load ptr, ptr %8, align 8
  %46 = load ptr, ptr %7, align 8
  %47 = call ptr @llvm.invariant.start.p0(i64 432, ptr %46)
  %48 = load i32, ptr %6, align 4
  %49 = getelementptr ptr, ptr %46, i32 %48
  %50 = getelementptr ptr, ptr %49, i32 2
  %51 = load ptr, ptr %50, align 8
  %52 = getelementptr { ptr, ptr }, ptr %51, i32 0, i32 1
  %53 = load ptr, ptr %52, align 8
  %54 = load ptr, ptr %38, align 8
  %55 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %54, 0
  %56 = load ptr, ptr %37, align 8
  %57 = insertvalue { ptr, ptr, ptr, i32 } %55, ptr %56, 1
  %58 = load ptr, ptr %36, align 8
  %59 = insertvalue { ptr, ptr, ptr, i32 } %57, ptr %58, 2
  %60 = load i32, ptr %35, align 4
  %61 = insertvalue { ptr, ptr, ptr, i32 } %59, i32 %60, 3
  call void %53(ptr %45, { ptr, ptr, ptr, i32 } %61) #2
  ret void
}

define ptr @Enumerated_B_init_iterableIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 16, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [54 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define { ptr, ptr, ptr, i32 } @Enumerated_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @Enumerated)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 432, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 2
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr { ptr, ptr }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = call { ptr, ptr, ptr, i32 } %27(ptr %19) #1
  %29 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %28, ptr %29, align 8
  call void @assume_offset(ptr %29, ptr @Iterable)
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 1
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %34, 1
  %36 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 2
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %37, 2
  %39 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 3
  %40 = load i32, ptr %39, align 4
  %41 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %40, 3
  %42 = alloca [0 x ptr], align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 0, ptr %42)
  %44 = call ptr @llvm.invariant.start.p0(i64 200, ptr %31)
  %45 = getelementptr ptr, ptr %31, i32 %40
  %46 = getelementptr ptr, ptr %45, i32 1
  %47 = load ptr, ptr %46, align 8
  %48 = alloca {}, align 8
  %49 = call ptr @behavior_wrapper(ptr %47, { ptr, ptr, ptr, i32 } %41, ptr %48)
  %50 = call { ptr, ptr, ptr, i32 } %49({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr %42)
  %51 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %50, ptr %51, align 8
  %52 = alloca i32, align 4
  %53 = alloca ptr, align 8
  %54 = alloca ptr, align 8
  %55 = alloca ptr, align 8
  %56 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 0
  %57 = load ptr, ptr %56, align 8
  store ptr %57, ptr %53, align 8
  %58 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 1
  %59 = load ptr, ptr %58, align 8
  store ptr %59, ptr %55, align 8
  %60 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 2
  %61 = load ptr, ptr %60, align 8
  store ptr %61, ptr %54, align 8
  %62 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 3
  %63 = load i32, ptr %62, align 4
  store i32 %63, ptr %52, align 4
  %64 = load ptr, ptr %53, align 8
  %65 = call i32 @get_offset(ptr %64, ptr @Iterator)
  store i32 %65, ptr %52, align 4
  %66 = load ptr, ptr %7, align 8
  %67 = load ptr, ptr %6, align 8
  %68 = call ptr @llvm.invariant.start.p0(i64 432, ptr %67)
  %69 = load i32, ptr %5, align 4
  %70 = getelementptr ptr, ptr %67, i32 %69
  %71 = load ptr, ptr %70, align 8
  %72 = call ptr @typegetter_wrapper(ptr %71, ptr %66)
  %73 = load ptr, ptr %7, align 8
  %74 = load ptr, ptr %6, align 8
  %75 = call ptr @llvm.invariant.start.p0(i64 432, ptr %74)
  %76 = load i32, ptr %5, align 4
  %77 = getelementptr ptr, ptr %74, i32 %76
  %78 = load ptr, ptr %77, align 8
  %79 = call ptr @typegetter_wrapper(ptr %78, ptr %73)
  %80 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([4 x ptr], ptr null, i32 1) to i64))
  %81 = getelementptr [4 x ptr], ptr %80, i32 0, i32 2
  store ptr %79, ptr %81, align 8
  %82 = getelementptr [4 x ptr], ptr %80, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %82, align 8
  %83 = getelementptr [4 x ptr], ptr %80, i32 0, i32 3
  store ptr null, ptr %83, align 8
  %84 = call ptr @llvm.invariant.start.p0(i64 24, ptr %80)
  store ptr @Pair, ptr %80, align 8
  %85 = alloca [3 x ptr], align 8
  store ptr @Enumerator, ptr %85, align 8
  %86 = getelementptr ptr, ptr %85, i32 1
  store ptr %72, ptr %86, align 8
  %87 = getelementptr ptr, ptr %85, i32 2
  store ptr %80, ptr %87, align 8
  %88 = load ptr, ptr %85, align 8
  %89 = getelementptr ptr, ptr %88, i32 6
  %90 = load ptr, ptr %89, align 8
  %91 = call { i64, i64 } @size_wrapper(ptr %90, ptr %85)
  %92 = extractvalue { i64, i64 } %91, 0
  %93 = call ptr @bump_malloc(i64 %92)
  store ptr %72, ptr %93, align 8
  %94 = getelementptr ptr, ptr %93, i32 1
  store ptr %80, ptr %94, align 8
  %95 = call ptr @llvm.invariant.start.p0(i64 16, ptr %93)
  %96 = alloca i32, align 4
  %97 = alloca ptr, align 8
  %98 = alloca ptr, align 8
  %99 = alloca ptr, align 8
  store ptr @Enumerator, ptr %99, align 8
  store ptr %93, ptr %98, align 8
  store i32 10, ptr %96, align 4
  %100 = load ptr, ptr %7, align 8
  %101 = load ptr, ptr %6, align 8
  %102 = call ptr @llvm.invariant.start.p0(i64 432, ptr %101)
  %103 = load i32, ptr %5, align 4
  %104 = getelementptr ptr, ptr %101, i32 %103
  %105 = getelementptr ptr, ptr %104, i32 2
  %106 = load ptr, ptr %105, align 8
  %107 = getelementptr { ptr, ptr }, ptr %106, i32 0, i32 0
  %108 = load ptr, ptr %107, align 8
  %109 = call { ptr, ptr, ptr, i32 } %108(ptr %100) #1
  %110 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %109, ptr %110, align 8
  call void @assume_offset(ptr %110, ptr @Iterable)
  %111 = getelementptr { ptr, ptr, ptr, i32 }, ptr %110, i32 0, i32 0
  %112 = load ptr, ptr %111, align 8
  %113 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %112, 0
  %114 = getelementptr { ptr, ptr, ptr, i32 }, ptr %110, i32 0, i32 1
  %115 = load ptr, ptr %114, align 8
  %116 = insertvalue { ptr, ptr, ptr, i32 } %113, ptr %115, 1
  %117 = getelementptr { ptr, ptr, ptr, i32 }, ptr %110, i32 0, i32 2
  %118 = load ptr, ptr %117, align 8
  %119 = insertvalue { ptr, ptr, ptr, i32 } %116, ptr %118, 2
  %120 = getelementptr { ptr, ptr, ptr, i32 }, ptr %110, i32 0, i32 3
  %121 = load i32, ptr %120, align 4
  %122 = insertvalue { ptr, ptr, ptr, i32 } %119, i32 %121, 3
  %123 = alloca [0 x ptr], align 8
  %124 = call ptr @llvm.invariant.start.p0(i64 0, ptr %123)
  %125 = call ptr @llvm.invariant.start.p0(i64 200, ptr %112)
  %126 = getelementptr ptr, ptr %112, i32 %121
  %127 = getelementptr ptr, ptr %126, i32 1
  %128 = load ptr, ptr %127, align 8
  %129 = alloca {}, align 8
  %130 = call ptr @behavior_wrapper(ptr %128, { ptr, ptr, ptr, i32 } %122, ptr %129)
  %131 = call { ptr, ptr, ptr, i32 } %130({ ptr, ptr, ptr, i32 } %122, { ptr, ptr, ptr, i32 } %122, ptr %123)
  %132 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %131, ptr %132, align 8
  %133 = alloca i32, align 4
  %134 = alloca ptr, align 8
  %135 = alloca ptr, align 8
  %136 = alloca ptr, align 8
  %137 = getelementptr { ptr, ptr, ptr, i32 }, ptr %132, i32 0, i32 0
  %138 = load ptr, ptr %137, align 8
  store ptr %138, ptr %136, align 8
  %139 = getelementptr { ptr, ptr, ptr, i32 }, ptr %132, i32 0, i32 1
  %140 = load ptr, ptr %139, align 8
  store ptr %140, ptr %135, align 8
  %141 = getelementptr { ptr, ptr, ptr, i32 }, ptr %132, i32 0, i32 2
  %142 = load ptr, ptr %141, align 8
  store ptr %142, ptr %134, align 8
  %143 = getelementptr { ptr, ptr, ptr, i32 }, ptr %132, i32 0, i32 3
  %144 = load i32, ptr %143, align 4
  store i32 %144, ptr %133, align 4
  %145 = load ptr, ptr %136, align 8
  %146 = call i32 @get_offset(ptr %145, ptr @Iterator)
  store i32 %146, ptr %133, align 4
  %147 = alloca i32, align 4
  %148 = alloca ptr, align 8
  %149 = alloca ptr, align 8
  %150 = alloca ptr, align 8
  %151 = load ptr, ptr %136, align 8
  store ptr %151, ptr %150, align 8
  %152 = load ptr, ptr %135, align 8
  store ptr %152, ptr %149, align 8
  %153 = load ptr, ptr %134, align 8
  store ptr %153, ptr %148, align 8
  %154 = load i32, ptr %133, align 4
  store i32 %154, ptr %147, align 4
  %155 = load ptr, ptr %150, align 8
  %156 = call i32 @get_offset(ptr %155, ptr @Iterator)
  store i32 %156, ptr %147, align 4
  %157 = load ptr, ptr %150, align 8
  %158 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %157, 0
  %159 = load ptr, ptr %149, align 8
  %160 = insertvalue { ptr, ptr, ptr, i32 } %158, ptr %159, 1
  %161 = load ptr, ptr %148, align 8
  %162 = insertvalue { ptr, ptr, ptr, i32 } %160, ptr %161, 2
  %163 = load i32, ptr %147, align 4
  %164 = insertvalue { ptr, ptr, ptr, i32 } %162, i32 %163, 3
  %165 = load ptr, ptr %99, align 8
  %166 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %165, 0
  %167 = load ptr, ptr %98, align 8
  %168 = insertvalue { ptr, ptr, ptr, i32 } %166, ptr %167, 1
  %169 = load ptr, ptr %97, align 8
  %170 = insertvalue { ptr, ptr, ptr, i32 } %168, ptr %169, 2
  %171 = load i32, ptr %96, align 4
  %172 = insertvalue { ptr, ptr, ptr, i32 } %170, i32 %171, 3
  %173 = load ptr, ptr %7, align 8
  %174 = load ptr, ptr %6, align 8
  %175 = call ptr @llvm.invariant.start.p0(i64 432, ptr %174)
  %176 = load i32, ptr %5, align 4
  %177 = getelementptr ptr, ptr %174, i32 %176
  %178 = load ptr, ptr %177, align 8
  %179 = call ptr @typegetter_wrapper(ptr %178, ptr %173)
  %180 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %181 = getelementptr [3 x ptr], ptr %180, i32 0, i32 1
  store ptr %179, ptr %181, align 8
  %182 = getelementptr [3 x ptr], ptr %180, i32 0, i32 2
  store ptr null, ptr %182, align 8
  %183 = call ptr @llvm.invariant.start.p0(i64 16, ptr %180)
  store ptr @Iterator, ptr %180, align 8
  %184 = alloca [1 x ptr], align 8
  %185 = getelementptr [1 x ptr], ptr %184, i32 0, i32 0
  store ptr %180, ptr %185, align 8
  %186 = call ptr @llvm.invariant.start.p0(i64 1, ptr %184)
  %187 = call ptr @llvm.invariant.start.p0(i64 88, ptr %165)
  %188 = getelementptr ptr, ptr %165, i32 %171
  %189 = getelementptr ptr, ptr %188, i32 4
  %190 = load ptr, ptr %189, align 8
  %191 = alloca { ptr }, align 8
  %192 = getelementptr { ptr }, ptr %191, i32 0, i32 0
  store ptr %157, ptr %192, align 8
  %193 = call ptr @behavior_wrapper(ptr %190, { ptr, ptr, ptr, i32 } %172, ptr %191)
  call void %193({ ptr, ptr, ptr, i32 } %172, { ptr, ptr, ptr, i32 } %172, ptr %184, { ptr, ptr, ptr, i32 } %164)
  %194 = alloca i32, align 4
  %195 = alloca ptr, align 8
  %196 = alloca ptr, align 8
  %197 = alloca ptr, align 8
  %198 = load ptr, ptr %99, align 8
  store ptr %198, ptr %197, align 8
  %199 = load ptr, ptr %98, align 8
  store ptr %199, ptr %196, align 8
  %200 = load ptr, ptr %97, align 8
  store ptr %200, ptr %195, align 8
  %201 = load i32, ptr %96, align 4
  store i32 %201, ptr %194, align 4
  %202 = load ptr, ptr %197, align 8
  %203 = call i32 @get_offset(ptr %202, ptr @Iterator)
  store i32 %203, ptr %194, align 4
  %204 = load ptr, ptr %197, align 8
  %205 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %204, 0
  %206 = load ptr, ptr %196, align 8
  %207 = insertvalue { ptr, ptr, ptr, i32 } %205, ptr %206, 1
  %208 = load ptr, ptr %195, align 8
  %209 = insertvalue { ptr, ptr, ptr, i32 } %207, ptr %208, 2
  %210 = load i32, ptr %194, align 4
  %211 = insertvalue { ptr, ptr, ptr, i32 } %209, i32 %210, 3
  ret { ptr, ptr, ptr, i32 } %211
}

define ptr @Enumerated_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 17, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [54 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @Enumerated_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 18, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [54 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Enumerated_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @Pair, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @Pair to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = ptrtoint ptr %20 to i64
  %22 = icmp eq i64 %21, ptrtoint (ptr @function_typ to i64)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 19, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [54 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define ptr @Enumerated_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 20, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [54 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Enumerated_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 21, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [54 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Enumerated_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 22, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [54 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @Enumerated_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 23, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [54 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Enumerated_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 24, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [54 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Enumerated_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 25, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [54 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define ptr @Enumerated_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 26, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [54 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define ptr @Enumerated_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 27, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [54 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define ptr @Enumerated_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 28, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [54 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define { i64, i64 } @_data_size_Enumerator(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %10
  %12 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %5
  %13 = select i1 %12, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %5
  %14 = urem i64 %11, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %17
  %19 = add i64 %11, %18
  %20 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %13
  %21 = select i1 %20, i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), i64 %13
  %22 = urem i64 %19, ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %23 = icmp eq i64 %22, 0
  %24 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %22
  %25 = select i1 %23, i64 0, i64 %24
  %26 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %25
  %27 = add i64 %19, %26
  %28 = urem i64 %27, %21
  %29 = icmp eq i64 %28, 0
  %30 = sub i64 %21, %28
  %31 = select i1 %29, i64 0, i64 %30
  %32 = add i64 %27, %31
  %33 = insertvalue { i64, i64 } undef, i64 %32, 0
  %34 = insertvalue { i64, i64 } %33, i64 %21, 1
  ret { i64, i64 } %34
}

define ptr @Enumerator_field_Enumerator_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define ptr @Enumerator_field_Enumerator_1(ptr %0) {
  %2 = getelementptr ptr, ptr %0, i32 1
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

define { ptr, ptr, ptr, i32 } @Enumerator_getter_iterator(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %7, %11
  %13 = getelementptr i8, ptr %0, i64 %12
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %15, 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 1
  %18 = load ptr, ptr %17, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %18, 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 2
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %21, 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 3
  %24 = load i32, ptr %23, align 4
  %25 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %24, 3
  ret { ptr, ptr, ptr, i32 } %25
}

define void @Enumerator_setter_iterator(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %8, %12
  %14 = getelementptr i8, ptr %0, i64 %13
  %15 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %15, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 0
  %18 = load ptr, ptr %16, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 1
  %21 = load ptr, ptr %19, align 8
  store ptr %21, ptr %20, align 8
  %22 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 2
  %24 = load ptr, ptr %22, align 8
  store ptr %24, ptr %23, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 3
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 3
  %27 = load i32, ptr %25, align 4
  store i32 %27, ptr %26, align 4
  ret void
}

define i32 @Enumerator_getter_index(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %11
  %13 = add i64 %7, %12
  %14 = urem i64 %13, ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 %13, %17
  %19 = getelementptr i8, ptr %0, i64 %18
  %20 = load i32, ptr %19, align 4
  ret i32 %20
}

define void @Enumerator_setter_index(ptr %0, i32 %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %12
  %14 = add i64 %8, %13
  %15 = urem i64 %14, ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %16 = icmp eq i64 %15, 0
  %17 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add i64 %14, %18
  %20 = getelementptr i8, ptr %0, i64 %19
  %21 = alloca i32, align 4
  store i32 %1, ptr %21, align 4
  %22 = load i32, ptr %21, align 4
  store i32 %22, ptr %20, align 4
  ret void
}

define void @Enumerator_init_iteratorIteratorT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3) {
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %5, align 8
  %6 = alloca i32, align 4
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %7, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %8, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %9, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = call i32 @get_offset(ptr %18, ptr @Enumerator)
  store i32 %19, ptr %6, align 4
  %20 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %20, align 8
  %21 = alloca i32, align 4
  %22 = alloca ptr, align 8
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  store ptr %26, ptr %24, align 8
  %27 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 1
  %28 = load ptr, ptr %27, align 8
  store ptr %28, ptr %23, align 8
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 2
  %30 = load ptr, ptr %29, align 8
  store ptr %30, ptr %22, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 3
  %32 = load i32, ptr %31, align 4
  store i32 %32, ptr %21, align 4
  %33 = load ptr, ptr %24, align 8
  %34 = call i32 @get_offset(ptr %33, ptr @Iterator)
  store i32 %34, ptr %21, align 4
  %35 = alloca i32, align 4
  %36 = alloca ptr, align 8
  %37 = alloca ptr, align 8
  %38 = alloca ptr, align 8
  %39 = load ptr, ptr %24, align 8
  store ptr %39, ptr %38, align 8
  %40 = load ptr, ptr %23, align 8
  store ptr %40, ptr %37, align 8
  %41 = load ptr, ptr %22, align 8
  store ptr %41, ptr %36, align 8
  %42 = load i32, ptr %21, align 4
  store i32 %42, ptr %35, align 4
  %43 = load ptr, ptr %38, align 8
  %44 = call i32 @get_offset(ptr %43, ptr @Iterator)
  store i32 %44, ptr %35, align 4
  %45 = load ptr, ptr %8, align 8
  %46 = load ptr, ptr %7, align 8
  %47 = call ptr @llvm.invariant.start.p0(i64 88, ptr %46)
  %48 = load i32, ptr %6, align 4
  %49 = getelementptr ptr, ptr %46, i32 %48
  %50 = getelementptr ptr, ptr %49, i32 2
  %51 = load ptr, ptr %50, align 8
  %52 = getelementptr { ptr, ptr }, ptr %51, i32 0, i32 1
  %53 = load ptr, ptr %52, align 8
  %54 = load ptr, ptr %38, align 8
  %55 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %54, 0
  %56 = load ptr, ptr %37, align 8
  %57 = insertvalue { ptr, ptr, ptr, i32 } %55, ptr %56, 1
  %58 = load ptr, ptr %36, align 8
  %59 = insertvalue { ptr, ptr, ptr, i32 } %57, ptr %58, 2
  %60 = load i32, ptr %35, align 4
  %61 = insertvalue { ptr, ptr, ptr, i32 } %59, i32 %60, 3
  call void %53(ptr %45, { ptr, ptr, ptr, i32 } %61) #2
  %62 = alloca i32, align 4
  store i32 0, ptr %62, align 4
  %63 = load ptr, ptr %8, align 8
  %64 = load ptr, ptr %7, align 8
  %65 = call ptr @llvm.invariant.start.p0(i64 88, ptr %64)
  %66 = load i32, ptr %6, align 4
  %67 = getelementptr ptr, ptr %64, i32 %66
  %68 = getelementptr ptr, ptr %67, i32 3
  %69 = load ptr, ptr %68, align 8
  %70 = getelementptr { ptr, ptr }, ptr %69, i32 0, i32 1
  %71 = load ptr, ptr %70, align 8
  %72 = load i32, ptr %62, align 4
  call void %71(ptr %63, i32 %72) #2
  ret void
}

define ptr @Enumerator_B_init_iteratorIteratorT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterator, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterator to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 6, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [11 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define { ptr, i160 } @Enumerator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca i160, align 8
  %5 = alloca ptr, align 8
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca i32, align 4
  %11 = alloca [3 x ptr], align 8
  %12 = alloca { ptr, ptr, ptr, i32 }, align 8
  %13 = alloca i160, align 8
  %14 = alloca ptr, align 8
  %15 = alloca i160, align 8
  %16 = alloca ptr, align 8
  %17 = alloca [2 x ptr], align 8
  %18 = alloca { ptr, ptr }, align 8
  %19 = alloca [0 x i8], align 1
  %20 = alloca [0 x i8], align 1
  %21 = alloca i160, align 8
  %22 = alloca ptr, align 8
  %23 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %23, align 8
  %24 = alloca i32, align 4
  %25 = alloca ptr, align 8
  %26 = alloca ptr, align 8
  %27 = alloca ptr, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %23, i32 0, i32 0
  %29 = load ptr, ptr %28, align 8
  store ptr %29, ptr %25, align 8
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %23, i32 0, i32 1
  %31 = load ptr, ptr %30, align 8
  store ptr %31, ptr %26, align 8
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %23, i32 0, i32 2
  %33 = load ptr, ptr %32, align 8
  store ptr %33, ptr %27, align 8
  %34 = getelementptr { ptr, ptr, ptr, i32 }, ptr %23, i32 0, i32 3
  %35 = load i32, ptr %34, align 4
  store i32 %35, ptr %24, align 4
  %36 = load ptr, ptr %25, align 8
  %37 = call i32 @get_offset(ptr %36, ptr @Enumerator)
  store i32 %37, ptr %24, align 4
  %38 = load ptr, ptr %26, align 8
  %39 = load ptr, ptr %25, align 8
  %40 = call ptr @llvm.invariant.start.p0(i64 88, ptr %39)
  %41 = load i32, ptr %24, align 4
  %42 = getelementptr ptr, ptr %39, i32 %41
  %43 = getelementptr ptr, ptr %42, i32 2
  %44 = load ptr, ptr %43, align 8
  %45 = getelementptr { ptr, ptr }, ptr %44, i32 0, i32 0
  %46 = load ptr, ptr %45, align 8
  %47 = call { ptr, ptr, ptr, i32 } %46(ptr %38) #1
  %48 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %47, ptr %48, align 8
  call void @assume_offset(ptr %48, ptr @Iterator)
  %49 = getelementptr { ptr, ptr, ptr, i32 }, ptr %48, i32 0, i32 0
  %50 = load ptr, ptr %49, align 8
  %51 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %50, 0
  %52 = getelementptr { ptr, ptr, ptr, i32 }, ptr %48, i32 0, i32 1
  %53 = load ptr, ptr %52, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } %51, ptr %53, 1
  %55 = getelementptr { ptr, ptr, ptr, i32 }, ptr %48, i32 0, i32 2
  %56 = load ptr, ptr %55, align 8
  %57 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %56, 2
  %58 = getelementptr { ptr, ptr, ptr, i32 }, ptr %48, i32 0, i32 3
  %59 = load i32, ptr %58, align 4
  %60 = insertvalue { ptr, ptr, ptr, i32 } %57, i32 %59, 3
  %61 = alloca [0 x ptr], align 8
  %62 = call ptr @llvm.invariant.start.p0(i64 0, ptr %61)
  %63 = call ptr @llvm.invariant.start.p0(i64 24, ptr %50)
  %64 = getelementptr ptr, ptr %50, i32 %59
  %65 = getelementptr ptr, ptr %64, i32 1
  %66 = load ptr, ptr %65, align 8
  %67 = alloca {}, align 8
  %68 = call ptr @behavior_wrapper(ptr %66, { ptr, ptr, ptr, i32 } %60, ptr %67)
  %69 = call { ptr, i160 } %68({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr %61)
  %70 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %69, ptr %70, align 8
  %71 = load ptr, ptr %26, align 8
  %72 = load ptr, ptr %25, align 8
  %73 = call ptr @llvm.invariant.start.p0(i64 88, ptr %72)
  %74 = load i32, ptr %24, align 4
  %75 = getelementptr ptr, ptr %72, i32 %74
  %76 = load ptr, ptr %75, align 8
  %77 = call ptr @typegetter_wrapper(ptr %76, ptr %71)
  %78 = load ptr, ptr %70, align 8
  %79 = ptrtoint ptr %78 to i64
  %80 = icmp eq i64 %79, ptrtoint (ptr @nil_typ to i64)
  %81 = icmp eq i64 %79, 0
  %82 = or i1 %80, %81
  %83 = icmp eq i1 %82, false
  %84 = alloca i1, align 1
  %85 = zext i1 %83 to i8
  store i8 %85, ptr %84, align 1
  %86 = load i8, ptr %84, align 1
  %87 = trunc i8 %86 to i1
  br i1 %87, label %88, label %190

88:                                               ; preds = %3
  %89 = getelementptr { ptr, i160 }, ptr %70, i32 0, i32 0
  %90 = load ptr, ptr %89, align 8
  store ptr %90, ptr %5, align 8
  %91 = getelementptr { ptr, i160 }, ptr %70, i32 0, i32 1
  %92 = load i160, ptr %91, align 4
  store i160 %92, ptr %4, align 4
  %93 = load ptr, ptr %26, align 8
  %94 = load ptr, ptr %25, align 8
  %95 = call ptr @llvm.invariant.start.p0(i64 88, ptr %94)
  %96 = load i32, ptr %24, align 4
  %97 = getelementptr ptr, ptr %94, i32 %96
  %98 = getelementptr ptr, ptr %97, i32 3
  %99 = load ptr, ptr %98, align 8
  %100 = getelementptr { ptr, ptr }, ptr %99, i32 0, i32 0
  %101 = load ptr, ptr %100, align 8
  %102 = call i32 %101(ptr %93) #1
  store i32 %102, ptr %6, align 4
  %103 = load i32, ptr %6, align 4
  store i32 %103, ptr %7, align 4
  %104 = load ptr, ptr %26, align 8
  %105 = load ptr, ptr %25, align 8
  %106 = call ptr @llvm.invariant.start.p0(i64 88, ptr %105)
  %107 = load i32, ptr %24, align 4
  %108 = getelementptr ptr, ptr %105, i32 %107
  %109 = getelementptr ptr, ptr %108, i32 3
  %110 = load ptr, ptr %109, align 8
  %111 = getelementptr { ptr, ptr }, ptr %110, i32 0, i32 0
  %112 = load ptr, ptr %111, align 8
  %113 = call i32 %112(ptr %104) #1
  store i32 %113, ptr %8, align 4
  store i32 1, ptr %9, align 4
  %114 = load i32, ptr %8, align 4
  %115 = load i32, ptr %9, align 4
  %116 = add i32 %114, %115
  store i32 %116, ptr %10, align 4
  %117 = load ptr, ptr %26, align 8
  %118 = load ptr, ptr %25, align 8
  %119 = call ptr @llvm.invariant.start.p0(i64 88, ptr %118)
  %120 = load i32, ptr %24, align 4
  %121 = getelementptr ptr, ptr %118, i32 %120
  %122 = getelementptr ptr, ptr %121, i32 3
  %123 = load ptr, ptr %122, align 8
  %124 = getelementptr { ptr, ptr }, ptr %123, i32 0, i32 1
  %125 = load ptr, ptr %124, align 8
  %126 = load i32, ptr %10, align 4
  call void %125(ptr %117, i32 %126) #2
  %127 = load ptr, ptr %26, align 8
  %128 = load ptr, ptr %25, align 8
  %129 = call ptr @llvm.invariant.start.p0(i64 88, ptr %128)
  %130 = load i32, ptr %24, align 4
  %131 = getelementptr ptr, ptr %128, i32 %130
  %132 = load ptr, ptr %131, align 8
  %133 = call ptr @typegetter_wrapper(ptr %132, ptr %127)
  store ptr @Pair, ptr %11, align 8
  %134 = getelementptr ptr, ptr %11, i32 1
  store ptr @_parameterization_i32, ptr %134, align 8
  %135 = getelementptr ptr, ptr %11, i32 2
  store ptr %133, ptr %135, align 8
  %136 = load ptr, ptr %11, align 8
  %137 = getelementptr ptr, ptr %136, i32 6
  %138 = load ptr, ptr %137, align 8
  %139 = call { i64, i64 } @size_wrapper(ptr %138, ptr %11)
  %140 = extractvalue { i64, i64 } %139, 0
  %141 = call ptr @bump_malloc(i64 %140)
  store ptr @_parameterization_i32, ptr %141, align 8
  %142 = getelementptr ptr, ptr %141, i32 1
  store ptr %133, ptr %142, align 8
  %143 = call ptr @llvm.invariant.start.p0(i64 16, ptr %141)
  %144 = getelementptr { ptr, ptr, ptr, i32 }, ptr %12, i32 0, i32 1
  %145 = getelementptr { ptr, ptr, ptr, i32 }, ptr %12, i32 0, i32 3
  store ptr @Pair, ptr %12, align 8
  store ptr %141, ptr %144, align 8
  store i32 10, ptr %145, align 4
  store ptr @i32_typ, ptr %14, align 8
  %146 = load i32, ptr %7, align 4
  store i32 %146, ptr %13, align 4
  %147 = load ptr, ptr %14, align 8
  %148 = insertvalue { ptr, i160 } undef, ptr %147, 0
  %149 = load i160, ptr %13, align 4
  %150 = insertvalue { ptr, i160 } %148, i160 %149, 1
  %151 = load ptr, ptr %5, align 8
  store ptr %151, ptr %16, align 8
  %152 = load i160, ptr %4, align 4
  store i160 %152, ptr %15, align 4
  %153 = load ptr, ptr %16, align 8
  %154 = insertvalue { ptr, i160 } undef, ptr %153, 0
  %155 = load i160, ptr %15, align 4
  %156 = insertvalue { ptr, i160 } %154, i160 %155, 1
  %157 = getelementptr { ptr, ptr, ptr, i32 }, ptr %12, i32 0, i32 0
  %158 = load ptr, ptr %157, align 8
  %159 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %158, 0
  %160 = load ptr, ptr %144, align 8
  %161 = insertvalue { ptr, ptr, ptr, i32 } %159, ptr %160, 1
  %162 = getelementptr { ptr, ptr, ptr, i32 }, ptr %12, i32 0, i32 2
  %163 = load ptr, ptr %162, align 8
  %164 = insertvalue { ptr, ptr, ptr, i32 } %161, ptr %163, 2
  %165 = load i32, ptr %145, align 4
  %166 = insertvalue { ptr, ptr, ptr, i32 } %164, i32 %165, 3
  %167 = load ptr, ptr %26, align 8
  %168 = load ptr, ptr %25, align 8
  %169 = call ptr @llvm.invariant.start.p0(i64 88, ptr %168)
  %170 = load i32, ptr %24, align 4
  %171 = getelementptr ptr, ptr %168, i32 %170
  %172 = load ptr, ptr %171, align 8
  %173 = call ptr @typegetter_wrapper(ptr %172, ptr %167)
  %174 = getelementptr [2 x ptr], ptr %17, i32 0, i32 0
  store ptr @_parameterization_i32, ptr %174, align 8
  %175 = getelementptr [2 x ptr], ptr %17, i32 0, i32 1
  store ptr %173, ptr %175, align 8
  %176 = call ptr @llvm.invariant.start.p0(i64 4, ptr %17)
  %177 = call ptr @llvm.invariant.start.p0(i64 112, ptr %158)
  %178 = getelementptr ptr, ptr %158, i32 %165
  %179 = getelementptr ptr, ptr %178, i32 8
  %180 = load ptr, ptr %179, align 8
  %181 = getelementptr { ptr, ptr }, ptr %18, i32 0, i32 0
  store ptr %147, ptr %181, align 8
  %182 = getelementptr { ptr, ptr }, ptr %18, i32 0, i32 1
  store ptr %153, ptr %182, align 8
  %183 = call ptr @behavior_wrapper(ptr %180, { ptr, ptr, ptr, i32 } %166, ptr %18)
  call void %183({ ptr, ptr, ptr, i32 } %166, { ptr, ptr, ptr, i32 } %166, ptr %17, { ptr, i160 } %150, { ptr, i160 } %156)
  %184 = getelementptr { ptr, i160 }, ptr %12, i32 0, i32 0
  %185 = load ptr, ptr %184, align 8
  %186 = insertvalue { ptr, i160 } undef, ptr %185, 0
  %187 = getelementptr { ptr, i160 }, ptr %12, i32 0, i32 1
  %188 = load i160, ptr %187, align 4
  %189 = insertvalue { ptr, i160 } %186, i160 %188, 1
  br label %198

190:                                              ; preds = %3
  %191 = getelementptr { ptr, i160 }, ptr %70, i32 0, i32 1
  %192 = load [0 x i8], ptr %191, align 1
  store [0 x i8] %192, ptr %19, align 1
  %193 = load [0 x i8], ptr %20, align 1
  store [0 x i8] %193, ptr %21, align 1
  store ptr @nil_typ, ptr %22, align 8
  %194 = load ptr, ptr %22, align 8
  %195 = insertvalue { ptr, i160 } undef, ptr %194, 0
  %196 = load i160, ptr %21, align 4
  %197 = insertvalue { ptr, i160 } %195, i160 %196, 1
  br label %198

198:                                              ; preds = %88, %190
  %199 = phi { ptr, i160 } [ %197, %190 ], [ %189, %88 ]
  br label %200

200:                                              ; preds = %198
  ret { ptr, i160 } %199
}

define ptr @Enumerator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 7, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [11 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { i64, i64 } @_data_size_Mapped(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %10
  %12 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %5
  %13 = select i1 %12, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %5
  %14 = urem i64 %11, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %17
  %19 = add i64 %11, %18
  %20 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), %13
  %21 = select i1 %20, i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), i64 %13
  %22 = urem i64 %19, ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64)
  %23 = icmp eq i64 %22, 0
  %24 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), %22
  %25 = select i1 %23, i64 0, i64 %24
  %26 = add i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), %25
  %27 = add i64 %19, %26
  %28 = urem i64 %27, %21
  %29 = icmp eq i64 %28, 0
  %30 = sub i64 %21, %28
  %31 = select i1 %29, i64 0, i64 %30
  %32 = add i64 %27, %31
  %33 = insertvalue { i64, i64 } undef, i64 %32, 0
  %34 = insertvalue { i64, i64 } %33, i64 %21, 1
  ret { i64, i64 } %34
}

define ptr @Mapped_field_Mapped_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define ptr @Mapped_field_Mapped_1(ptr %0) {
  %2 = getelementptr ptr, ptr %0, i32 1
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

define { ptr, ptr, ptr, i32 } @Mapped_getter_iterable(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %7, %11
  %13 = getelementptr i8, ptr %0, i64 %12
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %15, 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 1
  %18 = load ptr, ptr %17, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %18, 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 2
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %21, 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 3
  %24 = load i32, ptr %23, align 4
  %25 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %24, 3
  ret { ptr, ptr, ptr, i32 } %25
}

define void @Mapped_setter_iterable(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %8, %12
  %14 = getelementptr i8, ptr %0, i64 %13
  %15 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %15, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 0
  %18 = load ptr, ptr %16, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 1
  %21 = load ptr, ptr %19, align 8
  store ptr %21, ptr %20, align 8
  %22 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 2
  %24 = load ptr, ptr %22, align 8
  store ptr %24, ptr %23, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 3
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 3
  %27 = load i32, ptr %25, align 4
  store i32 %27, ptr %26, align 4
  ret void
}

define { ptr } @Mapped_getter_f(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %11
  %13 = add i64 %7, %12
  %14 = urem i64 %13, ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 %13, %17
  %19 = getelementptr i8, ptr %0, i64 %18
  %20 = getelementptr { ptr }, ptr %19, i32 0, i32 0
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr } undef, ptr %21, 0
  ret { ptr } %22
}

define void @Mapped_setter_f(ptr %0, { ptr } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %12
  %14 = add i64 %8, %13
  %15 = urem i64 %14, ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64)
  %16 = icmp eq i64 %15, 0
  %17 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add i64 %14, %18
  %20 = getelementptr i8, ptr %0, i64 %19
  %21 = alloca ptr, align 8
  store { ptr } %1, ptr %21, align 8
  %22 = getelementptr { ptr }, ptr %20, i32 0, i32 0
  %23 = load ptr, ptr %21, align 8
  store ptr %23, ptr %22, align 8
  ret void
}

define void @Mapped_init_iterableIterableT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) {
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %6, align 8
  %7 = alloca i32, align 4
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = alloca ptr, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %8, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 1
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %9, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 2
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %10, align 8
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  store i32 %18, ptr %7, align 4
  %19 = load ptr, ptr %8, align 8
  %20 = call i32 @get_offset(ptr %19, ptr @Mapped)
  store i32 %20, ptr %7, align 4
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %21, align 8
  %22 = alloca i32, align 4
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = alloca ptr, align 8
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  store ptr %27, ptr %25, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 1
  %29 = load ptr, ptr %28, align 8
  store ptr %29, ptr %24, align 8
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 2
  %31 = load ptr, ptr %30, align 8
  store ptr %31, ptr %23, align 8
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 3
  %33 = load i32, ptr %32, align 4
  store i32 %33, ptr %22, align 4
  %34 = load ptr, ptr %25, align 8
  %35 = call i32 @get_offset(ptr %34, ptr @Iterable)
  store i32 %35, ptr %22, align 4
  %36 = alloca i32, align 4
  %37 = alloca ptr, align 8
  %38 = alloca ptr, align 8
  %39 = alloca ptr, align 8
  %40 = load ptr, ptr %25, align 8
  store ptr %40, ptr %39, align 8
  %41 = load ptr, ptr %24, align 8
  store ptr %41, ptr %38, align 8
  %42 = load ptr, ptr %23, align 8
  store ptr %42, ptr %37, align 8
  %43 = load i32, ptr %22, align 4
  store i32 %43, ptr %36, align 4
  %44 = load ptr, ptr %39, align 8
  %45 = call i32 @get_offset(ptr %44, ptr @Iterable)
  store i32 %45, ptr %36, align 4
  %46 = load ptr, ptr %9, align 8
  %47 = load ptr, ptr %8, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 440, ptr %47)
  %49 = load i32, ptr %7, align 4
  %50 = getelementptr ptr, ptr %47, i32 %49
  %51 = getelementptr ptr, ptr %50, i32 2
  %52 = load ptr, ptr %51, align 8
  %53 = getelementptr { ptr, ptr }, ptr %52, i32 0, i32 1
  %54 = load ptr, ptr %53, align 8
  %55 = load ptr, ptr %39, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %55, 0
  %57 = load ptr, ptr %38, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %57, 1
  %59 = load ptr, ptr %37, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %59, 2
  %61 = load i32, ptr %36, align 4
  %62 = insertvalue { ptr, ptr, ptr, i32 } %60, i32 %61, 3
  call void %54(ptr %46, { ptr, ptr, ptr, i32 } %62) #2
  %63 = alloca ptr, align 8
  store { ptr } %4, ptr %63, align 8
  %64 = load ptr, ptr %9, align 8
  %65 = load ptr, ptr %8, align 8
  %66 = call ptr @llvm.invariant.start.p0(i64 440, ptr %65)
  %67 = load i32, ptr %7, align 4
  %68 = getelementptr ptr, ptr %65, i32 %67
  %69 = getelementptr ptr, ptr %68, i32 3
  %70 = load ptr, ptr %69, align 8
  %71 = getelementptr { ptr, ptr }, ptr %70, i32 0, i32 1
  %72 = load ptr, ptr %71, align 8
  %73 = load ptr, ptr %63, align 8
  %74 = insertvalue { ptr } undef, ptr %73, 0
  call void %72(ptr %64, { ptr } %74) #2
  ret void
}

define ptr @Mapped_B_init_iterableIterableT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @Iterable, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @Iterable to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = ptrtoint ptr %20 to i64
  %22 = icmp eq i64 %21, ptrtoint (ptr @function_typ to i64)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 17, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [55 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define { ptr, ptr, ptr, i32 } @Mapped_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @Mapped)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 440, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 2
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr { ptr, ptr }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = call { ptr, ptr, ptr, i32 } %27(ptr %19) #1
  %29 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %28, ptr %29, align 8
  call void @assume_offset(ptr %29, ptr @Iterable)
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 1
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %34, 1
  %36 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 2
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %37, 2
  %39 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 3
  %40 = load i32, ptr %39, align 4
  %41 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %40, 3
  %42 = alloca [0 x ptr], align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 0, ptr %42)
  %44 = call ptr @llvm.invariant.start.p0(i64 200, ptr %31)
  %45 = getelementptr ptr, ptr %31, i32 %40
  %46 = getelementptr ptr, ptr %45, i32 1
  %47 = load ptr, ptr %46, align 8
  %48 = alloca {}, align 8
  %49 = call ptr @behavior_wrapper(ptr %47, { ptr, ptr, ptr, i32 } %41, ptr %48)
  %50 = call { ptr, ptr, ptr, i32 } %49({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr %42)
  %51 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %50, ptr %51, align 8
  %52 = alloca i32, align 4
  %53 = alloca ptr, align 8
  %54 = alloca ptr, align 8
  %55 = alloca ptr, align 8
  %56 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 0
  %57 = load ptr, ptr %56, align 8
  store ptr %57, ptr %53, align 8
  %58 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 1
  %59 = load ptr, ptr %58, align 8
  store ptr %59, ptr %55, align 8
  %60 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 2
  %61 = load ptr, ptr %60, align 8
  store ptr %61, ptr %54, align 8
  %62 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 3
  %63 = load i32, ptr %62, align 4
  store i32 %63, ptr %52, align 4
  %64 = load ptr, ptr %53, align 8
  %65 = call i32 @get_offset(ptr %64, ptr @Iterator)
  store i32 %65, ptr %52, align 4
  %66 = load ptr, ptr %7, align 8
  %67 = load ptr, ptr %6, align 8
  %68 = call ptr @llvm.invariant.start.p0(i64 440, ptr %67)
  %69 = load i32, ptr %5, align 4
  %70 = getelementptr ptr, ptr %67, i32 %69
  %71 = getelementptr ptr, ptr %70, i32 3
  %72 = load ptr, ptr %71, align 8
  %73 = getelementptr { ptr, ptr }, ptr %72, i32 0, i32 0
  %74 = load ptr, ptr %73, align 8
  %75 = call { ptr } %74(ptr %66) #1
  %76 = alloca ptr, align 8
  store { ptr } %75, ptr %76, align 8
  %77 = load ptr, ptr %7, align 8
  %78 = load ptr, ptr %6, align 8
  %79 = call ptr @llvm.invariant.start.p0(i64 440, ptr %78)
  %80 = load i32, ptr %5, align 4
  %81 = getelementptr ptr, ptr %78, i32 %80
  %82 = load ptr, ptr %81, align 8
  %83 = call ptr @typegetter_wrapper(ptr %82, ptr %77)
  %84 = load ptr, ptr %7, align 8
  %85 = load ptr, ptr %6, align 8
  %86 = call ptr @llvm.invariant.start.p0(i64 440, ptr %85)
  %87 = load i32, ptr %5, align 4
  %88 = getelementptr ptr, ptr %85, i32 %87
  %89 = getelementptr ptr, ptr %88, i32 1
  %90 = load ptr, ptr %89, align 8
  %91 = call ptr @typegetter_wrapper(ptr %90, ptr %84)
  %92 = alloca [3 x ptr], align 8
  store ptr @Mapper, ptr %92, align 8
  %93 = getelementptr ptr, ptr %92, i32 1
  store ptr %83, ptr %93, align 8
  %94 = getelementptr ptr, ptr %92, i32 2
  store ptr %91, ptr %94, align 8
  %95 = load ptr, ptr %92, align 8
  %96 = getelementptr ptr, ptr %95, i32 6
  %97 = load ptr, ptr %96, align 8
  %98 = call { i64, i64 } @size_wrapper(ptr %97, ptr %92)
  %99 = extractvalue { i64, i64 } %98, 0
  %100 = call ptr @bump_malloc(i64 %99)
  store ptr %83, ptr %100, align 8
  %101 = getelementptr ptr, ptr %100, i32 1
  store ptr %91, ptr %101, align 8
  %102 = call ptr @llvm.invariant.start.p0(i64 16, ptr %100)
  %103 = alloca i32, align 4
  %104 = alloca ptr, align 8
  %105 = alloca ptr, align 8
  %106 = alloca ptr, align 8
  store ptr @Mapper, ptr %106, align 8
  store ptr %100, ptr %105, align 8
  store i32 10, ptr %103, align 4
  %107 = load ptr, ptr %7, align 8
  %108 = load ptr, ptr %6, align 8
  %109 = call ptr @llvm.invariant.start.p0(i64 440, ptr %108)
  %110 = load i32, ptr %5, align 4
  %111 = getelementptr ptr, ptr %108, i32 %110
  %112 = getelementptr ptr, ptr %111, i32 2
  %113 = load ptr, ptr %112, align 8
  %114 = getelementptr { ptr, ptr }, ptr %113, i32 0, i32 0
  %115 = load ptr, ptr %114, align 8
  %116 = call { ptr, ptr, ptr, i32 } %115(ptr %107) #1
  %117 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %116, ptr %117, align 8
  call void @assume_offset(ptr %117, ptr @Iterable)
  %118 = getelementptr { ptr, ptr, ptr, i32 }, ptr %117, i32 0, i32 0
  %119 = load ptr, ptr %118, align 8
  %120 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %119, 0
  %121 = getelementptr { ptr, ptr, ptr, i32 }, ptr %117, i32 0, i32 1
  %122 = load ptr, ptr %121, align 8
  %123 = insertvalue { ptr, ptr, ptr, i32 } %120, ptr %122, 1
  %124 = getelementptr { ptr, ptr, ptr, i32 }, ptr %117, i32 0, i32 2
  %125 = load ptr, ptr %124, align 8
  %126 = insertvalue { ptr, ptr, ptr, i32 } %123, ptr %125, 2
  %127 = getelementptr { ptr, ptr, ptr, i32 }, ptr %117, i32 0, i32 3
  %128 = load i32, ptr %127, align 4
  %129 = insertvalue { ptr, ptr, ptr, i32 } %126, i32 %128, 3
  %130 = alloca [0 x ptr], align 8
  %131 = call ptr @llvm.invariant.start.p0(i64 0, ptr %130)
  %132 = call ptr @llvm.invariant.start.p0(i64 200, ptr %119)
  %133 = getelementptr ptr, ptr %119, i32 %128
  %134 = getelementptr ptr, ptr %133, i32 1
  %135 = load ptr, ptr %134, align 8
  %136 = alloca {}, align 8
  %137 = call ptr @behavior_wrapper(ptr %135, { ptr, ptr, ptr, i32 } %129, ptr %136)
  %138 = call { ptr, ptr, ptr, i32 } %137({ ptr, ptr, ptr, i32 } %129, { ptr, ptr, ptr, i32 } %129, ptr %130)
  %139 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %138, ptr %139, align 8
  %140 = alloca i32, align 4
  %141 = alloca ptr, align 8
  %142 = alloca ptr, align 8
  %143 = alloca ptr, align 8
  %144 = getelementptr { ptr, ptr, ptr, i32 }, ptr %139, i32 0, i32 0
  %145 = load ptr, ptr %144, align 8
  store ptr %145, ptr %143, align 8
  %146 = getelementptr { ptr, ptr, ptr, i32 }, ptr %139, i32 0, i32 1
  %147 = load ptr, ptr %146, align 8
  store ptr %147, ptr %142, align 8
  %148 = getelementptr { ptr, ptr, ptr, i32 }, ptr %139, i32 0, i32 2
  %149 = load ptr, ptr %148, align 8
  store ptr %149, ptr %141, align 8
  %150 = getelementptr { ptr, ptr, ptr, i32 }, ptr %139, i32 0, i32 3
  %151 = load i32, ptr %150, align 4
  store i32 %151, ptr %140, align 4
  %152 = load ptr, ptr %143, align 8
  %153 = call i32 @get_offset(ptr %152, ptr @Iterator)
  store i32 %153, ptr %140, align 4
  %154 = load ptr, ptr %7, align 8
  %155 = load ptr, ptr %6, align 8
  %156 = call ptr @llvm.invariant.start.p0(i64 440, ptr %155)
  %157 = load i32, ptr %5, align 4
  %158 = getelementptr ptr, ptr %155, i32 %157
  %159 = getelementptr ptr, ptr %158, i32 3
  %160 = load ptr, ptr %159, align 8
  %161 = getelementptr { ptr, ptr }, ptr %160, i32 0, i32 0
  %162 = load ptr, ptr %161, align 8
  %163 = call { ptr } %162(ptr %154) #1
  %164 = alloca ptr, align 8
  store { ptr } %163, ptr %164, align 8
  %165 = alloca i32, align 4
  %166 = alloca ptr, align 8
  %167 = alloca ptr, align 8
  %168 = alloca ptr, align 8
  %169 = load ptr, ptr %143, align 8
  store ptr %169, ptr %168, align 8
  %170 = load ptr, ptr %142, align 8
  store ptr %170, ptr %167, align 8
  %171 = load ptr, ptr %141, align 8
  store ptr %171, ptr %166, align 8
  %172 = load i32, ptr %140, align 4
  store i32 %172, ptr %165, align 4
  %173 = load ptr, ptr %168, align 8
  %174 = call i32 @get_offset(ptr %173, ptr @Iterator)
  store i32 %174, ptr %165, align 4
  %175 = load ptr, ptr %168, align 8
  %176 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %175, 0
  %177 = load ptr, ptr %167, align 8
  %178 = insertvalue { ptr, ptr, ptr, i32 } %176, ptr %177, 1
  %179 = load ptr, ptr %166, align 8
  %180 = insertvalue { ptr, ptr, ptr, i32 } %178, ptr %179, 2
  %181 = load i32, ptr %165, align 4
  %182 = insertvalue { ptr, ptr, ptr, i32 } %180, i32 %181, 3
  %183 = load ptr, ptr %164, align 8
  %184 = insertvalue { ptr } undef, ptr %183, 0
  %185 = load ptr, ptr %106, align 8
  %186 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %185, 0
  %187 = load ptr, ptr %105, align 8
  %188 = insertvalue { ptr, ptr, ptr, i32 } %186, ptr %187, 1
  %189 = load ptr, ptr %104, align 8
  %190 = insertvalue { ptr, ptr, ptr, i32 } %188, ptr %189, 2
  %191 = load i32, ptr %103, align 4
  %192 = insertvalue { ptr, ptr, ptr, i32 } %190, i32 %191, 3
  %193 = load ptr, ptr %7, align 8
  %194 = load ptr, ptr %6, align 8
  %195 = call ptr @llvm.invariant.start.p0(i64 440, ptr %194)
  %196 = load i32, ptr %5, align 4
  %197 = getelementptr ptr, ptr %194, i32 %196
  %198 = load ptr, ptr %197, align 8
  %199 = call ptr @typegetter_wrapper(ptr %198, ptr %193)
  %200 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %201 = getelementptr [3 x ptr], ptr %200, i32 0, i32 1
  store ptr %199, ptr %201, align 8
  %202 = getelementptr [3 x ptr], ptr %200, i32 0, i32 2
  store ptr null, ptr %202, align 8
  %203 = call ptr @llvm.invariant.start.p0(i64 16, ptr %200)
  store ptr @Iterator, ptr %200, align 8
  %204 = load ptr, ptr %7, align 8
  %205 = load ptr, ptr %6, align 8
  %206 = call ptr @llvm.invariant.start.p0(i64 440, ptr %205)
  %207 = load i32, ptr %5, align 4
  %208 = getelementptr ptr, ptr %205, i32 %207
  %209 = getelementptr ptr, ptr %208, i32 1
  %210 = load ptr, ptr %209, align 8
  %211 = call ptr @typegetter_wrapper(ptr %210, ptr %204)
  %212 = load ptr, ptr %7, align 8
  %213 = load ptr, ptr %6, align 8
  %214 = call ptr @llvm.invariant.start.p0(i64 440, ptr %213)
  %215 = load i32, ptr %5, align 4
  %216 = getelementptr ptr, ptr %213, i32 %215
  %217 = load ptr, ptr %216, align 8
  %218 = call ptr @typegetter_wrapper(ptr %217, ptr %212)
  %219 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([4 x ptr], ptr null, i32 1) to i64))
  %220 = getelementptr [4 x ptr], ptr %219, i32 0, i32 2
  store ptr %218, ptr %220, align 8
  %221 = getelementptr [4 x ptr], ptr %219, i32 0, i32 1
  store ptr %211, ptr %221, align 8
  %222 = getelementptr [4 x ptr], ptr %219, i32 0, i32 3
  store ptr null, ptr %222, align 8
  %223 = call ptr @llvm.invariant.start.p0(i64 24, ptr %219)
  store ptr @function_typ, ptr %219, align 8
  %224 = alloca [2 x ptr], align 8
  %225 = getelementptr [2 x ptr], ptr %224, i32 0, i32 0
  store ptr %200, ptr %225, align 8
  %226 = getelementptr [2 x ptr], ptr %224, i32 0, i32 1
  store ptr %219, ptr %226, align 8
  %227 = call ptr @llvm.invariant.start.p0(i64 4, ptr %224)
  %228 = call ptr @llvm.invariant.start.p0(i64 88, ptr %185)
  %229 = getelementptr ptr, ptr %185, i32 %191
  %230 = getelementptr ptr, ptr %229, i32 4
  %231 = load ptr, ptr %230, align 8
  %232 = alloca { ptr, ptr }, align 8
  %233 = getelementptr { ptr, ptr }, ptr %232, i32 0, i32 0
  store ptr %175, ptr %233, align 8
  %234 = getelementptr { ptr, ptr }, ptr %232, i32 0, i32 1
  store ptr @function_typ, ptr %234, align 8
  %235 = call ptr @behavior_wrapper(ptr %231, { ptr, ptr, ptr, i32 } %192, ptr %232)
  call void %235({ ptr, ptr, ptr, i32 } %192, { ptr, ptr, ptr, i32 } %192, ptr %224, { ptr, ptr, ptr, i32 } %182, { ptr } %184)
  %236 = alloca i32, align 4
  %237 = alloca ptr, align 8
  %238 = alloca ptr, align 8
  %239 = alloca ptr, align 8
  %240 = load ptr, ptr %106, align 8
  store ptr %240, ptr %239, align 8
  %241 = load ptr, ptr %105, align 8
  store ptr %241, ptr %238, align 8
  %242 = load ptr, ptr %104, align 8
  store ptr %242, ptr %237, align 8
  %243 = load i32, ptr %103, align 4
  store i32 %243, ptr %236, align 4
  %244 = load ptr, ptr %239, align 8
  %245 = call i32 @get_offset(ptr %244, ptr @Iterator)
  store i32 %245, ptr %236, align 4
  %246 = load ptr, ptr %239, align 8
  %247 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %246, 0
  %248 = load ptr, ptr %238, align 8
  %249 = insertvalue { ptr, ptr, ptr, i32 } %247, ptr %248, 1
  %250 = load ptr, ptr %237, align 8
  %251 = insertvalue { ptr, ptr, ptr, i32 } %249, ptr %250, 2
  %252 = load i32, ptr %236, align 4
  %253 = insertvalue { ptr, ptr, ptr, i32 } %251, i32 %252, 3
  ret { ptr, ptr, ptr, i32 } %253
}

define ptr @Mapped_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 18, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [55 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @Mapped_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 19, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [55 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Mapped_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @any_typ, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @any_typ to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = ptrtoint ptr %20 to i64
  %22 = icmp eq i64 %21, ptrtoint (ptr @function_typ to i64)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 20, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [55 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define ptr @Mapped_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 21, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [55 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Mapped_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 22, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [55 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Mapped_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 23, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [55 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @Mapped_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 24, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [55 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Mapped_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 25, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [55 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Mapped_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 26, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [55 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define ptr @Mapped_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 27, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [55 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define ptr @Mapped_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 28, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [55 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define ptr @Mapped_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 29, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [55 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define { i64, i64 } @_data_size_Mapper(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %10
  %12 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %5
  %13 = select i1 %12, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %5
  %14 = urem i64 %11, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %17
  %19 = add i64 %11, %18
  %20 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), %13
  %21 = select i1 %20, i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), i64 %13
  %22 = urem i64 %19, ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64)
  %23 = icmp eq i64 %22, 0
  %24 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), %22
  %25 = select i1 %23, i64 0, i64 %24
  %26 = add i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), %25
  %27 = add i64 %19, %26
  %28 = urem i64 %27, %21
  %29 = icmp eq i64 %28, 0
  %30 = sub i64 %21, %28
  %31 = select i1 %29, i64 0, i64 %30
  %32 = add i64 %27, %31
  %33 = insertvalue { i64, i64 } undef, i64 %32, 0
  %34 = insertvalue { i64, i64 } %33, i64 %21, 1
  ret { i64, i64 } %34
}

define ptr @Mapper_field_Mapper_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define ptr @Mapper_field_Mapper_1(ptr %0) {
  %2 = getelementptr ptr, ptr %0, i32 1
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

define { ptr, ptr, ptr, i32 } @Mapper_getter_iterator(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %7, %11
  %13 = getelementptr i8, ptr %0, i64 %12
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %15, 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 1
  %18 = load ptr, ptr %17, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %18, 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 2
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %21, 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 3
  %24 = load i32, ptr %23, align 4
  %25 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %24, 3
  ret { ptr, ptr, ptr, i32 } %25
}

define void @Mapper_setter_iterator(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %8, %12
  %14 = getelementptr i8, ptr %0, i64 %13
  %15 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %15, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 0
  %18 = load ptr, ptr %16, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 1
  %21 = load ptr, ptr %19, align 8
  store ptr %21, ptr %20, align 8
  %22 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 2
  %24 = load ptr, ptr %22, align 8
  store ptr %24, ptr %23, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 3
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 3
  %27 = load i32, ptr %25, align 4
  store i32 %27, ptr %26, align 4
  ret void
}

define { ptr } @Mapper_getter_f(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %11
  %13 = add i64 %7, %12
  %14 = urem i64 %13, ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 %13, %17
  %19 = getelementptr i8, ptr %0, i64 %18
  %20 = getelementptr { ptr }, ptr %19, i32 0, i32 0
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr } undef, ptr %21, 0
  ret { ptr } %22
}

define void @Mapper_setter_f(ptr %0, { ptr } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %12
  %14 = add i64 %8, %13
  %15 = urem i64 %14, ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64)
  %16 = icmp eq i64 %15, 0
  %17 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add i64 %14, %18
  %20 = getelementptr i8, ptr %0, i64 %19
  %21 = alloca ptr, align 8
  store { ptr } %1, ptr %21, align 8
  %22 = getelementptr { ptr }, ptr %20, i32 0, i32 0
  %23 = load ptr, ptr %21, align 8
  store ptr %23, ptr %22, align 8
  ret void
}

define void @Mapper_init_iteratorIteratorT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) {
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %6, align 8
  %7 = alloca i32, align 4
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = alloca ptr, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %8, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 1
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %9, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 2
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %10, align 8
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  store i32 %18, ptr %7, align 4
  %19 = load ptr, ptr %8, align 8
  %20 = call i32 @get_offset(ptr %19, ptr @Mapper)
  store i32 %20, ptr %7, align 4
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %21, align 8
  %22 = alloca i32, align 4
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = alloca ptr, align 8
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  store ptr %27, ptr %25, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 1
  %29 = load ptr, ptr %28, align 8
  store ptr %29, ptr %24, align 8
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 2
  %31 = load ptr, ptr %30, align 8
  store ptr %31, ptr %23, align 8
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 3
  %33 = load i32, ptr %32, align 4
  store i32 %33, ptr %22, align 4
  %34 = load ptr, ptr %25, align 8
  %35 = call i32 @get_offset(ptr %34, ptr @Iterator)
  store i32 %35, ptr %22, align 4
  %36 = alloca i32, align 4
  %37 = alloca ptr, align 8
  %38 = alloca ptr, align 8
  %39 = alloca ptr, align 8
  %40 = load ptr, ptr %25, align 8
  store ptr %40, ptr %39, align 8
  %41 = load ptr, ptr %24, align 8
  store ptr %41, ptr %38, align 8
  %42 = load ptr, ptr %23, align 8
  store ptr %42, ptr %37, align 8
  %43 = load i32, ptr %22, align 4
  store i32 %43, ptr %36, align 4
  %44 = load ptr, ptr %39, align 8
  %45 = call i32 @get_offset(ptr %44, ptr @Iterator)
  store i32 %45, ptr %36, align 4
  %46 = load ptr, ptr %9, align 8
  %47 = load ptr, ptr %8, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 88, ptr %47)
  %49 = load i32, ptr %7, align 4
  %50 = getelementptr ptr, ptr %47, i32 %49
  %51 = getelementptr ptr, ptr %50, i32 2
  %52 = load ptr, ptr %51, align 8
  %53 = getelementptr { ptr, ptr }, ptr %52, i32 0, i32 1
  %54 = load ptr, ptr %53, align 8
  %55 = load ptr, ptr %39, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %55, 0
  %57 = load ptr, ptr %38, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %57, 1
  %59 = load ptr, ptr %37, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %59, 2
  %61 = load i32, ptr %36, align 4
  %62 = insertvalue { ptr, ptr, ptr, i32 } %60, i32 %61, 3
  call void %54(ptr %46, { ptr, ptr, ptr, i32 } %62) #2
  %63 = alloca ptr, align 8
  store { ptr } %4, ptr %63, align 8
  %64 = load ptr, ptr %9, align 8
  %65 = load ptr, ptr %8, align 8
  %66 = call ptr @llvm.invariant.start.p0(i64 88, ptr %65)
  %67 = load i32, ptr %7, align 4
  %68 = getelementptr ptr, ptr %65, i32 %67
  %69 = getelementptr ptr, ptr %68, i32 3
  %70 = load ptr, ptr %69, align 8
  %71 = getelementptr { ptr, ptr }, ptr %70, i32 0, i32 1
  %72 = load ptr, ptr %71, align 8
  %73 = load ptr, ptr %63, align 8
  %74 = insertvalue { ptr } undef, ptr %73, 0
  call void %72(ptr %64, { ptr } %74) #2
  ret void
}

define ptr @Mapper_B_init_iteratorIteratorT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @Iterator, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @Iterator to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = ptrtoint ptr %20 to i64
  %22 = icmp eq i64 %21, ptrtoint (ptr @function_typ to i64)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 6, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [11 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define { ptr, i160 } @Mapper_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca i160, align 8
  %5 = alloca ptr, align 8
  %6 = alloca i160, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca { ptr, i160 }, align 8
  %10 = alloca [0 x i8], align 1
  %11 = alloca [0 x i8], align 1
  %12 = alloca i160, align 8
  %13 = alloca ptr, align 8
  %14 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %14, align 8
  %15 = alloca i32, align 4
  %16 = alloca ptr, align 8
  %17 = alloca ptr, align 8
  %18 = alloca ptr, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 0
  %20 = load ptr, ptr %19, align 8
  store ptr %20, ptr %16, align 8
  %21 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 1
  %22 = load ptr, ptr %21, align 8
  store ptr %22, ptr %17, align 8
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 2
  %24 = load ptr, ptr %23, align 8
  store ptr %24, ptr %18, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 3
  %26 = load i32, ptr %25, align 4
  store i32 %26, ptr %15, align 4
  %27 = load ptr, ptr %16, align 8
  %28 = call i32 @get_offset(ptr %27, ptr @Mapper)
  store i32 %28, ptr %15, align 4
  %29 = load ptr, ptr %17, align 8
  %30 = load ptr, ptr %16, align 8
  %31 = call ptr @llvm.invariant.start.p0(i64 88, ptr %30)
  %32 = load i32, ptr %15, align 4
  %33 = getelementptr ptr, ptr %30, i32 %32
  %34 = getelementptr ptr, ptr %33, i32 2
  %35 = load ptr, ptr %34, align 8
  %36 = getelementptr { ptr, ptr }, ptr %35, i32 0, i32 0
  %37 = load ptr, ptr %36, align 8
  %38 = call { ptr, ptr, ptr, i32 } %37(ptr %29) #1
  %39 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %38, ptr %39, align 8
  call void @assume_offset(ptr %39, ptr @Iterator)
  %40 = getelementptr { ptr, ptr, ptr, i32 }, ptr %39, i32 0, i32 0
  %41 = load ptr, ptr %40, align 8
  %42 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %41, 0
  %43 = getelementptr { ptr, ptr, ptr, i32 }, ptr %39, i32 0, i32 1
  %44 = load ptr, ptr %43, align 8
  %45 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %44, 1
  %46 = getelementptr { ptr, ptr, ptr, i32 }, ptr %39, i32 0, i32 2
  %47 = load ptr, ptr %46, align 8
  %48 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr %47, 2
  %49 = getelementptr { ptr, ptr, ptr, i32 }, ptr %39, i32 0, i32 3
  %50 = load i32, ptr %49, align 4
  %51 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %50, 3
  %52 = alloca [0 x ptr], align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 0, ptr %52)
  %54 = call ptr @llvm.invariant.start.p0(i64 24, ptr %41)
  %55 = getelementptr ptr, ptr %41, i32 %50
  %56 = getelementptr ptr, ptr %55, i32 1
  %57 = load ptr, ptr %56, align 8
  %58 = alloca {}, align 8
  %59 = call ptr @behavior_wrapper(ptr %57, { ptr, ptr, ptr, i32 } %51, ptr %58)
  %60 = call { ptr, i160 } %59({ ptr, ptr, ptr, i32 } %51, { ptr, ptr, ptr, i32 } %51, ptr %52)
  %61 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %60, ptr %61, align 8
  %62 = load ptr, ptr %17, align 8
  %63 = load ptr, ptr %16, align 8
  %64 = call ptr @llvm.invariant.start.p0(i64 88, ptr %63)
  %65 = load i32, ptr %15, align 4
  %66 = getelementptr ptr, ptr %63, i32 %65
  %67 = load ptr, ptr %66, align 8
  %68 = call ptr @typegetter_wrapper(ptr %67, ptr %62)
  %69 = load ptr, ptr %61, align 8
  %70 = ptrtoint ptr %69 to i64
  %71 = icmp eq i64 %70, ptrtoint (ptr @nil_typ to i64)
  %72 = icmp eq i64 %70, 0
  %73 = or i1 %71, %72
  %74 = icmp eq i1 %73, false
  %75 = alloca i1, align 1
  %76 = zext i1 %74 to i8
  store i8 %76, ptr %75, align 1
  %77 = load i8, ptr %75, align 1
  %78 = trunc i8 %77 to i1
  br i1 %78, label %79, label %108

79:                                               ; preds = %3
  %80 = getelementptr { ptr, i160 }, ptr %61, i32 0, i32 0
  %81 = load ptr, ptr %80, align 8
  store ptr %81, ptr %5, align 8
  %82 = getelementptr { ptr, i160 }, ptr %61, i32 0, i32 1
  %83 = load i160, ptr %82, align 4
  store i160 %83, ptr %4, align 4
  %84 = load ptr, ptr %5, align 8
  store ptr %84, ptr %7, align 8
  %85 = load i160, ptr %4, align 4
  store i160 %85, ptr %6, align 4
  %86 = load ptr, ptr %7, align 8
  %87 = insertvalue { ptr, i160 } undef, ptr %86, 0
  %88 = load i160, ptr %6, align 4
  %89 = insertvalue { ptr, i160 } %87, i160 %88, 1
  %90 = load ptr, ptr %17, align 8
  %91 = load ptr, ptr %16, align 8
  %92 = call ptr @llvm.invariant.start.p0(i64 88, ptr %91)
  %93 = load i32, ptr %15, align 4
  %94 = getelementptr ptr, ptr %91, i32 %93
  %95 = getelementptr ptr, ptr %94, i32 3
  %96 = load ptr, ptr %95, align 8
  %97 = getelementptr { ptr, ptr }, ptr %96, i32 0, i32 0
  %98 = load ptr, ptr %97, align 8
  %99 = call { ptr } %98(ptr %90) #1
  store { ptr } %99, ptr %8, align 8
  %100 = load ptr, ptr %8, align 8
  %101 = call { ptr, i160 } %100({ ptr, i160 } %89)
  store { ptr, i160 } %101, ptr %9, align 8
  %102 = getelementptr { ptr, i160 }, ptr %9, i32 0, i32 0
  %103 = load ptr, ptr %102, align 8
  %104 = insertvalue { ptr, i160 } undef, ptr %103, 0
  %105 = getelementptr { ptr, i160 }, ptr %9, i32 0, i32 1
  %106 = load i160, ptr %105, align 4
  %107 = insertvalue { ptr, i160 } %104, i160 %106, 1
  br label %116

108:                                              ; preds = %3
  %109 = getelementptr { ptr, i160 }, ptr %61, i32 0, i32 1
  %110 = load [0 x i8], ptr %109, align 1
  store [0 x i8] %110, ptr %10, align 1
  %111 = load [0 x i8], ptr %11, align 1
  store [0 x i8] %111, ptr %12, align 1
  store ptr @nil_typ, ptr %13, align 8
  %112 = load ptr, ptr %13, align 8
  %113 = insertvalue { ptr, i160 } undef, ptr %112, 0
  %114 = load i160, ptr %12, align 4
  %115 = insertvalue { ptr, i160 } %113, i160 %114, 1
  br label %116

116:                                              ; preds = %79, %108
  %117 = phi { ptr, i160 } [ %115, %108 ], [ %107, %79 ]
  br label %118

118:                                              ; preds = %116
  ret { ptr, i160 } %117
}

define ptr @Mapper_B_next_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 7, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [11 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { i64, i64 } @_data_size_Filtered(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %10
  %12 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), %5
  %13 = select i1 %12, i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), i64 %5
  %14 = urem i64 %11, ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), %17
  %19 = add i64 %11, %18
  %20 = urem i64 %19, %13
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 %13, %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = add i64 %19, %23
  %25 = insertvalue { i64, i64 } undef, i64 %24, 0
  %26 = insertvalue { i64, i64 } %25, i64 %13, 1
  ret { i64, i64 } %26
}

define ptr @Filtered_field_Filtered_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define { ptr, ptr, ptr, i32 } @Filtered_getter_iterable(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = getelementptr i8, ptr %0, i64 %6
  %8 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %9, 0
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %12, 1
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %15, 2
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  %19 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %18, 3
  ret { ptr, ptr, ptr, i32 } %19
}

define void @Filtered_setter_iterable(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = getelementptr i8, ptr %0, i64 %7
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %9, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 0
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 0
  %12 = load ptr, ptr %10, align 8
  store ptr %12, ptr %11, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 1
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 1
  %15 = load ptr, ptr %13, align 8
  store ptr %15, ptr %14, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 2
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 2
  %18 = load ptr, ptr %16, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 3
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 3
  %21 = load i32, ptr %19, align 4
  store i32 %21, ptr %20, align 4
  ret void
}

define { ptr } @Filtered_getter_f(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %7, %11
  %13 = getelementptr i8, ptr %0, i64 %12
  %14 = getelementptr { ptr }, ptr %13, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr } undef, ptr %15, 0
  ret { ptr } %16
}

define void @Filtered_setter_f(ptr %0, { ptr } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %8, %12
  %14 = getelementptr i8, ptr %0, i64 %13
  %15 = alloca ptr, align 8
  store { ptr } %1, ptr %15, align 8
  %16 = getelementptr { ptr }, ptr %14, i32 0, i32 0
  %17 = load ptr, ptr %15, align 8
  store ptr %17, ptr %16, align 8
  ret void
}

define void @Filtered_init_iterableIterableT_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) {
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %6, align 8
  %7 = alloca i32, align 4
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = alloca ptr, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %8, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 1
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %9, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 2
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %10, align 8
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  store i32 %18, ptr %7, align 4
  %19 = load ptr, ptr %8, align 8
  %20 = call i32 @get_offset(ptr %19, ptr @Filtered)
  store i32 %20, ptr %7, align 4
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %21, align 8
  %22 = alloca i32, align 4
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = alloca ptr, align 8
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  store ptr %27, ptr %25, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 1
  %29 = load ptr, ptr %28, align 8
  store ptr %29, ptr %24, align 8
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 2
  %31 = load ptr, ptr %30, align 8
  store ptr %31, ptr %23, align 8
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 3
  %33 = load i32, ptr %32, align 4
  store i32 %33, ptr %22, align 4
  %34 = load ptr, ptr %25, align 8
  %35 = call i32 @get_offset(ptr %34, ptr @Iterable)
  store i32 %35, ptr %22, align 4
  %36 = alloca i32, align 4
  %37 = alloca ptr, align 8
  %38 = alloca ptr, align 8
  %39 = alloca ptr, align 8
  %40 = load ptr, ptr %25, align 8
  store ptr %40, ptr %39, align 8
  %41 = load ptr, ptr %24, align 8
  store ptr %41, ptr %38, align 8
  %42 = load ptr, ptr %23, align 8
  store ptr %42, ptr %37, align 8
  %43 = load i32, ptr %22, align 4
  store i32 %43, ptr %36, align 4
  %44 = load ptr, ptr %39, align 8
  %45 = call i32 @get_offset(ptr %44, ptr @Iterable)
  store i32 %45, ptr %36, align 4
  %46 = load ptr, ptr %9, align 8
  %47 = load ptr, ptr %8, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 432, ptr %47)
  %49 = load i32, ptr %7, align 4
  %50 = getelementptr ptr, ptr %47, i32 %49
  %51 = getelementptr ptr, ptr %50, i32 1
  %52 = load ptr, ptr %51, align 8
  %53 = getelementptr { ptr, ptr }, ptr %52, i32 0, i32 1
  %54 = load ptr, ptr %53, align 8
  %55 = load ptr, ptr %39, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %55, 0
  %57 = load ptr, ptr %38, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %57, 1
  %59 = load ptr, ptr %37, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %59, 2
  %61 = load i32, ptr %36, align 4
  %62 = insertvalue { ptr, ptr, ptr, i32 } %60, i32 %61, 3
  call void %54(ptr %46, { ptr, ptr, ptr, i32 } %62) #2
  %63 = alloca ptr, align 8
  store { ptr } %4, ptr %63, align 8
  %64 = load ptr, ptr %9, align 8
  %65 = load ptr, ptr %8, align 8
  %66 = call ptr @llvm.invariant.start.p0(i64 432, ptr %65)
  %67 = load i32, ptr %7, align 4
  %68 = getelementptr ptr, ptr %65, i32 %67
  %69 = getelementptr ptr, ptr %68, i32 2
  %70 = load ptr, ptr %69, align 8
  %71 = getelementptr { ptr, ptr }, ptr %70, i32 0, i32 1
  %72 = load ptr, ptr %71, align 8
  %73 = load ptr, ptr %63, align 8
  %74 = insertvalue { ptr } undef, ptr %73, 0
  call void %72(ptr %64, { ptr } %74) #2
  ret void
}

define ptr @Filtered_B_init_iterableIterableT_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @Iterable, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @Iterable to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = ptrtoint ptr %20 to i64
  %22 = icmp eq i64 %21, ptrtoint (ptr @function_typ to i64)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 16, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [54 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define { ptr, ptr, ptr, i32 } @Filtered_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @Filtered)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 432, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 1
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr { ptr, ptr }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = call { ptr, ptr, ptr, i32 } %27(ptr %19) #1
  %29 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %28, ptr %29, align 8
  call void @assume_offset(ptr %29, ptr @Iterable)
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 1
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %34, 1
  %36 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 2
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %37, 2
  %39 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 3
  %40 = load i32, ptr %39, align 4
  %41 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %40, 3
  %42 = alloca [0 x ptr], align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 0, ptr %42)
  %44 = call ptr @llvm.invariant.start.p0(i64 200, ptr %31)
  %45 = getelementptr ptr, ptr %31, i32 %40
  %46 = getelementptr ptr, ptr %45, i32 1
  %47 = load ptr, ptr %46, align 8
  %48 = alloca {}, align 8
  %49 = call ptr @behavior_wrapper(ptr %47, { ptr, ptr, ptr, i32 } %41, ptr %48)
  %50 = call { ptr, ptr, ptr, i32 } %49({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr %42)
  %51 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %50, ptr %51, align 8
  %52 = alloca i32, align 4
  %53 = alloca ptr, align 8
  %54 = alloca ptr, align 8
  %55 = alloca ptr, align 8
  %56 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 0
  %57 = load ptr, ptr %56, align 8
  store ptr %57, ptr %53, align 8
  %58 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 1
  %59 = load ptr, ptr %58, align 8
  store ptr %59, ptr %55, align 8
  %60 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 2
  %61 = load ptr, ptr %60, align 8
  store ptr %61, ptr %54, align 8
  %62 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 3
  %63 = load i32, ptr %62, align 4
  store i32 %63, ptr %52, align 4
  %64 = load ptr, ptr %53, align 8
  %65 = call i32 @get_offset(ptr %64, ptr @Iterator)
  store i32 %65, ptr %52, align 4
  %66 = load ptr, ptr %7, align 8
  %67 = load ptr, ptr %6, align 8
  %68 = call ptr @llvm.invariant.start.p0(i64 432, ptr %67)
  %69 = load i32, ptr %5, align 4
  %70 = getelementptr ptr, ptr %67, i32 %69
  %71 = getelementptr ptr, ptr %70, i32 2
  %72 = load ptr, ptr %71, align 8
  %73 = getelementptr { ptr, ptr }, ptr %72, i32 0, i32 0
  %74 = load ptr, ptr %73, align 8
  %75 = call { ptr } %74(ptr %66) #1
  %76 = alloca ptr, align 8
  store { ptr } %75, ptr %76, align 8
  %77 = load ptr, ptr %7, align 8
  %78 = load ptr, ptr %6, align 8
  %79 = call ptr @llvm.invariant.start.p0(i64 432, ptr %78)
  %80 = load i32, ptr %5, align 4
  %81 = getelementptr ptr, ptr %78, i32 %80
  %82 = load ptr, ptr %81, align 8
  %83 = call ptr @typegetter_wrapper(ptr %82, ptr %77)
  %84 = alloca [2 x ptr], align 8
  store ptr @Filterer, ptr %84, align 8
  %85 = getelementptr ptr, ptr %84, i32 1
  store ptr %83, ptr %85, align 8
  %86 = load ptr, ptr %84, align 8
  %87 = getelementptr ptr, ptr %86, i32 6
  %88 = load ptr, ptr %87, align 8
  %89 = call { i64, i64 } @size_wrapper(ptr %88, ptr %84)
  %90 = extractvalue { i64, i64 } %89, 0
  %91 = call ptr @bump_malloc(i64 %90)
  store ptr %83, ptr %91, align 8
  %92 = call ptr @llvm.invariant.start.p0(i64 8, ptr %91)
  %93 = alloca i32, align 4
  %94 = alloca ptr, align 8
  %95 = alloca ptr, align 8
  %96 = alloca ptr, align 8
  store ptr @Filterer, ptr %96, align 8
  store ptr %91, ptr %95, align 8
  store i32 10, ptr %93, align 4
  %97 = load ptr, ptr %7, align 8
  %98 = load ptr, ptr %6, align 8
  %99 = call ptr @llvm.invariant.start.p0(i64 432, ptr %98)
  %100 = load i32, ptr %5, align 4
  %101 = getelementptr ptr, ptr %98, i32 %100
  %102 = getelementptr ptr, ptr %101, i32 1
  %103 = load ptr, ptr %102, align 8
  %104 = getelementptr { ptr, ptr }, ptr %103, i32 0, i32 0
  %105 = load ptr, ptr %104, align 8
  %106 = call { ptr, ptr, ptr, i32 } %105(ptr %97) #1
  %107 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %106, ptr %107, align 8
  call void @assume_offset(ptr %107, ptr @Iterable)
  %108 = getelementptr { ptr, ptr, ptr, i32 }, ptr %107, i32 0, i32 0
  %109 = load ptr, ptr %108, align 8
  %110 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %109, 0
  %111 = getelementptr { ptr, ptr, ptr, i32 }, ptr %107, i32 0, i32 1
  %112 = load ptr, ptr %111, align 8
  %113 = insertvalue { ptr, ptr, ptr, i32 } %110, ptr %112, 1
  %114 = getelementptr { ptr, ptr, ptr, i32 }, ptr %107, i32 0, i32 2
  %115 = load ptr, ptr %114, align 8
  %116 = insertvalue { ptr, ptr, ptr, i32 } %113, ptr %115, 2
  %117 = getelementptr { ptr, ptr, ptr, i32 }, ptr %107, i32 0, i32 3
  %118 = load i32, ptr %117, align 4
  %119 = insertvalue { ptr, ptr, ptr, i32 } %116, i32 %118, 3
  %120 = alloca [0 x ptr], align 8
  %121 = call ptr @llvm.invariant.start.p0(i64 0, ptr %120)
  %122 = call ptr @llvm.invariant.start.p0(i64 200, ptr %109)
  %123 = getelementptr ptr, ptr %109, i32 %118
  %124 = getelementptr ptr, ptr %123, i32 1
  %125 = load ptr, ptr %124, align 8
  %126 = alloca {}, align 8
  %127 = call ptr @behavior_wrapper(ptr %125, { ptr, ptr, ptr, i32 } %119, ptr %126)
  %128 = call { ptr, ptr, ptr, i32 } %127({ ptr, ptr, ptr, i32 } %119, { ptr, ptr, ptr, i32 } %119, ptr %120)
  %129 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %128, ptr %129, align 8
  %130 = alloca i32, align 4
  %131 = alloca ptr, align 8
  %132 = alloca ptr, align 8
  %133 = alloca ptr, align 8
  %134 = getelementptr { ptr, ptr, ptr, i32 }, ptr %129, i32 0, i32 0
  %135 = load ptr, ptr %134, align 8
  store ptr %135, ptr %133, align 8
  %136 = getelementptr { ptr, ptr, ptr, i32 }, ptr %129, i32 0, i32 1
  %137 = load ptr, ptr %136, align 8
  store ptr %137, ptr %132, align 8
  %138 = getelementptr { ptr, ptr, ptr, i32 }, ptr %129, i32 0, i32 2
  %139 = load ptr, ptr %138, align 8
  store ptr %139, ptr %131, align 8
  %140 = getelementptr { ptr, ptr, ptr, i32 }, ptr %129, i32 0, i32 3
  %141 = load i32, ptr %140, align 4
  store i32 %141, ptr %130, align 4
  %142 = load ptr, ptr %133, align 8
  %143 = call i32 @get_offset(ptr %142, ptr @Iterator)
  store i32 %143, ptr %130, align 4
  %144 = load ptr, ptr %7, align 8
  %145 = load ptr, ptr %6, align 8
  %146 = call ptr @llvm.invariant.start.p0(i64 432, ptr %145)
  %147 = load i32, ptr %5, align 4
  %148 = getelementptr ptr, ptr %145, i32 %147
  %149 = getelementptr ptr, ptr %148, i32 2
  %150 = load ptr, ptr %149, align 8
  %151 = getelementptr { ptr, ptr }, ptr %150, i32 0, i32 0
  %152 = load ptr, ptr %151, align 8
  %153 = call { ptr } %152(ptr %144) #1
  %154 = alloca ptr, align 8
  store { ptr } %153, ptr %154, align 8
  %155 = alloca i32, align 4
  %156 = alloca ptr, align 8
  %157 = alloca ptr, align 8
  %158 = alloca ptr, align 8
  %159 = load ptr, ptr %133, align 8
  store ptr %159, ptr %158, align 8
  %160 = load ptr, ptr %132, align 8
  store ptr %160, ptr %157, align 8
  %161 = load ptr, ptr %131, align 8
  store ptr %161, ptr %156, align 8
  %162 = load i32, ptr %130, align 4
  store i32 %162, ptr %155, align 4
  %163 = load ptr, ptr %158, align 8
  %164 = call i32 @get_offset(ptr %163, ptr @Iterator)
  store i32 %164, ptr %155, align 4
  %165 = load ptr, ptr %158, align 8
  %166 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %165, 0
  %167 = load ptr, ptr %157, align 8
  %168 = insertvalue { ptr, ptr, ptr, i32 } %166, ptr %167, 1
  %169 = load ptr, ptr %156, align 8
  %170 = insertvalue { ptr, ptr, ptr, i32 } %168, ptr %169, 2
  %171 = load i32, ptr %155, align 4
  %172 = insertvalue { ptr, ptr, ptr, i32 } %170, i32 %171, 3
  %173 = load ptr, ptr %154, align 8
  %174 = insertvalue { ptr } undef, ptr %173, 0
  %175 = load ptr, ptr %96, align 8
  %176 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %175, 0
  %177 = load ptr, ptr %95, align 8
  %178 = insertvalue { ptr, ptr, ptr, i32 } %176, ptr %177, 1
  %179 = load ptr, ptr %94, align 8
  %180 = insertvalue { ptr, ptr, ptr, i32 } %178, ptr %179, 2
  %181 = load i32, ptr %93, align 4
  %182 = insertvalue { ptr, ptr, ptr, i32 } %180, i32 %181, 3
  %183 = load ptr, ptr %7, align 8
  %184 = load ptr, ptr %6, align 8
  %185 = call ptr @llvm.invariant.start.p0(i64 432, ptr %184)
  %186 = load i32, ptr %5, align 4
  %187 = getelementptr ptr, ptr %184, i32 %186
  %188 = load ptr, ptr %187, align 8
  %189 = call ptr @typegetter_wrapper(ptr %188, ptr %183)
  %190 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %191 = getelementptr [3 x ptr], ptr %190, i32 0, i32 1
  store ptr %189, ptr %191, align 8
  %192 = getelementptr [3 x ptr], ptr %190, i32 0, i32 2
  store ptr null, ptr %192, align 8
  %193 = call ptr @llvm.invariant.start.p0(i64 16, ptr %190)
  store ptr @Iterator, ptr %190, align 8
  %194 = load ptr, ptr %7, align 8
  %195 = load ptr, ptr %6, align 8
  %196 = call ptr @llvm.invariant.start.p0(i64 432, ptr %195)
  %197 = load i32, ptr %5, align 4
  %198 = getelementptr ptr, ptr %195, i32 %197
  %199 = load ptr, ptr %198, align 8
  %200 = call ptr @typegetter_wrapper(ptr %199, ptr %194)
  %201 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([4 x ptr], ptr null, i32 1) to i64))
  %202 = getelementptr [4 x ptr], ptr %201, i32 0, i32 2
  store ptr %200, ptr %202, align 8
  %203 = getelementptr [4 x ptr], ptr %201, i32 0, i32 1
  store ptr @_parameterization_Bool, ptr %203, align 8
  %204 = getelementptr [4 x ptr], ptr %201, i32 0, i32 3
  store ptr null, ptr %204, align 8
  %205 = call ptr @llvm.invariant.start.p0(i64 24, ptr %201)
  store ptr @function_typ, ptr %201, align 8
  %206 = alloca [2 x ptr], align 8
  %207 = getelementptr [2 x ptr], ptr %206, i32 0, i32 0
  store ptr %190, ptr %207, align 8
  %208 = getelementptr [2 x ptr], ptr %206, i32 0, i32 1
  store ptr %201, ptr %208, align 8
  %209 = call ptr @llvm.invariant.start.p0(i64 4, ptr %206)
  %210 = call ptr @llvm.invariant.start.p0(i64 80, ptr %175)
  %211 = getelementptr ptr, ptr %175, i32 %181
  %212 = getelementptr ptr, ptr %211, i32 3
  %213 = load ptr, ptr %212, align 8
  %214 = alloca { ptr, ptr }, align 8
  %215 = getelementptr { ptr, ptr }, ptr %214, i32 0, i32 0
  store ptr %165, ptr %215, align 8
  %216 = getelementptr { ptr, ptr }, ptr %214, i32 0, i32 1
  store ptr @function_typ, ptr %216, align 8
  %217 = call ptr @behavior_wrapper(ptr %213, { ptr, ptr, ptr, i32 } %182, ptr %214)
  call void %217({ ptr, ptr, ptr, i32 } %182, { ptr, ptr, ptr, i32 } %182, ptr %206, { ptr, ptr, ptr, i32 } %172, { ptr } %174)
  %218 = alloca i32, align 4
  %219 = alloca ptr, align 8
  %220 = alloca ptr, align 8
  %221 = alloca ptr, align 8
  %222 = load ptr, ptr %96, align 8
  store ptr %222, ptr %221, align 8
  %223 = load ptr, ptr %95, align 8
  store ptr %223, ptr %220, align 8
  %224 = load ptr, ptr %94, align 8
  store ptr %224, ptr %219, align 8
  %225 = load i32, ptr %93, align 4
  store i32 %225, ptr %218, align 4
  %226 = load ptr, ptr %221, align 8
  %227 = call i32 @get_offset(ptr %226, ptr @Iterator)
  store i32 %227, ptr %218, align 4
  %228 = load ptr, ptr %221, align 8
  %229 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %228, 0
  %230 = load ptr, ptr %220, align 8
  %231 = insertvalue { ptr, ptr, ptr, i32 } %229, ptr %230, 1
  %232 = load ptr, ptr %219, align 8
  %233 = insertvalue { ptr, ptr, ptr, i32 } %231, ptr %232, 2
  %234 = load i32, ptr %218, align 4
  %235 = insertvalue { ptr, ptr, ptr, i32 } %233, i32 %234, 3
  ret { ptr, ptr, ptr, i32 } %235
}

define ptr @Filtered_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 17, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [54 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @Filtered_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 18, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [54 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Filtered_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @any_typ, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @any_typ to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = ptrtoint ptr %20 to i64
  %22 = icmp eq i64 %21, ptrtoint (ptr @function_typ to i64)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 19, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [54 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define ptr @Filtered_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 20, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [54 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Filtered_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 21, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [54 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Filtered_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 22, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [54 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @Filtered_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 23, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [54 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Filtered_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 24, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [54 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Filtered_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 25, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [54 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define ptr @Filtered_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 26, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [54 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define ptr @Filtered_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 27, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [54 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define ptr @Filtered_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 28, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [54 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define { i64, i64 } @_data_size_Filterer(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %10
  %12 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), %5
  %13 = select i1 %12, i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), i64 %5
  %14 = urem i64 %11, ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), %17
  %19 = add i64 %11, %18
  %20 = urem i64 %19, %13
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 %13, %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = add i64 %19, %23
  %25 = insertvalue { i64, i64 } undef, i64 %24, 0
  %26 = insertvalue { i64, i64 } %25, i64 %13, 1
  ret { i64, i64 } %26
}

define ptr @Filterer_field_Filterer_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define { ptr, ptr, ptr, i32 } @Filterer_getter_iterator(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = getelementptr i8, ptr %0, i64 %6
  %8 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %9, 0
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %12, 1
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %15, 2
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  %19 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %18, 3
  ret { ptr, ptr, ptr, i32 } %19
}

define void @Filterer_setter_iterator(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = getelementptr i8, ptr %0, i64 %7
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %9, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 0
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 0
  %12 = load ptr, ptr %10, align 8
  store ptr %12, ptr %11, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 1
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 1
  %15 = load ptr, ptr %13, align 8
  store ptr %15, ptr %14, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 2
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 2
  %18 = load ptr, ptr %16, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 3
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 3
  %21 = load i32, ptr %19, align 4
  store i32 %21, ptr %20, align 4
  ret void
}

define { ptr } @Filterer_getter_f(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %7, %11
  %13 = getelementptr i8, ptr %0, i64 %12
  %14 = getelementptr { ptr }, ptr %13, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr } undef, ptr %15, 0
  ret { ptr } %16
}

define void @Filterer_setter_f(ptr %0, { ptr } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %8, %12
  %14 = getelementptr i8, ptr %0, i64 %13
  %15 = alloca ptr, align 8
  store { ptr } %1, ptr %15, align 8
  %16 = getelementptr { ptr }, ptr %14, i32 0, i32 0
  %17 = load ptr, ptr %15, align 8
  store ptr %17, ptr %16, align 8
  ret void
}

define void @Filterer_init_iteratorIteratorT_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) {
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %6, align 8
  %7 = alloca i32, align 4
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = alloca ptr, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %8, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 1
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %9, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 2
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %10, align 8
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  store i32 %18, ptr %7, align 4
  %19 = load ptr, ptr %8, align 8
  %20 = call i32 @get_offset(ptr %19, ptr @Filterer)
  store i32 %20, ptr %7, align 4
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %21, align 8
  %22 = alloca i32, align 4
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = alloca ptr, align 8
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  store ptr %27, ptr %25, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 1
  %29 = load ptr, ptr %28, align 8
  store ptr %29, ptr %24, align 8
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 2
  %31 = load ptr, ptr %30, align 8
  store ptr %31, ptr %23, align 8
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 3
  %33 = load i32, ptr %32, align 4
  store i32 %33, ptr %22, align 4
  %34 = load ptr, ptr %25, align 8
  %35 = call i32 @get_offset(ptr %34, ptr @Iterator)
  store i32 %35, ptr %22, align 4
  %36 = alloca i32, align 4
  %37 = alloca ptr, align 8
  %38 = alloca ptr, align 8
  %39 = alloca ptr, align 8
  %40 = load ptr, ptr %25, align 8
  store ptr %40, ptr %39, align 8
  %41 = load ptr, ptr %24, align 8
  store ptr %41, ptr %38, align 8
  %42 = load ptr, ptr %23, align 8
  store ptr %42, ptr %37, align 8
  %43 = load i32, ptr %22, align 4
  store i32 %43, ptr %36, align 4
  %44 = load ptr, ptr %39, align 8
  %45 = call i32 @get_offset(ptr %44, ptr @Iterator)
  store i32 %45, ptr %36, align 4
  %46 = load ptr, ptr %9, align 8
  %47 = load ptr, ptr %8, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 80, ptr %47)
  %49 = load i32, ptr %7, align 4
  %50 = getelementptr ptr, ptr %47, i32 %49
  %51 = getelementptr ptr, ptr %50, i32 1
  %52 = load ptr, ptr %51, align 8
  %53 = getelementptr { ptr, ptr }, ptr %52, i32 0, i32 1
  %54 = load ptr, ptr %53, align 8
  %55 = load ptr, ptr %39, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %55, 0
  %57 = load ptr, ptr %38, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %57, 1
  %59 = load ptr, ptr %37, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %59, 2
  %61 = load i32, ptr %36, align 4
  %62 = insertvalue { ptr, ptr, ptr, i32 } %60, i32 %61, 3
  call void %54(ptr %46, { ptr, ptr, ptr, i32 } %62) #2
  %63 = alloca ptr, align 8
  store { ptr } %4, ptr %63, align 8
  %64 = load ptr, ptr %9, align 8
  %65 = load ptr, ptr %8, align 8
  %66 = call ptr @llvm.invariant.start.p0(i64 80, ptr %65)
  %67 = load i32, ptr %7, align 4
  %68 = getelementptr ptr, ptr %65, i32 %67
  %69 = getelementptr ptr, ptr %68, i32 2
  %70 = load ptr, ptr %69, align 8
  %71 = getelementptr { ptr, ptr }, ptr %70, i32 0, i32 1
  %72 = load ptr, ptr %71, align 8
  %73 = load ptr, ptr %63, align 8
  %74 = insertvalue { ptr } undef, ptr %73, 0
  call void %72(ptr %64, { ptr } %74) #2
  ret void
}

define ptr @Filterer_B_init_iteratorIteratorT_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @Iterator, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @Iterator to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = ptrtoint ptr %20 to i64
  %22 = icmp eq i64 %21, ptrtoint (ptr @function_typ to i64)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 5, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [10 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define { ptr, i160 } @Filterer_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca i1, align 1
  %5 = alloca i160, align 8
  %6 = alloca ptr, align 8
  %7 = alloca i160, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = alloca i1, align 1
  %11 = alloca { ptr, ptr, ptr, i32 }, align 8
  %12 = alloca [0 x ptr], align 8
  %13 = alloca {}, align 8
  %14 = alloca { ptr, i160 }, align 8
  %15 = alloca [0 x i8], align 1
  %16 = alloca i160, align 8
  %17 = alloca ptr, align 8
  %18 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %18, align 8
  %19 = alloca i32, align 4
  %20 = alloca ptr, align 8
  %21 = alloca ptr, align 8
  %22 = alloca ptr, align 8
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %18, i32 0, i32 0
  %24 = load ptr, ptr %23, align 8
  store ptr %24, ptr %20, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %18, i32 0, i32 1
  %26 = load ptr, ptr %25, align 8
  store ptr %26, ptr %21, align 8
  %27 = getelementptr { ptr, ptr, ptr, i32 }, ptr %18, i32 0, i32 2
  %28 = load ptr, ptr %27, align 8
  store ptr %28, ptr %22, align 8
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %18, i32 0, i32 3
  %30 = load i32, ptr %29, align 4
  store i32 %30, ptr %19, align 4
  %31 = load ptr, ptr %20, align 8
  %32 = call i32 @get_offset(ptr %31, ptr @Filterer)
  store i32 %32, ptr %19, align 4
  %33 = load ptr, ptr %21, align 8
  %34 = load ptr, ptr %20, align 8
  %35 = call ptr @llvm.invariant.start.p0(i64 80, ptr %34)
  %36 = load i32, ptr %19, align 4
  %37 = getelementptr ptr, ptr %34, i32 %36
  %38 = getelementptr ptr, ptr %37, i32 1
  %39 = load ptr, ptr %38, align 8
  %40 = getelementptr { ptr, ptr }, ptr %39, i32 0, i32 0
  %41 = load ptr, ptr %40, align 8
  %42 = call { ptr, ptr, ptr, i32 } %41(ptr %33) #1
  %43 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %42, ptr %43, align 8
  call void @assume_offset(ptr %43, ptr @Iterator)
  %44 = getelementptr { ptr, ptr, ptr, i32 }, ptr %43, i32 0, i32 0
  %45 = load ptr, ptr %44, align 8
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %45, 0
  %47 = getelementptr { ptr, ptr, ptr, i32 }, ptr %43, i32 0, i32 1
  %48 = load ptr, ptr %47, align 8
  %49 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %48, 1
  %50 = getelementptr { ptr, ptr, ptr, i32 }, ptr %43, i32 0, i32 2
  %51 = load ptr, ptr %50, align 8
  %52 = insertvalue { ptr, ptr, ptr, i32 } %49, ptr %51, 2
  %53 = getelementptr { ptr, ptr, ptr, i32 }, ptr %43, i32 0, i32 3
  %54 = load i32, ptr %53, align 4
  %55 = insertvalue { ptr, ptr, ptr, i32 } %52, i32 %54, 3
  %56 = alloca [0 x ptr], align 8
  %57 = call ptr @llvm.invariant.start.p0(i64 0, ptr %56)
  %58 = call ptr @llvm.invariant.start.p0(i64 24, ptr %45)
  %59 = getelementptr ptr, ptr %45, i32 %54
  %60 = getelementptr ptr, ptr %59, i32 1
  %61 = load ptr, ptr %60, align 8
  %62 = alloca {}, align 8
  %63 = call ptr @behavior_wrapper(ptr %61, { ptr, ptr, ptr, i32 } %55, ptr %62)
  %64 = call { ptr, i160 } %63({ ptr, ptr, ptr, i32 } %55, { ptr, ptr, ptr, i32 } %55, ptr %56)
  %65 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %64, ptr %65, align 8
  br label %66

66:                                               ; preds = %153, %3
  %67 = load ptr, ptr %21, align 8
  %68 = load ptr, ptr %20, align 8
  %69 = call ptr @llvm.invariant.start.p0(i64 80, ptr %68)
  %70 = load i32, ptr %19, align 4
  %71 = getelementptr ptr, ptr %68, i32 %70
  %72 = load ptr, ptr %71, align 8
  %73 = call ptr @typegetter_wrapper(ptr %72, ptr %67)
  %74 = load ptr, ptr %65, align 8
  %75 = ptrtoint ptr %74 to i64
  %76 = icmp eq i64 %75, ptrtoint (ptr @nil_typ to i64)
  %77 = icmp eq i64 %75, 0
  %78 = or i1 %76, %77
  %79 = icmp eq i1 %78, false
  %80 = zext i1 %79 to i8
  store i8 %80, ptr %4, align 1
  %81 = load i8, ptr %4, align 1
  %82 = trunc i8 %81 to i1
  br i1 %82, label %83, label %147

83:                                               ; preds = %66
  %84 = getelementptr { ptr, i160 }, ptr %65, i32 0, i32 0
  %85 = load ptr, ptr %84, align 8
  store ptr %85, ptr %6, align 8
  %86 = getelementptr { ptr, i160 }, ptr %65, i32 0, i32 1
  %87 = load i160, ptr %86, align 4
  store i160 %87, ptr %5, align 4
  %88 = load ptr, ptr %6, align 8
  store ptr %88, ptr %8, align 8
  %89 = load i160, ptr %5, align 4
  store i160 %89, ptr %7, align 4
  %90 = load ptr, ptr %8, align 8
  %91 = insertvalue { ptr, i160 } undef, ptr %90, 0
  %92 = load i160, ptr %7, align 4
  %93 = insertvalue { ptr, i160 } %91, i160 %92, 1
  %94 = load ptr, ptr %21, align 8
  %95 = load ptr, ptr %20, align 8
  %96 = call ptr @llvm.invariant.start.p0(i64 80, ptr %95)
  %97 = load i32, ptr %19, align 4
  %98 = getelementptr ptr, ptr %95, i32 %97
  %99 = getelementptr ptr, ptr %98, i32 2
  %100 = load ptr, ptr %99, align 8
  %101 = getelementptr { ptr, ptr }, ptr %100, i32 0, i32 0
  %102 = load ptr, ptr %101, align 8
  %103 = call { ptr } %102(ptr %94) #1
  store { ptr } %103, ptr %9, align 8
  %104 = load ptr, ptr %9, align 8
  %105 = call i1 %104({ ptr, i160 } %93)
  %106 = zext i1 %105 to i8
  store i8 %106, ptr %10, align 1
  %107 = load i8, ptr %10, align 1
  %108 = trunc i8 %107 to i1
  %109 = zext i1 %108 to i32
  %110 = xor i1 %108, true
  %111 = zext i1 %110 to i32
  br i1 %108, label %112, label %113

112:                                              ; preds = %83
  br label %147

113:                                              ; preds = %83
  %114 = load ptr, ptr %21, align 8
  %115 = load ptr, ptr %20, align 8
  %116 = call ptr @llvm.invariant.start.p0(i64 80, ptr %115)
  %117 = load i32, ptr %19, align 4
  %118 = getelementptr ptr, ptr %115, i32 %117
  %119 = getelementptr ptr, ptr %118, i32 1
  %120 = load ptr, ptr %119, align 8
  %121 = getelementptr { ptr, ptr }, ptr %120, i32 0, i32 0
  %122 = load ptr, ptr %121, align 8
  %123 = call { ptr, ptr, ptr, i32 } %122(ptr %114) #1
  store { ptr, ptr, ptr, i32 } %123, ptr %11, align 8
  call void @assume_offset(ptr %11, ptr @Iterator)
  %124 = getelementptr { ptr, ptr, ptr, i32 }, ptr %11, i32 0, i32 0
  %125 = load ptr, ptr %124, align 8
  %126 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %125, 0
  %127 = getelementptr { ptr, ptr, ptr, i32 }, ptr %11, i32 0, i32 1
  %128 = load ptr, ptr %127, align 8
  %129 = insertvalue { ptr, ptr, ptr, i32 } %126, ptr %128, 1
  %130 = getelementptr { ptr, ptr, ptr, i32 }, ptr %11, i32 0, i32 2
  %131 = load ptr, ptr %130, align 8
  %132 = insertvalue { ptr, ptr, ptr, i32 } %129, ptr %131, 2
  %133 = getelementptr { ptr, ptr, ptr, i32 }, ptr %11, i32 0, i32 3
  %134 = load i32, ptr %133, align 4
  %135 = insertvalue { ptr, ptr, ptr, i32 } %132, i32 %134, 3
  %136 = call ptr @llvm.invariant.start.p0(i64 0, ptr %12)
  %137 = call ptr @llvm.invariant.start.p0(i64 24, ptr %125)
  %138 = getelementptr ptr, ptr %125, i32 %134
  %139 = getelementptr ptr, ptr %138, i32 1
  %140 = load ptr, ptr %139, align 8
  %141 = call ptr @behavior_wrapper(ptr %140, { ptr, ptr, ptr, i32 } %135, ptr %13)
  %142 = call { ptr, i160 } %141({ ptr, ptr, ptr, i32 } %135, { ptr, ptr, ptr, i32 } %135, ptr %12)
  store { ptr, i160 } %142, ptr %14, align 8
  %143 = getelementptr { ptr, i160 }, ptr %14, i32 0, i32 0
  %144 = load ptr, ptr %143, align 8
  store ptr %144, ptr %84, align 8
  %145 = getelementptr { ptr, i160 }, ptr %14, i32 0, i32 1
  %146 = load i160, ptr %145, align 4
  store i160 %146, ptr %86, align 4
  br label %147

147:                                              ; preds = %112, %113, %66
  %148 = phi i32 [ %109, %113 ], [ %109, %112 ], [ 2, %66 ]
  %149 = phi i32 [ %111, %113 ], [ %111, %112 ], [ 0, %66 ]
  br label %150

150:                                              ; preds = %147
  br label %151

151:                                              ; preds = %150
  %152 = trunc i32 %149 to i1
  br i1 %152, label %153, label %154

153:                                              ; preds = %151
  br label %66

154:                                              ; preds = %151
  %155 = zext i32 %148 to i64
  %156 = trunc i64 %155 to i32
  switch i32 %156, label %162 [
    i32 1, label %157
  ]

157:                                              ; preds = %154
  %158 = load ptr, ptr %6, align 8
  %159 = insertvalue { ptr, i160 } undef, ptr %158, 0
  %160 = load i160, ptr %5, align 4
  %161 = insertvalue { ptr, i160 } %159, i160 %160, 1
  br label %168

162:                                              ; preds = %154
  %163 = load [0 x i8], ptr %15, align 1
  store [0 x i8] %163, ptr %16, align 1
  store ptr @nil_typ, ptr %17, align 8
  %164 = load ptr, ptr %17, align 8
  %165 = insertvalue { ptr, i160 } undef, ptr %164, 0
  %166 = load i160, ptr %16, align 4
  %167 = insertvalue { ptr, i160 } %165, i160 %166, 1
  br label %168

168:                                              ; preds = %162, %157
  %169 = phi { ptr, i160 } [ %167, %162 ], [ %161, %157 ]
  ret { ptr, i160 } %169
}

define ptr @Filterer_B_next_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 6, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [10 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { i64, i64 } @_data_size_Chained(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %10
  %12 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %5
  %13 = select i1 %12, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %5
  %14 = urem i64 %11, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %17
  %19 = add i64 %11, %18
  %20 = urem i64 %19, %13
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 %13, %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = add i64 %19, %23
  %25 = insertvalue { i64, i64 } undef, i64 %24, 0
  %26 = insertvalue { i64, i64 } %25, i64 %13, 1
  ret { i64, i64 } %26
}

define ptr @Chained_field_Chained_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define { ptr, ptr, ptr, i32 } @Chained_getter_first(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = getelementptr i8, ptr %0, i64 %6
  %8 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %9, 0
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %12, 1
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %15, 2
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  %19 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %18, 3
  ret { ptr, ptr, ptr, i32 } %19
}

define void @Chained_setter_first(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = getelementptr i8, ptr %0, i64 %7
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %9, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 0
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 0
  %12 = load ptr, ptr %10, align 8
  store ptr %12, ptr %11, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 1
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 1
  %15 = load ptr, ptr %13, align 8
  store ptr %15, ptr %14, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 2
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 2
  %18 = load ptr, ptr %16, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 3
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 3
  %21 = load i32, ptr %19, align 4
  store i32 %21, ptr %20, align 4
  ret void
}

define { ptr, ptr, ptr, i32 } @Chained_getter_second(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %7, %11
  %13 = getelementptr i8, ptr %0, i64 %12
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %15, 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 1
  %18 = load ptr, ptr %17, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %18, 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 2
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %21, 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 3
  %24 = load i32, ptr %23, align 4
  %25 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %24, 3
  ret { ptr, ptr, ptr, i32 } %25
}

define void @Chained_setter_second(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %8, %12
  %14 = getelementptr i8, ptr %0, i64 %13
  %15 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %15, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 0
  %18 = load ptr, ptr %16, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 1
  %21 = load ptr, ptr %19, align 8
  store ptr %21, ptr %20, align 8
  %22 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 2
  %24 = load ptr, ptr %22, align 8
  store ptr %24, ptr %23, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 3
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 3
  %27 = load i32, ptr %25, align 4
  store i32 %27, ptr %26, align 4
  ret void
}

define void @Chained_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) {
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %6, align 8
  %7 = alloca i32, align 4
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = alloca ptr, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %8, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 1
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %9, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 2
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %10, align 8
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  store i32 %18, ptr %7, align 4
  %19 = load ptr, ptr %8, align 8
  %20 = call i32 @get_offset(ptr %19, ptr @Chained)
  store i32 %20, ptr %7, align 4
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %21, align 8
  %22 = alloca i32, align 4
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = alloca ptr, align 8
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  store ptr %27, ptr %25, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 1
  %29 = load ptr, ptr %28, align 8
  store ptr %29, ptr %24, align 8
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 2
  %31 = load ptr, ptr %30, align 8
  store ptr %31, ptr %23, align 8
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 3
  %33 = load i32, ptr %32, align 4
  store i32 %33, ptr %22, align 4
  %34 = load ptr, ptr %25, align 8
  %35 = call i32 @get_offset(ptr %34, ptr @Iterable)
  store i32 %35, ptr %22, align 4
  %36 = alloca i32, align 4
  %37 = alloca ptr, align 8
  %38 = alloca ptr, align 8
  %39 = alloca ptr, align 8
  %40 = load ptr, ptr %25, align 8
  store ptr %40, ptr %39, align 8
  %41 = load ptr, ptr %24, align 8
  store ptr %41, ptr %38, align 8
  %42 = load ptr, ptr %23, align 8
  store ptr %42, ptr %37, align 8
  %43 = load i32, ptr %22, align 4
  store i32 %43, ptr %36, align 4
  %44 = load ptr, ptr %39, align 8
  %45 = call i32 @get_offset(ptr %44, ptr @Iterable)
  store i32 %45, ptr %36, align 4
  %46 = load ptr, ptr %9, align 8
  %47 = load ptr, ptr %8, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 432, ptr %47)
  %49 = load i32, ptr %7, align 4
  %50 = getelementptr ptr, ptr %47, i32 %49
  %51 = getelementptr ptr, ptr %50, i32 1
  %52 = load ptr, ptr %51, align 8
  %53 = getelementptr { ptr, ptr }, ptr %52, i32 0, i32 1
  %54 = load ptr, ptr %53, align 8
  %55 = load ptr, ptr %39, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %55, 0
  %57 = load ptr, ptr %38, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %57, 1
  %59 = load ptr, ptr %37, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %59, 2
  %61 = load i32, ptr %36, align 4
  %62 = insertvalue { ptr, ptr, ptr, i32 } %60, i32 %61, 3
  call void %54(ptr %46, { ptr, ptr, ptr, i32 } %62) #2
  %63 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %4, ptr %63, align 8
  %64 = alloca i32, align 4
  %65 = alloca ptr, align 8
  %66 = alloca ptr, align 8
  %67 = alloca ptr, align 8
  %68 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 0
  %69 = load ptr, ptr %68, align 8
  store ptr %69, ptr %67, align 8
  %70 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 1
  %71 = load ptr, ptr %70, align 8
  store ptr %71, ptr %66, align 8
  %72 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 2
  %73 = load ptr, ptr %72, align 8
  store ptr %73, ptr %65, align 8
  %74 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 3
  %75 = load i32, ptr %74, align 4
  store i32 %75, ptr %64, align 4
  %76 = load ptr, ptr %67, align 8
  %77 = call i32 @get_offset(ptr %76, ptr @Iterable)
  store i32 %77, ptr %64, align 4
  %78 = alloca i32, align 4
  %79 = alloca ptr, align 8
  %80 = alloca ptr, align 8
  %81 = alloca ptr, align 8
  %82 = load ptr, ptr %67, align 8
  store ptr %82, ptr %81, align 8
  %83 = load ptr, ptr %66, align 8
  store ptr %83, ptr %80, align 8
  %84 = load ptr, ptr %65, align 8
  store ptr %84, ptr %79, align 8
  %85 = load i32, ptr %64, align 4
  store i32 %85, ptr %78, align 4
  %86 = load ptr, ptr %81, align 8
  %87 = call i32 @get_offset(ptr %86, ptr @Iterable)
  store i32 %87, ptr %78, align 4
  %88 = load ptr, ptr %9, align 8
  %89 = load ptr, ptr %8, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 432, ptr %89)
  %91 = load i32, ptr %7, align 4
  %92 = getelementptr ptr, ptr %89, i32 %91
  %93 = getelementptr ptr, ptr %92, i32 2
  %94 = load ptr, ptr %93, align 8
  %95 = getelementptr { ptr, ptr }, ptr %94, i32 0, i32 1
  %96 = load ptr, ptr %95, align 8
  %97 = load ptr, ptr %81, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %97, 0
  %99 = load ptr, ptr %80, align 8
  %100 = insertvalue { ptr, ptr, ptr, i32 } %98, ptr %99, 1
  %101 = load ptr, ptr %79, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } %100, ptr %101, 2
  %103 = load i32, ptr %78, align 4
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, i32 %103, 3
  call void %96(ptr %88, { ptr, ptr, ptr, i32 } %104) #2
  ret void
}

define ptr @Chained_B_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @Iterable, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @Iterable to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 1
  %22 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 2
  %23 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 0
  %24 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 1
  %25 = load i64, ptr %21, align 4
  %26 = load i64, ptr %22, align 4
  %27 = load ptr, ptr %23, align 8
  %28 = load ptr, ptr %24, align 8
  %29 = load i64, ptr @Iterable, align 4
  %30 = call i1 @subtype_test_wrapper(ptr %27, i64 %26, i64 %25, i64 %29, i64 ptrtoint (ptr @Iterable to i64), ptr %28)
  %31 = zext i1 %30 to i8
  store i8 %31, ptr %3, align 1
  store i32 16, ptr %6, align 4
  %32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %33 = load i32, ptr %6, align 4
  %34 = getelementptr [54 x ptr], ptr %32, i32 0, i32 %33
  %35 = getelementptr ptr, ptr %34, i32 10
  %36 = load ptr, ptr %35, align 8
  ret ptr %36
}

define { ptr, ptr, ptr, i32 } @Chained_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @Chained)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 432, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 1
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr { ptr, ptr }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = call { ptr, ptr, ptr, i32 } %27(ptr %19) #1
  %29 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %28, ptr %29, align 8
  call void @assume_offset(ptr %29, ptr @Iterable)
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 1
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %34, 1
  %36 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 2
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %37, 2
  %39 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 3
  %40 = load i32, ptr %39, align 4
  %41 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %40, 3
  %42 = alloca [0 x ptr], align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 0, ptr %42)
  %44 = call ptr @llvm.invariant.start.p0(i64 200, ptr %31)
  %45 = getelementptr ptr, ptr %31, i32 %40
  %46 = getelementptr ptr, ptr %45, i32 1
  %47 = load ptr, ptr %46, align 8
  %48 = alloca {}, align 8
  %49 = call ptr @behavior_wrapper(ptr %47, { ptr, ptr, ptr, i32 } %41, ptr %48)
  %50 = call { ptr, ptr, ptr, i32 } %49({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr %42)
  %51 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %50, ptr %51, align 8
  %52 = alloca i32, align 4
  %53 = alloca ptr, align 8
  %54 = alloca ptr, align 8
  %55 = alloca ptr, align 8
  %56 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 0
  %57 = load ptr, ptr %56, align 8
  store ptr %57, ptr %53, align 8
  %58 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 1
  %59 = load ptr, ptr %58, align 8
  store ptr %59, ptr %55, align 8
  %60 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 2
  %61 = load ptr, ptr %60, align 8
  store ptr %61, ptr %54, align 8
  %62 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 3
  %63 = load i32, ptr %62, align 4
  store i32 %63, ptr %52, align 4
  %64 = load ptr, ptr %53, align 8
  %65 = call i32 @get_offset(ptr %64, ptr @Iterator)
  store i32 %65, ptr %52, align 4
  %66 = load ptr, ptr %7, align 8
  %67 = load ptr, ptr %6, align 8
  %68 = call ptr @llvm.invariant.start.p0(i64 432, ptr %67)
  %69 = load i32, ptr %5, align 4
  %70 = getelementptr ptr, ptr %67, i32 %69
  %71 = getelementptr ptr, ptr %70, i32 2
  %72 = load ptr, ptr %71, align 8
  %73 = getelementptr { ptr, ptr }, ptr %72, i32 0, i32 0
  %74 = load ptr, ptr %73, align 8
  %75 = call { ptr, ptr, ptr, i32 } %74(ptr %66) #1
  %76 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %75, ptr %76, align 8
  call void @assume_offset(ptr %76, ptr @Iterable)
  %77 = getelementptr { ptr, ptr, ptr, i32 }, ptr %76, i32 0, i32 0
  %78 = load ptr, ptr %77, align 8
  %79 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %78, 0
  %80 = getelementptr { ptr, ptr, ptr, i32 }, ptr %76, i32 0, i32 1
  %81 = load ptr, ptr %80, align 8
  %82 = insertvalue { ptr, ptr, ptr, i32 } %79, ptr %81, 1
  %83 = getelementptr { ptr, ptr, ptr, i32 }, ptr %76, i32 0, i32 2
  %84 = load ptr, ptr %83, align 8
  %85 = insertvalue { ptr, ptr, ptr, i32 } %82, ptr %84, 2
  %86 = getelementptr { ptr, ptr, ptr, i32 }, ptr %76, i32 0, i32 3
  %87 = load i32, ptr %86, align 4
  %88 = insertvalue { ptr, ptr, ptr, i32 } %85, i32 %87, 3
  %89 = alloca [0 x ptr], align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 0, ptr %89)
  %91 = call ptr @llvm.invariant.start.p0(i64 200, ptr %78)
  %92 = getelementptr ptr, ptr %78, i32 %87
  %93 = getelementptr ptr, ptr %92, i32 1
  %94 = load ptr, ptr %93, align 8
  %95 = alloca {}, align 8
  %96 = call ptr @behavior_wrapper(ptr %94, { ptr, ptr, ptr, i32 } %88, ptr %95)
  %97 = call { ptr, ptr, ptr, i32 } %96({ ptr, ptr, ptr, i32 } %88, { ptr, ptr, ptr, i32 } %88, ptr %89)
  %98 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %97, ptr %98, align 8
  %99 = alloca i32, align 4
  %100 = alloca ptr, align 8
  %101 = alloca ptr, align 8
  %102 = alloca ptr, align 8
  %103 = getelementptr { ptr, ptr, ptr, i32 }, ptr %98, i32 0, i32 0
  %104 = load ptr, ptr %103, align 8
  store ptr %104, ptr %100, align 8
  %105 = getelementptr { ptr, ptr, ptr, i32 }, ptr %98, i32 0, i32 1
  %106 = load ptr, ptr %105, align 8
  store ptr %106, ptr %102, align 8
  %107 = getelementptr { ptr, ptr, ptr, i32 }, ptr %98, i32 0, i32 2
  %108 = load ptr, ptr %107, align 8
  store ptr %108, ptr %101, align 8
  %109 = getelementptr { ptr, ptr, ptr, i32 }, ptr %98, i32 0, i32 3
  %110 = load i32, ptr %109, align 4
  store i32 %110, ptr %99, align 4
  %111 = load ptr, ptr %100, align 8
  %112 = call i32 @get_offset(ptr %111, ptr @Iterator)
  store i32 %112, ptr %99, align 4
  %113 = load ptr, ptr %7, align 8
  %114 = load ptr, ptr %6, align 8
  %115 = call ptr @llvm.invariant.start.p0(i64 432, ptr %114)
  %116 = load i32, ptr %5, align 4
  %117 = getelementptr ptr, ptr %114, i32 %116
  %118 = load ptr, ptr %117, align 8
  %119 = call ptr @typegetter_wrapper(ptr %118, ptr %113)
  %120 = alloca [2 x ptr], align 8
  store ptr @Chainer, ptr %120, align 8
  %121 = getelementptr ptr, ptr %120, i32 1
  store ptr %119, ptr %121, align 8
  %122 = load ptr, ptr %120, align 8
  %123 = getelementptr ptr, ptr %122, i32 6
  %124 = load ptr, ptr %123, align 8
  %125 = call { i64, i64 } @size_wrapper(ptr %124, ptr %120)
  %126 = extractvalue { i64, i64 } %125, 0
  %127 = call ptr @bump_malloc(i64 %126)
  store ptr %119, ptr %127, align 8
  %128 = call ptr @llvm.invariant.start.p0(i64 8, ptr %127)
  %129 = alloca i32, align 4
  %130 = alloca ptr, align 8
  %131 = alloca ptr, align 8
  %132 = alloca ptr, align 8
  store ptr @Chainer, ptr %132, align 8
  store ptr %127, ptr %131, align 8
  store i32 10, ptr %129, align 4
  %133 = load ptr, ptr %7, align 8
  %134 = load ptr, ptr %6, align 8
  %135 = call ptr @llvm.invariant.start.p0(i64 432, ptr %134)
  %136 = load i32, ptr %5, align 4
  %137 = getelementptr ptr, ptr %134, i32 %136
  %138 = getelementptr ptr, ptr %137, i32 1
  %139 = load ptr, ptr %138, align 8
  %140 = getelementptr { ptr, ptr }, ptr %139, i32 0, i32 0
  %141 = load ptr, ptr %140, align 8
  %142 = call { ptr, ptr, ptr, i32 } %141(ptr %133) #1
  %143 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %142, ptr %143, align 8
  call void @assume_offset(ptr %143, ptr @Iterable)
  %144 = getelementptr { ptr, ptr, ptr, i32 }, ptr %143, i32 0, i32 0
  %145 = load ptr, ptr %144, align 8
  %146 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %145, 0
  %147 = getelementptr { ptr, ptr, ptr, i32 }, ptr %143, i32 0, i32 1
  %148 = load ptr, ptr %147, align 8
  %149 = insertvalue { ptr, ptr, ptr, i32 } %146, ptr %148, 1
  %150 = getelementptr { ptr, ptr, ptr, i32 }, ptr %143, i32 0, i32 2
  %151 = load ptr, ptr %150, align 8
  %152 = insertvalue { ptr, ptr, ptr, i32 } %149, ptr %151, 2
  %153 = getelementptr { ptr, ptr, ptr, i32 }, ptr %143, i32 0, i32 3
  %154 = load i32, ptr %153, align 4
  %155 = insertvalue { ptr, ptr, ptr, i32 } %152, i32 %154, 3
  %156 = alloca [0 x ptr], align 8
  %157 = call ptr @llvm.invariant.start.p0(i64 0, ptr %156)
  %158 = call ptr @llvm.invariant.start.p0(i64 200, ptr %145)
  %159 = getelementptr ptr, ptr %145, i32 %154
  %160 = getelementptr ptr, ptr %159, i32 1
  %161 = load ptr, ptr %160, align 8
  %162 = alloca {}, align 8
  %163 = call ptr @behavior_wrapper(ptr %161, { ptr, ptr, ptr, i32 } %155, ptr %162)
  %164 = call { ptr, ptr, ptr, i32 } %163({ ptr, ptr, ptr, i32 } %155, { ptr, ptr, ptr, i32 } %155, ptr %156)
  %165 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %164, ptr %165, align 8
  %166 = alloca i32, align 4
  %167 = alloca ptr, align 8
  %168 = alloca ptr, align 8
  %169 = alloca ptr, align 8
  %170 = getelementptr { ptr, ptr, ptr, i32 }, ptr %165, i32 0, i32 0
  %171 = load ptr, ptr %170, align 8
  store ptr %171, ptr %169, align 8
  %172 = getelementptr { ptr, ptr, ptr, i32 }, ptr %165, i32 0, i32 1
  %173 = load ptr, ptr %172, align 8
  store ptr %173, ptr %168, align 8
  %174 = getelementptr { ptr, ptr, ptr, i32 }, ptr %165, i32 0, i32 2
  %175 = load ptr, ptr %174, align 8
  store ptr %175, ptr %167, align 8
  %176 = getelementptr { ptr, ptr, ptr, i32 }, ptr %165, i32 0, i32 3
  %177 = load i32, ptr %176, align 4
  store i32 %177, ptr %166, align 4
  %178 = load ptr, ptr %169, align 8
  %179 = call i32 @get_offset(ptr %178, ptr @Iterator)
  store i32 %179, ptr %166, align 4
  %180 = load ptr, ptr %7, align 8
  %181 = load ptr, ptr %6, align 8
  %182 = call ptr @llvm.invariant.start.p0(i64 432, ptr %181)
  %183 = load i32, ptr %5, align 4
  %184 = getelementptr ptr, ptr %181, i32 %183
  %185 = getelementptr ptr, ptr %184, i32 2
  %186 = load ptr, ptr %185, align 8
  %187 = getelementptr { ptr, ptr }, ptr %186, i32 0, i32 0
  %188 = load ptr, ptr %187, align 8
  %189 = call { ptr, ptr, ptr, i32 } %188(ptr %180) #1
  %190 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %189, ptr %190, align 8
  call void @assume_offset(ptr %190, ptr @Iterable)
  %191 = getelementptr { ptr, ptr, ptr, i32 }, ptr %190, i32 0, i32 0
  %192 = load ptr, ptr %191, align 8
  %193 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %192, 0
  %194 = getelementptr { ptr, ptr, ptr, i32 }, ptr %190, i32 0, i32 1
  %195 = load ptr, ptr %194, align 8
  %196 = insertvalue { ptr, ptr, ptr, i32 } %193, ptr %195, 1
  %197 = getelementptr { ptr, ptr, ptr, i32 }, ptr %190, i32 0, i32 2
  %198 = load ptr, ptr %197, align 8
  %199 = insertvalue { ptr, ptr, ptr, i32 } %196, ptr %198, 2
  %200 = getelementptr { ptr, ptr, ptr, i32 }, ptr %190, i32 0, i32 3
  %201 = load i32, ptr %200, align 4
  %202 = insertvalue { ptr, ptr, ptr, i32 } %199, i32 %201, 3
  %203 = alloca [0 x ptr], align 8
  %204 = call ptr @llvm.invariant.start.p0(i64 0, ptr %203)
  %205 = call ptr @llvm.invariant.start.p0(i64 200, ptr %192)
  %206 = getelementptr ptr, ptr %192, i32 %201
  %207 = getelementptr ptr, ptr %206, i32 1
  %208 = load ptr, ptr %207, align 8
  %209 = alloca {}, align 8
  %210 = call ptr @behavior_wrapper(ptr %208, { ptr, ptr, ptr, i32 } %202, ptr %209)
  %211 = call { ptr, ptr, ptr, i32 } %210({ ptr, ptr, ptr, i32 } %202, { ptr, ptr, ptr, i32 } %202, ptr %203)
  %212 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %211, ptr %212, align 8
  %213 = alloca i32, align 4
  %214 = alloca ptr, align 8
  %215 = alloca ptr, align 8
  %216 = alloca ptr, align 8
  %217 = getelementptr { ptr, ptr, ptr, i32 }, ptr %212, i32 0, i32 0
  %218 = load ptr, ptr %217, align 8
  store ptr %218, ptr %216, align 8
  %219 = getelementptr { ptr, ptr, ptr, i32 }, ptr %212, i32 0, i32 1
  %220 = load ptr, ptr %219, align 8
  store ptr %220, ptr %215, align 8
  %221 = getelementptr { ptr, ptr, ptr, i32 }, ptr %212, i32 0, i32 2
  %222 = load ptr, ptr %221, align 8
  store ptr %222, ptr %214, align 8
  %223 = getelementptr { ptr, ptr, ptr, i32 }, ptr %212, i32 0, i32 3
  %224 = load i32, ptr %223, align 4
  store i32 %224, ptr %213, align 4
  %225 = load ptr, ptr %216, align 8
  %226 = call i32 @get_offset(ptr %225, ptr @Iterator)
  store i32 %226, ptr %213, align 4
  %227 = alloca i32, align 4
  %228 = alloca ptr, align 8
  %229 = alloca ptr, align 8
  %230 = alloca ptr, align 8
  %231 = load ptr, ptr %169, align 8
  store ptr %231, ptr %230, align 8
  %232 = load ptr, ptr %168, align 8
  store ptr %232, ptr %229, align 8
  %233 = load ptr, ptr %167, align 8
  store ptr %233, ptr %228, align 8
  %234 = load i32, ptr %166, align 4
  store i32 %234, ptr %227, align 4
  %235 = load ptr, ptr %230, align 8
  %236 = call i32 @get_offset(ptr %235, ptr @Iterator)
  store i32 %236, ptr %227, align 4
  %237 = load ptr, ptr %230, align 8
  %238 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %237, 0
  %239 = load ptr, ptr %229, align 8
  %240 = insertvalue { ptr, ptr, ptr, i32 } %238, ptr %239, 1
  %241 = load ptr, ptr %228, align 8
  %242 = insertvalue { ptr, ptr, ptr, i32 } %240, ptr %241, 2
  %243 = load i32, ptr %227, align 4
  %244 = insertvalue { ptr, ptr, ptr, i32 } %242, i32 %243, 3
  %245 = alloca i32, align 4
  %246 = alloca ptr, align 8
  %247 = alloca ptr, align 8
  %248 = alloca ptr, align 8
  %249 = load ptr, ptr %216, align 8
  store ptr %249, ptr %248, align 8
  %250 = load ptr, ptr %215, align 8
  store ptr %250, ptr %247, align 8
  %251 = load ptr, ptr %214, align 8
  store ptr %251, ptr %246, align 8
  %252 = load i32, ptr %213, align 4
  store i32 %252, ptr %245, align 4
  %253 = load ptr, ptr %248, align 8
  %254 = call i32 @get_offset(ptr %253, ptr @Iterator)
  store i32 %254, ptr %245, align 4
  %255 = load ptr, ptr %248, align 8
  %256 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %255, 0
  %257 = load ptr, ptr %247, align 8
  %258 = insertvalue { ptr, ptr, ptr, i32 } %256, ptr %257, 1
  %259 = load ptr, ptr %246, align 8
  %260 = insertvalue { ptr, ptr, ptr, i32 } %258, ptr %259, 2
  %261 = load i32, ptr %245, align 4
  %262 = insertvalue { ptr, ptr, ptr, i32 } %260, i32 %261, 3
  %263 = load ptr, ptr %132, align 8
  %264 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %263, 0
  %265 = load ptr, ptr %131, align 8
  %266 = insertvalue { ptr, ptr, ptr, i32 } %264, ptr %265, 1
  %267 = load ptr, ptr %130, align 8
  %268 = insertvalue { ptr, ptr, ptr, i32 } %266, ptr %267, 2
  %269 = load i32, ptr %129, align 4
  %270 = insertvalue { ptr, ptr, ptr, i32 } %268, i32 %269, 3
  %271 = load ptr, ptr %7, align 8
  %272 = load ptr, ptr %6, align 8
  %273 = call ptr @llvm.invariant.start.p0(i64 432, ptr %272)
  %274 = load i32, ptr %5, align 4
  %275 = getelementptr ptr, ptr %272, i32 %274
  %276 = load ptr, ptr %275, align 8
  %277 = call ptr @typegetter_wrapper(ptr %276, ptr %271)
  %278 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %279 = getelementptr [3 x ptr], ptr %278, i32 0, i32 1
  store ptr %277, ptr %279, align 8
  %280 = getelementptr [3 x ptr], ptr %278, i32 0, i32 2
  store ptr null, ptr %280, align 8
  %281 = call ptr @llvm.invariant.start.p0(i64 16, ptr %278)
  store ptr @Iterator, ptr %278, align 8
  %282 = load ptr, ptr %7, align 8
  %283 = load ptr, ptr %6, align 8
  %284 = call ptr @llvm.invariant.start.p0(i64 432, ptr %283)
  %285 = load i32, ptr %5, align 4
  %286 = getelementptr ptr, ptr %283, i32 %285
  %287 = load ptr, ptr %286, align 8
  %288 = call ptr @typegetter_wrapper(ptr %287, ptr %282)
  %289 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %290 = getelementptr [3 x ptr], ptr %289, i32 0, i32 1
  store ptr %288, ptr %290, align 8
  %291 = getelementptr [3 x ptr], ptr %289, i32 0, i32 2
  store ptr null, ptr %291, align 8
  %292 = call ptr @llvm.invariant.start.p0(i64 16, ptr %289)
  store ptr @Iterator, ptr %289, align 8
  %293 = alloca [2 x ptr], align 8
  %294 = getelementptr [2 x ptr], ptr %293, i32 0, i32 0
  store ptr %278, ptr %294, align 8
  %295 = getelementptr [2 x ptr], ptr %293, i32 0, i32 1
  store ptr %289, ptr %295, align 8
  %296 = call ptr @llvm.invariant.start.p0(i64 4, ptr %293)
  %297 = call ptr @llvm.invariant.start.p0(i64 88, ptr %263)
  %298 = getelementptr ptr, ptr %263, i32 %269
  %299 = getelementptr ptr, ptr %298, i32 4
  %300 = load ptr, ptr %299, align 8
  %301 = alloca { ptr, ptr }, align 8
  %302 = getelementptr { ptr, ptr }, ptr %301, i32 0, i32 0
  store ptr %237, ptr %302, align 8
  %303 = getelementptr { ptr, ptr }, ptr %301, i32 0, i32 1
  store ptr %255, ptr %303, align 8
  %304 = call ptr @behavior_wrapper(ptr %300, { ptr, ptr, ptr, i32 } %270, ptr %301)
  call void %304({ ptr, ptr, ptr, i32 } %270, { ptr, ptr, ptr, i32 } %270, ptr %293, { ptr, ptr, ptr, i32 } %244, { ptr, ptr, ptr, i32 } %262)
  %305 = alloca i32, align 4
  %306 = alloca ptr, align 8
  %307 = alloca ptr, align 8
  %308 = alloca ptr, align 8
  %309 = load ptr, ptr %132, align 8
  store ptr %309, ptr %308, align 8
  %310 = load ptr, ptr %131, align 8
  store ptr %310, ptr %307, align 8
  %311 = load ptr, ptr %130, align 8
  store ptr %311, ptr %306, align 8
  %312 = load i32, ptr %129, align 4
  store i32 %312, ptr %305, align 4
  %313 = load ptr, ptr %308, align 8
  %314 = call i32 @get_offset(ptr %313, ptr @Iterator)
  store i32 %314, ptr %305, align 4
  %315 = load ptr, ptr %308, align 8
  %316 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %315, 0
  %317 = load ptr, ptr %307, align 8
  %318 = insertvalue { ptr, ptr, ptr, i32 } %316, ptr %317, 1
  %319 = load ptr, ptr %306, align 8
  %320 = insertvalue { ptr, ptr, ptr, i32 } %318, ptr %319, 2
  %321 = load i32, ptr %305, align 4
  %322 = insertvalue { ptr, ptr, ptr, i32 } %320, i32 %321, 3
  ret { ptr, ptr, ptr, i32 } %322
}

define ptr @Chained_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 17, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [54 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @Chained_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 18, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [54 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Chained_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @any_typ, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @any_typ to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = ptrtoint ptr %20 to i64
  %22 = icmp eq i64 %21, ptrtoint (ptr @function_typ to i64)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 19, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [54 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define ptr @Chained_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 20, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [54 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Chained_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 21, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [54 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Chained_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 22, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [54 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @Chained_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 23, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [54 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Chained_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 24, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [54 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Chained_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 25, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [54 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define ptr @Chained_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 26, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [54 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define ptr @Chained_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 27, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [54 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define ptr @Chained_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 28, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [54 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define { i64, i64 } @_data_size_Chainer(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %10
  %12 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %5
  %13 = select i1 %12, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %5
  %14 = urem i64 %11, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %17
  %19 = add i64 %11, %18
  %20 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, i1 }, ptr null, i32 0, i32 1) to i64), %13
  %21 = select i1 %20, i64 ptrtoint (ptr getelementptr ({ i8, i1 }, ptr null, i32 0, i32 1) to i64), i64 %13
  %22 = urem i64 %19, ptrtoint (ptr getelementptr ({ i8, i1 }, ptr null, i32 0, i32 1) to i64)
  %23 = icmp eq i64 %22, 0
  %24 = sub i64 ptrtoint (ptr getelementptr ({ i8, i1 }, ptr null, i32 0, i32 1) to i64), %22
  %25 = select i1 %23, i64 0, i64 %24
  %26 = add i64 ptrtoint (ptr getelementptr (i1, ptr null, i32 1) to i64), %25
  %27 = add i64 %19, %26
  %28 = urem i64 %27, %21
  %29 = icmp eq i64 %28, 0
  %30 = sub i64 %21, %28
  %31 = select i1 %29, i64 0, i64 %30
  %32 = add i64 %27, %31
  %33 = insertvalue { i64, i64 } undef, i64 %32, 0
  %34 = insertvalue { i64, i64 } %33, i64 %21, 1
  ret { i64, i64 } %34
}

define ptr @Chainer_field_Chainer_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define { ptr, ptr, ptr, i32 } @Chainer_getter_first(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = getelementptr i8, ptr %0, i64 %6
  %8 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %9, 0
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %12, 1
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %15, 2
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  %19 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %18, 3
  ret { ptr, ptr, ptr, i32 } %19
}

define void @Chainer_setter_first(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = getelementptr i8, ptr %0, i64 %7
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %9, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 0
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 0
  %12 = load ptr, ptr %10, align 8
  store ptr %12, ptr %11, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 1
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 1
  %15 = load ptr, ptr %13, align 8
  store ptr %15, ptr %14, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 2
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 2
  %18 = load ptr, ptr %16, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 3
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 3
  %21 = load i32, ptr %19, align 4
  store i32 %21, ptr %20, align 4
  ret void
}

define { ptr, ptr, ptr, i32 } @Chainer_getter_second(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %7, %11
  %13 = getelementptr i8, ptr %0, i64 %12
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %15, 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 1
  %18 = load ptr, ptr %17, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %18, 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 2
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %21, 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 3
  %24 = load i32, ptr %23, align 4
  %25 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %24, 3
  ret { ptr, ptr, ptr, i32 } %25
}

define void @Chainer_setter_second(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %8, %12
  %14 = getelementptr i8, ptr %0, i64 %13
  %15 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %15, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 0
  %18 = load ptr, ptr %16, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 1
  %21 = load ptr, ptr %19, align 8
  store ptr %21, ptr %20, align 8
  %22 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 2
  %24 = load ptr, ptr %22, align 8
  store ptr %24, ptr %23, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 3
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 3
  %27 = load i32, ptr %25, align 4
  store i32 %27, ptr %26, align 4
  ret void
}

define i1 @Chainer_getter_on_first(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %11
  %13 = add i64 %7, %12
  %14 = urem i64 %13, ptrtoint (ptr getelementptr ({ i8, i1 }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, i1 }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 %13, %17
  %19 = getelementptr i8, ptr %0, i64 %18
  %20 = load i8, ptr %19, align 1
  %21 = trunc i8 %20 to i1
  ret i1 %21
}

define void @Chainer_setter_on_first(ptr %0, i1 %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %12
  %14 = add i64 %8, %13
  %15 = urem i64 %14, ptrtoint (ptr getelementptr ({ i8, i1 }, ptr null, i32 0, i32 1) to i64)
  %16 = icmp eq i64 %15, 0
  %17 = sub i64 ptrtoint (ptr getelementptr ({ i8, i1 }, ptr null, i32 0, i32 1) to i64), %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add i64 %14, %18
  %20 = getelementptr i8, ptr %0, i64 %19
  %21 = alloca i1, align 1
  %22 = zext i1 %1 to i8
  store i8 %22, ptr %21, align 1
  %23 = load i8, ptr %21, align 1
  %24 = trunc i8 %23 to i1
  %25 = zext i1 %24 to i8
  store i8 %25, ptr %20, align 1
  ret void
}

define void @Chainer_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) {
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %6, align 8
  %7 = alloca i32, align 4
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = alloca ptr, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %8, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 1
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %9, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 2
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %10, align 8
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  store i32 %18, ptr %7, align 4
  %19 = load ptr, ptr %8, align 8
  %20 = call i32 @get_offset(ptr %19, ptr @Chainer)
  store i32 %20, ptr %7, align 4
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %21, align 8
  %22 = alloca i32, align 4
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = alloca ptr, align 8
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  store ptr %27, ptr %25, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 1
  %29 = load ptr, ptr %28, align 8
  store ptr %29, ptr %24, align 8
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 2
  %31 = load ptr, ptr %30, align 8
  store ptr %31, ptr %23, align 8
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 3
  %33 = load i32, ptr %32, align 4
  store i32 %33, ptr %22, align 4
  %34 = load ptr, ptr %25, align 8
  %35 = call i32 @get_offset(ptr %34, ptr @Iterator)
  store i32 %35, ptr %22, align 4
  %36 = alloca i32, align 4
  %37 = alloca ptr, align 8
  %38 = alloca ptr, align 8
  %39 = alloca ptr, align 8
  %40 = load ptr, ptr %25, align 8
  store ptr %40, ptr %39, align 8
  %41 = load ptr, ptr %24, align 8
  store ptr %41, ptr %38, align 8
  %42 = load ptr, ptr %23, align 8
  store ptr %42, ptr %37, align 8
  %43 = load i32, ptr %22, align 4
  store i32 %43, ptr %36, align 4
  %44 = load ptr, ptr %39, align 8
  %45 = call i32 @get_offset(ptr %44, ptr @Iterator)
  store i32 %45, ptr %36, align 4
  %46 = load ptr, ptr %9, align 8
  %47 = load ptr, ptr %8, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 88, ptr %47)
  %49 = load i32, ptr %7, align 4
  %50 = getelementptr ptr, ptr %47, i32 %49
  %51 = getelementptr ptr, ptr %50, i32 1
  %52 = load ptr, ptr %51, align 8
  %53 = getelementptr { ptr, ptr }, ptr %52, i32 0, i32 1
  %54 = load ptr, ptr %53, align 8
  %55 = load ptr, ptr %39, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %55, 0
  %57 = load ptr, ptr %38, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %57, 1
  %59 = load ptr, ptr %37, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %59, 2
  %61 = load i32, ptr %36, align 4
  %62 = insertvalue { ptr, ptr, ptr, i32 } %60, i32 %61, 3
  call void %54(ptr %46, { ptr, ptr, ptr, i32 } %62) #2
  %63 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %4, ptr %63, align 8
  %64 = alloca i32, align 4
  %65 = alloca ptr, align 8
  %66 = alloca ptr, align 8
  %67 = alloca ptr, align 8
  %68 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 0
  %69 = load ptr, ptr %68, align 8
  store ptr %69, ptr %67, align 8
  %70 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 1
  %71 = load ptr, ptr %70, align 8
  store ptr %71, ptr %66, align 8
  %72 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 2
  %73 = load ptr, ptr %72, align 8
  store ptr %73, ptr %65, align 8
  %74 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 3
  %75 = load i32, ptr %74, align 4
  store i32 %75, ptr %64, align 4
  %76 = load ptr, ptr %67, align 8
  %77 = call i32 @get_offset(ptr %76, ptr @Iterator)
  store i32 %77, ptr %64, align 4
  %78 = alloca i32, align 4
  %79 = alloca ptr, align 8
  %80 = alloca ptr, align 8
  %81 = alloca ptr, align 8
  %82 = load ptr, ptr %67, align 8
  store ptr %82, ptr %81, align 8
  %83 = load ptr, ptr %66, align 8
  store ptr %83, ptr %80, align 8
  %84 = load ptr, ptr %65, align 8
  store ptr %84, ptr %79, align 8
  %85 = load i32, ptr %64, align 4
  store i32 %85, ptr %78, align 4
  %86 = load ptr, ptr %81, align 8
  %87 = call i32 @get_offset(ptr %86, ptr @Iterator)
  store i32 %87, ptr %78, align 4
  %88 = load ptr, ptr %9, align 8
  %89 = load ptr, ptr %8, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 88, ptr %89)
  %91 = load i32, ptr %7, align 4
  %92 = getelementptr ptr, ptr %89, i32 %91
  %93 = getelementptr ptr, ptr %92, i32 2
  %94 = load ptr, ptr %93, align 8
  %95 = getelementptr { ptr, ptr }, ptr %94, i32 0, i32 1
  %96 = load ptr, ptr %95, align 8
  %97 = load ptr, ptr %81, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %97, 0
  %99 = load ptr, ptr %80, align 8
  %100 = insertvalue { ptr, ptr, ptr, i32 } %98, ptr %99, 1
  %101 = load ptr, ptr %79, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } %100, ptr %101, 2
  %103 = load i32, ptr %78, align 4
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, i32 %103, 3
  call void %96(ptr %88, { ptr, ptr, ptr, i32 } %104) #2
  %105 = alloca i1, align 1
  store i8 1, ptr %105, align 1
  %106 = load ptr, ptr %9, align 8
  %107 = load ptr, ptr %8, align 8
  %108 = call ptr @llvm.invariant.start.p0(i64 88, ptr %107)
  %109 = load i32, ptr %7, align 4
  %110 = getelementptr ptr, ptr %107, i32 %109
  %111 = getelementptr ptr, ptr %110, i32 3
  %112 = load ptr, ptr %111, align 8
  %113 = getelementptr { ptr, ptr }, ptr %112, i32 0, i32 1
  %114 = load ptr, ptr %113, align 8
  %115 = load i8, ptr %105, align 1
  %116 = trunc i8 %115 to i1
  call void %114(ptr %106, i1 %116) #2
  ret void
}

define ptr @Chainer_B_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @Iterator, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @Iterator to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 1
  %22 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 2
  %23 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 0
  %24 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 1
  %25 = load i64, ptr %21, align 4
  %26 = load i64, ptr %22, align 4
  %27 = load ptr, ptr %23, align 8
  %28 = load ptr, ptr %24, align 8
  %29 = load i64, ptr @Iterator, align 4
  %30 = call i1 @subtype_test_wrapper(ptr %27, i64 %26, i64 %25, i64 %29, i64 ptrtoint (ptr @Iterator to i64), ptr %28)
  %31 = zext i1 %30 to i8
  store i8 %31, ptr %3, align 1
  store i32 6, ptr %6, align 4
  %32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %33 = load i32, ptr %6, align 4
  %34 = getelementptr [11 x ptr], ptr %32, i32 0, i32 %33
  %35 = getelementptr ptr, ptr %34, i32 10
  %36 = load ptr, ptr %35, align 8
  ret ptr %36
}

define { ptr, i160 } @Chainer_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  %5 = alloca [0 x ptr], align 8
  %6 = alloca {}, align 8
  %7 = alloca { ptr, i160 }, align 8
  %8 = alloca i1, align 1
  %9 = alloca i160, align 8
  %10 = alloca ptr, align 8
  %11 = alloca [0 x i8], align 1
  %12 = alloca i1, align 1
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %14 = alloca [0 x ptr], align 8
  %15 = alloca {}, align 8
  %16 = alloca { ptr, i160 }, align 8
  %17 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %17, align 8
  %18 = alloca i32, align 4
  %19 = alloca ptr, align 8
  %20 = alloca ptr, align 8
  %21 = alloca ptr, align 8
  %22 = getelementptr { ptr, ptr, ptr, i32 }, ptr %17, i32 0, i32 0
  %23 = load ptr, ptr %22, align 8
  store ptr %23, ptr %19, align 8
  %24 = getelementptr { ptr, ptr, ptr, i32 }, ptr %17, i32 0, i32 1
  %25 = load ptr, ptr %24, align 8
  store ptr %25, ptr %20, align 8
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %17, i32 0, i32 2
  %27 = load ptr, ptr %26, align 8
  store ptr %27, ptr %21, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %17, i32 0, i32 3
  %29 = load i32, ptr %28, align 4
  store i32 %29, ptr %18, align 4
  %30 = load ptr, ptr %19, align 8
  %31 = call i32 @get_offset(ptr %30, ptr @Chainer)
  store i32 %31, ptr %18, align 4
  %32 = load ptr, ptr %20, align 8
  %33 = load ptr, ptr %19, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 88, ptr %33)
  %35 = load i32, ptr %18, align 4
  %36 = getelementptr ptr, ptr %33, i32 %35
  %37 = getelementptr ptr, ptr %36, i32 3
  %38 = load ptr, ptr %37, align 8
  %39 = getelementptr { ptr, ptr }, ptr %38, i32 0, i32 0
  %40 = load ptr, ptr %39, align 8
  %41 = call i1 %40(ptr %32) #1
  %42 = alloca i1, align 1
  %43 = zext i1 %41 to i8
  store i8 %43, ptr %42, align 1
  %44 = load i8, ptr %42, align 1
  %45 = trunc i8 %44 to i1
  br i1 %45, label %46, label %119

46:                                               ; preds = %3
  %47 = load ptr, ptr %20, align 8
  %48 = load ptr, ptr %19, align 8
  %49 = call ptr @llvm.invariant.start.p0(i64 88, ptr %48)
  %50 = load i32, ptr %18, align 4
  %51 = getelementptr ptr, ptr %48, i32 %50
  %52 = getelementptr ptr, ptr %51, i32 1
  %53 = load ptr, ptr %52, align 8
  %54 = getelementptr { ptr, ptr }, ptr %53, i32 0, i32 0
  %55 = load ptr, ptr %54, align 8
  %56 = call { ptr, ptr, ptr, i32 } %55(ptr %47) #1
  store { ptr, ptr, ptr, i32 } %56, ptr %4, align 8
  call void @assume_offset(ptr %4, ptr @Iterator)
  %57 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %58 = load ptr, ptr %57, align 8
  %59 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %58, 0
  %60 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %61 = load ptr, ptr %60, align 8
  %62 = insertvalue { ptr, ptr, ptr, i32 } %59, ptr %61, 1
  %63 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %64 = load ptr, ptr %63, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %64, 2
  %66 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %67 = load i32, ptr %66, align 4
  %68 = insertvalue { ptr, ptr, ptr, i32 } %65, i32 %67, 3
  %69 = call ptr @llvm.invariant.start.p0(i64 0, ptr %5)
  %70 = call ptr @llvm.invariant.start.p0(i64 24, ptr %58)
  %71 = getelementptr ptr, ptr %58, i32 %67
  %72 = getelementptr ptr, ptr %71, i32 1
  %73 = load ptr, ptr %72, align 8
  %74 = call ptr @behavior_wrapper(ptr %73, { ptr, ptr, ptr, i32 } %68, ptr %6)
  %75 = call { ptr, i160 } %74({ ptr, ptr, ptr, i32 } %68, { ptr, ptr, ptr, i32 } %68, ptr %5)
  store { ptr, i160 } %75, ptr %7, align 8
  %76 = load ptr, ptr %20, align 8
  %77 = load ptr, ptr %19, align 8
  %78 = call ptr @llvm.invariant.start.p0(i64 88, ptr %77)
  %79 = load i32, ptr %18, align 4
  %80 = getelementptr ptr, ptr %77, i32 %79
  %81 = load ptr, ptr %80, align 8
  %82 = call ptr @typegetter_wrapper(ptr %81, ptr %76)
  %83 = load ptr, ptr %7, align 8
  %84 = ptrtoint ptr %83 to i64
  %85 = icmp eq i64 %84, ptrtoint (ptr @nil_typ to i64)
  %86 = icmp eq i64 %84, 0
  %87 = or i1 %85, %86
  %88 = icmp eq i1 %87, false
  %89 = zext i1 %88 to i8
  store i8 %89, ptr %8, align 1
  %90 = load i8, ptr %8, align 1
  %91 = trunc i8 %90 to i1
  %92 = xor i1 %91, true
  %93 = zext i1 %92 to i32
  br i1 %91, label %94, label %103

94:                                               ; preds = %46
  %95 = getelementptr { ptr, i160 }, ptr %7, i32 0, i32 0
  %96 = load ptr, ptr %95, align 8
  store ptr %96, ptr %10, align 8
  %97 = getelementptr { ptr, i160 }, ptr %7, i32 0, i32 1
  %98 = load i160, ptr %97, align 4
  store i160 %98, ptr %9, align 4
  %99 = load ptr, ptr %10, align 8
  %100 = insertvalue { ptr, i160 } undef, ptr %99, 0
  %101 = load i160, ptr %9, align 4
  %102 = insertvalue { ptr, i160 } %100, i160 %101, 1
  br label %117

103:                                              ; preds = %46
  %104 = getelementptr { ptr, i160 }, ptr %7, i32 0, i32 1
  %105 = load [0 x i8], ptr %104, align 1
  store [0 x i8] %105, ptr %11, align 1
  store i8 0, ptr %12, align 1
  %106 = load ptr, ptr %20, align 8
  %107 = load ptr, ptr %19, align 8
  %108 = call ptr @llvm.invariant.start.p0(i64 88, ptr %107)
  %109 = load i32, ptr %18, align 4
  %110 = getelementptr ptr, ptr %107, i32 %109
  %111 = getelementptr ptr, ptr %110, i32 3
  %112 = load ptr, ptr %111, align 8
  %113 = getelementptr { ptr, ptr }, ptr %112, i32 0, i32 1
  %114 = load ptr, ptr %113, align 8
  %115 = load i8, ptr %12, align 1
  %116 = trunc i8 %115 to i1
  call void %114(ptr %106, i1 %116) #2
  br label %117

117:                                              ; preds = %94, %103
  %118 = phi { ptr, i160 } [ poison, %103 ], [ %102, %94 ]
  br label %119

119:                                              ; preds = %117, %3
  %120 = phi { ptr, i160 } [ %118, %117 ], [ poison, %3 ]
  %121 = phi i32 [ %93, %117 ], [ 1, %3 ]
  br label %122

122:                                              ; preds = %119
  br label %123

123:                                              ; preds = %122
  %124 = zext i32 %121 to i64
  %125 = trunc i64 %124 to i32
  switch i32 %125, label %127 [
    i32 0, label %126
  ]

126:                                              ; preds = %123
  br label %163

127:                                              ; preds = %123
  %128 = load ptr, ptr %20, align 8
  %129 = load ptr, ptr %19, align 8
  %130 = call ptr @llvm.invariant.start.p0(i64 88, ptr %129)
  %131 = load i32, ptr %18, align 4
  %132 = getelementptr ptr, ptr %129, i32 %131
  %133 = getelementptr ptr, ptr %132, i32 2
  %134 = load ptr, ptr %133, align 8
  %135 = getelementptr { ptr, ptr }, ptr %134, i32 0, i32 0
  %136 = load ptr, ptr %135, align 8
  %137 = call { ptr, ptr, ptr, i32 } %136(ptr %128) #1
  store { ptr, ptr, ptr, i32 } %137, ptr %13, align 8
  call void @assume_offset(ptr %13, ptr @Iterator)
  %138 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 0
  %139 = load ptr, ptr %138, align 8
  %140 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %139, 0
  %141 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 1
  %142 = load ptr, ptr %141, align 8
  %143 = insertvalue { ptr, ptr, ptr, i32 } %140, ptr %142, 1
  %144 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 2
  %145 = load ptr, ptr %144, align 8
  %146 = insertvalue { ptr, ptr, ptr, i32 } %143, ptr %145, 2
  %147 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 3
  %148 = load i32, ptr %147, align 4
  %149 = insertvalue { ptr, ptr, ptr, i32 } %146, i32 %148, 3
  %150 = call ptr @llvm.invariant.start.p0(i64 0, ptr %14)
  %151 = call ptr @llvm.invariant.start.p0(i64 24, ptr %139)
  %152 = getelementptr ptr, ptr %139, i32 %148
  %153 = getelementptr ptr, ptr %152, i32 1
  %154 = load ptr, ptr %153, align 8
  %155 = call ptr @behavior_wrapper(ptr %154, { ptr, ptr, ptr, i32 } %149, ptr %15)
  %156 = call { ptr, i160 } %155({ ptr, ptr, ptr, i32 } %149, { ptr, ptr, ptr, i32 } %149, ptr %14)
  store { ptr, i160 } %156, ptr %16, align 8
  %157 = getelementptr { ptr, i160 }, ptr %16, i32 0, i32 0
  %158 = load ptr, ptr %157, align 8
  %159 = insertvalue { ptr, i160 } undef, ptr %158, 0
  %160 = getelementptr { ptr, i160 }, ptr %16, i32 0, i32 1
  %161 = load i160, ptr %160, align 4
  %162 = insertvalue { ptr, i160 } %159, i160 %161, 1
  br label %163

163:                                              ; preds = %127, %126
  %164 = phi { ptr, i160 } [ %162, %127 ], [ %120, %126 ]
  ret { ptr, i160 } %164
}

define ptr @Chainer_B_next_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 7, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [11 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { i64, i64 } @_data_size_Interleaved(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %10
  %12 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %5
  %13 = select i1 %12, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %5
  %14 = urem i64 %11, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %17
  %19 = add i64 %11, %18
  %20 = urem i64 %19, %13
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 %13, %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = add i64 %19, %23
  %25 = insertvalue { i64, i64 } undef, i64 %24, 0
  %26 = insertvalue { i64, i64 } %25, i64 %13, 1
  ret { i64, i64 } %26
}

define ptr @Interleaved_field_Interleaved_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define { ptr, ptr, ptr, i32 } @Interleaved_getter_first(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = getelementptr i8, ptr %0, i64 %6
  %8 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %9, 0
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %12, 1
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %15, 2
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  %19 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %18, 3
  ret { ptr, ptr, ptr, i32 } %19
}

define void @Interleaved_setter_first(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = getelementptr i8, ptr %0, i64 %7
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %9, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 0
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 0
  %12 = load ptr, ptr %10, align 8
  store ptr %12, ptr %11, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 1
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 1
  %15 = load ptr, ptr %13, align 8
  store ptr %15, ptr %14, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 2
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 2
  %18 = load ptr, ptr %16, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 3
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 3
  %21 = load i32, ptr %19, align 4
  store i32 %21, ptr %20, align 4
  ret void
}

define { ptr, ptr, ptr, i32 } @Interleaved_getter_second(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %7, %11
  %13 = getelementptr i8, ptr %0, i64 %12
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %15, 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 1
  %18 = load ptr, ptr %17, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %18, 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 2
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %21, 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 3
  %24 = load i32, ptr %23, align 4
  %25 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %24, 3
  ret { ptr, ptr, ptr, i32 } %25
}

define void @Interleaved_setter_second(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %8, %12
  %14 = getelementptr i8, ptr %0, i64 %13
  %15 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %15, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 0
  %18 = load ptr, ptr %16, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 1
  %21 = load ptr, ptr %19, align 8
  store ptr %21, ptr %20, align 8
  %22 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 2
  %24 = load ptr, ptr %22, align 8
  store ptr %24, ptr %23, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 3
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 3
  %27 = load i32, ptr %25, align 4
  store i32 %27, ptr %26, align 4
  ret void
}

define void @Interleaved_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) {
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %6, align 8
  %7 = alloca i32, align 4
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = alloca ptr, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %8, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 1
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %9, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 2
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %10, align 8
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  store i32 %18, ptr %7, align 4
  %19 = load ptr, ptr %8, align 8
  %20 = call i32 @get_offset(ptr %19, ptr @Interleaved)
  store i32 %20, ptr %7, align 4
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %21, align 8
  %22 = alloca i32, align 4
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = alloca ptr, align 8
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  store ptr %27, ptr %25, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 1
  %29 = load ptr, ptr %28, align 8
  store ptr %29, ptr %24, align 8
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 2
  %31 = load ptr, ptr %30, align 8
  store ptr %31, ptr %23, align 8
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 3
  %33 = load i32, ptr %32, align 4
  store i32 %33, ptr %22, align 4
  %34 = load ptr, ptr %25, align 8
  %35 = call i32 @get_offset(ptr %34, ptr @Iterable)
  store i32 %35, ptr %22, align 4
  %36 = alloca i32, align 4
  %37 = alloca ptr, align 8
  %38 = alloca ptr, align 8
  %39 = alloca ptr, align 8
  %40 = load ptr, ptr %25, align 8
  store ptr %40, ptr %39, align 8
  %41 = load ptr, ptr %24, align 8
  store ptr %41, ptr %38, align 8
  %42 = load ptr, ptr %23, align 8
  store ptr %42, ptr %37, align 8
  %43 = load i32, ptr %22, align 4
  store i32 %43, ptr %36, align 4
  %44 = load ptr, ptr %39, align 8
  %45 = call i32 @get_offset(ptr %44, ptr @Iterable)
  store i32 %45, ptr %36, align 4
  %46 = load ptr, ptr %9, align 8
  %47 = load ptr, ptr %8, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 432, ptr %47)
  %49 = load i32, ptr %7, align 4
  %50 = getelementptr ptr, ptr %47, i32 %49
  %51 = getelementptr ptr, ptr %50, i32 1
  %52 = load ptr, ptr %51, align 8
  %53 = getelementptr { ptr, ptr }, ptr %52, i32 0, i32 1
  %54 = load ptr, ptr %53, align 8
  %55 = load ptr, ptr %39, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %55, 0
  %57 = load ptr, ptr %38, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %57, 1
  %59 = load ptr, ptr %37, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %59, 2
  %61 = load i32, ptr %36, align 4
  %62 = insertvalue { ptr, ptr, ptr, i32 } %60, i32 %61, 3
  call void %54(ptr %46, { ptr, ptr, ptr, i32 } %62) #2
  %63 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %4, ptr %63, align 8
  %64 = alloca i32, align 4
  %65 = alloca ptr, align 8
  %66 = alloca ptr, align 8
  %67 = alloca ptr, align 8
  %68 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 0
  %69 = load ptr, ptr %68, align 8
  store ptr %69, ptr %67, align 8
  %70 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 1
  %71 = load ptr, ptr %70, align 8
  store ptr %71, ptr %66, align 8
  %72 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 2
  %73 = load ptr, ptr %72, align 8
  store ptr %73, ptr %65, align 8
  %74 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 3
  %75 = load i32, ptr %74, align 4
  store i32 %75, ptr %64, align 4
  %76 = load ptr, ptr %67, align 8
  %77 = call i32 @get_offset(ptr %76, ptr @Iterable)
  store i32 %77, ptr %64, align 4
  %78 = alloca i32, align 4
  %79 = alloca ptr, align 8
  %80 = alloca ptr, align 8
  %81 = alloca ptr, align 8
  %82 = load ptr, ptr %67, align 8
  store ptr %82, ptr %81, align 8
  %83 = load ptr, ptr %66, align 8
  store ptr %83, ptr %80, align 8
  %84 = load ptr, ptr %65, align 8
  store ptr %84, ptr %79, align 8
  %85 = load i32, ptr %64, align 4
  store i32 %85, ptr %78, align 4
  %86 = load ptr, ptr %81, align 8
  %87 = call i32 @get_offset(ptr %86, ptr @Iterable)
  store i32 %87, ptr %78, align 4
  %88 = load ptr, ptr %9, align 8
  %89 = load ptr, ptr %8, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 432, ptr %89)
  %91 = load i32, ptr %7, align 4
  %92 = getelementptr ptr, ptr %89, i32 %91
  %93 = getelementptr ptr, ptr %92, i32 2
  %94 = load ptr, ptr %93, align 8
  %95 = getelementptr { ptr, ptr }, ptr %94, i32 0, i32 1
  %96 = load ptr, ptr %95, align 8
  %97 = load ptr, ptr %81, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %97, 0
  %99 = load ptr, ptr %80, align 8
  %100 = insertvalue { ptr, ptr, ptr, i32 } %98, ptr %99, 1
  %101 = load ptr, ptr %79, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } %100, ptr %101, 2
  %103 = load i32, ptr %78, align 4
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, i32 %103, 3
  call void %96(ptr %88, { ptr, ptr, ptr, i32 } %104) #2
  ret void
}

define ptr @Interleaved_B_init_firstIterableT_secondIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @Iterable, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @Iterable to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 1
  %22 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 2
  %23 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 0
  %24 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 1
  %25 = load i64, ptr %21, align 4
  %26 = load i64, ptr %22, align 4
  %27 = load ptr, ptr %23, align 8
  %28 = load ptr, ptr %24, align 8
  %29 = load i64, ptr @Iterable, align 4
  %30 = call i1 @subtype_test_wrapper(ptr %27, i64 %26, i64 %25, i64 %29, i64 ptrtoint (ptr @Iterable to i64), ptr %28)
  %31 = zext i1 %30 to i8
  store i8 %31, ptr %3, align 1
  store i32 16, ptr %6, align 4
  %32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %33 = load i32, ptr %6, align 4
  %34 = getelementptr [54 x ptr], ptr %32, i32 0, i32 %33
  %35 = getelementptr ptr, ptr %34, i32 10
  %36 = load ptr, ptr %35, align 8
  ret ptr %36
}

define { ptr, ptr, ptr, i32 } @Interleaved_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @Interleaved)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 432, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 1
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr { ptr, ptr }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = call { ptr, ptr, ptr, i32 } %27(ptr %19) #1
  %29 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %28, ptr %29, align 8
  call void @assume_offset(ptr %29, ptr @Iterable)
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 1
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %34, 1
  %36 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 2
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %37, 2
  %39 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 3
  %40 = load i32, ptr %39, align 4
  %41 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %40, 3
  %42 = alloca [0 x ptr], align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 0, ptr %42)
  %44 = call ptr @llvm.invariant.start.p0(i64 200, ptr %31)
  %45 = getelementptr ptr, ptr %31, i32 %40
  %46 = getelementptr ptr, ptr %45, i32 1
  %47 = load ptr, ptr %46, align 8
  %48 = alloca {}, align 8
  %49 = call ptr @behavior_wrapper(ptr %47, { ptr, ptr, ptr, i32 } %41, ptr %48)
  %50 = call { ptr, ptr, ptr, i32 } %49({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr %42)
  %51 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %50, ptr %51, align 8
  %52 = alloca i32, align 4
  %53 = alloca ptr, align 8
  %54 = alloca ptr, align 8
  %55 = alloca ptr, align 8
  %56 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 0
  %57 = load ptr, ptr %56, align 8
  store ptr %57, ptr %53, align 8
  %58 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 1
  %59 = load ptr, ptr %58, align 8
  store ptr %59, ptr %55, align 8
  %60 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 2
  %61 = load ptr, ptr %60, align 8
  store ptr %61, ptr %54, align 8
  %62 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 3
  %63 = load i32, ptr %62, align 4
  store i32 %63, ptr %52, align 4
  %64 = load ptr, ptr %53, align 8
  %65 = call i32 @get_offset(ptr %64, ptr @Iterator)
  store i32 %65, ptr %52, align 4
  %66 = load ptr, ptr %7, align 8
  %67 = load ptr, ptr %6, align 8
  %68 = call ptr @llvm.invariant.start.p0(i64 432, ptr %67)
  %69 = load i32, ptr %5, align 4
  %70 = getelementptr ptr, ptr %67, i32 %69
  %71 = getelementptr ptr, ptr %70, i32 2
  %72 = load ptr, ptr %71, align 8
  %73 = getelementptr { ptr, ptr }, ptr %72, i32 0, i32 0
  %74 = load ptr, ptr %73, align 8
  %75 = call { ptr, ptr, ptr, i32 } %74(ptr %66) #1
  %76 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %75, ptr %76, align 8
  call void @assume_offset(ptr %76, ptr @Iterable)
  %77 = getelementptr { ptr, ptr, ptr, i32 }, ptr %76, i32 0, i32 0
  %78 = load ptr, ptr %77, align 8
  %79 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %78, 0
  %80 = getelementptr { ptr, ptr, ptr, i32 }, ptr %76, i32 0, i32 1
  %81 = load ptr, ptr %80, align 8
  %82 = insertvalue { ptr, ptr, ptr, i32 } %79, ptr %81, 1
  %83 = getelementptr { ptr, ptr, ptr, i32 }, ptr %76, i32 0, i32 2
  %84 = load ptr, ptr %83, align 8
  %85 = insertvalue { ptr, ptr, ptr, i32 } %82, ptr %84, 2
  %86 = getelementptr { ptr, ptr, ptr, i32 }, ptr %76, i32 0, i32 3
  %87 = load i32, ptr %86, align 4
  %88 = insertvalue { ptr, ptr, ptr, i32 } %85, i32 %87, 3
  %89 = alloca [0 x ptr], align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 0, ptr %89)
  %91 = call ptr @llvm.invariant.start.p0(i64 200, ptr %78)
  %92 = getelementptr ptr, ptr %78, i32 %87
  %93 = getelementptr ptr, ptr %92, i32 1
  %94 = load ptr, ptr %93, align 8
  %95 = alloca {}, align 8
  %96 = call ptr @behavior_wrapper(ptr %94, { ptr, ptr, ptr, i32 } %88, ptr %95)
  %97 = call { ptr, ptr, ptr, i32 } %96({ ptr, ptr, ptr, i32 } %88, { ptr, ptr, ptr, i32 } %88, ptr %89)
  %98 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %97, ptr %98, align 8
  %99 = alloca i32, align 4
  %100 = alloca ptr, align 8
  %101 = alloca ptr, align 8
  %102 = alloca ptr, align 8
  %103 = getelementptr { ptr, ptr, ptr, i32 }, ptr %98, i32 0, i32 0
  %104 = load ptr, ptr %103, align 8
  store ptr %104, ptr %100, align 8
  %105 = getelementptr { ptr, ptr, ptr, i32 }, ptr %98, i32 0, i32 1
  %106 = load ptr, ptr %105, align 8
  store ptr %106, ptr %102, align 8
  %107 = getelementptr { ptr, ptr, ptr, i32 }, ptr %98, i32 0, i32 2
  %108 = load ptr, ptr %107, align 8
  store ptr %108, ptr %101, align 8
  %109 = getelementptr { ptr, ptr, ptr, i32 }, ptr %98, i32 0, i32 3
  %110 = load i32, ptr %109, align 4
  store i32 %110, ptr %99, align 4
  %111 = load ptr, ptr %100, align 8
  %112 = call i32 @get_offset(ptr %111, ptr @Iterator)
  store i32 %112, ptr %99, align 4
  %113 = load ptr, ptr %7, align 8
  %114 = load ptr, ptr %6, align 8
  %115 = call ptr @llvm.invariant.start.p0(i64 432, ptr %114)
  %116 = load i32, ptr %5, align 4
  %117 = getelementptr ptr, ptr %114, i32 %116
  %118 = load ptr, ptr %117, align 8
  %119 = call ptr @typegetter_wrapper(ptr %118, ptr %113)
  %120 = alloca [2 x ptr], align 8
  store ptr @Interleaver, ptr %120, align 8
  %121 = getelementptr ptr, ptr %120, i32 1
  store ptr %119, ptr %121, align 8
  %122 = load ptr, ptr %120, align 8
  %123 = getelementptr ptr, ptr %122, i32 6
  %124 = load ptr, ptr %123, align 8
  %125 = call { i64, i64 } @size_wrapper(ptr %124, ptr %120)
  %126 = extractvalue { i64, i64 } %125, 0
  %127 = call ptr @bump_malloc(i64 %126)
  store ptr %119, ptr %127, align 8
  %128 = call ptr @llvm.invariant.start.p0(i64 8, ptr %127)
  %129 = alloca i32, align 4
  %130 = alloca ptr, align 8
  %131 = alloca ptr, align 8
  %132 = alloca ptr, align 8
  store ptr @Interleaver, ptr %132, align 8
  store ptr %127, ptr %131, align 8
  store i32 10, ptr %129, align 4
  %133 = load ptr, ptr %7, align 8
  %134 = load ptr, ptr %6, align 8
  %135 = call ptr @llvm.invariant.start.p0(i64 432, ptr %134)
  %136 = load i32, ptr %5, align 4
  %137 = getelementptr ptr, ptr %134, i32 %136
  %138 = getelementptr ptr, ptr %137, i32 1
  %139 = load ptr, ptr %138, align 8
  %140 = getelementptr { ptr, ptr }, ptr %139, i32 0, i32 0
  %141 = load ptr, ptr %140, align 8
  %142 = call { ptr, ptr, ptr, i32 } %141(ptr %133) #1
  %143 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %142, ptr %143, align 8
  call void @assume_offset(ptr %143, ptr @Iterable)
  %144 = getelementptr { ptr, ptr, ptr, i32 }, ptr %143, i32 0, i32 0
  %145 = load ptr, ptr %144, align 8
  %146 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %145, 0
  %147 = getelementptr { ptr, ptr, ptr, i32 }, ptr %143, i32 0, i32 1
  %148 = load ptr, ptr %147, align 8
  %149 = insertvalue { ptr, ptr, ptr, i32 } %146, ptr %148, 1
  %150 = getelementptr { ptr, ptr, ptr, i32 }, ptr %143, i32 0, i32 2
  %151 = load ptr, ptr %150, align 8
  %152 = insertvalue { ptr, ptr, ptr, i32 } %149, ptr %151, 2
  %153 = getelementptr { ptr, ptr, ptr, i32 }, ptr %143, i32 0, i32 3
  %154 = load i32, ptr %153, align 4
  %155 = insertvalue { ptr, ptr, ptr, i32 } %152, i32 %154, 3
  %156 = alloca [0 x ptr], align 8
  %157 = call ptr @llvm.invariant.start.p0(i64 0, ptr %156)
  %158 = call ptr @llvm.invariant.start.p0(i64 200, ptr %145)
  %159 = getelementptr ptr, ptr %145, i32 %154
  %160 = getelementptr ptr, ptr %159, i32 1
  %161 = load ptr, ptr %160, align 8
  %162 = alloca {}, align 8
  %163 = call ptr @behavior_wrapper(ptr %161, { ptr, ptr, ptr, i32 } %155, ptr %162)
  %164 = call { ptr, ptr, ptr, i32 } %163({ ptr, ptr, ptr, i32 } %155, { ptr, ptr, ptr, i32 } %155, ptr %156)
  %165 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %164, ptr %165, align 8
  %166 = alloca i32, align 4
  %167 = alloca ptr, align 8
  %168 = alloca ptr, align 8
  %169 = alloca ptr, align 8
  %170 = getelementptr { ptr, ptr, ptr, i32 }, ptr %165, i32 0, i32 0
  %171 = load ptr, ptr %170, align 8
  store ptr %171, ptr %169, align 8
  %172 = getelementptr { ptr, ptr, ptr, i32 }, ptr %165, i32 0, i32 1
  %173 = load ptr, ptr %172, align 8
  store ptr %173, ptr %168, align 8
  %174 = getelementptr { ptr, ptr, ptr, i32 }, ptr %165, i32 0, i32 2
  %175 = load ptr, ptr %174, align 8
  store ptr %175, ptr %167, align 8
  %176 = getelementptr { ptr, ptr, ptr, i32 }, ptr %165, i32 0, i32 3
  %177 = load i32, ptr %176, align 4
  store i32 %177, ptr %166, align 4
  %178 = load ptr, ptr %169, align 8
  %179 = call i32 @get_offset(ptr %178, ptr @Iterator)
  store i32 %179, ptr %166, align 4
  %180 = load ptr, ptr %7, align 8
  %181 = load ptr, ptr %6, align 8
  %182 = call ptr @llvm.invariant.start.p0(i64 432, ptr %181)
  %183 = load i32, ptr %5, align 4
  %184 = getelementptr ptr, ptr %181, i32 %183
  %185 = getelementptr ptr, ptr %184, i32 2
  %186 = load ptr, ptr %185, align 8
  %187 = getelementptr { ptr, ptr }, ptr %186, i32 0, i32 0
  %188 = load ptr, ptr %187, align 8
  %189 = call { ptr, ptr, ptr, i32 } %188(ptr %180) #1
  %190 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %189, ptr %190, align 8
  call void @assume_offset(ptr %190, ptr @Iterable)
  %191 = getelementptr { ptr, ptr, ptr, i32 }, ptr %190, i32 0, i32 0
  %192 = load ptr, ptr %191, align 8
  %193 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %192, 0
  %194 = getelementptr { ptr, ptr, ptr, i32 }, ptr %190, i32 0, i32 1
  %195 = load ptr, ptr %194, align 8
  %196 = insertvalue { ptr, ptr, ptr, i32 } %193, ptr %195, 1
  %197 = getelementptr { ptr, ptr, ptr, i32 }, ptr %190, i32 0, i32 2
  %198 = load ptr, ptr %197, align 8
  %199 = insertvalue { ptr, ptr, ptr, i32 } %196, ptr %198, 2
  %200 = getelementptr { ptr, ptr, ptr, i32 }, ptr %190, i32 0, i32 3
  %201 = load i32, ptr %200, align 4
  %202 = insertvalue { ptr, ptr, ptr, i32 } %199, i32 %201, 3
  %203 = alloca [0 x ptr], align 8
  %204 = call ptr @llvm.invariant.start.p0(i64 0, ptr %203)
  %205 = call ptr @llvm.invariant.start.p0(i64 200, ptr %192)
  %206 = getelementptr ptr, ptr %192, i32 %201
  %207 = getelementptr ptr, ptr %206, i32 1
  %208 = load ptr, ptr %207, align 8
  %209 = alloca {}, align 8
  %210 = call ptr @behavior_wrapper(ptr %208, { ptr, ptr, ptr, i32 } %202, ptr %209)
  %211 = call { ptr, ptr, ptr, i32 } %210({ ptr, ptr, ptr, i32 } %202, { ptr, ptr, ptr, i32 } %202, ptr %203)
  %212 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %211, ptr %212, align 8
  %213 = alloca i32, align 4
  %214 = alloca ptr, align 8
  %215 = alloca ptr, align 8
  %216 = alloca ptr, align 8
  %217 = getelementptr { ptr, ptr, ptr, i32 }, ptr %212, i32 0, i32 0
  %218 = load ptr, ptr %217, align 8
  store ptr %218, ptr %216, align 8
  %219 = getelementptr { ptr, ptr, ptr, i32 }, ptr %212, i32 0, i32 1
  %220 = load ptr, ptr %219, align 8
  store ptr %220, ptr %215, align 8
  %221 = getelementptr { ptr, ptr, ptr, i32 }, ptr %212, i32 0, i32 2
  %222 = load ptr, ptr %221, align 8
  store ptr %222, ptr %214, align 8
  %223 = getelementptr { ptr, ptr, ptr, i32 }, ptr %212, i32 0, i32 3
  %224 = load i32, ptr %223, align 4
  store i32 %224, ptr %213, align 4
  %225 = load ptr, ptr %216, align 8
  %226 = call i32 @get_offset(ptr %225, ptr @Iterator)
  store i32 %226, ptr %213, align 4
  %227 = alloca i32, align 4
  %228 = alloca ptr, align 8
  %229 = alloca ptr, align 8
  %230 = alloca ptr, align 8
  %231 = load ptr, ptr %169, align 8
  store ptr %231, ptr %230, align 8
  %232 = load ptr, ptr %168, align 8
  store ptr %232, ptr %229, align 8
  %233 = load ptr, ptr %167, align 8
  store ptr %233, ptr %228, align 8
  %234 = load i32, ptr %166, align 4
  store i32 %234, ptr %227, align 4
  %235 = load ptr, ptr %230, align 8
  %236 = call i32 @get_offset(ptr %235, ptr @Iterator)
  store i32 %236, ptr %227, align 4
  %237 = load ptr, ptr %230, align 8
  %238 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %237, 0
  %239 = load ptr, ptr %229, align 8
  %240 = insertvalue { ptr, ptr, ptr, i32 } %238, ptr %239, 1
  %241 = load ptr, ptr %228, align 8
  %242 = insertvalue { ptr, ptr, ptr, i32 } %240, ptr %241, 2
  %243 = load i32, ptr %227, align 4
  %244 = insertvalue { ptr, ptr, ptr, i32 } %242, i32 %243, 3
  %245 = alloca i32, align 4
  %246 = alloca ptr, align 8
  %247 = alloca ptr, align 8
  %248 = alloca ptr, align 8
  %249 = load ptr, ptr %216, align 8
  store ptr %249, ptr %248, align 8
  %250 = load ptr, ptr %215, align 8
  store ptr %250, ptr %247, align 8
  %251 = load ptr, ptr %214, align 8
  store ptr %251, ptr %246, align 8
  %252 = load i32, ptr %213, align 4
  store i32 %252, ptr %245, align 4
  %253 = load ptr, ptr %248, align 8
  %254 = call i32 @get_offset(ptr %253, ptr @Iterator)
  store i32 %254, ptr %245, align 4
  %255 = load ptr, ptr %248, align 8
  %256 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %255, 0
  %257 = load ptr, ptr %247, align 8
  %258 = insertvalue { ptr, ptr, ptr, i32 } %256, ptr %257, 1
  %259 = load ptr, ptr %246, align 8
  %260 = insertvalue { ptr, ptr, ptr, i32 } %258, ptr %259, 2
  %261 = load i32, ptr %245, align 4
  %262 = insertvalue { ptr, ptr, ptr, i32 } %260, i32 %261, 3
  %263 = load ptr, ptr %132, align 8
  %264 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %263, 0
  %265 = load ptr, ptr %131, align 8
  %266 = insertvalue { ptr, ptr, ptr, i32 } %264, ptr %265, 1
  %267 = load ptr, ptr %130, align 8
  %268 = insertvalue { ptr, ptr, ptr, i32 } %266, ptr %267, 2
  %269 = load i32, ptr %129, align 4
  %270 = insertvalue { ptr, ptr, ptr, i32 } %268, i32 %269, 3
  %271 = load ptr, ptr %7, align 8
  %272 = load ptr, ptr %6, align 8
  %273 = call ptr @llvm.invariant.start.p0(i64 432, ptr %272)
  %274 = load i32, ptr %5, align 4
  %275 = getelementptr ptr, ptr %272, i32 %274
  %276 = load ptr, ptr %275, align 8
  %277 = call ptr @typegetter_wrapper(ptr %276, ptr %271)
  %278 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %279 = getelementptr [3 x ptr], ptr %278, i32 0, i32 1
  store ptr %277, ptr %279, align 8
  %280 = getelementptr [3 x ptr], ptr %278, i32 0, i32 2
  store ptr null, ptr %280, align 8
  %281 = call ptr @llvm.invariant.start.p0(i64 16, ptr %278)
  store ptr @Iterator, ptr %278, align 8
  %282 = load ptr, ptr %7, align 8
  %283 = load ptr, ptr %6, align 8
  %284 = call ptr @llvm.invariant.start.p0(i64 432, ptr %283)
  %285 = load i32, ptr %5, align 4
  %286 = getelementptr ptr, ptr %283, i32 %285
  %287 = load ptr, ptr %286, align 8
  %288 = call ptr @typegetter_wrapper(ptr %287, ptr %282)
  %289 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %290 = getelementptr [3 x ptr], ptr %289, i32 0, i32 1
  store ptr %288, ptr %290, align 8
  %291 = getelementptr [3 x ptr], ptr %289, i32 0, i32 2
  store ptr null, ptr %291, align 8
  %292 = call ptr @llvm.invariant.start.p0(i64 16, ptr %289)
  store ptr @Iterator, ptr %289, align 8
  %293 = alloca [2 x ptr], align 8
  %294 = getelementptr [2 x ptr], ptr %293, i32 0, i32 0
  store ptr %278, ptr %294, align 8
  %295 = getelementptr [2 x ptr], ptr %293, i32 0, i32 1
  store ptr %289, ptr %295, align 8
  %296 = call ptr @llvm.invariant.start.p0(i64 4, ptr %293)
  %297 = call ptr @llvm.invariant.start.p0(i64 88, ptr %263)
  %298 = getelementptr ptr, ptr %263, i32 %269
  %299 = getelementptr ptr, ptr %298, i32 4
  %300 = load ptr, ptr %299, align 8
  %301 = alloca { ptr, ptr }, align 8
  %302 = getelementptr { ptr, ptr }, ptr %301, i32 0, i32 0
  store ptr %237, ptr %302, align 8
  %303 = getelementptr { ptr, ptr }, ptr %301, i32 0, i32 1
  store ptr %255, ptr %303, align 8
  %304 = call ptr @behavior_wrapper(ptr %300, { ptr, ptr, ptr, i32 } %270, ptr %301)
  call void %304({ ptr, ptr, ptr, i32 } %270, { ptr, ptr, ptr, i32 } %270, ptr %293, { ptr, ptr, ptr, i32 } %244, { ptr, ptr, ptr, i32 } %262)
  %305 = alloca i32, align 4
  %306 = alloca ptr, align 8
  %307 = alloca ptr, align 8
  %308 = alloca ptr, align 8
  %309 = load ptr, ptr %132, align 8
  store ptr %309, ptr %308, align 8
  %310 = load ptr, ptr %131, align 8
  store ptr %310, ptr %307, align 8
  %311 = load ptr, ptr %130, align 8
  store ptr %311, ptr %306, align 8
  %312 = load i32, ptr %129, align 4
  store i32 %312, ptr %305, align 4
  %313 = load ptr, ptr %308, align 8
  %314 = call i32 @get_offset(ptr %313, ptr @Iterator)
  store i32 %314, ptr %305, align 4
  %315 = load ptr, ptr %308, align 8
  %316 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %315, 0
  %317 = load ptr, ptr %307, align 8
  %318 = insertvalue { ptr, ptr, ptr, i32 } %316, ptr %317, 1
  %319 = load ptr, ptr %306, align 8
  %320 = insertvalue { ptr, ptr, ptr, i32 } %318, ptr %319, 2
  %321 = load i32, ptr %305, align 4
  %322 = insertvalue { ptr, ptr, ptr, i32 } %320, i32 %321, 3
  ret { ptr, ptr, ptr, i32 } %322
}

define ptr @Interleaved_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 17, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [54 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @Interleaved_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 18, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [54 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Interleaved_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @any_typ, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @any_typ to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = ptrtoint ptr %20 to i64
  %22 = icmp eq i64 %21, ptrtoint (ptr @function_typ to i64)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 19, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [54 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define ptr @Interleaved_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 20, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [54 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Interleaved_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 21, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [54 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Interleaved_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 22, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [54 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @Interleaved_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 23, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [54 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Interleaved_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 24, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [54 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Interleaved_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 25, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [54 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define ptr @Interleaved_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 26, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [54 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define ptr @Interleaved_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 27, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [54 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define ptr @Interleaved_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 28, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [54 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define { i64, i64 } @_data_size_Interleaver(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %10
  %12 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %5
  %13 = select i1 %12, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %5
  %14 = urem i64 %11, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %17
  %19 = add i64 %11, %18
  %20 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, i1 }, ptr null, i32 0, i32 1) to i64), %13
  %21 = select i1 %20, i64 ptrtoint (ptr getelementptr ({ i8, i1 }, ptr null, i32 0, i32 1) to i64), i64 %13
  %22 = urem i64 %19, ptrtoint (ptr getelementptr ({ i8, i1 }, ptr null, i32 0, i32 1) to i64)
  %23 = icmp eq i64 %22, 0
  %24 = sub i64 ptrtoint (ptr getelementptr ({ i8, i1 }, ptr null, i32 0, i32 1) to i64), %22
  %25 = select i1 %23, i64 0, i64 %24
  %26 = add i64 ptrtoint (ptr getelementptr (i1, ptr null, i32 1) to i64), %25
  %27 = add i64 %19, %26
  %28 = urem i64 %27, %21
  %29 = icmp eq i64 %28, 0
  %30 = sub i64 %21, %28
  %31 = select i1 %29, i64 0, i64 %30
  %32 = add i64 %27, %31
  %33 = insertvalue { i64, i64 } undef, i64 %32, 0
  %34 = insertvalue { i64, i64 } %33, i64 %21, 1
  ret { i64, i64 } %34
}

define ptr @Interleaver_field_Interleaver_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define { ptr, ptr, ptr, i32 } @Interleaver_getter_first(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = getelementptr i8, ptr %0, i64 %6
  %8 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %9, 0
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %12, 1
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %15, 2
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  %19 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %18, 3
  ret { ptr, ptr, ptr, i32 } %19
}

define void @Interleaver_setter_first(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = getelementptr i8, ptr %0, i64 %7
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %9, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 0
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 0
  %12 = load ptr, ptr %10, align 8
  store ptr %12, ptr %11, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 1
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 1
  %15 = load ptr, ptr %13, align 8
  store ptr %15, ptr %14, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 2
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 2
  %18 = load ptr, ptr %16, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 3
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 3
  %21 = load i32, ptr %19, align 4
  store i32 %21, ptr %20, align 4
  ret void
}

define { ptr, ptr, ptr, i32 } @Interleaver_getter_second(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %7, %11
  %13 = getelementptr i8, ptr %0, i64 %12
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %15, 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 1
  %18 = load ptr, ptr %17, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %18, 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 2
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %21, 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 3
  %24 = load i32, ptr %23, align 4
  %25 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %24, 3
  ret { ptr, ptr, ptr, i32 } %25
}

define void @Interleaver_setter_second(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %8, %12
  %14 = getelementptr i8, ptr %0, i64 %13
  %15 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %15, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 0
  %18 = load ptr, ptr %16, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 1
  %21 = load ptr, ptr %19, align 8
  store ptr %21, ptr %20, align 8
  %22 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 2
  %24 = load ptr, ptr %22, align 8
  store ptr %24, ptr %23, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 3
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 3
  %27 = load i32, ptr %25, align 4
  store i32 %27, ptr %26, align 4
  ret void
}

define i1 @Interleaver_getter_on_first(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %11
  %13 = add i64 %7, %12
  %14 = urem i64 %13, ptrtoint (ptr getelementptr ({ i8, i1 }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, i1 }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 %13, %17
  %19 = getelementptr i8, ptr %0, i64 %18
  %20 = load i8, ptr %19, align 1
  %21 = trunc i8 %20 to i1
  ret i1 %21
}

define void @Interleaver_setter_on_first(ptr %0, i1 %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %12
  %14 = add i64 %8, %13
  %15 = urem i64 %14, ptrtoint (ptr getelementptr ({ i8, i1 }, ptr null, i32 0, i32 1) to i64)
  %16 = icmp eq i64 %15, 0
  %17 = sub i64 ptrtoint (ptr getelementptr ({ i8, i1 }, ptr null, i32 0, i32 1) to i64), %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add i64 %14, %18
  %20 = getelementptr i8, ptr %0, i64 %19
  %21 = alloca i1, align 1
  %22 = zext i1 %1 to i8
  store i8 %22, ptr %21, align 1
  %23 = load i8, ptr %21, align 1
  %24 = trunc i8 %23 to i1
  %25 = zext i1 %24 to i8
  store i8 %25, ptr %20, align 1
  ret void
}

define void @Interleaver_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) {
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %6, align 8
  %7 = alloca i32, align 4
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = alloca ptr, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %8, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 1
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %9, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 2
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %10, align 8
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  store i32 %18, ptr %7, align 4
  %19 = load ptr, ptr %8, align 8
  %20 = call i32 @get_offset(ptr %19, ptr @Interleaver)
  store i32 %20, ptr %7, align 4
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %21, align 8
  %22 = alloca i32, align 4
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = alloca ptr, align 8
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  store ptr %27, ptr %25, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 1
  %29 = load ptr, ptr %28, align 8
  store ptr %29, ptr %24, align 8
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 2
  %31 = load ptr, ptr %30, align 8
  store ptr %31, ptr %23, align 8
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 3
  %33 = load i32, ptr %32, align 4
  store i32 %33, ptr %22, align 4
  %34 = load ptr, ptr %25, align 8
  %35 = call i32 @get_offset(ptr %34, ptr @Iterator)
  store i32 %35, ptr %22, align 4
  %36 = alloca i32, align 4
  %37 = alloca ptr, align 8
  %38 = alloca ptr, align 8
  %39 = alloca ptr, align 8
  %40 = load ptr, ptr %25, align 8
  store ptr %40, ptr %39, align 8
  %41 = load ptr, ptr %24, align 8
  store ptr %41, ptr %38, align 8
  %42 = load ptr, ptr %23, align 8
  store ptr %42, ptr %37, align 8
  %43 = load i32, ptr %22, align 4
  store i32 %43, ptr %36, align 4
  %44 = load ptr, ptr %39, align 8
  %45 = call i32 @get_offset(ptr %44, ptr @Iterator)
  store i32 %45, ptr %36, align 4
  %46 = load ptr, ptr %9, align 8
  %47 = load ptr, ptr %8, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 88, ptr %47)
  %49 = load i32, ptr %7, align 4
  %50 = getelementptr ptr, ptr %47, i32 %49
  %51 = getelementptr ptr, ptr %50, i32 1
  %52 = load ptr, ptr %51, align 8
  %53 = getelementptr { ptr, ptr }, ptr %52, i32 0, i32 1
  %54 = load ptr, ptr %53, align 8
  %55 = load ptr, ptr %39, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %55, 0
  %57 = load ptr, ptr %38, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %57, 1
  %59 = load ptr, ptr %37, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %59, 2
  %61 = load i32, ptr %36, align 4
  %62 = insertvalue { ptr, ptr, ptr, i32 } %60, i32 %61, 3
  call void %54(ptr %46, { ptr, ptr, ptr, i32 } %62) #2
  %63 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %4, ptr %63, align 8
  %64 = alloca i32, align 4
  %65 = alloca ptr, align 8
  %66 = alloca ptr, align 8
  %67 = alloca ptr, align 8
  %68 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 0
  %69 = load ptr, ptr %68, align 8
  store ptr %69, ptr %67, align 8
  %70 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 1
  %71 = load ptr, ptr %70, align 8
  store ptr %71, ptr %66, align 8
  %72 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 2
  %73 = load ptr, ptr %72, align 8
  store ptr %73, ptr %65, align 8
  %74 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 3
  %75 = load i32, ptr %74, align 4
  store i32 %75, ptr %64, align 4
  %76 = load ptr, ptr %67, align 8
  %77 = call i32 @get_offset(ptr %76, ptr @Iterator)
  store i32 %77, ptr %64, align 4
  %78 = alloca i32, align 4
  %79 = alloca ptr, align 8
  %80 = alloca ptr, align 8
  %81 = alloca ptr, align 8
  %82 = load ptr, ptr %67, align 8
  store ptr %82, ptr %81, align 8
  %83 = load ptr, ptr %66, align 8
  store ptr %83, ptr %80, align 8
  %84 = load ptr, ptr %65, align 8
  store ptr %84, ptr %79, align 8
  %85 = load i32, ptr %64, align 4
  store i32 %85, ptr %78, align 4
  %86 = load ptr, ptr %81, align 8
  %87 = call i32 @get_offset(ptr %86, ptr @Iterator)
  store i32 %87, ptr %78, align 4
  %88 = load ptr, ptr %9, align 8
  %89 = load ptr, ptr %8, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 88, ptr %89)
  %91 = load i32, ptr %7, align 4
  %92 = getelementptr ptr, ptr %89, i32 %91
  %93 = getelementptr ptr, ptr %92, i32 2
  %94 = load ptr, ptr %93, align 8
  %95 = getelementptr { ptr, ptr }, ptr %94, i32 0, i32 1
  %96 = load ptr, ptr %95, align 8
  %97 = load ptr, ptr %81, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %97, 0
  %99 = load ptr, ptr %80, align 8
  %100 = insertvalue { ptr, ptr, ptr, i32 } %98, ptr %99, 1
  %101 = load ptr, ptr %79, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } %100, ptr %101, 2
  %103 = load i32, ptr %78, align 4
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, i32 %103, 3
  call void %96(ptr %88, { ptr, ptr, ptr, i32 } %104) #2
  %105 = alloca i1, align 1
  store i8 1, ptr %105, align 1
  %106 = load ptr, ptr %9, align 8
  %107 = load ptr, ptr %8, align 8
  %108 = call ptr @llvm.invariant.start.p0(i64 88, ptr %107)
  %109 = load i32, ptr %7, align 4
  %110 = getelementptr ptr, ptr %107, i32 %109
  %111 = getelementptr ptr, ptr %110, i32 3
  %112 = load ptr, ptr %111, align 8
  %113 = getelementptr { ptr, ptr }, ptr %112, i32 0, i32 1
  %114 = load ptr, ptr %113, align 8
  %115 = load i8, ptr %105, align 1
  %116 = trunc i8 %115 to i1
  call void %114(ptr %106, i1 %116) #2
  ret void
}

define ptr @Interleaver_B_init_firstIteratorT_secondIteratorT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @Iterator, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @Iterator to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 1
  %22 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 2
  %23 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 0
  %24 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 1
  %25 = load i64, ptr %21, align 4
  %26 = load i64, ptr %22, align 4
  %27 = load ptr, ptr %23, align 8
  %28 = load ptr, ptr %24, align 8
  %29 = load i64, ptr @Iterator, align 4
  %30 = call i1 @subtype_test_wrapper(ptr %27, i64 %26, i64 %25, i64 %29, i64 ptrtoint (ptr @Iterator to i64), ptr %28)
  %31 = zext i1 %30 to i8
  store i8 %31, ptr %3, align 1
  store i32 6, ptr %6, align 4
  %32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %33 = load i32, ptr %6, align 4
  %34 = getelementptr [11 x ptr], ptr %32, i32 0, i32 %33
  %35 = getelementptr ptr, ptr %34, i32 10
  %36 = load ptr, ptr %35, align 8
  ret ptr %36
}

define { ptr, i160 } @Interleaver_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca i1, align 1
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  %6 = alloca [0 x ptr], align 8
  %7 = alloca {}, align 8
  %8 = alloca { ptr, i160 }, align 8
  %9 = alloca i1, align 1
  %10 = alloca { ptr, i160 }, align 8
  %11 = alloca [0 x i8], align 1
  %12 = alloca { ptr, ptr, ptr, i32 }, align 8
  %13 = alloca [0 x ptr], align 8
  %14 = alloca {}, align 8
  %15 = alloca { ptr, i160 }, align 8
  %16 = alloca i1, align 1
  %17 = alloca { ptr, ptr, ptr, i32 }, align 8
  %18 = alloca [0 x ptr], align 8
  %19 = alloca {}, align 8
  %20 = alloca { ptr, i160 }, align 8
  %21 = alloca i1, align 1
  %22 = alloca { ptr, i160 }, align 8
  %23 = alloca [0 x i8], align 1
  %24 = alloca { ptr, ptr, ptr, i32 }, align 8
  %25 = alloca [0 x ptr], align 8
  %26 = alloca {}, align 8
  %27 = alloca { ptr, i160 }, align 8
  %28 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %28, align 8
  %29 = alloca i32, align 4
  %30 = alloca ptr, align 8
  %31 = alloca ptr, align 8
  %32 = alloca ptr, align 8
  %33 = getelementptr { ptr, ptr, ptr, i32 }, ptr %28, i32 0, i32 0
  %34 = load ptr, ptr %33, align 8
  store ptr %34, ptr %30, align 8
  %35 = getelementptr { ptr, ptr, ptr, i32 }, ptr %28, i32 0, i32 1
  %36 = load ptr, ptr %35, align 8
  store ptr %36, ptr %31, align 8
  %37 = getelementptr { ptr, ptr, ptr, i32 }, ptr %28, i32 0, i32 2
  %38 = load ptr, ptr %37, align 8
  store ptr %38, ptr %32, align 8
  %39 = getelementptr { ptr, ptr, ptr, i32 }, ptr %28, i32 0, i32 3
  %40 = load i32, ptr %39, align 4
  store i32 %40, ptr %29, align 4
  %41 = load ptr, ptr %30, align 8
  %42 = call i32 @get_offset(ptr %41, ptr @Interleaver)
  store i32 %42, ptr %29, align 4
  %43 = load ptr, ptr %31, align 8
  %44 = load ptr, ptr %30, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 88, ptr %44)
  %46 = load i32, ptr %29, align 4
  %47 = getelementptr ptr, ptr %44, i32 %46
  %48 = getelementptr ptr, ptr %47, i32 3
  %49 = load ptr, ptr %48, align 8
  %50 = getelementptr { ptr, ptr }, ptr %49, i32 0, i32 0
  %51 = load ptr, ptr %50, align 8
  %52 = call i1 %51(ptr %43) #1
  %53 = alloca i1, align 1
  %54 = zext i1 %52 to i8
  store i8 %54, ptr %53, align 1
  %55 = load i8, ptr %53, align 1
  %56 = trunc i8 %55 to i1
  br i1 %56, label %57, label %160

57:                                               ; preds = %3
  store i8 0, ptr %4, align 1
  %58 = load ptr, ptr %31, align 8
  %59 = load ptr, ptr %30, align 8
  %60 = call ptr @llvm.invariant.start.p0(i64 88, ptr %59)
  %61 = load i32, ptr %29, align 4
  %62 = getelementptr ptr, ptr %59, i32 %61
  %63 = getelementptr ptr, ptr %62, i32 3
  %64 = load ptr, ptr %63, align 8
  %65 = getelementptr { ptr, ptr }, ptr %64, i32 0, i32 1
  %66 = load ptr, ptr %65, align 8
  %67 = load i8, ptr %4, align 1
  %68 = trunc i8 %67 to i1
  call void %66(ptr %58, i1 %68) #2
  %69 = load ptr, ptr %31, align 8
  %70 = load ptr, ptr %30, align 8
  %71 = call ptr @llvm.invariant.start.p0(i64 88, ptr %70)
  %72 = load i32, ptr %29, align 4
  %73 = getelementptr ptr, ptr %70, i32 %72
  %74 = getelementptr ptr, ptr %73, i32 1
  %75 = load ptr, ptr %74, align 8
  %76 = getelementptr { ptr, ptr }, ptr %75, i32 0, i32 0
  %77 = load ptr, ptr %76, align 8
  %78 = call { ptr, ptr, ptr, i32 } %77(ptr %69) #1
  store { ptr, ptr, ptr, i32 } %78, ptr %5, align 8
  call void @assume_offset(ptr %5, ptr @Iterator)
  %79 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %80 = load ptr, ptr %79, align 8
  %81 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %80, 0
  %82 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %83 = load ptr, ptr %82, align 8
  %84 = insertvalue { ptr, ptr, ptr, i32 } %81, ptr %83, 1
  %85 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %86 = load ptr, ptr %85, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } %84, ptr %86, 2
  %88 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %89 = load i32, ptr %88, align 4
  %90 = insertvalue { ptr, ptr, ptr, i32 } %87, i32 %89, 3
  %91 = call ptr @llvm.invariant.start.p0(i64 0, ptr %6)
  %92 = call ptr @llvm.invariant.start.p0(i64 24, ptr %80)
  %93 = getelementptr ptr, ptr %80, i32 %89
  %94 = getelementptr ptr, ptr %93, i32 1
  %95 = load ptr, ptr %94, align 8
  %96 = call ptr @behavior_wrapper(ptr %95, { ptr, ptr, ptr, i32 } %90, ptr %7)
  %97 = call { ptr, i160 } %96({ ptr, ptr, ptr, i32 } %90, { ptr, ptr, ptr, i32 } %90, ptr %6)
  store { ptr, i160 } %97, ptr %8, align 8
  %98 = load ptr, ptr %31, align 8
  %99 = load ptr, ptr %30, align 8
  %100 = call ptr @llvm.invariant.start.p0(i64 88, ptr %99)
  %101 = load i32, ptr %29, align 4
  %102 = getelementptr ptr, ptr %99, i32 %101
  %103 = load ptr, ptr %102, align 8
  %104 = call ptr @typegetter_wrapper(ptr %103, ptr %98)
  %105 = load ptr, ptr %8, align 8
  %106 = ptrtoint ptr %105 to i64
  %107 = icmp eq i64 %106, ptrtoint (ptr @nil_typ to i64)
  %108 = icmp eq i64 %106, 0
  %109 = or i1 %107, %108
  %110 = icmp eq i1 %109, false
  %111 = zext i1 %110 to i8
  store i8 %111, ptr %9, align 1
  %112 = load i8, ptr %9, align 1
  %113 = trunc i8 %112 to i1
  %114 = xor i1 %113, true
  %115 = zext i1 %114 to i32
  br i1 %113, label %116, label %118

116:                                              ; preds = %57, %160
  %117 = phi i32 [ %218, %160 ], [ %115, %57 ]
  br label %156

118:                                              ; preds = %57
  %119 = getelementptr { ptr, i160 }, ptr %8, i32 0, i32 1
  %120 = load [0 x i8], ptr %119, align 1
  store [0 x i8] %120, ptr %11, align 1
  %121 = load ptr, ptr %31, align 8
  %122 = load ptr, ptr %30, align 8
  %123 = call ptr @llvm.invariant.start.p0(i64 88, ptr %122)
  %124 = load i32, ptr %29, align 4
  %125 = getelementptr ptr, ptr %122, i32 %124
  %126 = getelementptr ptr, ptr %125, i32 2
  %127 = load ptr, ptr %126, align 8
  %128 = getelementptr { ptr, ptr }, ptr %127, i32 0, i32 0
  %129 = load ptr, ptr %128, align 8
  %130 = call { ptr, ptr, ptr, i32 } %129(ptr %121) #1
  store { ptr, ptr, ptr, i32 } %130, ptr %12, align 8
  call void @assume_offset(ptr %12, ptr @Iterator)
  %131 = getelementptr { ptr, ptr, ptr, i32 }, ptr %12, i32 0, i32 0
  %132 = load ptr, ptr %131, align 8
  %133 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %132, 0
  %134 = getelementptr { ptr, ptr, ptr, i32 }, ptr %12, i32 0, i32 1
  %135 = load ptr, ptr %134, align 8
  %136 = insertvalue { ptr, ptr, ptr, i32 } %133, ptr %135, 1
  %137 = getelementptr { ptr, ptr, ptr, i32 }, ptr %12, i32 0, i32 2
  %138 = load ptr, ptr %137, align 8
  %139 = insertvalue { ptr, ptr, ptr, i32 } %136, ptr %138, 2
  %140 = getelementptr { ptr, ptr, ptr, i32 }, ptr %12, i32 0, i32 3
  %141 = load i32, ptr %140, align 4
  %142 = insertvalue { ptr, ptr, ptr, i32 } %139, i32 %141, 3
  %143 = call ptr @llvm.invariant.start.p0(i64 0, ptr %13)
  %144 = call ptr @llvm.invariant.start.p0(i64 24, ptr %132)
  %145 = getelementptr ptr, ptr %132, i32 %141
  %146 = getelementptr ptr, ptr %145, i32 1
  %147 = load ptr, ptr %146, align 8
  %148 = call ptr @behavior_wrapper(ptr %147, { ptr, ptr, ptr, i32 } %142, ptr %14)
  %149 = call { ptr, i160 } %148({ ptr, ptr, ptr, i32 } %142, { ptr, ptr, ptr, i32 } %142, ptr %13)
  store { ptr, i160 } %149, ptr %15, align 8
  %150 = getelementptr { ptr, i160 }, ptr %15, i32 0, i32 0
  %151 = load ptr, ptr %150, align 8
  %152 = insertvalue { ptr, i160 } undef, ptr %151, 0
  %153 = getelementptr { ptr, i160 }, ptr %15, i32 0, i32 1
  %154 = load i160, ptr %153, align 4
  %155 = insertvalue { ptr, i160 } %152, i160 %154, 1
  br label %156

156:                                              ; preds = %116, %118, %219
  %157 = phi { ptr, i160 } [ %256, %219 ], [ %155, %118 ], [ poison, %116 ]
  %158 = phi i32 [ %218, %219 ], [ %115, %118 ], [ %117, %116 ]
  br label %159

159:                                              ; preds = %156
  br label %257

160:                                              ; preds = %3
  store i8 1, ptr %16, align 1
  %161 = load ptr, ptr %31, align 8
  %162 = load ptr, ptr %30, align 8
  %163 = call ptr @llvm.invariant.start.p0(i64 88, ptr %162)
  %164 = load i32, ptr %29, align 4
  %165 = getelementptr ptr, ptr %162, i32 %164
  %166 = getelementptr ptr, ptr %165, i32 3
  %167 = load ptr, ptr %166, align 8
  %168 = getelementptr { ptr, ptr }, ptr %167, i32 0, i32 1
  %169 = load ptr, ptr %168, align 8
  %170 = load i8, ptr %16, align 1
  %171 = trunc i8 %170 to i1
  call void %169(ptr %161, i1 %171) #2
  %172 = load ptr, ptr %31, align 8
  %173 = load ptr, ptr %30, align 8
  %174 = call ptr @llvm.invariant.start.p0(i64 88, ptr %173)
  %175 = load i32, ptr %29, align 4
  %176 = getelementptr ptr, ptr %173, i32 %175
  %177 = getelementptr ptr, ptr %176, i32 2
  %178 = load ptr, ptr %177, align 8
  %179 = getelementptr { ptr, ptr }, ptr %178, i32 0, i32 0
  %180 = load ptr, ptr %179, align 8
  %181 = call { ptr, ptr, ptr, i32 } %180(ptr %172) #1
  store { ptr, ptr, ptr, i32 } %181, ptr %17, align 8
  call void @assume_offset(ptr %17, ptr @Iterator)
  %182 = getelementptr { ptr, ptr, ptr, i32 }, ptr %17, i32 0, i32 0
  %183 = load ptr, ptr %182, align 8
  %184 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %183, 0
  %185 = getelementptr { ptr, ptr, ptr, i32 }, ptr %17, i32 0, i32 1
  %186 = load ptr, ptr %185, align 8
  %187 = insertvalue { ptr, ptr, ptr, i32 } %184, ptr %186, 1
  %188 = getelementptr { ptr, ptr, ptr, i32 }, ptr %17, i32 0, i32 2
  %189 = load ptr, ptr %188, align 8
  %190 = insertvalue { ptr, ptr, ptr, i32 } %187, ptr %189, 2
  %191 = getelementptr { ptr, ptr, ptr, i32 }, ptr %17, i32 0, i32 3
  %192 = load i32, ptr %191, align 4
  %193 = insertvalue { ptr, ptr, ptr, i32 } %190, i32 %192, 3
  %194 = call ptr @llvm.invariant.start.p0(i64 0, ptr %18)
  %195 = call ptr @llvm.invariant.start.p0(i64 24, ptr %183)
  %196 = getelementptr ptr, ptr %183, i32 %192
  %197 = getelementptr ptr, ptr %196, i32 1
  %198 = load ptr, ptr %197, align 8
  %199 = call ptr @behavior_wrapper(ptr %198, { ptr, ptr, ptr, i32 } %193, ptr %19)
  %200 = call { ptr, i160 } %199({ ptr, ptr, ptr, i32 } %193, { ptr, ptr, ptr, i32 } %193, ptr %18)
  store { ptr, i160 } %200, ptr %20, align 8
  %201 = load ptr, ptr %31, align 8
  %202 = load ptr, ptr %30, align 8
  %203 = call ptr @llvm.invariant.start.p0(i64 88, ptr %202)
  %204 = load i32, ptr %29, align 4
  %205 = getelementptr ptr, ptr %202, i32 %204
  %206 = load ptr, ptr %205, align 8
  %207 = call ptr @typegetter_wrapper(ptr %206, ptr %201)
  %208 = load ptr, ptr %20, align 8
  %209 = ptrtoint ptr %208 to i64
  %210 = icmp eq i64 %209, ptrtoint (ptr @nil_typ to i64)
  %211 = icmp eq i64 %209, 0
  %212 = or i1 %210, %211
  %213 = icmp eq i1 %212, false
  %214 = zext i1 %213 to i8
  store i8 %214, ptr %21, align 1
  %215 = load i8, ptr %21, align 1
  %216 = trunc i8 %215 to i1
  %217 = xor i1 %216, true
  %218 = zext i1 %217 to i32
  br i1 %216, label %116, label %219

219:                                              ; preds = %160
  %220 = getelementptr { ptr, i160 }, ptr %20, i32 0, i32 1
  %221 = load [0 x i8], ptr %220, align 1
  store [0 x i8] %221, ptr %23, align 1
  %222 = load ptr, ptr %31, align 8
  %223 = load ptr, ptr %30, align 8
  %224 = call ptr @llvm.invariant.start.p0(i64 88, ptr %223)
  %225 = load i32, ptr %29, align 4
  %226 = getelementptr ptr, ptr %223, i32 %225
  %227 = getelementptr ptr, ptr %226, i32 1
  %228 = load ptr, ptr %227, align 8
  %229 = getelementptr { ptr, ptr }, ptr %228, i32 0, i32 0
  %230 = load ptr, ptr %229, align 8
  %231 = call { ptr, ptr, ptr, i32 } %230(ptr %222) #1
  store { ptr, ptr, ptr, i32 } %231, ptr %24, align 8
  call void @assume_offset(ptr %24, ptr @Iterator)
  %232 = getelementptr { ptr, ptr, ptr, i32 }, ptr %24, i32 0, i32 0
  %233 = load ptr, ptr %232, align 8
  %234 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %233, 0
  %235 = getelementptr { ptr, ptr, ptr, i32 }, ptr %24, i32 0, i32 1
  %236 = load ptr, ptr %235, align 8
  %237 = insertvalue { ptr, ptr, ptr, i32 } %234, ptr %236, 1
  %238 = getelementptr { ptr, ptr, ptr, i32 }, ptr %24, i32 0, i32 2
  %239 = load ptr, ptr %238, align 8
  %240 = insertvalue { ptr, ptr, ptr, i32 } %237, ptr %239, 2
  %241 = getelementptr { ptr, ptr, ptr, i32 }, ptr %24, i32 0, i32 3
  %242 = load i32, ptr %241, align 4
  %243 = insertvalue { ptr, ptr, ptr, i32 } %240, i32 %242, 3
  %244 = call ptr @llvm.invariant.start.p0(i64 0, ptr %25)
  %245 = call ptr @llvm.invariant.start.p0(i64 24, ptr %233)
  %246 = getelementptr ptr, ptr %233, i32 %242
  %247 = getelementptr ptr, ptr %246, i32 1
  %248 = load ptr, ptr %247, align 8
  %249 = call ptr @behavior_wrapper(ptr %248, { ptr, ptr, ptr, i32 } %243, ptr %26)
  %250 = call { ptr, i160 } %249({ ptr, ptr, ptr, i32 } %243, { ptr, ptr, ptr, i32 } %243, ptr %25)
  store { ptr, i160 } %250, ptr %27, align 8
  %251 = getelementptr { ptr, i160 }, ptr %27, i32 0, i32 0
  %252 = load ptr, ptr %251, align 8
  %253 = insertvalue { ptr, i160 } undef, ptr %252, 0
  %254 = getelementptr { ptr, i160 }, ptr %27, i32 0, i32 1
  %255 = load i160, ptr %254, align 4
  %256 = insertvalue { ptr, i160 } %253, i160 %255, 1
  br label %156

257:                                              ; preds = %159
  br label %258

258:                                              ; preds = %257
  %259 = zext i32 %158 to i64
  %260 = trunc i64 %259 to i32
  switch i32 %260, label %274 [
    i32 0, label %261
  ]

261:                                              ; preds = %258
  %262 = select i1 %56, ptr %8, ptr %20
  %263 = select i1 %56, ptr %10, ptr %22
  %264 = getelementptr { ptr, i160 }, ptr %262, i32 0, i32 0
  %265 = getelementptr { ptr, i160 }, ptr %263, i32 0, i32 0
  %266 = load ptr, ptr %264, align 8
  store ptr %266, ptr %265, align 8
  %267 = getelementptr { ptr, i160 }, ptr %262, i32 0, i32 1
  %268 = getelementptr { ptr, i160 }, ptr %263, i32 0, i32 1
  %269 = load i160, ptr %267, align 4
  store i160 %269, ptr %268, align 4
  %270 = load ptr, ptr %265, align 8
  %271 = insertvalue { ptr, i160 } undef, ptr %270, 0
  %272 = load i160, ptr %268, align 4
  %273 = insertvalue { ptr, i160 } %271, i160 %272, 1
  br label %275

274:                                              ; preds = %258
  br label %275

275:                                              ; preds = %274, %261
  %276 = phi { ptr, i160 } [ %157, %274 ], [ %273, %261 ]
  ret { ptr, i160 } %276
}

define ptr @Interleaver_B_next_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 7, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [11 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { i64, i64 } @_data_size_Zipped(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %10
  %12 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %5
  %13 = select i1 %12, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 %5
  %14 = urem i64 %11, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %17
  %19 = add i64 %11, %18
  %20 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %13
  %21 = select i1 %20, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %13
  %22 = urem i64 %19, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %23 = icmp eq i64 %22, 0
  %24 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %22
  %25 = select i1 %23, i64 0, i64 %24
  %26 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %25
  %27 = add i64 %19, %26
  %28 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %21
  %29 = select i1 %28, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %21
  %30 = urem i64 %27, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %31 = icmp eq i64 %30, 0
  %32 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %30
  %33 = select i1 %31, i64 0, i64 %32
  %34 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %33
  %35 = add i64 %27, %34
  %36 = urem i64 %35, %29
  %37 = icmp eq i64 %36, 0
  %38 = sub i64 %29, %36
  %39 = select i1 %37, i64 0, i64 %38
  %40 = add i64 %35, %39
  %41 = insertvalue { i64, i64 } undef, i64 %40, 0
  %42 = insertvalue { i64, i64 } %41, i64 %29, 1
  ret { i64, i64 } %42
}

define ptr @Zipped_field_Zipped_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define ptr @Zipped_field_Zipped_1(ptr %0) {
  %2 = getelementptr ptr, ptr %0, i32 1
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

define ptr @Zipped_field_Zipped_2(ptr %0) {
  %2 = getelementptr ptr, ptr %0, i32 2
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

define { ptr, ptr, ptr, i32 } @Zipped_getter_first(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %11
  %13 = add i64 %7, %12
  %14 = urem i64 %13, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 %13, %17
  %19 = getelementptr i8, ptr %0, i64 %18
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 0
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %21, 0
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 1
  %24 = load ptr, ptr %23, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %24, 1
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 2
  %27 = load ptr, ptr %26, align 8
  %28 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %27, 2
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 3
  %30 = load i32, ptr %29, align 4
  %31 = insertvalue { ptr, ptr, ptr, i32 } %28, i32 %30, 3
  ret { ptr, ptr, ptr, i32 } %31
}

define void @Zipped_setter_first(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %12
  %14 = add i64 %8, %13
  %15 = urem i64 %14, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %16 = icmp eq i64 %15, 0
  %17 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add i64 %14, %18
  %20 = getelementptr i8, ptr %0, i64 %19
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %21, align 8
  %22 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 0
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 0
  %24 = load ptr, ptr %22, align 8
  store ptr %24, ptr %23, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 1
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 1
  %27 = load ptr, ptr %25, align 8
  store ptr %27, ptr %26, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 2
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 2
  %30 = load ptr, ptr %28, align 8
  store ptr %30, ptr %29, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 3
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 3
  %33 = load i32, ptr %31, align 4
  store i32 %33, ptr %32, align 4
  ret void
}

define { ptr, ptr, ptr, i32 } @Zipped_getter_second(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %11
  %13 = add i64 %7, %12
  %14 = urem i64 %13, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %17
  %19 = add i64 %13, %18
  %20 = urem i64 %19, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = add i64 %19, %23
  %25 = getelementptr i8, ptr %0, i64 %24
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %27, 0
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 1
  %30 = load ptr, ptr %29, align 8
  %31 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %30, 1
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 2
  %33 = load ptr, ptr %32, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %33, 2
  %35 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 3
  %36 = load i32, ptr %35, align 4
  %37 = insertvalue { ptr, ptr, ptr, i32 } %34, i32 %36, 3
  ret { ptr, ptr, ptr, i32 } %37
}

define void @Zipped_setter_second(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %12
  %14 = add i64 %8, %13
  %15 = urem i64 %14, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %16 = icmp eq i64 %15, 0
  %17 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %18
  %20 = add i64 %14, %19
  %21 = urem i64 %20, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %22 = icmp eq i64 %21, 0
  %23 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %21
  %24 = select i1 %22, i64 0, i64 %23
  %25 = add i64 %20, %24
  %26 = getelementptr i8, ptr %0, i64 %25
  %27 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %27, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 0
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 0
  %30 = load ptr, ptr %28, align 8
  store ptr %30, ptr %29, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 1
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 1
  %33 = load ptr, ptr %31, align 8
  store ptr %33, ptr %32, align 8
  %34 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 2
  %35 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 2
  %36 = load ptr, ptr %34, align 8
  store ptr %36, ptr %35, align 8
  %37 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 3
  %38 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 3
  %39 = load i32, ptr %37, align 4
  store i32 %39, ptr %38, align 4
  ret void
}

define void @Zipped_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) {
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %6, align 8
  %7 = alloca i32, align 4
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = alloca ptr, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %8, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 1
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %9, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 2
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %10, align 8
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  store i32 %18, ptr %7, align 4
  %19 = load ptr, ptr %8, align 8
  %20 = call i32 @get_offset(ptr %19, ptr @Zipped)
  store i32 %20, ptr %7, align 4
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %21, align 8
  %22 = alloca i32, align 4
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = alloca ptr, align 8
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  store ptr %27, ptr %25, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 1
  %29 = load ptr, ptr %28, align 8
  store ptr %29, ptr %24, align 8
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 2
  %31 = load ptr, ptr %30, align 8
  store ptr %31, ptr %23, align 8
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 3
  %33 = load i32, ptr %32, align 4
  store i32 %33, ptr %22, align 4
  %34 = load ptr, ptr %25, align 8
  %35 = call i32 @get_offset(ptr %34, ptr @Iterable)
  store i32 %35, ptr %22, align 4
  %36 = alloca i32, align 4
  %37 = alloca ptr, align 8
  %38 = alloca ptr, align 8
  %39 = alloca ptr, align 8
  %40 = load ptr, ptr %25, align 8
  store ptr %40, ptr %39, align 8
  %41 = load ptr, ptr %24, align 8
  store ptr %41, ptr %38, align 8
  %42 = load ptr, ptr %23, align 8
  store ptr %42, ptr %37, align 8
  %43 = load i32, ptr %22, align 4
  store i32 %43, ptr %36, align 4
  %44 = load ptr, ptr %39, align 8
  %45 = call i32 @get_offset(ptr %44, ptr @Iterable)
  store i32 %45, ptr %36, align 4
  %46 = load ptr, ptr %9, align 8
  %47 = load ptr, ptr %8, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 448, ptr %47)
  %49 = load i32, ptr %7, align 4
  %50 = getelementptr ptr, ptr %47, i32 %49
  %51 = getelementptr ptr, ptr %50, i32 3
  %52 = load ptr, ptr %51, align 8
  %53 = getelementptr { ptr, ptr }, ptr %52, i32 0, i32 1
  %54 = load ptr, ptr %53, align 8
  %55 = load ptr, ptr %39, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %55, 0
  %57 = load ptr, ptr %38, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %57, 1
  %59 = load ptr, ptr %37, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %59, 2
  %61 = load i32, ptr %36, align 4
  %62 = insertvalue { ptr, ptr, ptr, i32 } %60, i32 %61, 3
  call void %54(ptr %46, { ptr, ptr, ptr, i32 } %62) #2
  %63 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %4, ptr %63, align 8
  %64 = alloca i32, align 4
  %65 = alloca ptr, align 8
  %66 = alloca ptr, align 8
  %67 = alloca ptr, align 8
  %68 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 0
  %69 = load ptr, ptr %68, align 8
  store ptr %69, ptr %67, align 8
  %70 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 1
  %71 = load ptr, ptr %70, align 8
  store ptr %71, ptr %66, align 8
  %72 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 2
  %73 = load ptr, ptr %72, align 8
  store ptr %73, ptr %65, align 8
  %74 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 3
  %75 = load i32, ptr %74, align 4
  store i32 %75, ptr %64, align 4
  %76 = load ptr, ptr %67, align 8
  %77 = call i32 @get_offset(ptr %76, ptr @Iterable)
  store i32 %77, ptr %64, align 4
  %78 = alloca i32, align 4
  %79 = alloca ptr, align 8
  %80 = alloca ptr, align 8
  %81 = alloca ptr, align 8
  %82 = load ptr, ptr %67, align 8
  store ptr %82, ptr %81, align 8
  %83 = load ptr, ptr %66, align 8
  store ptr %83, ptr %80, align 8
  %84 = load ptr, ptr %65, align 8
  store ptr %84, ptr %79, align 8
  %85 = load i32, ptr %64, align 4
  store i32 %85, ptr %78, align 4
  %86 = load ptr, ptr %81, align 8
  %87 = call i32 @get_offset(ptr %86, ptr @Iterable)
  store i32 %87, ptr %78, align 4
  %88 = load ptr, ptr %9, align 8
  %89 = load ptr, ptr %8, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 448, ptr %89)
  %91 = load i32, ptr %7, align 4
  %92 = getelementptr ptr, ptr %89, i32 %91
  %93 = getelementptr ptr, ptr %92, i32 4
  %94 = load ptr, ptr %93, align 8
  %95 = getelementptr { ptr, ptr }, ptr %94, i32 0, i32 1
  %96 = load ptr, ptr %95, align 8
  %97 = load ptr, ptr %81, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %97, 0
  %99 = load ptr, ptr %80, align 8
  %100 = insertvalue { ptr, ptr, ptr, i32 } %98, ptr %99, 1
  %101 = load ptr, ptr %79, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } %100, ptr %101, 2
  %103 = load i32, ptr %78, align 4
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, i32 %103, 3
  call void %96(ptr %88, { ptr, ptr, ptr, i32 } %104) #2
  ret void
}

define ptr @Zipped_B_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @Iterable, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @Iterable to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 1
  %22 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 2
  %23 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 0
  %24 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 1
  %25 = load i64, ptr %21, align 4
  %26 = load i64, ptr %22, align 4
  %27 = load ptr, ptr %23, align 8
  %28 = load ptr, ptr %24, align 8
  %29 = load i64, ptr @Iterable, align 4
  %30 = call i1 @subtype_test_wrapper(ptr %27, i64 %26, i64 %25, i64 %29, i64 ptrtoint (ptr @Iterable to i64), ptr %28)
  %31 = zext i1 %30 to i8
  store i8 %31, ptr %3, align 1
  store i32 18, ptr %6, align 4
  %32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %33 = load i32, ptr %6, align 4
  %34 = getelementptr [56 x ptr], ptr %32, i32 0, i32 %33
  %35 = getelementptr ptr, ptr %34, i32 10
  %36 = load ptr, ptr %35, align 8
  ret ptr %36
}

define { ptr, ptr, ptr, i32 } @Zipped_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @Zipped)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 448, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 3
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr { ptr, ptr }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = call { ptr, ptr, ptr, i32 } %27(ptr %19) #1
  %29 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %28, ptr %29, align 8
  call void @assume_offset(ptr %29, ptr @Iterable)
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 1
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %34, 1
  %36 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 2
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %37, 2
  %39 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 3
  %40 = load i32, ptr %39, align 4
  %41 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %40, 3
  %42 = alloca [0 x ptr], align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 0, ptr %42)
  %44 = call ptr @llvm.invariant.start.p0(i64 200, ptr %31)
  %45 = getelementptr ptr, ptr %31, i32 %40
  %46 = getelementptr ptr, ptr %45, i32 1
  %47 = load ptr, ptr %46, align 8
  %48 = alloca {}, align 8
  %49 = call ptr @behavior_wrapper(ptr %47, { ptr, ptr, ptr, i32 } %41, ptr %48)
  %50 = call { ptr, ptr, ptr, i32 } %49({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr %42)
  %51 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %50, ptr %51, align 8
  %52 = alloca i32, align 4
  %53 = alloca ptr, align 8
  %54 = alloca ptr, align 8
  %55 = alloca ptr, align 8
  %56 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 0
  %57 = load ptr, ptr %56, align 8
  store ptr %57, ptr %53, align 8
  %58 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 1
  %59 = load ptr, ptr %58, align 8
  store ptr %59, ptr %55, align 8
  %60 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 2
  %61 = load ptr, ptr %60, align 8
  store ptr %61, ptr %54, align 8
  %62 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 3
  %63 = load i32, ptr %62, align 4
  store i32 %63, ptr %52, align 4
  %64 = load ptr, ptr %53, align 8
  %65 = call i32 @get_offset(ptr %64, ptr @Iterator)
  store i32 %65, ptr %52, align 4
  %66 = load ptr, ptr %7, align 8
  %67 = load ptr, ptr %6, align 8
  %68 = call ptr @llvm.invariant.start.p0(i64 448, ptr %67)
  %69 = load i32, ptr %5, align 4
  %70 = getelementptr ptr, ptr %67, i32 %69
  %71 = getelementptr ptr, ptr %70, i32 4
  %72 = load ptr, ptr %71, align 8
  %73 = getelementptr { ptr, ptr }, ptr %72, i32 0, i32 0
  %74 = load ptr, ptr %73, align 8
  %75 = call { ptr, ptr, ptr, i32 } %74(ptr %66) #1
  %76 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %75, ptr %76, align 8
  call void @assume_offset(ptr %76, ptr @Iterable)
  %77 = getelementptr { ptr, ptr, ptr, i32 }, ptr %76, i32 0, i32 0
  %78 = load ptr, ptr %77, align 8
  %79 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %78, 0
  %80 = getelementptr { ptr, ptr, ptr, i32 }, ptr %76, i32 0, i32 1
  %81 = load ptr, ptr %80, align 8
  %82 = insertvalue { ptr, ptr, ptr, i32 } %79, ptr %81, 1
  %83 = getelementptr { ptr, ptr, ptr, i32 }, ptr %76, i32 0, i32 2
  %84 = load ptr, ptr %83, align 8
  %85 = insertvalue { ptr, ptr, ptr, i32 } %82, ptr %84, 2
  %86 = getelementptr { ptr, ptr, ptr, i32 }, ptr %76, i32 0, i32 3
  %87 = load i32, ptr %86, align 4
  %88 = insertvalue { ptr, ptr, ptr, i32 } %85, i32 %87, 3
  %89 = alloca [0 x ptr], align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 0, ptr %89)
  %91 = call ptr @llvm.invariant.start.p0(i64 200, ptr %78)
  %92 = getelementptr ptr, ptr %78, i32 %87
  %93 = getelementptr ptr, ptr %92, i32 1
  %94 = load ptr, ptr %93, align 8
  %95 = alloca {}, align 8
  %96 = call ptr @behavior_wrapper(ptr %94, { ptr, ptr, ptr, i32 } %88, ptr %95)
  %97 = call { ptr, ptr, ptr, i32 } %96({ ptr, ptr, ptr, i32 } %88, { ptr, ptr, ptr, i32 } %88, ptr %89)
  %98 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %97, ptr %98, align 8
  %99 = alloca i32, align 4
  %100 = alloca ptr, align 8
  %101 = alloca ptr, align 8
  %102 = alloca ptr, align 8
  %103 = getelementptr { ptr, ptr, ptr, i32 }, ptr %98, i32 0, i32 0
  %104 = load ptr, ptr %103, align 8
  store ptr %104, ptr %100, align 8
  %105 = getelementptr { ptr, ptr, ptr, i32 }, ptr %98, i32 0, i32 1
  %106 = load ptr, ptr %105, align 8
  store ptr %106, ptr %102, align 8
  %107 = getelementptr { ptr, ptr, ptr, i32 }, ptr %98, i32 0, i32 2
  %108 = load ptr, ptr %107, align 8
  store ptr %108, ptr %101, align 8
  %109 = getelementptr { ptr, ptr, ptr, i32 }, ptr %98, i32 0, i32 3
  %110 = load i32, ptr %109, align 4
  store i32 %110, ptr %99, align 4
  %111 = load ptr, ptr %100, align 8
  %112 = call i32 @get_offset(ptr %111, ptr @Iterator)
  store i32 %112, ptr %99, align 4
  %113 = load ptr, ptr %7, align 8
  %114 = load ptr, ptr %6, align 8
  %115 = call ptr @llvm.invariant.start.p0(i64 448, ptr %114)
  %116 = load i32, ptr %5, align 4
  %117 = getelementptr ptr, ptr %114, i32 %116
  %118 = load ptr, ptr %117, align 8
  %119 = call ptr @typegetter_wrapper(ptr %118, ptr %113)
  %120 = load ptr, ptr %7, align 8
  %121 = load ptr, ptr %6, align 8
  %122 = call ptr @llvm.invariant.start.p0(i64 448, ptr %121)
  %123 = load i32, ptr %5, align 4
  %124 = getelementptr ptr, ptr %121, i32 %123
  %125 = getelementptr ptr, ptr %124, i32 1
  %126 = load ptr, ptr %125, align 8
  %127 = call ptr @typegetter_wrapper(ptr %126, ptr %120)
  %128 = load ptr, ptr %7, align 8
  %129 = load ptr, ptr %6, align 8
  %130 = call ptr @llvm.invariant.start.p0(i64 448, ptr %129)
  %131 = load i32, ptr %5, align 4
  %132 = getelementptr ptr, ptr %129, i32 %131
  %133 = load ptr, ptr %132, align 8
  %134 = call ptr @typegetter_wrapper(ptr %133, ptr %128)
  %135 = load ptr, ptr %7, align 8
  %136 = load ptr, ptr %6, align 8
  %137 = call ptr @llvm.invariant.start.p0(i64 448, ptr %136)
  %138 = load i32, ptr %5, align 4
  %139 = getelementptr ptr, ptr %136, i32 %138
  %140 = getelementptr ptr, ptr %139, i32 1
  %141 = load ptr, ptr %140, align 8
  %142 = call ptr @typegetter_wrapper(ptr %141, ptr %135)
  %143 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([4 x ptr], ptr null, i32 1) to i64))
  %144 = getelementptr [4 x ptr], ptr %143, i32 0, i32 2
  store ptr %142, ptr %144, align 8
  %145 = getelementptr [4 x ptr], ptr %143, i32 0, i32 1
  store ptr %134, ptr %145, align 8
  %146 = getelementptr [4 x ptr], ptr %143, i32 0, i32 3
  store ptr null, ptr %146, align 8
  %147 = call ptr @llvm.invariant.start.p0(i64 24, ptr %143)
  store ptr @Pair, ptr %143, align 8
  %148 = alloca [4 x ptr], align 8
  store ptr @Zipper, ptr %148, align 8
  %149 = getelementptr ptr, ptr %148, i32 1
  store ptr %119, ptr %149, align 8
  %150 = getelementptr ptr, ptr %148, i32 2
  store ptr %127, ptr %150, align 8
  %151 = getelementptr ptr, ptr %148, i32 3
  store ptr %143, ptr %151, align 8
  %152 = load ptr, ptr %148, align 8
  %153 = getelementptr ptr, ptr %152, i32 6
  %154 = load ptr, ptr %153, align 8
  %155 = call { i64, i64 } @size_wrapper(ptr %154, ptr %148)
  %156 = extractvalue { i64, i64 } %155, 0
  %157 = call ptr @bump_malloc(i64 %156)
  store ptr %119, ptr %157, align 8
  %158 = getelementptr ptr, ptr %157, i32 1
  store ptr %127, ptr %158, align 8
  %159 = getelementptr ptr, ptr %157, i32 2
  store ptr %143, ptr %159, align 8
  %160 = call ptr @llvm.invariant.start.p0(i64 24, ptr %157)
  %161 = alloca i32, align 4
  %162 = alloca ptr, align 8
  %163 = alloca ptr, align 8
  %164 = alloca ptr, align 8
  store ptr @Zipper, ptr %164, align 8
  store ptr %157, ptr %163, align 8
  store i32 10, ptr %161, align 4
  %165 = load ptr, ptr %7, align 8
  %166 = load ptr, ptr %6, align 8
  %167 = call ptr @llvm.invariant.start.p0(i64 448, ptr %166)
  %168 = load i32, ptr %5, align 4
  %169 = getelementptr ptr, ptr %166, i32 %168
  %170 = getelementptr ptr, ptr %169, i32 3
  %171 = load ptr, ptr %170, align 8
  %172 = getelementptr { ptr, ptr }, ptr %171, i32 0, i32 0
  %173 = load ptr, ptr %172, align 8
  %174 = call { ptr, ptr, ptr, i32 } %173(ptr %165) #1
  %175 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %174, ptr %175, align 8
  call void @assume_offset(ptr %175, ptr @Iterable)
  %176 = getelementptr { ptr, ptr, ptr, i32 }, ptr %175, i32 0, i32 0
  %177 = load ptr, ptr %176, align 8
  %178 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %177, 0
  %179 = getelementptr { ptr, ptr, ptr, i32 }, ptr %175, i32 0, i32 1
  %180 = load ptr, ptr %179, align 8
  %181 = insertvalue { ptr, ptr, ptr, i32 } %178, ptr %180, 1
  %182 = getelementptr { ptr, ptr, ptr, i32 }, ptr %175, i32 0, i32 2
  %183 = load ptr, ptr %182, align 8
  %184 = insertvalue { ptr, ptr, ptr, i32 } %181, ptr %183, 2
  %185 = getelementptr { ptr, ptr, ptr, i32 }, ptr %175, i32 0, i32 3
  %186 = load i32, ptr %185, align 4
  %187 = insertvalue { ptr, ptr, ptr, i32 } %184, i32 %186, 3
  %188 = alloca [0 x ptr], align 8
  %189 = call ptr @llvm.invariant.start.p0(i64 0, ptr %188)
  %190 = call ptr @llvm.invariant.start.p0(i64 200, ptr %177)
  %191 = getelementptr ptr, ptr %177, i32 %186
  %192 = getelementptr ptr, ptr %191, i32 1
  %193 = load ptr, ptr %192, align 8
  %194 = alloca {}, align 8
  %195 = call ptr @behavior_wrapper(ptr %193, { ptr, ptr, ptr, i32 } %187, ptr %194)
  %196 = call { ptr, ptr, ptr, i32 } %195({ ptr, ptr, ptr, i32 } %187, { ptr, ptr, ptr, i32 } %187, ptr %188)
  %197 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %196, ptr %197, align 8
  %198 = alloca i32, align 4
  %199 = alloca ptr, align 8
  %200 = alloca ptr, align 8
  %201 = alloca ptr, align 8
  %202 = getelementptr { ptr, ptr, ptr, i32 }, ptr %197, i32 0, i32 0
  %203 = load ptr, ptr %202, align 8
  store ptr %203, ptr %201, align 8
  %204 = getelementptr { ptr, ptr, ptr, i32 }, ptr %197, i32 0, i32 1
  %205 = load ptr, ptr %204, align 8
  store ptr %205, ptr %200, align 8
  %206 = getelementptr { ptr, ptr, ptr, i32 }, ptr %197, i32 0, i32 2
  %207 = load ptr, ptr %206, align 8
  store ptr %207, ptr %199, align 8
  %208 = getelementptr { ptr, ptr, ptr, i32 }, ptr %197, i32 0, i32 3
  %209 = load i32, ptr %208, align 4
  store i32 %209, ptr %198, align 4
  %210 = load ptr, ptr %201, align 8
  %211 = call i32 @get_offset(ptr %210, ptr @Iterator)
  store i32 %211, ptr %198, align 4
  %212 = load ptr, ptr %7, align 8
  %213 = load ptr, ptr %6, align 8
  %214 = call ptr @llvm.invariant.start.p0(i64 448, ptr %213)
  %215 = load i32, ptr %5, align 4
  %216 = getelementptr ptr, ptr %213, i32 %215
  %217 = getelementptr ptr, ptr %216, i32 4
  %218 = load ptr, ptr %217, align 8
  %219 = getelementptr { ptr, ptr }, ptr %218, i32 0, i32 0
  %220 = load ptr, ptr %219, align 8
  %221 = call { ptr, ptr, ptr, i32 } %220(ptr %212) #1
  %222 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %221, ptr %222, align 8
  call void @assume_offset(ptr %222, ptr @Iterable)
  %223 = getelementptr { ptr, ptr, ptr, i32 }, ptr %222, i32 0, i32 0
  %224 = load ptr, ptr %223, align 8
  %225 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %224, 0
  %226 = getelementptr { ptr, ptr, ptr, i32 }, ptr %222, i32 0, i32 1
  %227 = load ptr, ptr %226, align 8
  %228 = insertvalue { ptr, ptr, ptr, i32 } %225, ptr %227, 1
  %229 = getelementptr { ptr, ptr, ptr, i32 }, ptr %222, i32 0, i32 2
  %230 = load ptr, ptr %229, align 8
  %231 = insertvalue { ptr, ptr, ptr, i32 } %228, ptr %230, 2
  %232 = getelementptr { ptr, ptr, ptr, i32 }, ptr %222, i32 0, i32 3
  %233 = load i32, ptr %232, align 4
  %234 = insertvalue { ptr, ptr, ptr, i32 } %231, i32 %233, 3
  %235 = alloca [0 x ptr], align 8
  %236 = call ptr @llvm.invariant.start.p0(i64 0, ptr %235)
  %237 = call ptr @llvm.invariant.start.p0(i64 200, ptr %224)
  %238 = getelementptr ptr, ptr %224, i32 %233
  %239 = getelementptr ptr, ptr %238, i32 1
  %240 = load ptr, ptr %239, align 8
  %241 = alloca {}, align 8
  %242 = call ptr @behavior_wrapper(ptr %240, { ptr, ptr, ptr, i32 } %234, ptr %241)
  %243 = call { ptr, ptr, ptr, i32 } %242({ ptr, ptr, ptr, i32 } %234, { ptr, ptr, ptr, i32 } %234, ptr %235)
  %244 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %243, ptr %244, align 8
  %245 = alloca i32, align 4
  %246 = alloca ptr, align 8
  %247 = alloca ptr, align 8
  %248 = alloca ptr, align 8
  %249 = getelementptr { ptr, ptr, ptr, i32 }, ptr %244, i32 0, i32 0
  %250 = load ptr, ptr %249, align 8
  store ptr %250, ptr %248, align 8
  %251 = getelementptr { ptr, ptr, ptr, i32 }, ptr %244, i32 0, i32 1
  %252 = load ptr, ptr %251, align 8
  store ptr %252, ptr %247, align 8
  %253 = getelementptr { ptr, ptr, ptr, i32 }, ptr %244, i32 0, i32 2
  %254 = load ptr, ptr %253, align 8
  store ptr %254, ptr %246, align 8
  %255 = getelementptr { ptr, ptr, ptr, i32 }, ptr %244, i32 0, i32 3
  %256 = load i32, ptr %255, align 4
  store i32 %256, ptr %245, align 4
  %257 = load ptr, ptr %248, align 8
  %258 = call i32 @get_offset(ptr %257, ptr @Iterator)
  store i32 %258, ptr %245, align 4
  %259 = alloca i32, align 4
  %260 = alloca ptr, align 8
  %261 = alloca ptr, align 8
  %262 = alloca ptr, align 8
  %263 = load ptr, ptr %201, align 8
  store ptr %263, ptr %262, align 8
  %264 = load ptr, ptr %200, align 8
  store ptr %264, ptr %261, align 8
  %265 = load ptr, ptr %199, align 8
  store ptr %265, ptr %260, align 8
  %266 = load i32, ptr %198, align 4
  store i32 %266, ptr %259, align 4
  %267 = load ptr, ptr %262, align 8
  %268 = call i32 @get_offset(ptr %267, ptr @Iterator)
  store i32 %268, ptr %259, align 4
  %269 = load ptr, ptr %262, align 8
  %270 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %269, 0
  %271 = load ptr, ptr %261, align 8
  %272 = insertvalue { ptr, ptr, ptr, i32 } %270, ptr %271, 1
  %273 = load ptr, ptr %260, align 8
  %274 = insertvalue { ptr, ptr, ptr, i32 } %272, ptr %273, 2
  %275 = load i32, ptr %259, align 4
  %276 = insertvalue { ptr, ptr, ptr, i32 } %274, i32 %275, 3
  %277 = alloca i32, align 4
  %278 = alloca ptr, align 8
  %279 = alloca ptr, align 8
  %280 = alloca ptr, align 8
  %281 = load ptr, ptr %248, align 8
  store ptr %281, ptr %280, align 8
  %282 = load ptr, ptr %247, align 8
  store ptr %282, ptr %279, align 8
  %283 = load ptr, ptr %246, align 8
  store ptr %283, ptr %278, align 8
  %284 = load i32, ptr %245, align 4
  store i32 %284, ptr %277, align 4
  %285 = load ptr, ptr %280, align 8
  %286 = call i32 @get_offset(ptr %285, ptr @Iterator)
  store i32 %286, ptr %277, align 4
  %287 = load ptr, ptr %280, align 8
  %288 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %287, 0
  %289 = load ptr, ptr %279, align 8
  %290 = insertvalue { ptr, ptr, ptr, i32 } %288, ptr %289, 1
  %291 = load ptr, ptr %278, align 8
  %292 = insertvalue { ptr, ptr, ptr, i32 } %290, ptr %291, 2
  %293 = load i32, ptr %277, align 4
  %294 = insertvalue { ptr, ptr, ptr, i32 } %292, i32 %293, 3
  %295 = load ptr, ptr %164, align 8
  %296 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %295, 0
  %297 = load ptr, ptr %163, align 8
  %298 = insertvalue { ptr, ptr, ptr, i32 } %296, ptr %297, 1
  %299 = load ptr, ptr %162, align 8
  %300 = insertvalue { ptr, ptr, ptr, i32 } %298, ptr %299, 2
  %301 = load i32, ptr %161, align 4
  %302 = insertvalue { ptr, ptr, ptr, i32 } %300, i32 %301, 3
  %303 = load ptr, ptr %7, align 8
  %304 = load ptr, ptr %6, align 8
  %305 = call ptr @llvm.invariant.start.p0(i64 448, ptr %304)
  %306 = load i32, ptr %5, align 4
  %307 = getelementptr ptr, ptr %304, i32 %306
  %308 = load ptr, ptr %307, align 8
  %309 = call ptr @typegetter_wrapper(ptr %308, ptr %303)
  %310 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %311 = getelementptr [3 x ptr], ptr %310, i32 0, i32 1
  store ptr %309, ptr %311, align 8
  %312 = getelementptr [3 x ptr], ptr %310, i32 0, i32 2
  store ptr null, ptr %312, align 8
  %313 = call ptr @llvm.invariant.start.p0(i64 16, ptr %310)
  store ptr @Iterator, ptr %310, align 8
  %314 = load ptr, ptr %7, align 8
  %315 = load ptr, ptr %6, align 8
  %316 = call ptr @llvm.invariant.start.p0(i64 448, ptr %315)
  %317 = load i32, ptr %5, align 4
  %318 = getelementptr ptr, ptr %315, i32 %317
  %319 = getelementptr ptr, ptr %318, i32 1
  %320 = load ptr, ptr %319, align 8
  %321 = call ptr @typegetter_wrapper(ptr %320, ptr %314)
  %322 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %323 = getelementptr [3 x ptr], ptr %322, i32 0, i32 1
  store ptr %321, ptr %323, align 8
  %324 = getelementptr [3 x ptr], ptr %322, i32 0, i32 2
  store ptr null, ptr %324, align 8
  %325 = call ptr @llvm.invariant.start.p0(i64 16, ptr %322)
  store ptr @Iterator, ptr %322, align 8
  %326 = alloca [2 x ptr], align 8
  %327 = getelementptr [2 x ptr], ptr %326, i32 0, i32 0
  store ptr %310, ptr %327, align 8
  %328 = getelementptr [2 x ptr], ptr %326, i32 0, i32 1
  store ptr %322, ptr %328, align 8
  %329 = call ptr @llvm.invariant.start.p0(i64 4, ptr %326)
  %330 = call ptr @llvm.invariant.start.p0(i64 96, ptr %295)
  %331 = getelementptr ptr, ptr %295, i32 %301
  %332 = getelementptr ptr, ptr %331, i32 5
  %333 = load ptr, ptr %332, align 8
  %334 = alloca { ptr, ptr }, align 8
  %335 = getelementptr { ptr, ptr }, ptr %334, i32 0, i32 0
  store ptr %269, ptr %335, align 8
  %336 = getelementptr { ptr, ptr }, ptr %334, i32 0, i32 1
  store ptr %287, ptr %336, align 8
  %337 = call ptr @behavior_wrapper(ptr %333, { ptr, ptr, ptr, i32 } %302, ptr %334)
  call void %337({ ptr, ptr, ptr, i32 } %302, { ptr, ptr, ptr, i32 } %302, ptr %326, { ptr, ptr, ptr, i32 } %276, { ptr, ptr, ptr, i32 } %294)
  %338 = alloca i32, align 4
  %339 = alloca ptr, align 8
  %340 = alloca ptr, align 8
  %341 = alloca ptr, align 8
  %342 = load ptr, ptr %164, align 8
  store ptr %342, ptr %341, align 8
  %343 = load ptr, ptr %163, align 8
  store ptr %343, ptr %340, align 8
  %344 = load ptr, ptr %162, align 8
  store ptr %344, ptr %339, align 8
  %345 = load i32, ptr %161, align 4
  store i32 %345, ptr %338, align 4
  %346 = load ptr, ptr %341, align 8
  %347 = call i32 @get_offset(ptr %346, ptr @Iterator)
  store i32 %347, ptr %338, align 4
  %348 = load ptr, ptr %341, align 8
  %349 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %348, 0
  %350 = load ptr, ptr %340, align 8
  %351 = insertvalue { ptr, ptr, ptr, i32 } %349, ptr %350, 1
  %352 = load ptr, ptr %339, align 8
  %353 = insertvalue { ptr, ptr, ptr, i32 } %351, ptr %352, 2
  %354 = load i32, ptr %338, align 4
  %355 = insertvalue { ptr, ptr, ptr, i32 } %353, i32 %354, 3
  ret { ptr, ptr, ptr, i32 } %355
}

define ptr @Zipped_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 19, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [56 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @Zipped_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 20, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [56 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Zipped_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @Pair, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @Pair to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = ptrtoint ptr %20 to i64
  %22 = icmp eq i64 %21, ptrtoint (ptr @function_typ to i64)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 21, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [56 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define ptr @Zipped_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 22, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [56 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Zipped_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 23, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [56 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Zipped_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 24, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [56 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @Zipped_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 25, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [56 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Zipped_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 26, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [56 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Zipped_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 27, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [56 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define ptr @Zipped_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 28, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [56 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define ptr @Zipped_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 29, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [56 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define ptr @Zipped_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 30, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [56 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define { i64, i64 } @_data_size_Zipper(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %10
  %12 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %5
  %13 = select i1 %12, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 %5
  %14 = urem i64 %11, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %17
  %19 = add i64 %11, %18
  %20 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %13
  %21 = select i1 %20, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %13
  %22 = urem i64 %19, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %23 = icmp eq i64 %22, 0
  %24 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %22
  %25 = select i1 %23, i64 0, i64 %24
  %26 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %25
  %27 = add i64 %19, %26
  %28 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %21
  %29 = select i1 %28, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %21
  %30 = urem i64 %27, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %31 = icmp eq i64 %30, 0
  %32 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %30
  %33 = select i1 %31, i64 0, i64 %32
  %34 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %33
  %35 = add i64 %27, %34
  %36 = urem i64 %35, %29
  %37 = icmp eq i64 %36, 0
  %38 = sub i64 %29, %36
  %39 = select i1 %37, i64 0, i64 %38
  %40 = add i64 %35, %39
  %41 = insertvalue { i64, i64 } undef, i64 %40, 0
  %42 = insertvalue { i64, i64 } %41, i64 %29, 1
  ret { i64, i64 } %42
}

define ptr @Zipper_field_Zipper_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define ptr @Zipper_field_Zipper_1(ptr %0) {
  %2 = getelementptr ptr, ptr %0, i32 1
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

define ptr @Zipper_field_Zipper_2(ptr %0) {
  %2 = getelementptr ptr, ptr %0, i32 2
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

define { ptr, ptr, ptr, i32 } @Zipper_getter_first(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %11
  %13 = add i64 %7, %12
  %14 = urem i64 %13, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 %13, %17
  %19 = getelementptr i8, ptr %0, i64 %18
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 0
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %21, 0
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 1
  %24 = load ptr, ptr %23, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %24, 1
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 2
  %27 = load ptr, ptr %26, align 8
  %28 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %27, 2
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 3
  %30 = load i32, ptr %29, align 4
  %31 = insertvalue { ptr, ptr, ptr, i32 } %28, i32 %30, 3
  ret { ptr, ptr, ptr, i32 } %31
}

define void @Zipper_setter_first(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %12
  %14 = add i64 %8, %13
  %15 = urem i64 %14, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %16 = icmp eq i64 %15, 0
  %17 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add i64 %14, %18
  %20 = getelementptr i8, ptr %0, i64 %19
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %21, align 8
  %22 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 0
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 0
  %24 = load ptr, ptr %22, align 8
  store ptr %24, ptr %23, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 1
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 1
  %27 = load ptr, ptr %25, align 8
  store ptr %27, ptr %26, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 2
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 2
  %30 = load ptr, ptr %28, align 8
  store ptr %30, ptr %29, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 3
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 3
  %33 = load i32, ptr %31, align 4
  store i32 %33, ptr %32, align 4
  ret void
}

define { ptr, ptr, ptr, i32 } @Zipper_getter_second(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %11
  %13 = add i64 %7, %12
  %14 = urem i64 %13, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %17
  %19 = add i64 %13, %18
  %20 = urem i64 %19, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = add i64 %19, %23
  %25 = getelementptr i8, ptr %0, i64 %24
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %27, 0
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 1
  %30 = load ptr, ptr %29, align 8
  %31 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %30, 1
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 2
  %33 = load ptr, ptr %32, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %33, 2
  %35 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 3
  %36 = load i32, ptr %35, align 4
  %37 = insertvalue { ptr, ptr, ptr, i32 } %34, i32 %36, 3
  ret { ptr, ptr, ptr, i32 } %37
}

define void @Zipper_setter_second(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %12
  %14 = add i64 %8, %13
  %15 = urem i64 %14, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %16 = icmp eq i64 %15, 0
  %17 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %18
  %20 = add i64 %14, %19
  %21 = urem i64 %20, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %22 = icmp eq i64 %21, 0
  %23 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %21
  %24 = select i1 %22, i64 0, i64 %23
  %25 = add i64 %20, %24
  %26 = getelementptr i8, ptr %0, i64 %25
  %27 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %27, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 0
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 0
  %30 = load ptr, ptr %28, align 8
  store ptr %30, ptr %29, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 1
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 1
  %33 = load ptr, ptr %31, align 8
  store ptr %33, ptr %32, align 8
  %34 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 2
  %35 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 2
  %36 = load ptr, ptr %34, align 8
  store ptr %36, ptr %35, align 8
  %37 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 3
  %38 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 3
  %39 = load i32, ptr %37, align 4
  store i32 %39, ptr %38, align 4
  ret void
}

define void @Zipper_init_firstIteratorT_secondIteratorU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) {
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %6, align 8
  %7 = alloca i32, align 4
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = alloca ptr, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %8, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 1
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %9, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 2
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %10, align 8
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  store i32 %18, ptr %7, align 4
  %19 = load ptr, ptr %8, align 8
  %20 = call i32 @get_offset(ptr %19, ptr @Zipper)
  store i32 %20, ptr %7, align 4
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %21, align 8
  %22 = alloca i32, align 4
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = alloca ptr, align 8
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  store ptr %27, ptr %25, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 1
  %29 = load ptr, ptr %28, align 8
  store ptr %29, ptr %24, align 8
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 2
  %31 = load ptr, ptr %30, align 8
  store ptr %31, ptr %23, align 8
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 3
  %33 = load i32, ptr %32, align 4
  store i32 %33, ptr %22, align 4
  %34 = load ptr, ptr %25, align 8
  %35 = call i32 @get_offset(ptr %34, ptr @Iterator)
  store i32 %35, ptr %22, align 4
  %36 = alloca i32, align 4
  %37 = alloca ptr, align 8
  %38 = alloca ptr, align 8
  %39 = alloca ptr, align 8
  %40 = load ptr, ptr %25, align 8
  store ptr %40, ptr %39, align 8
  %41 = load ptr, ptr %24, align 8
  store ptr %41, ptr %38, align 8
  %42 = load ptr, ptr %23, align 8
  store ptr %42, ptr %37, align 8
  %43 = load i32, ptr %22, align 4
  store i32 %43, ptr %36, align 4
  %44 = load ptr, ptr %39, align 8
  %45 = call i32 @get_offset(ptr %44, ptr @Iterator)
  store i32 %45, ptr %36, align 4
  %46 = load ptr, ptr %9, align 8
  %47 = load ptr, ptr %8, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 96, ptr %47)
  %49 = load i32, ptr %7, align 4
  %50 = getelementptr ptr, ptr %47, i32 %49
  %51 = getelementptr ptr, ptr %50, i32 3
  %52 = load ptr, ptr %51, align 8
  %53 = getelementptr { ptr, ptr }, ptr %52, i32 0, i32 1
  %54 = load ptr, ptr %53, align 8
  %55 = load ptr, ptr %39, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %55, 0
  %57 = load ptr, ptr %38, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %57, 1
  %59 = load ptr, ptr %37, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %59, 2
  %61 = load i32, ptr %36, align 4
  %62 = insertvalue { ptr, ptr, ptr, i32 } %60, i32 %61, 3
  call void %54(ptr %46, { ptr, ptr, ptr, i32 } %62) #2
  %63 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %4, ptr %63, align 8
  %64 = alloca i32, align 4
  %65 = alloca ptr, align 8
  %66 = alloca ptr, align 8
  %67 = alloca ptr, align 8
  %68 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 0
  %69 = load ptr, ptr %68, align 8
  store ptr %69, ptr %67, align 8
  %70 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 1
  %71 = load ptr, ptr %70, align 8
  store ptr %71, ptr %66, align 8
  %72 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 2
  %73 = load ptr, ptr %72, align 8
  store ptr %73, ptr %65, align 8
  %74 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 3
  %75 = load i32, ptr %74, align 4
  store i32 %75, ptr %64, align 4
  %76 = load ptr, ptr %67, align 8
  %77 = call i32 @get_offset(ptr %76, ptr @Iterator)
  store i32 %77, ptr %64, align 4
  %78 = alloca i32, align 4
  %79 = alloca ptr, align 8
  %80 = alloca ptr, align 8
  %81 = alloca ptr, align 8
  %82 = load ptr, ptr %67, align 8
  store ptr %82, ptr %81, align 8
  %83 = load ptr, ptr %66, align 8
  store ptr %83, ptr %80, align 8
  %84 = load ptr, ptr %65, align 8
  store ptr %84, ptr %79, align 8
  %85 = load i32, ptr %64, align 4
  store i32 %85, ptr %78, align 4
  %86 = load ptr, ptr %81, align 8
  %87 = call i32 @get_offset(ptr %86, ptr @Iterator)
  store i32 %87, ptr %78, align 4
  %88 = load ptr, ptr %9, align 8
  %89 = load ptr, ptr %8, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 96, ptr %89)
  %91 = load i32, ptr %7, align 4
  %92 = getelementptr ptr, ptr %89, i32 %91
  %93 = getelementptr ptr, ptr %92, i32 4
  %94 = load ptr, ptr %93, align 8
  %95 = getelementptr { ptr, ptr }, ptr %94, i32 0, i32 1
  %96 = load ptr, ptr %95, align 8
  %97 = load ptr, ptr %81, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %97, 0
  %99 = load ptr, ptr %80, align 8
  %100 = insertvalue { ptr, ptr, ptr, i32 } %98, ptr %99, 1
  %101 = load ptr, ptr %79, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } %100, ptr %101, 2
  %103 = load i32, ptr %78, align 4
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, i32 %103, 3
  call void %96(ptr %88, { ptr, ptr, ptr, i32 } %104) #2
  ret void
}

define ptr @Zipper_B_init_firstIteratorT_secondIteratorU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @Iterator, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @Iterator to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 1
  %22 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 2
  %23 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 0
  %24 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 1
  %25 = load i64, ptr %21, align 4
  %26 = load i64, ptr %22, align 4
  %27 = load ptr, ptr %23, align 8
  %28 = load ptr, ptr %24, align 8
  %29 = load i64, ptr @Iterator, align 4
  %30 = call i1 @subtype_test_wrapper(ptr %27, i64 %26, i64 %25, i64 %29, i64 ptrtoint (ptr @Iterator to i64), ptr %28)
  %31 = zext i1 %30 to i8
  store i8 %31, ptr %3, align 1
  store i32 7, ptr %6, align 4
  %32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %33 = load i32, ptr %6, align 4
  %34 = getelementptr [12 x ptr], ptr %32, i32 0, i32 %33
  %35 = getelementptr ptr, ptr %34, i32 10
  %36 = load ptr, ptr %35, align 8
  ret ptr %36
}

define { ptr, i160 } @Zipper_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca i1, align 1
  %5 = alloca [0 x i8], align 1
  %6 = alloca i160, align 8
  %7 = alloca ptr, align 8
  %8 = alloca i160, align 8
  %9 = alloca ptr, align 8
  %10 = alloca i160, align 8
  %11 = alloca ptr, align 8
  %12 = alloca [3 x ptr], align 8
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %14 = alloca i160, align 8
  %15 = alloca ptr, align 8
  %16 = alloca i160, align 8
  %17 = alloca ptr, align 8
  %18 = alloca [2 x ptr], align 8
  %19 = alloca { ptr, ptr }, align 8
  %20 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %20, align 8
  %21 = alloca i32, align 4
  %22 = alloca ptr, align 8
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  store ptr %26, ptr %22, align 8
  %27 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 1
  %28 = load ptr, ptr %27, align 8
  store ptr %28, ptr %23, align 8
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 2
  %30 = load ptr, ptr %29, align 8
  store ptr %30, ptr %24, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 3
  %32 = load i32, ptr %31, align 4
  store i32 %32, ptr %21, align 4
  %33 = load ptr, ptr %22, align 8
  %34 = call i32 @get_offset(ptr %33, ptr @Zipper)
  store i32 %34, ptr %21, align 4
  %35 = load ptr, ptr %23, align 8
  %36 = load ptr, ptr %22, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 96, ptr %36)
  %38 = load i32, ptr %21, align 4
  %39 = getelementptr ptr, ptr %36, i32 %38
  %40 = getelementptr ptr, ptr %39, i32 3
  %41 = load ptr, ptr %40, align 8
  %42 = getelementptr { ptr, ptr }, ptr %41, i32 0, i32 0
  %43 = load ptr, ptr %42, align 8
  %44 = call { ptr, ptr, ptr, i32 } %43(ptr %35) #1
  %45 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %44, ptr %45, align 8
  call void @assume_offset(ptr %45, ptr @Iterator)
  %46 = getelementptr { ptr, ptr, ptr, i32 }, ptr %45, i32 0, i32 0
  %47 = load ptr, ptr %46, align 8
  %48 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %47, 0
  %49 = getelementptr { ptr, ptr, ptr, i32 }, ptr %45, i32 0, i32 1
  %50 = load ptr, ptr %49, align 8
  %51 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %50, 1
  %52 = getelementptr { ptr, ptr, ptr, i32 }, ptr %45, i32 0, i32 2
  %53 = load ptr, ptr %52, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } %51, ptr %53, 2
  %55 = getelementptr { ptr, ptr, ptr, i32 }, ptr %45, i32 0, i32 3
  %56 = load i32, ptr %55, align 4
  %57 = insertvalue { ptr, ptr, ptr, i32 } %54, i32 %56, 3
  %58 = alloca [0 x ptr], align 8
  %59 = call ptr @llvm.invariant.start.p0(i64 0, ptr %58)
  %60 = call ptr @llvm.invariant.start.p0(i64 24, ptr %47)
  %61 = getelementptr ptr, ptr %47, i32 %56
  %62 = getelementptr ptr, ptr %61, i32 1
  %63 = load ptr, ptr %62, align 8
  %64 = alloca {}, align 8
  %65 = call ptr @behavior_wrapper(ptr %63, { ptr, ptr, ptr, i32 } %57, ptr %64)
  %66 = call { ptr, i160 } %65({ ptr, ptr, ptr, i32 } %57, { ptr, ptr, ptr, i32 } %57, ptr %58)
  %67 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %66, ptr %67, align 8
  %68 = load ptr, ptr %23, align 8
  %69 = load ptr, ptr %22, align 8
  %70 = call ptr @llvm.invariant.start.p0(i64 96, ptr %69)
  %71 = load i32, ptr %21, align 4
  %72 = getelementptr ptr, ptr %69, i32 %71
  %73 = getelementptr ptr, ptr %72, i32 4
  %74 = load ptr, ptr %73, align 8
  %75 = getelementptr { ptr, ptr }, ptr %74, i32 0, i32 0
  %76 = load ptr, ptr %75, align 8
  %77 = call { ptr, ptr, ptr, i32 } %76(ptr %68) #1
  %78 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %77, ptr %78, align 8
  call void @assume_offset(ptr %78, ptr @Iterator)
  %79 = getelementptr { ptr, ptr, ptr, i32 }, ptr %78, i32 0, i32 0
  %80 = load ptr, ptr %79, align 8
  %81 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %80, 0
  %82 = getelementptr { ptr, ptr, ptr, i32 }, ptr %78, i32 0, i32 1
  %83 = load ptr, ptr %82, align 8
  %84 = insertvalue { ptr, ptr, ptr, i32 } %81, ptr %83, 1
  %85 = getelementptr { ptr, ptr, ptr, i32 }, ptr %78, i32 0, i32 2
  %86 = load ptr, ptr %85, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } %84, ptr %86, 2
  %88 = getelementptr { ptr, ptr, ptr, i32 }, ptr %78, i32 0, i32 3
  %89 = load i32, ptr %88, align 4
  %90 = insertvalue { ptr, ptr, ptr, i32 } %87, i32 %89, 3
  %91 = alloca [0 x ptr], align 8
  %92 = call ptr @llvm.invariant.start.p0(i64 0, ptr %91)
  %93 = call ptr @llvm.invariant.start.p0(i64 24, ptr %80)
  %94 = getelementptr ptr, ptr %80, i32 %89
  %95 = getelementptr ptr, ptr %94, i32 1
  %96 = load ptr, ptr %95, align 8
  %97 = alloca {}, align 8
  %98 = call ptr @behavior_wrapper(ptr %96, { ptr, ptr, ptr, i32 } %90, ptr %97)
  %99 = call { ptr, i160 } %98({ ptr, ptr, ptr, i32 } %90, { ptr, ptr, ptr, i32 } %90, ptr %91)
  %100 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %99, ptr %100, align 8
  %101 = load ptr, ptr %67, align 8
  %102 = ptrtoint ptr %101 to i64
  %103 = icmp eq i64 %102, ptrtoint (ptr @nil_typ to i64)
  %104 = icmp eq i64 %102, 0
  %105 = or i1 %103, %104
  %106 = alloca i1, align 1
  %107 = zext i1 %105 to i8
  store i8 %107, ptr %106, align 1
  %108 = alloca i1, align 1
  %109 = load i8, ptr %106, align 1
  %110 = trunc i8 %109 to i1
  %111 = zext i1 %110 to i8
  store i8 %111, ptr %108, align 1
  br i1 %110, label %112, label %113

112:                                              ; preds = %3
  br label %123

113:                                              ; preds = %3
  %114 = load ptr, ptr %100, align 8
  %115 = ptrtoint ptr %114 to i64
  %116 = icmp eq i64 %115, ptrtoint (ptr @nil_typ to i64)
  %117 = icmp eq i64 %115, 0
  %118 = or i1 %116, %117
  %119 = zext i1 %118 to i8
  store i8 %119, ptr %4, align 1
  %120 = load i8, ptr %4, align 1
  %121 = trunc i8 %120 to i1
  %122 = zext i1 %121 to i8
  store i8 %122, ptr %108, align 1
  br label %123

123:                                              ; preds = %112, %113
  %124 = load i8, ptr %108, align 1
  %125 = trunc i8 %124 to i1
  br i1 %125, label %126, label %132

126:                                              ; preds = %123
  %127 = load [0 x i8], ptr %5, align 1
  store [0 x i8] %127, ptr %6, align 1
  store ptr @nil_typ, ptr %7, align 8
  %128 = load ptr, ptr %7, align 8
  %129 = insertvalue { ptr, i160 } undef, ptr %128, 0
  %130 = load i160, ptr %6, align 4
  %131 = insertvalue { ptr, i160 } %129, i160 %130, 1
  br label %221

132:                                              ; preds = %123
  %133 = getelementptr { ptr, i160 }, ptr %67, i32 0, i32 0
  %134 = load ptr, ptr %133, align 8
  store ptr %134, ptr %9, align 8
  %135 = getelementptr { ptr, i160 }, ptr %67, i32 0, i32 1
  %136 = load i160, ptr %135, align 4
  store i160 %136, ptr %8, align 4
  %137 = getelementptr { ptr, i160 }, ptr %100, i32 0, i32 0
  %138 = load ptr, ptr %137, align 8
  store ptr %138, ptr %11, align 8
  %139 = getelementptr { ptr, i160 }, ptr %100, i32 0, i32 1
  %140 = load i160, ptr %139, align 4
  store i160 %140, ptr %10, align 4
  %141 = load ptr, ptr %23, align 8
  %142 = load ptr, ptr %22, align 8
  %143 = call ptr @llvm.invariant.start.p0(i64 96, ptr %142)
  %144 = load i32, ptr %21, align 4
  %145 = getelementptr ptr, ptr %142, i32 %144
  %146 = load ptr, ptr %145, align 8
  %147 = call ptr @typegetter_wrapper(ptr %146, ptr %141)
  %148 = load ptr, ptr %23, align 8
  %149 = load ptr, ptr %22, align 8
  %150 = call ptr @llvm.invariant.start.p0(i64 96, ptr %149)
  %151 = load i32, ptr %21, align 4
  %152 = getelementptr ptr, ptr %149, i32 %151
  %153 = getelementptr ptr, ptr %152, i32 1
  %154 = load ptr, ptr %153, align 8
  %155 = call ptr @typegetter_wrapper(ptr %154, ptr %148)
  store ptr @Pair, ptr %12, align 8
  %156 = getelementptr ptr, ptr %12, i32 1
  store ptr %147, ptr %156, align 8
  %157 = getelementptr ptr, ptr %12, i32 2
  store ptr %155, ptr %157, align 8
  %158 = load ptr, ptr %12, align 8
  %159 = getelementptr ptr, ptr %158, i32 6
  %160 = load ptr, ptr %159, align 8
  %161 = call { i64, i64 } @size_wrapper(ptr %160, ptr %12)
  %162 = extractvalue { i64, i64 } %161, 0
  %163 = call ptr @bump_malloc(i64 %162)
  store ptr %147, ptr %163, align 8
  %164 = getelementptr ptr, ptr %163, i32 1
  store ptr %155, ptr %164, align 8
  %165 = call ptr @llvm.invariant.start.p0(i64 16, ptr %163)
  %166 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 1
  %167 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 3
  store ptr @Pair, ptr %13, align 8
  store ptr %163, ptr %166, align 8
  store i32 10, ptr %167, align 4
  %168 = load ptr, ptr %9, align 8
  store ptr %168, ptr %15, align 8
  %169 = load i160, ptr %8, align 4
  store i160 %169, ptr %14, align 4
  %170 = load ptr, ptr %15, align 8
  %171 = insertvalue { ptr, i160 } undef, ptr %170, 0
  %172 = load i160, ptr %14, align 4
  %173 = insertvalue { ptr, i160 } %171, i160 %172, 1
  %174 = load ptr, ptr %11, align 8
  store ptr %174, ptr %17, align 8
  %175 = load i160, ptr %10, align 4
  store i160 %175, ptr %16, align 4
  %176 = load ptr, ptr %17, align 8
  %177 = insertvalue { ptr, i160 } undef, ptr %176, 0
  %178 = load i160, ptr %16, align 4
  %179 = insertvalue { ptr, i160 } %177, i160 %178, 1
  %180 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 0
  %181 = load ptr, ptr %180, align 8
  %182 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %181, 0
  %183 = load ptr, ptr %166, align 8
  %184 = insertvalue { ptr, ptr, ptr, i32 } %182, ptr %183, 1
  %185 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 2
  %186 = load ptr, ptr %185, align 8
  %187 = insertvalue { ptr, ptr, ptr, i32 } %184, ptr %186, 2
  %188 = load i32, ptr %167, align 4
  %189 = insertvalue { ptr, ptr, ptr, i32 } %187, i32 %188, 3
  %190 = load ptr, ptr %23, align 8
  %191 = load ptr, ptr %22, align 8
  %192 = call ptr @llvm.invariant.start.p0(i64 96, ptr %191)
  %193 = load i32, ptr %21, align 4
  %194 = getelementptr ptr, ptr %191, i32 %193
  %195 = load ptr, ptr %194, align 8
  %196 = call ptr @typegetter_wrapper(ptr %195, ptr %190)
  %197 = load ptr, ptr %23, align 8
  %198 = load ptr, ptr %22, align 8
  %199 = call ptr @llvm.invariant.start.p0(i64 96, ptr %198)
  %200 = load i32, ptr %21, align 4
  %201 = getelementptr ptr, ptr %198, i32 %200
  %202 = getelementptr ptr, ptr %201, i32 1
  %203 = load ptr, ptr %202, align 8
  %204 = call ptr @typegetter_wrapper(ptr %203, ptr %197)
  %205 = getelementptr [2 x ptr], ptr %18, i32 0, i32 0
  store ptr %196, ptr %205, align 8
  %206 = getelementptr [2 x ptr], ptr %18, i32 0, i32 1
  store ptr %204, ptr %206, align 8
  %207 = call ptr @llvm.invariant.start.p0(i64 4, ptr %18)
  %208 = call ptr @llvm.invariant.start.p0(i64 112, ptr %181)
  %209 = getelementptr ptr, ptr %181, i32 %188
  %210 = getelementptr ptr, ptr %209, i32 8
  %211 = load ptr, ptr %210, align 8
  %212 = getelementptr { ptr, ptr }, ptr %19, i32 0, i32 0
  store ptr %170, ptr %212, align 8
  %213 = getelementptr { ptr, ptr }, ptr %19, i32 0, i32 1
  store ptr %176, ptr %213, align 8
  %214 = call ptr @behavior_wrapper(ptr %211, { ptr, ptr, ptr, i32 } %189, ptr %19)
  call void %214({ ptr, ptr, ptr, i32 } %189, { ptr, ptr, ptr, i32 } %189, ptr %18, { ptr, i160 } %173, { ptr, i160 } %179)
  %215 = getelementptr { ptr, i160 }, ptr %13, i32 0, i32 0
  %216 = load ptr, ptr %215, align 8
  %217 = insertvalue { ptr, i160 } undef, ptr %216, 0
  %218 = getelementptr { ptr, i160 }, ptr %13, i32 0, i32 1
  %219 = load i160, ptr %218, align 4
  %220 = insertvalue { ptr, i160 } %217, i160 %219, 1
  br label %221

221:                                              ; preds = %126, %132
  %222 = phi { ptr, i160 } [ %220, %132 ], [ %131, %126 ]
  br label %223

223:                                              ; preds = %221
  ret { ptr, i160 } %222
}

define ptr @Zipper_B_next_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 8, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [12 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { i64, i64 } @_data_size_Products(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %10
  %12 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %5
  %13 = select i1 %12, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 %5
  %14 = urem i64 %11, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %17
  %19 = add i64 %11, %18
  %20 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %13
  %21 = select i1 %20, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %13
  %22 = urem i64 %19, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %23 = icmp eq i64 %22, 0
  %24 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %22
  %25 = select i1 %23, i64 0, i64 %24
  %26 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %25
  %27 = add i64 %19, %26
  %28 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %21
  %29 = select i1 %28, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %21
  %30 = urem i64 %27, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %31 = icmp eq i64 %30, 0
  %32 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %30
  %33 = select i1 %31, i64 0, i64 %32
  %34 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %33
  %35 = add i64 %27, %34
  %36 = urem i64 %35, %29
  %37 = icmp eq i64 %36, 0
  %38 = sub i64 %29, %36
  %39 = select i1 %37, i64 0, i64 %38
  %40 = add i64 %35, %39
  %41 = insertvalue { i64, i64 } undef, i64 %40, 0
  %42 = insertvalue { i64, i64 } %41, i64 %29, 1
  ret { i64, i64 } %42
}

define ptr @Products_field_Products_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define ptr @Products_field_Products_1(ptr %0) {
  %2 = getelementptr ptr, ptr %0, i32 1
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

define ptr @Products_field_Products_2(ptr %0) {
  %2 = getelementptr ptr, ptr %0, i32 2
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

define { ptr, ptr, ptr, i32 } @Products_getter_first(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %11
  %13 = add i64 %7, %12
  %14 = urem i64 %13, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 %13, %17
  %19 = getelementptr i8, ptr %0, i64 %18
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 0
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %21, 0
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 1
  %24 = load ptr, ptr %23, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %24, 1
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 2
  %27 = load ptr, ptr %26, align 8
  %28 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %27, 2
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 3
  %30 = load i32, ptr %29, align 4
  %31 = insertvalue { ptr, ptr, ptr, i32 } %28, i32 %30, 3
  ret { ptr, ptr, ptr, i32 } %31
}

define void @Products_setter_first(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %12
  %14 = add i64 %8, %13
  %15 = urem i64 %14, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %16 = icmp eq i64 %15, 0
  %17 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add i64 %14, %18
  %20 = getelementptr i8, ptr %0, i64 %19
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %21, align 8
  %22 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 0
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 0
  %24 = load ptr, ptr %22, align 8
  store ptr %24, ptr %23, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 1
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 1
  %27 = load ptr, ptr %25, align 8
  store ptr %27, ptr %26, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 2
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 2
  %30 = load ptr, ptr %28, align 8
  store ptr %30, ptr %29, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 3
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 3
  %33 = load i32, ptr %31, align 4
  store i32 %33, ptr %32, align 4
  ret void
}

define { ptr, ptr, ptr, i32 } @Products_getter_second(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %11
  %13 = add i64 %7, %12
  %14 = urem i64 %13, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %17
  %19 = add i64 %13, %18
  %20 = urem i64 %19, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = add i64 %19, %23
  %25 = getelementptr i8, ptr %0, i64 %24
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %27, 0
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 1
  %30 = load ptr, ptr %29, align 8
  %31 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %30, 1
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 2
  %33 = load ptr, ptr %32, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %33, 2
  %35 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 3
  %36 = load i32, ptr %35, align 4
  %37 = insertvalue { ptr, ptr, ptr, i32 } %34, i32 %36, 3
  ret { ptr, ptr, ptr, i32 } %37
}

define void @Products_setter_second(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %12
  %14 = add i64 %8, %13
  %15 = urem i64 %14, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %16 = icmp eq i64 %15, 0
  %17 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %18
  %20 = add i64 %14, %19
  %21 = urem i64 %20, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %22 = icmp eq i64 %21, 0
  %23 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %21
  %24 = select i1 %22, i64 0, i64 %23
  %25 = add i64 %20, %24
  %26 = getelementptr i8, ptr %0, i64 %25
  %27 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %27, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 0
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 0
  %30 = load ptr, ptr %28, align 8
  store ptr %30, ptr %29, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 1
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 1
  %33 = load ptr, ptr %31, align 8
  store ptr %33, ptr %32, align 8
  %34 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 2
  %35 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 2
  %36 = load ptr, ptr %34, align 8
  store ptr %36, ptr %35, align 8
  %37 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 3
  %38 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 3
  %39 = load i32, ptr %37, align 4
  store i32 %39, ptr %38, align 4
  ret void
}

define void @Products_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) {
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %6, align 8
  %7 = alloca i32, align 4
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = alloca ptr, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %8, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 1
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %9, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 2
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %10, align 8
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  store i32 %18, ptr %7, align 4
  %19 = load ptr, ptr %8, align 8
  %20 = call i32 @get_offset(ptr %19, ptr @Products)
  store i32 %20, ptr %7, align 4
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %21, align 8
  %22 = alloca i32, align 4
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = alloca ptr, align 8
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  store ptr %27, ptr %25, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 1
  %29 = load ptr, ptr %28, align 8
  store ptr %29, ptr %24, align 8
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 2
  %31 = load ptr, ptr %30, align 8
  store ptr %31, ptr %23, align 8
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 3
  %33 = load i32, ptr %32, align 4
  store i32 %33, ptr %22, align 4
  %34 = load ptr, ptr %25, align 8
  %35 = call i32 @get_offset(ptr %34, ptr @Iterable)
  store i32 %35, ptr %22, align 4
  %36 = alloca i32, align 4
  %37 = alloca ptr, align 8
  %38 = alloca ptr, align 8
  %39 = alloca ptr, align 8
  %40 = load ptr, ptr %25, align 8
  store ptr %40, ptr %39, align 8
  %41 = load ptr, ptr %24, align 8
  store ptr %41, ptr %38, align 8
  %42 = load ptr, ptr %23, align 8
  store ptr %42, ptr %37, align 8
  %43 = load i32, ptr %22, align 4
  store i32 %43, ptr %36, align 4
  %44 = load ptr, ptr %39, align 8
  %45 = call i32 @get_offset(ptr %44, ptr @Iterable)
  store i32 %45, ptr %36, align 4
  %46 = load ptr, ptr %9, align 8
  %47 = load ptr, ptr %8, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 448, ptr %47)
  %49 = load i32, ptr %7, align 4
  %50 = getelementptr ptr, ptr %47, i32 %49
  %51 = getelementptr ptr, ptr %50, i32 3
  %52 = load ptr, ptr %51, align 8
  %53 = getelementptr { ptr, ptr }, ptr %52, i32 0, i32 1
  %54 = load ptr, ptr %53, align 8
  %55 = load ptr, ptr %39, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %55, 0
  %57 = load ptr, ptr %38, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %57, 1
  %59 = load ptr, ptr %37, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %59, 2
  %61 = load i32, ptr %36, align 4
  %62 = insertvalue { ptr, ptr, ptr, i32 } %60, i32 %61, 3
  call void %54(ptr %46, { ptr, ptr, ptr, i32 } %62) #2
  %63 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %4, ptr %63, align 8
  %64 = alloca i32, align 4
  %65 = alloca ptr, align 8
  %66 = alloca ptr, align 8
  %67 = alloca ptr, align 8
  %68 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 0
  %69 = load ptr, ptr %68, align 8
  store ptr %69, ptr %67, align 8
  %70 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 1
  %71 = load ptr, ptr %70, align 8
  store ptr %71, ptr %66, align 8
  %72 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 2
  %73 = load ptr, ptr %72, align 8
  store ptr %73, ptr %65, align 8
  %74 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 3
  %75 = load i32, ptr %74, align 4
  store i32 %75, ptr %64, align 4
  %76 = load ptr, ptr %67, align 8
  %77 = call i32 @get_offset(ptr %76, ptr @Iterable)
  store i32 %77, ptr %64, align 4
  %78 = alloca i32, align 4
  %79 = alloca ptr, align 8
  %80 = alloca ptr, align 8
  %81 = alloca ptr, align 8
  %82 = load ptr, ptr %67, align 8
  store ptr %82, ptr %81, align 8
  %83 = load ptr, ptr %66, align 8
  store ptr %83, ptr %80, align 8
  %84 = load ptr, ptr %65, align 8
  store ptr %84, ptr %79, align 8
  %85 = load i32, ptr %64, align 4
  store i32 %85, ptr %78, align 4
  %86 = load ptr, ptr %81, align 8
  %87 = call i32 @get_offset(ptr %86, ptr @Iterable)
  store i32 %87, ptr %78, align 4
  %88 = load ptr, ptr %9, align 8
  %89 = load ptr, ptr %8, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 448, ptr %89)
  %91 = load i32, ptr %7, align 4
  %92 = getelementptr ptr, ptr %89, i32 %91
  %93 = getelementptr ptr, ptr %92, i32 4
  %94 = load ptr, ptr %93, align 8
  %95 = getelementptr { ptr, ptr }, ptr %94, i32 0, i32 1
  %96 = load ptr, ptr %95, align 8
  %97 = load ptr, ptr %81, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %97, 0
  %99 = load ptr, ptr %80, align 8
  %100 = insertvalue { ptr, ptr, ptr, i32 } %98, ptr %99, 1
  %101 = load ptr, ptr %79, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } %100, ptr %101, 2
  %103 = load i32, ptr %78, align 4
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, i32 %103, 3
  call void %96(ptr %88, { ptr, ptr, ptr, i32 } %104) #2
  ret void
}

define ptr @Products_B_init_firstIterableT_secondIterableU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @Iterable, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @Iterable to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 1
  %22 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 2
  %23 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 0
  %24 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 1
  %25 = load i64, ptr %21, align 4
  %26 = load i64, ptr %22, align 4
  %27 = load ptr, ptr %23, align 8
  %28 = load ptr, ptr %24, align 8
  %29 = load i64, ptr @Iterable, align 4
  %30 = call i1 @subtype_test_wrapper(ptr %27, i64 %26, i64 %25, i64 %29, i64 ptrtoint (ptr @Iterable to i64), ptr %28)
  %31 = zext i1 %30 to i8
  store i8 %31, ptr %3, align 1
  store i32 18, ptr %6, align 4
  %32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %33 = load i32, ptr %6, align 4
  %34 = getelementptr [56 x ptr], ptr %32, i32 0, i32 %33
  %35 = getelementptr ptr, ptr %34, i32 10
  %36 = load ptr, ptr %35, align 8
  ret ptr %36
}

define { ptr, ptr, ptr, i32 } @Products_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @Products)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 448, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 3
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr { ptr, ptr }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = call { ptr, ptr, ptr, i32 } %27(ptr %19) #1
  %29 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %28, ptr %29, align 8
  call void @assume_offset(ptr %29, ptr @Iterable)
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 1
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %34, 1
  %36 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 2
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %37, 2
  %39 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 3
  %40 = load i32, ptr %39, align 4
  %41 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %40, 3
  %42 = alloca [0 x ptr], align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 0, ptr %42)
  %44 = call ptr @llvm.invariant.start.p0(i64 200, ptr %31)
  %45 = getelementptr ptr, ptr %31, i32 %40
  %46 = getelementptr ptr, ptr %45, i32 1
  %47 = load ptr, ptr %46, align 8
  %48 = alloca {}, align 8
  %49 = call ptr @behavior_wrapper(ptr %47, { ptr, ptr, ptr, i32 } %41, ptr %48)
  %50 = call { ptr, ptr, ptr, i32 } %49({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr %42)
  %51 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %50, ptr %51, align 8
  %52 = alloca i32, align 4
  %53 = alloca ptr, align 8
  %54 = alloca ptr, align 8
  %55 = alloca ptr, align 8
  %56 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 0
  %57 = load ptr, ptr %56, align 8
  store ptr %57, ptr %53, align 8
  %58 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 1
  %59 = load ptr, ptr %58, align 8
  store ptr %59, ptr %55, align 8
  %60 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 2
  %61 = load ptr, ptr %60, align 8
  store ptr %61, ptr %54, align 8
  %62 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 3
  %63 = load i32, ptr %62, align 4
  store i32 %63, ptr %52, align 4
  %64 = load ptr, ptr %53, align 8
  %65 = call i32 @get_offset(ptr %64, ptr @Iterator)
  store i32 %65, ptr %52, align 4
  %66 = load ptr, ptr %7, align 8
  %67 = load ptr, ptr %6, align 8
  %68 = call ptr @llvm.invariant.start.p0(i64 448, ptr %67)
  %69 = load i32, ptr %5, align 4
  %70 = getelementptr ptr, ptr %67, i32 %69
  %71 = getelementptr ptr, ptr %70, i32 4
  %72 = load ptr, ptr %71, align 8
  %73 = getelementptr { ptr, ptr }, ptr %72, i32 0, i32 0
  %74 = load ptr, ptr %73, align 8
  %75 = call { ptr, ptr, ptr, i32 } %74(ptr %66) #1
  %76 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %75, ptr %76, align 8
  call void @assume_offset(ptr %76, ptr @Iterable)
  %77 = load ptr, ptr %7, align 8
  %78 = load ptr, ptr %6, align 8
  %79 = call ptr @llvm.invariant.start.p0(i64 448, ptr %78)
  %80 = load i32, ptr %5, align 4
  %81 = getelementptr ptr, ptr %78, i32 %80
  %82 = load ptr, ptr %81, align 8
  %83 = call ptr @typegetter_wrapper(ptr %82, ptr %77)
  %84 = load ptr, ptr %7, align 8
  %85 = load ptr, ptr %6, align 8
  %86 = call ptr @llvm.invariant.start.p0(i64 448, ptr %85)
  %87 = load i32, ptr %5, align 4
  %88 = getelementptr ptr, ptr %85, i32 %87
  %89 = getelementptr ptr, ptr %88, i32 1
  %90 = load ptr, ptr %89, align 8
  %91 = call ptr @typegetter_wrapper(ptr %90, ptr %84)
  %92 = load ptr, ptr %7, align 8
  %93 = load ptr, ptr %6, align 8
  %94 = call ptr @llvm.invariant.start.p0(i64 448, ptr %93)
  %95 = load i32, ptr %5, align 4
  %96 = getelementptr ptr, ptr %93, i32 %95
  %97 = load ptr, ptr %96, align 8
  %98 = call ptr @typegetter_wrapper(ptr %97, ptr %92)
  %99 = load ptr, ptr %7, align 8
  %100 = load ptr, ptr %6, align 8
  %101 = call ptr @llvm.invariant.start.p0(i64 448, ptr %100)
  %102 = load i32, ptr %5, align 4
  %103 = getelementptr ptr, ptr %100, i32 %102
  %104 = getelementptr ptr, ptr %103, i32 1
  %105 = load ptr, ptr %104, align 8
  %106 = call ptr @typegetter_wrapper(ptr %105, ptr %99)
  %107 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([4 x ptr], ptr null, i32 1) to i64))
  %108 = getelementptr [4 x ptr], ptr %107, i32 0, i32 2
  store ptr %106, ptr %108, align 8
  %109 = getelementptr [4 x ptr], ptr %107, i32 0, i32 1
  store ptr %98, ptr %109, align 8
  %110 = getelementptr [4 x ptr], ptr %107, i32 0, i32 3
  store ptr null, ptr %110, align 8
  %111 = call ptr @llvm.invariant.start.p0(i64 24, ptr %107)
  store ptr @Pair, ptr %107, align 8
  %112 = alloca [4 x ptr], align 8
  store ptr @Productizer, ptr %112, align 8
  %113 = getelementptr ptr, ptr %112, i32 1
  store ptr %83, ptr %113, align 8
  %114 = getelementptr ptr, ptr %112, i32 2
  store ptr %91, ptr %114, align 8
  %115 = getelementptr ptr, ptr %112, i32 3
  store ptr %107, ptr %115, align 8
  %116 = load ptr, ptr %112, align 8
  %117 = getelementptr ptr, ptr %116, i32 6
  %118 = load ptr, ptr %117, align 8
  %119 = call { i64, i64 } @size_wrapper(ptr %118, ptr %112)
  %120 = extractvalue { i64, i64 } %119, 0
  %121 = call ptr @bump_malloc(i64 %120)
  store ptr %83, ptr %121, align 8
  %122 = getelementptr ptr, ptr %121, i32 1
  store ptr %91, ptr %122, align 8
  %123 = getelementptr ptr, ptr %121, i32 2
  store ptr %107, ptr %123, align 8
  %124 = call ptr @llvm.invariant.start.p0(i64 24, ptr %121)
  %125 = alloca i32, align 4
  %126 = alloca ptr, align 8
  %127 = alloca ptr, align 8
  %128 = alloca ptr, align 8
  store ptr @Productizer, ptr %128, align 8
  store ptr %121, ptr %127, align 8
  store i32 10, ptr %125, align 4
  %129 = load ptr, ptr %7, align 8
  %130 = load ptr, ptr %6, align 8
  %131 = call ptr @llvm.invariant.start.p0(i64 448, ptr %130)
  %132 = load i32, ptr %5, align 4
  %133 = getelementptr ptr, ptr %130, i32 %132
  %134 = getelementptr ptr, ptr %133, i32 3
  %135 = load ptr, ptr %134, align 8
  %136 = getelementptr { ptr, ptr }, ptr %135, i32 0, i32 0
  %137 = load ptr, ptr %136, align 8
  %138 = call { ptr, ptr, ptr, i32 } %137(ptr %129) #1
  %139 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %138, ptr %139, align 8
  call void @assume_offset(ptr %139, ptr @Iterable)
  %140 = getelementptr { ptr, ptr, ptr, i32 }, ptr %139, i32 0, i32 0
  %141 = load ptr, ptr %140, align 8
  %142 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %141, 0
  %143 = getelementptr { ptr, ptr, ptr, i32 }, ptr %139, i32 0, i32 1
  %144 = load ptr, ptr %143, align 8
  %145 = insertvalue { ptr, ptr, ptr, i32 } %142, ptr %144, 1
  %146 = getelementptr { ptr, ptr, ptr, i32 }, ptr %139, i32 0, i32 2
  %147 = load ptr, ptr %146, align 8
  %148 = insertvalue { ptr, ptr, ptr, i32 } %145, ptr %147, 2
  %149 = getelementptr { ptr, ptr, ptr, i32 }, ptr %139, i32 0, i32 3
  %150 = load i32, ptr %149, align 4
  %151 = insertvalue { ptr, ptr, ptr, i32 } %148, i32 %150, 3
  %152 = alloca [0 x ptr], align 8
  %153 = call ptr @llvm.invariant.start.p0(i64 0, ptr %152)
  %154 = call ptr @llvm.invariant.start.p0(i64 200, ptr %141)
  %155 = getelementptr ptr, ptr %141, i32 %150
  %156 = getelementptr ptr, ptr %155, i32 1
  %157 = load ptr, ptr %156, align 8
  %158 = alloca {}, align 8
  %159 = call ptr @behavior_wrapper(ptr %157, { ptr, ptr, ptr, i32 } %151, ptr %158)
  %160 = call { ptr, ptr, ptr, i32 } %159({ ptr, ptr, ptr, i32 } %151, { ptr, ptr, ptr, i32 } %151, ptr %152)
  %161 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %160, ptr %161, align 8
  %162 = alloca i32, align 4
  %163 = alloca ptr, align 8
  %164 = alloca ptr, align 8
  %165 = alloca ptr, align 8
  %166 = getelementptr { ptr, ptr, ptr, i32 }, ptr %161, i32 0, i32 0
  %167 = load ptr, ptr %166, align 8
  store ptr %167, ptr %165, align 8
  %168 = getelementptr { ptr, ptr, ptr, i32 }, ptr %161, i32 0, i32 1
  %169 = load ptr, ptr %168, align 8
  store ptr %169, ptr %164, align 8
  %170 = getelementptr { ptr, ptr, ptr, i32 }, ptr %161, i32 0, i32 2
  %171 = load ptr, ptr %170, align 8
  store ptr %171, ptr %163, align 8
  %172 = getelementptr { ptr, ptr, ptr, i32 }, ptr %161, i32 0, i32 3
  %173 = load i32, ptr %172, align 4
  store i32 %173, ptr %162, align 4
  %174 = load ptr, ptr %165, align 8
  %175 = call i32 @get_offset(ptr %174, ptr @Iterator)
  store i32 %175, ptr %162, align 4
  %176 = load ptr, ptr %7, align 8
  %177 = load ptr, ptr %6, align 8
  %178 = call ptr @llvm.invariant.start.p0(i64 448, ptr %177)
  %179 = load i32, ptr %5, align 4
  %180 = getelementptr ptr, ptr %177, i32 %179
  %181 = getelementptr ptr, ptr %180, i32 4
  %182 = load ptr, ptr %181, align 8
  %183 = getelementptr { ptr, ptr }, ptr %182, i32 0, i32 0
  %184 = load ptr, ptr %183, align 8
  %185 = call { ptr, ptr, ptr, i32 } %184(ptr %176) #1
  %186 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %185, ptr %186, align 8
  call void @assume_offset(ptr %186, ptr @Iterable)
  %187 = alloca i32, align 4
  %188 = alloca ptr, align 8
  %189 = alloca ptr, align 8
  %190 = alloca ptr, align 8
  %191 = load ptr, ptr %165, align 8
  store ptr %191, ptr %190, align 8
  %192 = load ptr, ptr %164, align 8
  store ptr %192, ptr %189, align 8
  %193 = load ptr, ptr %163, align 8
  store ptr %193, ptr %188, align 8
  %194 = load i32, ptr %162, align 4
  store i32 %194, ptr %187, align 4
  %195 = load ptr, ptr %190, align 8
  %196 = call i32 @get_offset(ptr %195, ptr @Iterator)
  store i32 %196, ptr %187, align 4
  %197 = load ptr, ptr %190, align 8
  %198 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %197, 0
  %199 = load ptr, ptr %189, align 8
  %200 = insertvalue { ptr, ptr, ptr, i32 } %198, ptr %199, 1
  %201 = load ptr, ptr %188, align 8
  %202 = insertvalue { ptr, ptr, ptr, i32 } %200, ptr %201, 2
  %203 = load i32, ptr %187, align 4
  %204 = insertvalue { ptr, ptr, ptr, i32 } %202, i32 %203, 3
  %205 = alloca i32, align 4
  %206 = alloca ptr, align 8
  %207 = alloca ptr, align 8
  %208 = alloca ptr, align 8
  %209 = getelementptr { ptr, ptr, ptr, i32 }, ptr %186, i32 0, i32 0
  %210 = load ptr, ptr %209, align 8
  store ptr %210, ptr %208, align 8
  %211 = getelementptr { ptr, ptr, ptr, i32 }, ptr %186, i32 0, i32 1
  %212 = load ptr, ptr %211, align 8
  store ptr %212, ptr %207, align 8
  %213 = getelementptr { ptr, ptr, ptr, i32 }, ptr %186, i32 0, i32 2
  %214 = load ptr, ptr %213, align 8
  store ptr %214, ptr %206, align 8
  %215 = getelementptr { ptr, ptr, ptr, i32 }, ptr %186, i32 0, i32 3
  %216 = load i32, ptr %215, align 4
  store i32 %216, ptr %205, align 4
  %217 = load ptr, ptr %208, align 8
  %218 = call i32 @get_offset(ptr %217, ptr @Iterable)
  store i32 %218, ptr %205, align 4
  %219 = load ptr, ptr %208, align 8
  %220 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %219, 0
  %221 = load ptr, ptr %207, align 8
  %222 = insertvalue { ptr, ptr, ptr, i32 } %220, ptr %221, 1
  %223 = load ptr, ptr %206, align 8
  %224 = insertvalue { ptr, ptr, ptr, i32 } %222, ptr %223, 2
  %225 = load i32, ptr %205, align 4
  %226 = insertvalue { ptr, ptr, ptr, i32 } %224, i32 %225, 3
  %227 = load ptr, ptr %128, align 8
  %228 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %227, 0
  %229 = load ptr, ptr %127, align 8
  %230 = insertvalue { ptr, ptr, ptr, i32 } %228, ptr %229, 1
  %231 = load ptr, ptr %126, align 8
  %232 = insertvalue { ptr, ptr, ptr, i32 } %230, ptr %231, 2
  %233 = load i32, ptr %125, align 4
  %234 = insertvalue { ptr, ptr, ptr, i32 } %232, i32 %233, 3
  %235 = load ptr, ptr %7, align 8
  %236 = load ptr, ptr %6, align 8
  %237 = call ptr @llvm.invariant.start.p0(i64 448, ptr %236)
  %238 = load i32, ptr %5, align 4
  %239 = getelementptr ptr, ptr %236, i32 %238
  %240 = load ptr, ptr %239, align 8
  %241 = call ptr @typegetter_wrapper(ptr %240, ptr %235)
  %242 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %243 = getelementptr [3 x ptr], ptr %242, i32 0, i32 1
  store ptr %241, ptr %243, align 8
  %244 = getelementptr [3 x ptr], ptr %242, i32 0, i32 2
  store ptr null, ptr %244, align 8
  %245 = call ptr @llvm.invariant.start.p0(i64 16, ptr %242)
  store ptr @Iterator, ptr %242, align 8
  %246 = load ptr, ptr %7, align 8
  %247 = load ptr, ptr %6, align 8
  %248 = call ptr @llvm.invariant.start.p0(i64 448, ptr %247)
  %249 = load i32, ptr %5, align 4
  %250 = getelementptr ptr, ptr %247, i32 %249
  %251 = getelementptr ptr, ptr %250, i32 1
  %252 = load ptr, ptr %251, align 8
  %253 = call ptr @typegetter_wrapper(ptr %252, ptr %246)
  %254 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %255 = getelementptr [3 x ptr], ptr %254, i32 0, i32 1
  store ptr %253, ptr %255, align 8
  %256 = getelementptr [3 x ptr], ptr %254, i32 0, i32 2
  store ptr null, ptr %256, align 8
  %257 = call ptr @llvm.invariant.start.p0(i64 16, ptr %254)
  store ptr @Iterable, ptr %254, align 8
  %258 = alloca [2 x ptr], align 8
  %259 = getelementptr [2 x ptr], ptr %258, i32 0, i32 0
  store ptr %242, ptr %259, align 8
  %260 = getelementptr [2 x ptr], ptr %258, i32 0, i32 1
  store ptr %254, ptr %260, align 8
  %261 = call ptr @llvm.invariant.start.p0(i64 4, ptr %258)
  %262 = call ptr @llvm.invariant.start.p0(i64 112, ptr %227)
  %263 = getelementptr ptr, ptr %227, i32 %233
  %264 = getelementptr ptr, ptr %263, i32 7
  %265 = load ptr, ptr %264, align 8
  %266 = alloca { ptr, ptr }, align 8
  %267 = getelementptr { ptr, ptr }, ptr %266, i32 0, i32 0
  store ptr %197, ptr %267, align 8
  %268 = getelementptr { ptr, ptr }, ptr %266, i32 0, i32 1
  store ptr %219, ptr %268, align 8
  %269 = call ptr @behavior_wrapper(ptr %265, { ptr, ptr, ptr, i32 } %234, ptr %266)
  call void %269({ ptr, ptr, ptr, i32 } %234, { ptr, ptr, ptr, i32 } %234, ptr %258, { ptr, ptr, ptr, i32 } %204, { ptr, ptr, ptr, i32 } %226)
  %270 = alloca i32, align 4
  %271 = alloca ptr, align 8
  %272 = alloca ptr, align 8
  %273 = alloca ptr, align 8
  %274 = load ptr, ptr %128, align 8
  store ptr %274, ptr %273, align 8
  %275 = load ptr, ptr %127, align 8
  store ptr %275, ptr %272, align 8
  %276 = load ptr, ptr %126, align 8
  store ptr %276, ptr %271, align 8
  %277 = load i32, ptr %125, align 4
  store i32 %277, ptr %270, align 4
  %278 = load ptr, ptr %273, align 8
  %279 = call i32 @get_offset(ptr %278, ptr @Iterator)
  store i32 %279, ptr %270, align 4
  %280 = load ptr, ptr %273, align 8
  %281 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %280, 0
  %282 = load ptr, ptr %272, align 8
  %283 = insertvalue { ptr, ptr, ptr, i32 } %281, ptr %282, 1
  %284 = load ptr, ptr %271, align 8
  %285 = insertvalue { ptr, ptr, ptr, i32 } %283, ptr %284, 2
  %286 = load i32, ptr %270, align 4
  %287 = insertvalue { ptr, ptr, ptr, i32 } %285, i32 %286, 3
  ret { ptr, ptr, ptr, i32 } %287
}

define ptr @Products_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 19, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [56 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @Products_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 20, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [56 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Products_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @Pair, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @Pair to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = ptrtoint ptr %20 to i64
  %22 = icmp eq i64 %21, ptrtoint (ptr @function_typ to i64)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 21, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [56 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define ptr @Products_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 22, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [56 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Products_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 23, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [56 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Products_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 24, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [56 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @Products_B_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 25, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [56 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Products_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 26, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [56 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @Products_B_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 27, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [56 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define ptr @Products_B_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 28, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [56 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define ptr @Products_B_zip_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 29, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [56 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define ptr @Products_B_product_otherIterableU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 30, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [56 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define { i64, i64 } @_data_size_Productizer(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %10
  %12 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %5
  %13 = select i1 %12, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 %5
  %14 = urem i64 %11, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %17
  %19 = add i64 %11, %18
  %20 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %13
  %21 = select i1 %20, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %13
  %22 = urem i64 %19, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %23 = icmp eq i64 %22, 0
  %24 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %22
  %25 = select i1 %23, i64 0, i64 %24
  %26 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %25
  %27 = add i64 %19, %26
  %28 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %21
  %29 = select i1 %28, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %21
  %30 = urem i64 %27, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %31 = icmp eq i64 %30, 0
  %32 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %30
  %33 = select i1 %31, i64 0, i64 %32
  %34 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %33
  %35 = add i64 %27, %34
  %36 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %29
  %37 = select i1 %36, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %29
  %38 = urem i64 %35, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %39 = icmp eq i64 %38, 0
  %40 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %38
  %41 = select i1 %39, i64 0, i64 %40
  %42 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %41
  %43 = add i64 %35, %42
  %44 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, i160 } }, ptr null, i32 0, i32 1) to i64), %37
  %45 = select i1 %44, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, i160 } }, ptr null, i32 0, i32 1) to i64), i64 %37
  %46 = urem i64 %43, ptrtoint (ptr getelementptr ({ i8, { ptr, i160 } }, ptr null, i32 0, i32 1) to i64)
  %47 = icmp eq i64 %46, 0
  %48 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, i160 } }, ptr null, i32 0, i32 1) to i64), %46
  %49 = select i1 %47, i64 0, i64 %48
  %50 = add i64 ptrtoint (ptr getelementptr ({ ptr, i160 }, ptr null, i32 1) to i64), %49
  %51 = add i64 %43, %50
  %52 = urem i64 %51, %45
  %53 = icmp eq i64 %52, 0
  %54 = sub i64 %45, %52
  %55 = select i1 %53, i64 0, i64 %54
  %56 = add i64 %51, %55
  %57 = insertvalue { i64, i64 } undef, i64 %56, 0
  %58 = insertvalue { i64, i64 } %57, i64 %45, 1
  ret { i64, i64 } %58
}

define ptr @Productizer_field_Productizer_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define ptr @Productizer_field_Productizer_1(ptr %0) {
  %2 = getelementptr ptr, ptr %0, i32 1
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

define ptr @Productizer_field_Productizer_2(ptr %0) {
  %2 = getelementptr ptr, ptr %0, i32 2
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

define { ptr, ptr, ptr, i32 } @Productizer_getter_first_iterator(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %11
  %13 = add i64 %7, %12
  %14 = urem i64 %13, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 %13, %17
  %19 = getelementptr i8, ptr %0, i64 %18
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 0
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %21, 0
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 1
  %24 = load ptr, ptr %23, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %24, 1
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 2
  %27 = load ptr, ptr %26, align 8
  %28 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %27, 2
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 3
  %30 = load i32, ptr %29, align 4
  %31 = insertvalue { ptr, ptr, ptr, i32 } %28, i32 %30, 3
  ret { ptr, ptr, ptr, i32 } %31
}

define void @Productizer_setter_first_iterator(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %12
  %14 = add i64 %8, %13
  %15 = urem i64 %14, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %16 = icmp eq i64 %15, 0
  %17 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add i64 %14, %18
  %20 = getelementptr i8, ptr %0, i64 %19
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %21, align 8
  %22 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 0
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 0
  %24 = load ptr, ptr %22, align 8
  store ptr %24, ptr %23, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 1
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 1
  %27 = load ptr, ptr %25, align 8
  store ptr %27, ptr %26, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 2
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 2
  %30 = load ptr, ptr %28, align 8
  store ptr %30, ptr %29, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 3
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 3
  %33 = load i32, ptr %31, align 4
  store i32 %33, ptr %32, align 4
  ret void
}

define { ptr, ptr, ptr, i32 } @Productizer_getter_second_iterator(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %11
  %13 = add i64 %7, %12
  %14 = urem i64 %13, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %17
  %19 = add i64 %13, %18
  %20 = urem i64 %19, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = add i64 %19, %23
  %25 = getelementptr i8, ptr %0, i64 %24
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %27, 0
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 1
  %30 = load ptr, ptr %29, align 8
  %31 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %30, 1
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 2
  %33 = load ptr, ptr %32, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %33, 2
  %35 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 3
  %36 = load i32, ptr %35, align 4
  %37 = insertvalue { ptr, ptr, ptr, i32 } %34, i32 %36, 3
  ret { ptr, ptr, ptr, i32 } %37
}

define void @Productizer_setter_second_iterator(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %12
  %14 = add i64 %8, %13
  %15 = urem i64 %14, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %16 = icmp eq i64 %15, 0
  %17 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %18
  %20 = add i64 %14, %19
  %21 = urem i64 %20, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %22 = icmp eq i64 %21, 0
  %23 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %21
  %24 = select i1 %22, i64 0, i64 %23
  %25 = add i64 %20, %24
  %26 = getelementptr i8, ptr %0, i64 %25
  %27 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %27, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 0
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 0
  %30 = load ptr, ptr %28, align 8
  store ptr %30, ptr %29, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 1
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 1
  %33 = load ptr, ptr %31, align 8
  store ptr %33, ptr %32, align 8
  %34 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 2
  %35 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 2
  %36 = load ptr, ptr %34, align 8
  store ptr %36, ptr %35, align 8
  %37 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 3
  %38 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 3
  %39 = load i32, ptr %37, align 4
  store i32 %39, ptr %38, align 4
  ret void
}

define { ptr, ptr, ptr, i32 } @Productizer_getter_second(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %11
  %13 = add i64 %7, %12
  %14 = urem i64 %13, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %17
  %19 = add i64 %13, %18
  %20 = urem i64 %19, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %23
  %25 = add i64 %19, %24
  %26 = urem i64 %25, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %27 = icmp eq i64 %26, 0
  %28 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %26
  %29 = select i1 %27, i64 0, i64 %28
  %30 = add i64 %25, %29
  %31 = getelementptr i8, ptr %0, i64 %30
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %31, i32 0, i32 0
  %33 = load ptr, ptr %32, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %33, 0
  %35 = getelementptr { ptr, ptr, ptr, i32 }, ptr %31, i32 0, i32 1
  %36 = load ptr, ptr %35, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } %34, ptr %36, 1
  %38 = getelementptr { ptr, ptr, ptr, i32 }, ptr %31, i32 0, i32 2
  %39 = load ptr, ptr %38, align 8
  %40 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %39, 2
  %41 = getelementptr { ptr, ptr, ptr, i32 }, ptr %31, i32 0, i32 3
  %42 = load i32, ptr %41, align 4
  %43 = insertvalue { ptr, ptr, ptr, i32 } %40, i32 %42, 3
  ret { ptr, ptr, ptr, i32 } %43
}

define void @Productizer_setter_second(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %12
  %14 = add i64 %8, %13
  %15 = urem i64 %14, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %16 = icmp eq i64 %15, 0
  %17 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %18
  %20 = add i64 %14, %19
  %21 = urem i64 %20, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %22 = icmp eq i64 %21, 0
  %23 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %21
  %24 = select i1 %22, i64 0, i64 %23
  %25 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %24
  %26 = add i64 %20, %25
  %27 = urem i64 %26, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %28 = icmp eq i64 %27, 0
  %29 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %27
  %30 = select i1 %28, i64 0, i64 %29
  %31 = add i64 %26, %30
  %32 = getelementptr i8, ptr %0, i64 %31
  %33 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %33, align 8
  %34 = getelementptr { ptr, ptr, ptr, i32 }, ptr %33, i32 0, i32 0
  %35 = getelementptr { ptr, ptr, ptr, i32 }, ptr %32, i32 0, i32 0
  %36 = load ptr, ptr %34, align 8
  store ptr %36, ptr %35, align 8
  %37 = getelementptr { ptr, ptr, ptr, i32 }, ptr %33, i32 0, i32 1
  %38 = getelementptr { ptr, ptr, ptr, i32 }, ptr %32, i32 0, i32 1
  %39 = load ptr, ptr %37, align 8
  store ptr %39, ptr %38, align 8
  %40 = getelementptr { ptr, ptr, ptr, i32 }, ptr %33, i32 0, i32 2
  %41 = getelementptr { ptr, ptr, ptr, i32 }, ptr %32, i32 0, i32 2
  %42 = load ptr, ptr %40, align 8
  store ptr %42, ptr %41, align 8
  %43 = getelementptr { ptr, ptr, ptr, i32 }, ptr %33, i32 0, i32 3
  %44 = getelementptr { ptr, ptr, ptr, i32 }, ptr %32, i32 0, i32 3
  %45 = load i32, ptr %43, align 4
  store i32 %45, ptr %44, align 4
  ret void
}

define { ptr, i160 } @Productizer_getter_current_first(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %11
  %13 = add i64 %7, %12
  %14 = urem i64 %13, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %17
  %19 = add i64 %13, %18
  %20 = urem i64 %19, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %23
  %25 = add i64 %19, %24
  %26 = urem i64 %25, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %27 = icmp eq i64 %26, 0
  %28 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %26
  %29 = select i1 %27, i64 0, i64 %28
  %30 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %29
  %31 = add i64 %25, %30
  %32 = urem i64 %31, ptrtoint (ptr getelementptr ({ i8, { ptr, i160 } }, ptr null, i32 0, i32 1) to i64)
  %33 = icmp eq i64 %32, 0
  %34 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, i160 } }, ptr null, i32 0, i32 1) to i64), %32
  %35 = select i1 %33, i64 0, i64 %34
  %36 = add i64 %31, %35
  %37 = getelementptr i8, ptr %0, i64 %36
  %38 = getelementptr { ptr, i160 }, ptr %37, i32 0, i32 0
  %39 = load ptr, ptr %38, align 8
  %40 = insertvalue { ptr, i160 } undef, ptr %39, 0
  %41 = getelementptr { ptr, i160 }, ptr %37, i32 0, i32 1
  %42 = load i160, ptr %41, align 4
  %43 = insertvalue { ptr, i160 } %40, i160 %42, 1
  ret { ptr, i160 } %43
}

define void @Productizer_setter_current_first(ptr %0, { ptr, i160 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %12
  %14 = add i64 %8, %13
  %15 = urem i64 %14, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %16 = icmp eq i64 %15, 0
  %17 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %18
  %20 = add i64 %14, %19
  %21 = urem i64 %20, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %22 = icmp eq i64 %21, 0
  %23 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %21
  %24 = select i1 %22, i64 0, i64 %23
  %25 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %24
  %26 = add i64 %20, %25
  %27 = urem i64 %26, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %28 = icmp eq i64 %27, 0
  %29 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %27
  %30 = select i1 %28, i64 0, i64 %29
  %31 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %30
  %32 = add i64 %26, %31
  %33 = urem i64 %32, ptrtoint (ptr getelementptr ({ i8, { ptr, i160 } }, ptr null, i32 0, i32 1) to i64)
  %34 = icmp eq i64 %33, 0
  %35 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, i160 } }, ptr null, i32 0, i32 1) to i64), %33
  %36 = select i1 %34, i64 0, i64 %35
  %37 = add i64 %32, %36
  %38 = getelementptr i8, ptr %0, i64 %37
  %39 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %1, ptr %39, align 8
  %40 = getelementptr { ptr, i160 }, ptr %39, i32 0, i32 0
  %41 = getelementptr { ptr, i160 }, ptr %38, i32 0, i32 0
  %42 = load ptr, ptr %40, align 8
  store ptr %42, ptr %41, align 8
  %43 = getelementptr { ptr, i160 }, ptr %39, i32 0, i32 1
  %44 = getelementptr { ptr, i160 }, ptr %38, i32 0, i32 1
  %45 = load i160, ptr %43, align 4
  store i160 %45, ptr %44, align 4
  ret void
}

define void @Productizer_init_first_iteratorIteratorT_secondIterableU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) {
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %6, align 8
  %7 = alloca i32, align 4
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = alloca ptr, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %8, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 1
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %9, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 2
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %10, align 8
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  store i32 %18, ptr %7, align 4
  %19 = load ptr, ptr %8, align 8
  %20 = call i32 @get_offset(ptr %19, ptr @Productizer)
  store i32 %20, ptr %7, align 4
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %21, align 8
  %22 = alloca i32, align 4
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = alloca ptr, align 8
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  store ptr %27, ptr %25, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 1
  %29 = load ptr, ptr %28, align 8
  store ptr %29, ptr %24, align 8
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 2
  %31 = load ptr, ptr %30, align 8
  store ptr %31, ptr %23, align 8
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 3
  %33 = load i32, ptr %32, align 4
  store i32 %33, ptr %22, align 4
  %34 = load ptr, ptr %25, align 8
  %35 = call i32 @get_offset(ptr %34, ptr @Iterator)
  store i32 %35, ptr %22, align 4
  %36 = alloca i32, align 4
  %37 = alloca ptr, align 8
  %38 = alloca ptr, align 8
  %39 = alloca ptr, align 8
  %40 = load ptr, ptr %25, align 8
  store ptr %40, ptr %39, align 8
  %41 = load ptr, ptr %24, align 8
  store ptr %41, ptr %38, align 8
  %42 = load ptr, ptr %23, align 8
  store ptr %42, ptr %37, align 8
  %43 = load i32, ptr %22, align 4
  store i32 %43, ptr %36, align 4
  %44 = load ptr, ptr %39, align 8
  %45 = call i32 @get_offset(ptr %44, ptr @Iterator)
  store i32 %45, ptr %36, align 4
  %46 = load ptr, ptr %9, align 8
  %47 = load ptr, ptr %8, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 112, ptr %47)
  %49 = load i32, ptr %7, align 4
  %50 = getelementptr ptr, ptr %47, i32 %49
  %51 = getelementptr ptr, ptr %50, i32 3
  %52 = load ptr, ptr %51, align 8
  %53 = getelementptr { ptr, ptr }, ptr %52, i32 0, i32 1
  %54 = load ptr, ptr %53, align 8
  %55 = load ptr, ptr %39, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %55, 0
  %57 = load ptr, ptr %38, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %57, 1
  %59 = load ptr, ptr %37, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %59, 2
  %61 = load i32, ptr %36, align 4
  %62 = insertvalue { ptr, ptr, ptr, i32 } %60, i32 %61, 3
  call void %54(ptr %46, { ptr, ptr, ptr, i32 } %62) #2
  %63 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %4, ptr %63, align 8
  %64 = alloca i32, align 4
  %65 = alloca ptr, align 8
  %66 = alloca ptr, align 8
  %67 = alloca ptr, align 8
  %68 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 0
  %69 = load ptr, ptr %68, align 8
  store ptr %69, ptr %67, align 8
  %70 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 1
  %71 = load ptr, ptr %70, align 8
  store ptr %71, ptr %66, align 8
  %72 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 2
  %73 = load ptr, ptr %72, align 8
  store ptr %73, ptr %65, align 8
  %74 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 3
  %75 = load i32, ptr %74, align 4
  store i32 %75, ptr %64, align 4
  %76 = load ptr, ptr %67, align 8
  %77 = call i32 @get_offset(ptr %76, ptr @Iterable)
  store i32 %77, ptr %64, align 4
  %78 = alloca i32, align 4
  %79 = alloca ptr, align 8
  %80 = alloca ptr, align 8
  %81 = alloca ptr, align 8
  %82 = load ptr, ptr %67, align 8
  store ptr %82, ptr %81, align 8
  %83 = load ptr, ptr %66, align 8
  store ptr %83, ptr %80, align 8
  %84 = load ptr, ptr %65, align 8
  store ptr %84, ptr %79, align 8
  %85 = load i32, ptr %64, align 4
  store i32 %85, ptr %78, align 4
  %86 = load ptr, ptr %81, align 8
  %87 = call i32 @get_offset(ptr %86, ptr @Iterable)
  store i32 %87, ptr %78, align 4
  %88 = load ptr, ptr %9, align 8
  %89 = load ptr, ptr %8, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 112, ptr %89)
  %91 = load i32, ptr %7, align 4
  %92 = getelementptr ptr, ptr %89, i32 %91
  %93 = getelementptr ptr, ptr %92, i32 5
  %94 = load ptr, ptr %93, align 8
  %95 = getelementptr { ptr, ptr }, ptr %94, i32 0, i32 1
  %96 = load ptr, ptr %95, align 8
  %97 = load ptr, ptr %81, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %97, 0
  %99 = load ptr, ptr %80, align 8
  %100 = insertvalue { ptr, ptr, ptr, i32 } %98, ptr %99, 1
  %101 = load ptr, ptr %79, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } %100, ptr %101, 2
  %103 = load i32, ptr %78, align 4
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, i32 %103, 3
  call void %96(ptr %88, { ptr, ptr, ptr, i32 } %104) #2
  %105 = load ptr, ptr %9, align 8
  %106 = load ptr, ptr %8, align 8
  %107 = call ptr @llvm.invariant.start.p0(i64 112, ptr %106)
  %108 = load i32, ptr %7, align 4
  %109 = getelementptr ptr, ptr %106, i32 %108
  %110 = getelementptr ptr, ptr %109, i32 5
  %111 = load ptr, ptr %110, align 8
  %112 = getelementptr { ptr, ptr }, ptr %111, i32 0, i32 0
  %113 = load ptr, ptr %112, align 8
  %114 = call { ptr, ptr, ptr, i32 } %113(ptr %105) #1
  %115 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %114, ptr %115, align 8
  call void @assume_offset(ptr %115, ptr @Iterable)
  %116 = getelementptr { ptr, ptr, ptr, i32 }, ptr %115, i32 0, i32 0
  %117 = load ptr, ptr %116, align 8
  %118 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %117, 0
  %119 = getelementptr { ptr, ptr, ptr, i32 }, ptr %115, i32 0, i32 1
  %120 = load ptr, ptr %119, align 8
  %121 = insertvalue { ptr, ptr, ptr, i32 } %118, ptr %120, 1
  %122 = getelementptr { ptr, ptr, ptr, i32 }, ptr %115, i32 0, i32 2
  %123 = load ptr, ptr %122, align 8
  %124 = insertvalue { ptr, ptr, ptr, i32 } %121, ptr %123, 2
  %125 = getelementptr { ptr, ptr, ptr, i32 }, ptr %115, i32 0, i32 3
  %126 = load i32, ptr %125, align 4
  %127 = insertvalue { ptr, ptr, ptr, i32 } %124, i32 %126, 3
  %128 = alloca [0 x ptr], align 8
  %129 = call ptr @llvm.invariant.start.p0(i64 0, ptr %128)
  %130 = call ptr @llvm.invariant.start.p0(i64 200, ptr %117)
  %131 = getelementptr ptr, ptr %117, i32 %126
  %132 = getelementptr ptr, ptr %131, i32 1
  %133 = load ptr, ptr %132, align 8
  %134 = alloca {}, align 8
  %135 = call ptr @behavior_wrapper(ptr %133, { ptr, ptr, ptr, i32 } %127, ptr %134)
  %136 = call { ptr, ptr, ptr, i32 } %135({ ptr, ptr, ptr, i32 } %127, { ptr, ptr, ptr, i32 } %127, ptr %128)
  %137 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %136, ptr %137, align 8
  %138 = alloca i32, align 4
  %139 = alloca ptr, align 8
  %140 = alloca ptr, align 8
  %141 = alloca ptr, align 8
  %142 = getelementptr { ptr, ptr, ptr, i32 }, ptr %137, i32 0, i32 0
  %143 = load ptr, ptr %142, align 8
  store ptr %143, ptr %141, align 8
  %144 = getelementptr { ptr, ptr, ptr, i32 }, ptr %137, i32 0, i32 1
  %145 = load ptr, ptr %144, align 8
  store ptr %145, ptr %140, align 8
  %146 = getelementptr { ptr, ptr, ptr, i32 }, ptr %137, i32 0, i32 2
  %147 = load ptr, ptr %146, align 8
  store ptr %147, ptr %139, align 8
  %148 = getelementptr { ptr, ptr, ptr, i32 }, ptr %137, i32 0, i32 3
  %149 = load i32, ptr %148, align 4
  store i32 %149, ptr %138, align 4
  %150 = load ptr, ptr %141, align 8
  %151 = call i32 @get_offset(ptr %150, ptr @Iterator)
  store i32 %151, ptr %138, align 4
  %152 = alloca i32, align 4
  %153 = alloca ptr, align 8
  %154 = alloca ptr, align 8
  %155 = alloca ptr, align 8
  %156 = load ptr, ptr %141, align 8
  store ptr %156, ptr %155, align 8
  %157 = load ptr, ptr %140, align 8
  store ptr %157, ptr %154, align 8
  %158 = load ptr, ptr %139, align 8
  store ptr %158, ptr %153, align 8
  %159 = load i32, ptr %138, align 4
  store i32 %159, ptr %152, align 4
  %160 = load ptr, ptr %155, align 8
  %161 = call i32 @get_offset(ptr %160, ptr @Iterator)
  store i32 %161, ptr %152, align 4
  %162 = load ptr, ptr %9, align 8
  %163 = load ptr, ptr %8, align 8
  %164 = call ptr @llvm.invariant.start.p0(i64 112, ptr %163)
  %165 = load i32, ptr %7, align 4
  %166 = getelementptr ptr, ptr %163, i32 %165
  %167 = getelementptr ptr, ptr %166, i32 4
  %168 = load ptr, ptr %167, align 8
  %169 = getelementptr { ptr, ptr }, ptr %168, i32 0, i32 1
  %170 = load ptr, ptr %169, align 8
  %171 = load ptr, ptr %155, align 8
  %172 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %171, 0
  %173 = load ptr, ptr %154, align 8
  %174 = insertvalue { ptr, ptr, ptr, i32 } %172, ptr %173, 1
  %175 = load ptr, ptr %153, align 8
  %176 = insertvalue { ptr, ptr, ptr, i32 } %174, ptr %175, 2
  %177 = load i32, ptr %152, align 4
  %178 = insertvalue { ptr, ptr, ptr, i32 } %176, i32 %177, 3
  call void %170(ptr %162, { ptr, ptr, ptr, i32 } %178) #2
  %179 = load ptr, ptr %9, align 8
  %180 = load ptr, ptr %8, align 8
  %181 = call ptr @llvm.invariant.start.p0(i64 112, ptr %180)
  %182 = load i32, ptr %7, align 4
  %183 = getelementptr ptr, ptr %180, i32 %182
  %184 = getelementptr ptr, ptr %183, i32 3
  %185 = load ptr, ptr %184, align 8
  %186 = getelementptr { ptr, ptr }, ptr %185, i32 0, i32 0
  %187 = load ptr, ptr %186, align 8
  %188 = call { ptr, ptr, ptr, i32 } %187(ptr %179) #1
  %189 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %188, ptr %189, align 8
  call void @assume_offset(ptr %189, ptr @Iterator)
  %190 = getelementptr { ptr, ptr, ptr, i32 }, ptr %189, i32 0, i32 0
  %191 = load ptr, ptr %190, align 8
  %192 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %191, 0
  %193 = getelementptr { ptr, ptr, ptr, i32 }, ptr %189, i32 0, i32 1
  %194 = load ptr, ptr %193, align 8
  %195 = insertvalue { ptr, ptr, ptr, i32 } %192, ptr %194, 1
  %196 = getelementptr { ptr, ptr, ptr, i32 }, ptr %189, i32 0, i32 2
  %197 = load ptr, ptr %196, align 8
  %198 = insertvalue { ptr, ptr, ptr, i32 } %195, ptr %197, 2
  %199 = getelementptr { ptr, ptr, ptr, i32 }, ptr %189, i32 0, i32 3
  %200 = load i32, ptr %199, align 4
  %201 = insertvalue { ptr, ptr, ptr, i32 } %198, i32 %200, 3
  %202 = alloca [0 x ptr], align 8
  %203 = call ptr @llvm.invariant.start.p0(i64 0, ptr %202)
  %204 = call ptr @llvm.invariant.start.p0(i64 24, ptr %191)
  %205 = getelementptr ptr, ptr %191, i32 %200
  %206 = getelementptr ptr, ptr %205, i32 1
  %207 = load ptr, ptr %206, align 8
  %208 = alloca {}, align 8
  %209 = call ptr @behavior_wrapper(ptr %207, { ptr, ptr, ptr, i32 } %201, ptr %208)
  %210 = call { ptr, i160 } %209({ ptr, ptr, ptr, i32 } %201, { ptr, ptr, ptr, i32 } %201, ptr %202)
  %211 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %210, ptr %211, align 8
  %212 = load ptr, ptr %9, align 8
  %213 = load ptr, ptr %8, align 8
  %214 = call ptr @llvm.invariant.start.p0(i64 112, ptr %213)
  %215 = load i32, ptr %7, align 4
  %216 = getelementptr ptr, ptr %213, i32 %215
  %217 = getelementptr ptr, ptr %216, i32 6
  %218 = load ptr, ptr %217, align 8
  %219 = getelementptr { ptr, ptr }, ptr %218, i32 0, i32 1
  %220 = load ptr, ptr %219, align 8
  %221 = getelementptr { ptr, i160 }, ptr %211, i32 0, i32 0
  %222 = load ptr, ptr %221, align 8
  %223 = insertvalue { ptr, i160 } undef, ptr %222, 0
  %224 = getelementptr { ptr, i160 }, ptr %211, i32 0, i32 1
  %225 = load i160, ptr %224, align 4
  %226 = insertvalue { ptr, i160 } %223, i160 %225, 1
  call void %220(ptr %212, { ptr, i160 } %226) #2
  ret void
}

define ptr @Productizer_B_init_first_iteratorIteratorT_secondIterableU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @Iterator, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @Iterator to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 1
  %22 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 2
  %23 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 0
  %24 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 1
  %25 = load i64, ptr %21, align 4
  %26 = load i64, ptr %22, align 4
  %27 = load ptr, ptr %23, align 8
  %28 = load ptr, ptr %24, align 8
  %29 = load i64, ptr @Iterable, align 4
  %30 = call i1 @subtype_test_wrapper(ptr %27, i64 %26, i64 %25, i64 %29, i64 ptrtoint (ptr @Iterable to i64), ptr %28)
  %31 = zext i1 %30 to i8
  store i8 %31, ptr %3, align 1
  store i32 9, ptr %6, align 4
  %32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %33 = load i32, ptr %6, align 4
  %34 = getelementptr [14 x ptr], ptr %32, i32 0, i32 %33
  %35 = getelementptr ptr, ptr %34, i32 10
  %36 = load ptr, ptr %35, align 8
  ret ptr %36
}

define { ptr, i160 } @Productizer_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca i1, align 1
  %5 = alloca i160, align 8
  %6 = alloca ptr, align 8
  %7 = alloca { ptr, ptr, ptr, i32 }, align 8
  %8 = alloca [0 x ptr], align 8
  %9 = alloca {}, align 8
  %10 = alloca { ptr, i160 }, align 8
  %11 = alloca i1, align 1
  %12 = alloca i160, align 8
  %13 = alloca ptr, align 8
  %14 = alloca [3 x ptr], align 8
  %15 = alloca { ptr, ptr, ptr, i32 }, align 8
  %16 = alloca i160, align 8
  %17 = alloca ptr, align 8
  %18 = alloca i160, align 8
  %19 = alloca ptr, align 8
  %20 = alloca [2 x ptr], align 8
  %21 = alloca { ptr, ptr }, align 8
  %22 = alloca [0 x i8], align 1
  %23 = alloca { ptr, ptr, ptr, i32 }, align 8
  %24 = alloca [0 x ptr], align 8
  %25 = alloca {}, align 8
  %26 = alloca { ptr, i160 }, align 8
  %27 = alloca { ptr, ptr, ptr, i32 }, align 8
  %28 = alloca [0 x ptr], align 8
  %29 = alloca {}, align 8
  %30 = alloca { ptr, ptr, ptr, i32 }, align 8
  %31 = alloca i32, align 4
  %32 = alloca ptr, align 8
  %33 = alloca ptr, align 8
  %34 = alloca ptr, align 8
  %35 = alloca i32, align 4
  %36 = alloca ptr, align 8
  %37 = alloca ptr, align 8
  %38 = alloca ptr, align 8
  %39 = alloca { ptr, i160 }, align 8
  %40 = alloca i160, align 8
  %41 = alloca ptr, align 8
  %42 = alloca [0 x i8], align 1
  %43 = alloca i160, align 8
  %44 = alloca ptr, align 8
  %45 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %45, align 8
  %46 = alloca i32, align 4
  %47 = alloca ptr, align 8
  %48 = alloca ptr, align 8
  %49 = alloca ptr, align 8
  %50 = getelementptr { ptr, ptr, ptr, i32 }, ptr %45, i32 0, i32 0
  %51 = load ptr, ptr %50, align 8
  store ptr %51, ptr %47, align 8
  %52 = getelementptr { ptr, ptr, ptr, i32 }, ptr %45, i32 0, i32 1
  %53 = load ptr, ptr %52, align 8
  store ptr %53, ptr %48, align 8
  %54 = getelementptr { ptr, ptr, ptr, i32 }, ptr %45, i32 0, i32 2
  %55 = load ptr, ptr %54, align 8
  store ptr %55, ptr %49, align 8
  %56 = getelementptr { ptr, ptr, ptr, i32 }, ptr %45, i32 0, i32 3
  %57 = load i32, ptr %56, align 4
  store i32 %57, ptr %46, align 4
  %58 = load ptr, ptr %47, align 8
  %59 = call i32 @get_offset(ptr %58, ptr @Productizer)
  store i32 %59, ptr %46, align 4
  %60 = load ptr, ptr %48, align 8
  %61 = load ptr, ptr %47, align 8
  %62 = call ptr @llvm.invariant.start.p0(i64 112, ptr %61)
  %63 = load i32, ptr %46, align 4
  %64 = getelementptr ptr, ptr %61, i32 %63
  %65 = getelementptr ptr, ptr %64, i32 6
  %66 = load ptr, ptr %65, align 8
  %67 = getelementptr { ptr, ptr }, ptr %66, i32 0, i32 0
  %68 = load ptr, ptr %67, align 8
  %69 = call { ptr, i160 } %68(ptr %60) #1
  %70 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %69, ptr %70, align 8
  %71 = alloca i160, align 8
  %72 = alloca ptr, align 8
  %73 = getelementptr { ptr, i160 }, ptr %70, i32 0, i32 0
  %74 = load ptr, ptr %73, align 8
  store ptr %74, ptr %72, align 8
  %75 = getelementptr { ptr, i160 }, ptr %70, i32 0, i32 1
  %76 = load i160, ptr %75, align 4
  store i160 %76, ptr %71, align 4
  br label %77

77:                                               ; preds = %278, %3
  %78 = load ptr, ptr %48, align 8
  %79 = load ptr, ptr %47, align 8
  %80 = call ptr @llvm.invariant.start.p0(i64 112, ptr %79)
  %81 = load i32, ptr %46, align 4
  %82 = getelementptr ptr, ptr %79, i32 %81
  %83 = load ptr, ptr %82, align 8
  %84 = call ptr @typegetter_wrapper(ptr %83, ptr %78)
  %85 = load ptr, ptr %72, align 8
  %86 = ptrtoint ptr %85 to i64
  %87 = icmp eq i64 %86, ptrtoint (ptr @nil_typ to i64)
  %88 = icmp eq i64 %86, 0
  %89 = or i1 %87, %88
  %90 = icmp eq i1 %89, false
  %91 = zext i1 %90 to i8
  store i8 %91, ptr %4, align 1
  %92 = load i8, ptr %4, align 1
  %93 = trunc i8 %92 to i1
  br i1 %93, label %94, label %272

94:                                               ; preds = %77
  %95 = load ptr, ptr %72, align 8
  store ptr %95, ptr %6, align 8
  %96 = load i160, ptr %71, align 4
  store i160 %96, ptr %5, align 4
  %97 = load ptr, ptr %48, align 8
  %98 = load ptr, ptr %47, align 8
  %99 = call ptr @llvm.invariant.start.p0(i64 112, ptr %98)
  %100 = load i32, ptr %46, align 4
  %101 = getelementptr ptr, ptr %98, i32 %100
  %102 = getelementptr ptr, ptr %101, i32 4
  %103 = load ptr, ptr %102, align 8
  %104 = getelementptr { ptr, ptr }, ptr %103, i32 0, i32 0
  %105 = load ptr, ptr %104, align 8
  %106 = call { ptr, ptr, ptr, i32 } %105(ptr %97) #1
  store { ptr, ptr, ptr, i32 } %106, ptr %7, align 8
  call void @assume_offset(ptr %7, ptr @Iterator)
  %107 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 0
  %108 = load ptr, ptr %107, align 8
  %109 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %108, 0
  %110 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 1
  %111 = load ptr, ptr %110, align 8
  %112 = insertvalue { ptr, ptr, ptr, i32 } %109, ptr %111, 1
  %113 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 2
  %114 = load ptr, ptr %113, align 8
  %115 = insertvalue { ptr, ptr, ptr, i32 } %112, ptr %114, 2
  %116 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 3
  %117 = load i32, ptr %116, align 4
  %118 = insertvalue { ptr, ptr, ptr, i32 } %115, i32 %117, 3
  %119 = call ptr @llvm.invariant.start.p0(i64 0, ptr %8)
  %120 = call ptr @llvm.invariant.start.p0(i64 24, ptr %108)
  %121 = getelementptr ptr, ptr %108, i32 %117
  %122 = getelementptr ptr, ptr %121, i32 1
  %123 = load ptr, ptr %122, align 8
  %124 = call ptr @behavior_wrapper(ptr %123, { ptr, ptr, ptr, i32 } %118, ptr %9)
  %125 = call { ptr, i160 } %124({ ptr, ptr, ptr, i32 } %118, { ptr, ptr, ptr, i32 } %118, ptr %8)
  store { ptr, i160 } %125, ptr %10, align 8
  %126 = load ptr, ptr %48, align 8
  %127 = load ptr, ptr %47, align 8
  %128 = call ptr @llvm.invariant.start.p0(i64 112, ptr %127)
  %129 = load i32, ptr %46, align 4
  %130 = getelementptr ptr, ptr %127, i32 %129
  %131 = getelementptr ptr, ptr %130, i32 1
  %132 = load ptr, ptr %131, align 8
  %133 = call ptr @typegetter_wrapper(ptr %132, ptr %126)
  %134 = load ptr, ptr %10, align 8
  %135 = ptrtoint ptr %134 to i64
  %136 = icmp eq i64 %135, ptrtoint (ptr @nil_typ to i64)
  %137 = icmp eq i64 %135, 0
  %138 = or i1 %136, %137
  %139 = icmp eq i1 %138, false
  %140 = zext i1 %139 to i8
  store i8 %140, ptr %11, align 1
  %141 = load i8, ptr %11, align 1
  %142 = trunc i8 %141 to i1
  %143 = zext i1 %142 to i32
  %144 = xor i1 %142, true
  %145 = zext i1 %144 to i32
  br i1 %142, label %146, label %147

146:                                              ; preds = %94
  br label %272

147:                                              ; preds = %94
  %148 = getelementptr { ptr, i160 }, ptr %10, i32 0, i32 1
  %149 = load [0 x i8], ptr %148, align 1
  store [0 x i8] %149, ptr %22, align 1
  %150 = load ptr, ptr %48, align 8
  %151 = load ptr, ptr %47, align 8
  %152 = call ptr @llvm.invariant.start.p0(i64 112, ptr %151)
  %153 = load i32, ptr %46, align 4
  %154 = getelementptr ptr, ptr %151, i32 %153
  %155 = getelementptr ptr, ptr %154, i32 3
  %156 = load ptr, ptr %155, align 8
  %157 = getelementptr { ptr, ptr }, ptr %156, i32 0, i32 0
  %158 = load ptr, ptr %157, align 8
  %159 = call { ptr, ptr, ptr, i32 } %158(ptr %150) #1
  store { ptr, ptr, ptr, i32 } %159, ptr %23, align 8
  call void @assume_offset(ptr %23, ptr @Iterator)
  %160 = getelementptr { ptr, ptr, ptr, i32 }, ptr %23, i32 0, i32 0
  %161 = load ptr, ptr %160, align 8
  %162 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %161, 0
  %163 = getelementptr { ptr, ptr, ptr, i32 }, ptr %23, i32 0, i32 1
  %164 = load ptr, ptr %163, align 8
  %165 = insertvalue { ptr, ptr, ptr, i32 } %162, ptr %164, 1
  %166 = getelementptr { ptr, ptr, ptr, i32 }, ptr %23, i32 0, i32 2
  %167 = load ptr, ptr %166, align 8
  %168 = insertvalue { ptr, ptr, ptr, i32 } %165, ptr %167, 2
  %169 = getelementptr { ptr, ptr, ptr, i32 }, ptr %23, i32 0, i32 3
  %170 = load i32, ptr %169, align 4
  %171 = insertvalue { ptr, ptr, ptr, i32 } %168, i32 %170, 3
  %172 = call ptr @llvm.invariant.start.p0(i64 0, ptr %24)
  %173 = call ptr @llvm.invariant.start.p0(i64 24, ptr %161)
  %174 = getelementptr ptr, ptr %161, i32 %170
  %175 = getelementptr ptr, ptr %174, i32 1
  %176 = load ptr, ptr %175, align 8
  %177 = call ptr @behavior_wrapper(ptr %176, { ptr, ptr, ptr, i32 } %171, ptr %25)
  %178 = call { ptr, i160 } %177({ ptr, ptr, ptr, i32 } %171, { ptr, ptr, ptr, i32 } %171, ptr %24)
  store { ptr, i160 } %178, ptr %26, align 8
  %179 = load ptr, ptr %48, align 8
  %180 = load ptr, ptr %47, align 8
  %181 = call ptr @llvm.invariant.start.p0(i64 112, ptr %180)
  %182 = load i32, ptr %46, align 4
  %183 = getelementptr ptr, ptr %180, i32 %182
  %184 = getelementptr ptr, ptr %183, i32 6
  %185 = load ptr, ptr %184, align 8
  %186 = getelementptr { ptr, ptr }, ptr %185, i32 0, i32 1
  %187 = load ptr, ptr %186, align 8
  %188 = getelementptr { ptr, i160 }, ptr %26, i32 0, i32 0
  %189 = load ptr, ptr %188, align 8
  %190 = insertvalue { ptr, i160 } undef, ptr %189, 0
  %191 = getelementptr { ptr, i160 }, ptr %26, i32 0, i32 1
  %192 = load i160, ptr %191, align 4
  %193 = insertvalue { ptr, i160 } %190, i160 %192, 1
  call void %187(ptr %179, { ptr, i160 } %193) #2
  %194 = load ptr, ptr %48, align 8
  %195 = load ptr, ptr %47, align 8
  %196 = call ptr @llvm.invariant.start.p0(i64 112, ptr %195)
  %197 = load i32, ptr %46, align 4
  %198 = getelementptr ptr, ptr %195, i32 %197
  %199 = getelementptr ptr, ptr %198, i32 5
  %200 = load ptr, ptr %199, align 8
  %201 = getelementptr { ptr, ptr }, ptr %200, i32 0, i32 0
  %202 = load ptr, ptr %201, align 8
  %203 = call { ptr, ptr, ptr, i32 } %202(ptr %194) #1
  store { ptr, ptr, ptr, i32 } %203, ptr %27, align 8
  call void @assume_offset(ptr %27, ptr @Iterable)
  %204 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 0
  %205 = load ptr, ptr %204, align 8
  %206 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %205, 0
  %207 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 1
  %208 = load ptr, ptr %207, align 8
  %209 = insertvalue { ptr, ptr, ptr, i32 } %206, ptr %208, 1
  %210 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 2
  %211 = load ptr, ptr %210, align 8
  %212 = insertvalue { ptr, ptr, ptr, i32 } %209, ptr %211, 2
  %213 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 3
  %214 = load i32, ptr %213, align 4
  %215 = insertvalue { ptr, ptr, ptr, i32 } %212, i32 %214, 3
  %216 = call ptr @llvm.invariant.start.p0(i64 0, ptr %28)
  %217 = call ptr @llvm.invariant.start.p0(i64 200, ptr %205)
  %218 = getelementptr ptr, ptr %205, i32 %214
  %219 = getelementptr ptr, ptr %218, i32 1
  %220 = load ptr, ptr %219, align 8
  %221 = call ptr @behavior_wrapper(ptr %220, { ptr, ptr, ptr, i32 } %215, ptr %29)
  %222 = call { ptr, ptr, ptr, i32 } %221({ ptr, ptr, ptr, i32 } %215, { ptr, ptr, ptr, i32 } %215, ptr %28)
  store { ptr, ptr, ptr, i32 } %222, ptr %30, align 8
  %223 = getelementptr { ptr, ptr, ptr, i32 }, ptr %30, i32 0, i32 0
  %224 = load ptr, ptr %223, align 8
  store ptr %224, ptr %34, align 8
  %225 = getelementptr { ptr, ptr, ptr, i32 }, ptr %30, i32 0, i32 1
  %226 = load ptr, ptr %225, align 8
  store ptr %226, ptr %33, align 8
  %227 = getelementptr { ptr, ptr, ptr, i32 }, ptr %30, i32 0, i32 2
  %228 = load ptr, ptr %227, align 8
  store ptr %228, ptr %32, align 8
  %229 = getelementptr { ptr, ptr, ptr, i32 }, ptr %30, i32 0, i32 3
  %230 = load i32, ptr %229, align 4
  store i32 %230, ptr %31, align 4
  %231 = load ptr, ptr %34, align 8
  %232 = call i32 @get_offset(ptr %231, ptr @Iterator)
  store i32 %232, ptr %31, align 4
  %233 = load ptr, ptr %34, align 8
  store ptr %233, ptr %38, align 8
  %234 = load ptr, ptr %33, align 8
  store ptr %234, ptr %37, align 8
  %235 = load ptr, ptr %32, align 8
  store ptr %235, ptr %36, align 8
  %236 = load i32, ptr %31, align 4
  store i32 %236, ptr %35, align 4
  %237 = load ptr, ptr %38, align 8
  %238 = call i32 @get_offset(ptr %237, ptr @Iterator)
  store i32 %238, ptr %35, align 4
  %239 = load ptr, ptr %48, align 8
  %240 = load ptr, ptr %47, align 8
  %241 = call ptr @llvm.invariant.start.p0(i64 112, ptr %240)
  %242 = load i32, ptr %46, align 4
  %243 = getelementptr ptr, ptr %240, i32 %242
  %244 = getelementptr ptr, ptr %243, i32 4
  %245 = load ptr, ptr %244, align 8
  %246 = getelementptr { ptr, ptr }, ptr %245, i32 0, i32 1
  %247 = load ptr, ptr %246, align 8
  %248 = load ptr, ptr %38, align 8
  %249 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %248, 0
  %250 = load ptr, ptr %37, align 8
  %251 = insertvalue { ptr, ptr, ptr, i32 } %249, ptr %250, 1
  %252 = load ptr, ptr %36, align 8
  %253 = insertvalue { ptr, ptr, ptr, i32 } %251, ptr %252, 2
  %254 = load i32, ptr %35, align 4
  %255 = insertvalue { ptr, ptr, ptr, i32 } %253, i32 %254, 3
  call void %247(ptr %239, { ptr, ptr, ptr, i32 } %255) #2
  %256 = load ptr, ptr %48, align 8
  %257 = load ptr, ptr %47, align 8
  %258 = call ptr @llvm.invariant.start.p0(i64 112, ptr %257)
  %259 = load i32, ptr %46, align 4
  %260 = getelementptr ptr, ptr %257, i32 %259
  %261 = getelementptr ptr, ptr %260, i32 6
  %262 = load ptr, ptr %261, align 8
  %263 = getelementptr { ptr, ptr }, ptr %262, i32 0, i32 0
  %264 = load ptr, ptr %263, align 8
  %265 = call { ptr, i160 } %264(ptr %256) #1
  store { ptr, i160 } %265, ptr %39, align 8
  %266 = getelementptr { ptr, i160 }, ptr %39, i32 0, i32 0
  %267 = load ptr, ptr %266, align 8
  store ptr %267, ptr %41, align 8
  %268 = getelementptr { ptr, i160 }, ptr %39, i32 0, i32 1
  %269 = load i160, ptr %268, align 4
  store i160 %269, ptr %40, align 4
  %270 = load ptr, ptr %41, align 8
  store ptr %270, ptr %72, align 8
  %271 = load i160, ptr %40, align 4
  store i160 %271, ptr %71, align 4
  br label %272

272:                                              ; preds = %146, %147, %77
  %273 = phi i32 [ %143, %147 ], [ %143, %146 ], [ 2, %77 ]
  %274 = phi i32 [ %145, %147 ], [ %145, %146 ], [ 0, %77 ]
  br label %275

275:                                              ; preds = %272
  br label %276

276:                                              ; preds = %275
  %277 = trunc i32 %274 to i1
  br i1 %277, label %278, label %279

278:                                              ; preds = %276
  br label %77

279:                                              ; preds = %276
  %280 = zext i32 %273 to i64
  %281 = trunc i64 %280 to i32
  switch i32 %281, label %367 [
    i32 1, label %282
  ]

282:                                              ; preds = %279
  %283 = getelementptr { ptr, i160 }, ptr %10, i32 0, i32 0
  %284 = load ptr, ptr %283, align 8
  store ptr %284, ptr %13, align 8
  %285 = getelementptr { ptr, i160 }, ptr %10, i32 0, i32 1
  %286 = load i160, ptr %285, align 4
  store i160 %286, ptr %12, align 4
  %287 = load ptr, ptr %48, align 8
  %288 = load ptr, ptr %47, align 8
  %289 = call ptr @llvm.invariant.start.p0(i64 112, ptr %288)
  %290 = load i32, ptr %46, align 4
  %291 = getelementptr ptr, ptr %288, i32 %290
  %292 = load ptr, ptr %291, align 8
  %293 = call ptr @typegetter_wrapper(ptr %292, ptr %287)
  %294 = load ptr, ptr %48, align 8
  %295 = load ptr, ptr %47, align 8
  %296 = call ptr @llvm.invariant.start.p0(i64 112, ptr %295)
  %297 = load i32, ptr %46, align 4
  %298 = getelementptr ptr, ptr %295, i32 %297
  %299 = getelementptr ptr, ptr %298, i32 1
  %300 = load ptr, ptr %299, align 8
  %301 = call ptr @typegetter_wrapper(ptr %300, ptr %294)
  store ptr @Pair, ptr %14, align 8
  %302 = getelementptr ptr, ptr %14, i32 1
  store ptr %293, ptr %302, align 8
  %303 = getelementptr ptr, ptr %14, i32 2
  store ptr %301, ptr %303, align 8
  %304 = load ptr, ptr %14, align 8
  %305 = getelementptr ptr, ptr %304, i32 6
  %306 = load ptr, ptr %305, align 8
  %307 = call { i64, i64 } @size_wrapper(ptr %306, ptr %14)
  %308 = extractvalue { i64, i64 } %307, 0
  %309 = call ptr @bump_malloc(i64 %308)
  store ptr %293, ptr %309, align 8
  %310 = getelementptr ptr, ptr %309, i32 1
  store ptr %301, ptr %310, align 8
  %311 = call ptr @llvm.invariant.start.p0(i64 16, ptr %309)
  %312 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 1
  %313 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 3
  store ptr @Pair, ptr %15, align 8
  store ptr %309, ptr %312, align 8
  store i32 10, ptr %313, align 4
  %314 = load ptr, ptr %6, align 8
  store ptr %314, ptr %17, align 8
  %315 = load i160, ptr %5, align 4
  store i160 %315, ptr %16, align 4
  %316 = load ptr, ptr %17, align 8
  %317 = insertvalue { ptr, i160 } undef, ptr %316, 0
  %318 = load i160, ptr %16, align 4
  %319 = insertvalue { ptr, i160 } %317, i160 %318, 1
  %320 = load ptr, ptr %13, align 8
  store ptr %320, ptr %19, align 8
  %321 = load i160, ptr %12, align 4
  store i160 %321, ptr %18, align 4
  %322 = load ptr, ptr %19, align 8
  %323 = insertvalue { ptr, i160 } undef, ptr %322, 0
  %324 = load i160, ptr %18, align 4
  %325 = insertvalue { ptr, i160 } %323, i160 %324, 1
  %326 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 0
  %327 = load ptr, ptr %326, align 8
  %328 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %327, 0
  %329 = load ptr, ptr %312, align 8
  %330 = insertvalue { ptr, ptr, ptr, i32 } %328, ptr %329, 1
  %331 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 2
  %332 = load ptr, ptr %331, align 8
  %333 = insertvalue { ptr, ptr, ptr, i32 } %330, ptr %332, 2
  %334 = load i32, ptr %313, align 4
  %335 = insertvalue { ptr, ptr, ptr, i32 } %333, i32 %334, 3
  %336 = load ptr, ptr %48, align 8
  %337 = load ptr, ptr %47, align 8
  %338 = call ptr @llvm.invariant.start.p0(i64 112, ptr %337)
  %339 = load i32, ptr %46, align 4
  %340 = getelementptr ptr, ptr %337, i32 %339
  %341 = load ptr, ptr %340, align 8
  %342 = call ptr @typegetter_wrapper(ptr %341, ptr %336)
  %343 = load ptr, ptr %48, align 8
  %344 = load ptr, ptr %47, align 8
  %345 = call ptr @llvm.invariant.start.p0(i64 112, ptr %344)
  %346 = load i32, ptr %46, align 4
  %347 = getelementptr ptr, ptr %344, i32 %346
  %348 = getelementptr ptr, ptr %347, i32 1
  %349 = load ptr, ptr %348, align 8
  %350 = call ptr @typegetter_wrapper(ptr %349, ptr %343)
  %351 = getelementptr [2 x ptr], ptr %20, i32 0, i32 0
  store ptr %342, ptr %351, align 8
  %352 = getelementptr [2 x ptr], ptr %20, i32 0, i32 1
  store ptr %350, ptr %352, align 8
  %353 = call ptr @llvm.invariant.start.p0(i64 4, ptr %20)
  %354 = call ptr @llvm.invariant.start.p0(i64 112, ptr %327)
  %355 = getelementptr ptr, ptr %327, i32 %334
  %356 = getelementptr ptr, ptr %355, i32 8
  %357 = load ptr, ptr %356, align 8
  %358 = getelementptr { ptr, ptr }, ptr %21, i32 0, i32 0
  store ptr %316, ptr %358, align 8
  %359 = getelementptr { ptr, ptr }, ptr %21, i32 0, i32 1
  store ptr %322, ptr %359, align 8
  %360 = call ptr @behavior_wrapper(ptr %357, { ptr, ptr, ptr, i32 } %335, ptr %21)
  call void %360({ ptr, ptr, ptr, i32 } %335, { ptr, ptr, ptr, i32 } %335, ptr %20, { ptr, i160 } %319, { ptr, i160 } %325)
  %361 = getelementptr { ptr, i160 }, ptr %15, i32 0, i32 0
  %362 = load ptr, ptr %361, align 8
  %363 = insertvalue { ptr, i160 } undef, ptr %362, 0
  %364 = getelementptr { ptr, i160 }, ptr %15, i32 0, i32 1
  %365 = load i160, ptr %364, align 4
  %366 = insertvalue { ptr, i160 } %363, i160 %365, 1
  br label %373

367:                                              ; preds = %279
  %368 = load [0 x i8], ptr %42, align 1
  store [0 x i8] %368, ptr %43, align 1
  store ptr @nil_typ, ptr %44, align 8
  %369 = load ptr, ptr %44, align 8
  %370 = insertvalue { ptr, i160 } undef, ptr %369, 0
  %371 = load i160, ptr %43, align 4
  %372 = insertvalue { ptr, i160 } %370, i160 %371, 1
  br label %373

373:                                              ; preds = %367, %282
  %374 = phi { ptr, i160 } [ %372, %367 ], [ %366, %282 ]
  ret { ptr, i160 } %374
}

define ptr @Productizer_B_next_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 10, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [14 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare ptr @llvm.invariant.start.p0(i64 immarg, ptr nocapture) #0

attributes #0 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #1 = { nounwind willreturn memory(argmem: read, inaccessiblemem: readwrite) }
attributes #2 = { nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0}

!0 = !{i32 2, !"Debug Info Version", i32 3}
// -----
; ModuleID = 'LLVMDialectModule'
source_filename = "LLVMDialectModule"

%bool_typ = type opaque
%i1_typ = type opaque
%i8_typ = type opaque
%i32_typ = type opaque
%i64_typ = type opaque
%i128_typ = type opaque
%f64_typ = type opaque
%nil_typ = type opaque
%any_typ = type opaque
%nothing_typ = type opaque
%coroutine_typ = type opaque
%function_typ = type opaque
%buffer_typ = type opaque
%tuple_typ = type opaque
%union_typ = type opaque
%Object = type opaque
%Pair = type opaque
%Iterator = type opaque
%Iterable = type opaque
%ConstantTimeIterator = type opaque
%CoroIterator = type opaque
%Enumerated = type opaque
%Enumerator = type opaque
%Mapped = type opaque
%Mapper = type opaque
%Filtered = type opaque
%Filterer = type opaque
%Chained = type opaque
%Chainer = type opaque
%Interleaved = type opaque
%Interleaver = type opaque
%Zipped = type opaque
%Zipper = type opaque
%Products = type opaque
%Productizer = type opaque

@_parameterization_i32 = linkonce_odr constant [2 x ptr] [ptr @i32_typ, ptr null]
@i32_string = linkonce_odr constant [4 x i8] c"%d\0A\00"
@i64_string = linkonce_odr constant [6 x i8] c"%lld\0A\00"
@float_string = linkonce_odr constant [4 x i8] c"%f\0A\00"
@string_string = linkonce_odr constant [4 x i8] c"%s\0A\00"
@bool_typ = external constant %bool_typ
@i1_typ = external constant %i1_typ
@i8_typ = external constant %i8_typ
@i32_typ = external constant %i32_typ
@i64_typ = external constant %i64_typ
@i128_typ = external constant %i128_typ
@f64_typ = external constant %f64_typ
@nil_typ = external constant %nil_typ
@any_typ = external constant %any_typ
@nothing_typ = external constant %nothing_typ
@coroutine_typ = external constant %coroutine_typ
@function_typ = external constant %function_typ
@buffer_typ = external constant %buffer_typ
@tuple_typ = external constant %tuple_typ
@union_typ = external constant %union_typ
@Object = external constant %Object
@Pair = external constant %Pair
@Iterator = external constant %Iterator
@Iterable = external constant %Iterable
@ConstantTimeIterator = external constant %ConstantTimeIterator
@CoroIterator = external constant %CoroIterator
@Enumerated = external constant %Enumerated
@Enumerator = external constant %Enumerator
@Mapped = external constant %Mapped
@Mapper = external constant %Mapper
@Filtered = external constant %Filtered
@Filterer = external constant %Filterer
@Chained = external constant %Chained
@Chainer = external constant %Chainer
@Interleaved = external constant %Interleaved
@Interleaver = external constant %Interleaver
@Zipped = external constant %Zipped
@Zipper = external constant %Zipper
@Products = external constant %Products
@Productizer = external constant %Productizer
@Collection_hashtbl = constant [4 x ptr] [ptr @Collection, ptr @Object, ptr @any_typ, ptr @Iterable]
@Collection_offset_tbl = constant [4 x i32] [i32 10, i32 69, i32 10, i32 44]
@Collection = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 1375598993350293883, i64 6000206382045714115, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Collection_hashtbl, ptr @Collection_offset_tbl, ptr @_data_size_Collection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@EnumeratedCollection_hashtbl = constant [8 x ptr] [ptr @EnumeratedCollection, ptr null, ptr @Iterable, ptr @Object, ptr @any_typ, ptr null, ptr @Collection, ptr null]
@EnumeratedCollection_offset_tbl = constant [8 x i32] [i32 10, i32 0, i32 107, i32 132, i32 10, i32 0, i32 48, i32 0]
@EnumeratedCollection = constant { [3 x i64], [7 x ptr], [122 x ptr] } { [3 x i64] [i64 7081690788784801875, i64 730343677788615109, i64 7], [7 x ptr] [ptr @subtype_test, ptr @EnumeratedCollection_hashtbl, ptr @EnumeratedCollection_offset_tbl, ptr @_data_size_EnumeratedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [122 x ptr] [ptr @EnumeratedCollection_field_EnumeratedCollection_0, ptr @EnumeratedCollection_field_EnumeratedCollection_1, ptr @EnumeratedCollection_field_iterable, ptr @EnumeratedCollection_B_init_iterableCollectionT, ptr @EnumeratedCollection_B_size_, ptr @EnumeratedCollection_B_is_empty_, ptr @EnumeratedCollection_B_iterator_, ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing, ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_enumerate_, ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_chain_otherCollectionT_chain_otherIterableT, ptr @EnumeratedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @EnumeratedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @EnumeratedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @EnumeratedCollection_init_iterableCollectionT, ptr @EnumeratedCollection_size_, ptr @Collection_is_empty_, ptr @EnumeratedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Collection_chain_otherCollectionT, ptr @Iterable_chain_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @EnumeratedCollection_field_EnumeratedCollection_1, ptr @EnumeratedCollection_B_size_, ptr @EnumeratedCollection_B_is_empty_, ptr @EnumeratedCollection_B_iterator_, ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing, ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_enumerate_, ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_chain_otherCollectionT_chain_otherIterableT, ptr @EnumeratedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @EnumeratedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @EnumeratedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @EnumeratedCollection_size_, ptr @Collection_is_empty_, ptr @EnumeratedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Collection_chain_otherCollectionT, ptr @Iterable_chain_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @EnumeratedCollection_field_EnumeratedCollection_1, ptr @EnumeratedCollection_B_iterator_, ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing, ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_enumerate_, ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_chain_otherCollectionT_chain_otherIterableT, ptr @EnumeratedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @EnumeratedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @EnumeratedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @EnumeratedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @EnumeratedCollection_field_EnumeratedCollection_1, ptr @EnumeratedCollection_B_iterator_, ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing, ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_enumerate_, ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool, ptr @EnumeratedCollection_B_chain_otherCollectionT_chain_otherIterableT, ptr @EnumeratedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @EnumeratedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @EnumeratedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @EnumeratedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@MappedCollection_hashtbl = constant [8 x ptr] [ptr null, ptr @any_typ, ptr @Collection, ptr null, ptr @Iterable, ptr @Object, ptr null, ptr @MappedCollection]
@MappedCollection_offset_tbl = constant [8 x i32] [i32 0, i32 10, i32 49, i32 0, i32 108, i32 133, i32 0, i32 10]
@MappedCollection = constant { [3 x i64], [7 x ptr], [123 x ptr] } { [3 x i64] [i64 5460697656559120915, i64 5853293231305208895, i64 7], [7 x ptr] [ptr @subtype_test, ptr @MappedCollection_hashtbl, ptr @MappedCollection_offset_tbl, ptr @_data_size_MappedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [123 x ptr] [ptr @MappedCollection_field_MappedCollection_0, ptr @MappedCollection_field_MappedCollection_1, ptr @MappedCollection_field_iterable, ptr @MappedCollection_field_f, ptr @MappedCollection_B_init_iterableCollectionT_fFunctionT_to_U, ptr @MappedCollection_B_size_, ptr @MappedCollection_B_is_empty_, ptr @MappedCollection_B_iterator_, ptr @MappedCollection_B_each_fFunctionT_to_Nothing, ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MappedCollection_B_all_fFunctionT_to_Bool, ptr @MappedCollection_B_any_fFunctionT_to_Bool, ptr @MappedCollection_B_enumerate_, ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MappedCollection_B_filter_fFunctionT_to_Bool, ptr @MappedCollection_B_chain_otherCollectionT_chain_otherIterableT, ptr @MappedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MappedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @MappedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @MappedCollection_init_iterableCollectionT_fFunctionT_to_U, ptr @MappedCollection_size_, ptr @Collection_is_empty_, ptr @MappedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Collection_chain_otherCollectionT, ptr @Iterable_chain_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @MappedCollection_field_MappedCollection_1, ptr @MappedCollection_B_size_, ptr @MappedCollection_B_is_empty_, ptr @MappedCollection_B_iterator_, ptr @MappedCollection_B_each_fFunctionT_to_Nothing, ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MappedCollection_B_all_fFunctionT_to_Bool, ptr @MappedCollection_B_any_fFunctionT_to_Bool, ptr @MappedCollection_B_enumerate_, ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MappedCollection_B_filter_fFunctionT_to_Bool, ptr @MappedCollection_B_chain_otherCollectionT_chain_otherIterableT, ptr @MappedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MappedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @MappedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @MappedCollection_size_, ptr @Collection_is_empty_, ptr @MappedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Collection_chain_otherCollectionT, ptr @Iterable_chain_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @MappedCollection_field_MappedCollection_1, ptr @MappedCollection_B_iterator_, ptr @MappedCollection_B_each_fFunctionT_to_Nothing, ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MappedCollection_B_all_fFunctionT_to_Bool, ptr @MappedCollection_B_any_fFunctionT_to_Bool, ptr @MappedCollection_B_enumerate_, ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MappedCollection_B_filter_fFunctionT_to_Bool, ptr @MappedCollection_B_chain_otherCollectionT_chain_otherIterableT, ptr @MappedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MappedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @MappedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @MappedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @MappedCollection_field_MappedCollection_1, ptr @MappedCollection_B_iterator_, ptr @MappedCollection_B_each_fFunctionT_to_Nothing, ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @MappedCollection_B_all_fFunctionT_to_Bool, ptr @MappedCollection_B_any_fFunctionT_to_Bool, ptr @MappedCollection_B_enumerate_, ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @MappedCollection_B_filter_fFunctionT_to_Bool, ptr @MappedCollection_B_chain_otherCollectionT_chain_otherIterableT, ptr @MappedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @MappedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @MappedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @MappedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ChainedCollection_hashtbl = constant [8 x ptr] [ptr @Collection, ptr @Iterable, ptr @any_typ, ptr null, ptr @Object, ptr @ChainedCollection, ptr null, ptr null]
@ChainedCollection_offset_tbl = constant [8 x i32] [i32 48, i32 107, i32 10, i32 0, i32 132, i32 10, i32 0, i32 0]
@ChainedCollection = constant { [3 x i64], [7 x ptr], [122 x ptr] } { [3 x i64] [i64 -4136536984535342799, i64 8042990625783235507, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ChainedCollection_hashtbl, ptr @ChainedCollection_offset_tbl, ptr @_data_size_ChainedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [122 x ptr] [ptr @ChainedCollection_field_ChainedCollection_0, ptr @ChainedCollection_field_first, ptr @ChainedCollection_field_second, ptr @ChainedCollection_B_init_firstCollectionT_secondCollectionT, ptr @ChainedCollection_B_size_, ptr @ChainedCollection_B_is_empty_, ptr @ChainedCollection_B_iterator_, ptr @ChainedCollection_B_each_fFunctionT_to_Nothing, ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainedCollection_B_all_fFunctionT_to_Bool, ptr @ChainedCollection_B_any_fFunctionT_to_Bool, ptr @ChainedCollection_B_enumerate_, ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ChainedCollection_B_filter_fFunctionT_to_Bool, ptr @ChainedCollection_B_chain_otherCollectionT_chain_otherIterableT, ptr @ChainedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ChainedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ChainedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ChainedCollection_init_firstCollectionT_secondCollectionT, ptr @ChainedCollection_size_, ptr @Collection_is_empty_, ptr @ChainedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Collection_chain_otherCollectionT, ptr @Iterable_chain_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @ChainedCollection_field_ChainedCollection_0, ptr @ChainedCollection_B_size_, ptr @ChainedCollection_B_is_empty_, ptr @ChainedCollection_B_iterator_, ptr @ChainedCollection_B_each_fFunctionT_to_Nothing, ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainedCollection_B_all_fFunctionT_to_Bool, ptr @ChainedCollection_B_any_fFunctionT_to_Bool, ptr @ChainedCollection_B_enumerate_, ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ChainedCollection_B_filter_fFunctionT_to_Bool, ptr @ChainedCollection_B_chain_otherCollectionT_chain_otherIterableT, ptr @ChainedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ChainedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ChainedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ChainedCollection_size_, ptr @Collection_is_empty_, ptr @ChainedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Collection_chain_otherCollectionT, ptr @Iterable_chain_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @ChainedCollection_field_ChainedCollection_0, ptr @ChainedCollection_B_iterator_, ptr @ChainedCollection_B_each_fFunctionT_to_Nothing, ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainedCollection_B_all_fFunctionT_to_Bool, ptr @ChainedCollection_B_any_fFunctionT_to_Bool, ptr @ChainedCollection_B_enumerate_, ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ChainedCollection_B_filter_fFunctionT_to_Bool, ptr @ChainedCollection_B_chain_otherCollectionT_chain_otherIterableT, ptr @ChainedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ChainedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ChainedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ChainedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ChainedCollection_field_ChainedCollection_0, ptr @ChainedCollection_B_iterator_, ptr @ChainedCollection_B_each_fFunctionT_to_Nothing, ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ChainedCollection_B_all_fFunctionT_to_Bool, ptr @ChainedCollection_B_any_fFunctionT_to_Bool, ptr @ChainedCollection_B_enumerate_, ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ChainedCollection_B_filter_fFunctionT_to_Bool, ptr @ChainedCollection_B_chain_otherCollectionT_chain_otherIterableT, ptr @ChainedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ChainedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ChainedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ChainedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@InterleavedCollection_hashtbl = constant [8 x ptr] [ptr @Iterable, ptr null, ptr null, ptr null, ptr @any_typ, ptr @Object, ptr @Collection, ptr @InterleavedCollection]
@InterleavedCollection_offset_tbl = constant [8 x i32] [i32 107, i32 0, i32 0, i32 0, i32 10, i32 132, i32 48, i32 10]
@InterleavedCollection = constant { [3 x i64], [7 x ptr], [122 x ptr] } { [3 x i64] [i64 8589355597059143861, i64 -6543691589861190041, i64 7], [7 x ptr] [ptr @subtype_test, ptr @InterleavedCollection_hashtbl, ptr @InterleavedCollection_offset_tbl, ptr @_data_size_InterleavedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [122 x ptr] [ptr @InterleavedCollection_field_InterleavedCollection_0, ptr @InterleavedCollection_field_first, ptr @InterleavedCollection_field_second, ptr @InterleavedCollection_B_init_firstCollectionT_secondCollectionT, ptr @InterleavedCollection_B_size_, ptr @InterleavedCollection_B_is_empty_, ptr @InterleavedCollection_B_iterator_, ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing, ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleavedCollection_B_all_fFunctionT_to_Bool, ptr @InterleavedCollection_B_any_fFunctionT_to_Bool, ptr @InterleavedCollection_B_enumerate_, ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool, ptr @InterleavedCollection_B_chain_otherCollectionT_chain_otherIterableT, ptr @InterleavedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @InterleavedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @InterleavedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @InterleavedCollection_init_firstCollectionT_secondCollectionT, ptr @InterleavedCollection_size_, ptr @Collection_is_empty_, ptr @InterleavedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Collection_chain_otherCollectionT, ptr @Iterable_chain_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @InterleavedCollection_field_InterleavedCollection_0, ptr @InterleavedCollection_B_size_, ptr @InterleavedCollection_B_is_empty_, ptr @InterleavedCollection_B_iterator_, ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing, ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleavedCollection_B_all_fFunctionT_to_Bool, ptr @InterleavedCollection_B_any_fFunctionT_to_Bool, ptr @InterleavedCollection_B_enumerate_, ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool, ptr @InterleavedCollection_B_chain_otherCollectionT_chain_otherIterableT, ptr @InterleavedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @InterleavedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @InterleavedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @InterleavedCollection_size_, ptr @Collection_is_empty_, ptr @InterleavedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Collection_chain_otherCollectionT, ptr @Iterable_chain_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @InterleavedCollection_field_InterleavedCollection_0, ptr @InterleavedCollection_B_iterator_, ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing, ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleavedCollection_B_all_fFunctionT_to_Bool, ptr @InterleavedCollection_B_any_fFunctionT_to_Bool, ptr @InterleavedCollection_B_enumerate_, ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool, ptr @InterleavedCollection_B_chain_otherCollectionT_chain_otherIterableT, ptr @InterleavedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @InterleavedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @InterleavedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @InterleavedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @InterleavedCollection_field_InterleavedCollection_0, ptr @InterleavedCollection_B_iterator_, ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing, ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @InterleavedCollection_B_all_fFunctionT_to_Bool, ptr @InterleavedCollection_B_any_fFunctionT_to_Bool, ptr @InterleavedCollection_B_enumerate_, ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool, ptr @InterleavedCollection_B_chain_otherCollectionT_chain_otherIterableT, ptr @InterleavedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @InterleavedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @InterleavedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @InterleavedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ZippedCollection_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr null, ptr null, ptr @Object, ptr @ZippedCollection, ptr null, ptr @Collection]
@ZippedCollection_offset_tbl = constant [8 x i32] [i32 10, i32 109, i32 0, i32 0, i32 134, i32 10, i32 0, i32 50]
@ZippedCollection = constant { [3 x i64], [7 x ptr], [124 x ptr] } { [3 x i64] [i64 880335312586431241, i64 4546286743183166287, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ZippedCollection_hashtbl, ptr @ZippedCollection_offset_tbl, ptr @_data_size_ZippedCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [124 x ptr] [ptr @ZippedCollection_field_ZippedCollection_0, ptr @ZippedCollection_field_ZippedCollection_1, ptr @ZippedCollection_field_ZippedCollection_2, ptr @ZippedCollection_field_first, ptr @ZippedCollection_field_second, ptr @ZippedCollection_B_init_firstCollectionT_secondCollectionU, ptr @ZippedCollection_B_size_, ptr @ZippedCollection_B_is_empty_, ptr @ZippedCollection_B_iterator_, ptr @ZippedCollection_B_each_fFunctionT_to_Nothing, ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZippedCollection_B_all_fFunctionT_to_Bool, ptr @ZippedCollection_B_any_fFunctionT_to_Bool, ptr @ZippedCollection_B_enumerate_, ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ZippedCollection_B_filter_fFunctionT_to_Bool, ptr @ZippedCollection_B_chain_otherCollectionT_chain_otherIterableT, ptr @ZippedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ZippedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ZippedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ZippedCollection_init_firstCollectionT_secondCollectionU, ptr @ZippedCollection_size_, ptr @Collection_is_empty_, ptr @ZippedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Collection_chain_otherCollectionT, ptr @Iterable_chain_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @ZippedCollection_field_ZippedCollection_2, ptr @ZippedCollection_B_size_, ptr @ZippedCollection_B_is_empty_, ptr @ZippedCollection_B_iterator_, ptr @ZippedCollection_B_each_fFunctionT_to_Nothing, ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZippedCollection_B_all_fFunctionT_to_Bool, ptr @ZippedCollection_B_any_fFunctionT_to_Bool, ptr @ZippedCollection_B_enumerate_, ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ZippedCollection_B_filter_fFunctionT_to_Bool, ptr @ZippedCollection_B_chain_otherCollectionT_chain_otherIterableT, ptr @ZippedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ZippedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ZippedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ZippedCollection_size_, ptr @Collection_is_empty_, ptr @ZippedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Collection_chain_otherCollectionT, ptr @Iterable_chain_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @ZippedCollection_field_ZippedCollection_2, ptr @ZippedCollection_B_iterator_, ptr @ZippedCollection_B_each_fFunctionT_to_Nothing, ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZippedCollection_B_all_fFunctionT_to_Bool, ptr @ZippedCollection_B_any_fFunctionT_to_Bool, ptr @ZippedCollection_B_enumerate_, ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ZippedCollection_B_filter_fFunctionT_to_Bool, ptr @ZippedCollection_B_chain_otherCollectionT_chain_otherIterableT, ptr @ZippedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ZippedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ZippedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ZippedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ZippedCollection_field_ZippedCollection_2, ptr @ZippedCollection_B_iterator_, ptr @ZippedCollection_B_each_fFunctionT_to_Nothing, ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ZippedCollection_B_all_fFunctionT_to_Bool, ptr @ZippedCollection_B_any_fFunctionT_to_Bool, ptr @ZippedCollection_B_enumerate_, ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ZippedCollection_B_filter_fFunctionT_to_Bool, ptr @ZippedCollection_B_chain_otherCollectionT_chain_otherIterableT, ptr @ZippedCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ZippedCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ZippedCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ZippedCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@ProductCollection_hashtbl = constant [8 x ptr] [ptr @Collection, ptr null, ptr @Object, ptr @any_typ, ptr null, ptr @Iterable, ptr @ProductCollection, ptr null]
@ProductCollection_offset_tbl = constant [8 x i32] [i32 50, i32 0, i32 134, i32 10, i32 0, i32 109, i32 10, i32 0]
@ProductCollection = constant { [3 x i64], [7 x ptr], [124 x ptr] } { [3 x i64] [i64 -310975631771072937, i64 -5539752344751640487, i64 7], [7 x ptr] [ptr @subtype_test, ptr @ProductCollection_hashtbl, ptr @ProductCollection_offset_tbl, ptr @_data_size_ProductCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [124 x ptr] [ptr @ProductCollection_field_ProductCollection_0, ptr @ProductCollection_field_ProductCollection_1, ptr @ProductCollection_field_ProductCollection_2, ptr @ProductCollection_field_first, ptr @ProductCollection_field_second, ptr @ProductCollection_B_init_firstCollectionT_secondCollectionU, ptr @ProductCollection_B_size_, ptr @ProductCollection_B_is_empty_, ptr @ProductCollection_B_iterator_, ptr @ProductCollection_B_each_fFunctionT_to_Nothing, ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductCollection_B_all_fFunctionT_to_Bool, ptr @ProductCollection_B_any_fFunctionT_to_Bool, ptr @ProductCollection_B_enumerate_, ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ProductCollection_B_filter_fFunctionT_to_Bool, ptr @ProductCollection_B_chain_otherCollectionT_chain_otherIterableT, ptr @ProductCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ProductCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ProductCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ProductCollection_init_firstCollectionT_secondCollectionU, ptr @ProductCollection_size_, ptr @Collection_is_empty_, ptr @ProductCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Collection_chain_otherCollectionT, ptr @Iterable_chain_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @ProductCollection_field_ProductCollection_2, ptr @ProductCollection_B_size_, ptr @ProductCollection_B_is_empty_, ptr @ProductCollection_B_iterator_, ptr @ProductCollection_B_each_fFunctionT_to_Nothing, ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductCollection_B_all_fFunctionT_to_Bool, ptr @ProductCollection_B_any_fFunctionT_to_Bool, ptr @ProductCollection_B_enumerate_, ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ProductCollection_B_filter_fFunctionT_to_Bool, ptr @ProductCollection_B_chain_otherCollectionT_chain_otherIterableT, ptr @ProductCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ProductCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ProductCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ProductCollection_size_, ptr @Collection_is_empty_, ptr @ProductCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Collection_chain_otherCollectionT, ptr @Iterable_chain_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @ProductCollection_field_ProductCollection_2, ptr @ProductCollection_B_iterator_, ptr @ProductCollection_B_each_fFunctionT_to_Nothing, ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductCollection_B_all_fFunctionT_to_Bool, ptr @ProductCollection_B_any_fFunctionT_to_Bool, ptr @ProductCollection_B_enumerate_, ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ProductCollection_B_filter_fFunctionT_to_Bool, ptr @ProductCollection_B_chain_otherCollectionT_chain_otherIterableT, ptr @ProductCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ProductCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ProductCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ProductCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @ProductCollection_field_ProductCollection_2, ptr @ProductCollection_B_iterator_, ptr @ProductCollection_B_each_fFunctionT_to_Nothing, ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @ProductCollection_B_all_fFunctionT_to_Bool, ptr @ProductCollection_B_any_fFunctionT_to_Bool, ptr @ProductCollection_B_enumerate_, ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @ProductCollection_B_filter_fFunctionT_to_Bool, ptr @ProductCollection_B_chain_otherCollectionT_chain_otherIterableT, ptr @ProductCollection_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @ProductCollection_B_zip_otherIterableU_zip_otherCollectionU, ptr @ProductCollection_B_product_otherIterableU_product_otherCollectionU, ptr @ProductCollection_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@EnumeratedCollection_field_iterable = internal constant { ptr, ptr } { ptr @EnumeratedCollection_getter_iterable, ptr @EnumeratedCollection_setter_iterable }
@MappedCollection_field_iterable = internal constant { ptr, ptr } { ptr @MappedCollection_getter_iterable, ptr @MappedCollection_setter_iterable }
@MappedCollection_field_f = internal constant { ptr, ptr } { ptr @MappedCollection_getter_f, ptr @MappedCollection_setter_f }
@ChainedCollection_field_first = internal constant { ptr, ptr } { ptr @ChainedCollection_getter_first, ptr @ChainedCollection_setter_first }
@ChainedCollection_field_second = internal constant { ptr, ptr } { ptr @ChainedCollection_getter_second, ptr @ChainedCollection_setter_second }
@InterleavedCollection_field_first = internal constant { ptr, ptr } { ptr @InterleavedCollection_getter_first, ptr @InterleavedCollection_setter_first }
@InterleavedCollection_field_second = internal constant { ptr, ptr } { ptr @InterleavedCollection_getter_second, ptr @InterleavedCollection_setter_second }
@ZippedCollection_field_first = internal constant { ptr, ptr } { ptr @ZippedCollection_getter_first, ptr @ZippedCollection_setter_first }
@ZippedCollection_field_second = internal constant { ptr, ptr } { ptr @ZippedCollection_getter_second, ptr @ZippedCollection_setter_second }
@ProductCollection_field_first = internal constant { ptr, ptr } { ptr @ProductCollection_getter_first, ptr @ProductCollection_setter_first }
@ProductCollection_field_second = internal constant { ptr, ptr } { ptr @ProductCollection_getter_second, ptr @ProductCollection_setter_second }

declare i32 @printf(ptr, ...)

declare ptr @bump_malloc(i64)

declare void @free(ptr)

declare void @setup_landing_pad()

declare void @anoint_trampoline(ptr)

declare ptr @adjust_trampoline(ptr)

declare ptr @coroutine_create(ptr, ptr)

declare void @arg_passer(ptr)

declare void @arg_buffer_filler(ptr)

declare void @coroutine_yield(ptr)

declare void @coroutine_yield_cold(ptr)

declare ptr @get_current_coroutine()

declare i32 @get_offset(ptr, ptr)

declare void @assume_offset(ptr, ptr)

declare { ptr, i160 } @_box_Default(ptr, ptr)

declare void @_unbox_Default({ ptr, i160 }, ptr, ptr)

declare { i64, i64 } @_size_Default(ptr)

declare void @_unbox_union_typ({ ptr, i160 }, ptr, ptr)

declare { i64, i64 } @_data_size_tuple_typ(ptr)

declare { i64, i64 } @_data_size_union_typ(ptr)

declare i1 @subtype_test(i64, i64, i64, i64, ptr)

declare i1 @subtype_test_wrapper(ptr, i64, i64, i64, i64, ptr)

declare { i64, i64 } @size_wrapper(ptr, ptr)

declare ptr @typegetter_wrapper(ptr, ptr)

declare { ptr, i160 } @box_wrapper(ptr, ptr, ptr)

declare void @unbox_wrapper(ptr, { ptr, i160 }, ptr, ptr)

declare ptr @behavior_wrapper(ptr, { ptr, ptr, ptr, i32 }, ptr)

declare ptr @class_behavior_wrapper(ptr, ptr)

declare void @coroutine_call(ptr)

define { i64, i64 } @_data_size_Collection(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %3
  %5 = icmp eq i64 %4, 0
  %6 = sub i64 %3, %4
  %7 = select i1 %5, i64 0, i64 %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = insertvalue { i64, i64 } undef, i64 %8, 0
  %10 = insertvalue { i64, i64 } %9, i64 %3, 1
  ret { i64, i64 } %10
}

define ptr @Collection_field_Collection_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define ptr @Collection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 15, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [59 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define i1 @Collection_is_empty_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %8, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %6, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %8, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @Collection)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %8, align 8
  %20 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %19, 0
  %21 = load ptr, ptr %7, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %21, 1
  %23 = load ptr, ptr %6, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %23, 2
  %25 = load i32, ptr %5, align 4
  %26 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %25, 3
  %27 = alloca [0 x ptr], align 8
  %28 = call ptr @llvm.invariant.start.p0(i64 0, ptr %27)
  %29 = call ptr @llvm.invariant.start.p0(i64 472, ptr %19)
  %30 = getelementptr ptr, ptr %19, i32 %25
  %31 = getelementptr ptr, ptr %30, i32 1
  %32 = load ptr, ptr %31, align 8
  %33 = alloca {}, align 8
  %34 = call ptr @behavior_wrapper(ptr %32, { ptr, ptr, ptr, i32 } %26, ptr %33)
  %35 = call i32 %34({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr %27)
  %36 = alloca i32, align 4
  store i32 %35, ptr %36, align 4
  %37 = alloca i32, align 4
  store i32 0, ptr %37, align 4
  %38 = load i32, ptr %36, align 4
  %39 = load i32, ptr %37, align 4
  %40 = icmp eq i32 %38, %39
  %41 = alloca i1, align 1
  %42 = zext i1 %40 to i8
  store i8 %42, ptr %41, align 1
  %43 = load i8, ptr %41, align 1
  %44 = trunc i8 %43 to i1
  ret i1 %44
}

define ptr @Collection_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 16, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [59 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

declare { ptr, ptr, ptr, i32 } @Iterable_iterator_()

define ptr @Collection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 17, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [59 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

declare void @Iterable_each_fFunctionT_to_Nothing({ ptr })

define ptr @Collection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 18, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [59 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

declare { ptr, i160 } @Iterable_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, i160 }, { ptr })

define ptr @Collection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @any_typ, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @any_typ to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = ptrtoint ptr %20 to i64
  %22 = icmp eq i64 %21, ptrtoint (ptr @function_typ to i64)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 19, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [59 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

declare i1 @Iterable_all_fFunctionT_to_Bool({ ptr })

define ptr @Collection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 20, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [59 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

declare i1 @Iterable_any_fFunctionT_to_Bool({ ptr })

define ptr @Collection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 21, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [59 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define { ptr, ptr, ptr, i32 } @Collection_enumerate_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @Collection)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 472, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = load ptr, ptr %23, align 8
  %25 = call ptr @typegetter_wrapper(ptr %24, ptr %19)
  %26 = load ptr, ptr %7, align 8
  %27 = load ptr, ptr %6, align 8
  %28 = call ptr @llvm.invariant.start.p0(i64 472, ptr %27)
  %29 = load i32, ptr %5, align 4
  %30 = getelementptr ptr, ptr %27, i32 %29
  %31 = load ptr, ptr %30, align 8
  %32 = call ptr @typegetter_wrapper(ptr %31, ptr %26)
  %33 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([4 x ptr], ptr null, i32 1) to i64))
  %34 = getelementptr [4 x ptr], ptr %33, i32 0, i32 2
  store ptr %32, ptr %34, align 8
  %35 = getelementptr [4 x ptr], ptr %33, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %35, align 8
  %36 = getelementptr [4 x ptr], ptr %33, i32 0, i32 3
  store ptr null, ptr %36, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 24, ptr %33)
  store ptr @Pair, ptr %33, align 8
  %38 = alloca [3 x ptr], align 8
  store ptr @EnumeratedCollection, ptr %38, align 8
  %39 = getelementptr ptr, ptr %38, i32 1
  store ptr %25, ptr %39, align 8
  %40 = getelementptr ptr, ptr %38, i32 2
  store ptr %33, ptr %40, align 8
  %41 = load ptr, ptr %38, align 8
  %42 = getelementptr ptr, ptr %41, i32 6
  %43 = load ptr, ptr %42, align 8
  %44 = call { i64, i64 } @size_wrapper(ptr %43, ptr %38)
  %45 = extractvalue { i64, i64 } %44, 0
  %46 = call ptr @bump_malloc(i64 %45)
  store ptr %25, ptr %46, align 8
  %47 = getelementptr ptr, ptr %46, i32 1
  store ptr %33, ptr %47, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 16, ptr %46)
  %49 = alloca i32, align 4
  %50 = alloca ptr, align 8
  %51 = alloca ptr, align 8
  %52 = alloca ptr, align 8
  store ptr @EnumeratedCollection, ptr %52, align 8
  store ptr %46, ptr %51, align 8
  store i32 10, ptr %49, align 4
  %53 = alloca i32, align 4
  %54 = alloca ptr, align 8
  %55 = alloca ptr, align 8
  %56 = alloca ptr, align 8
  %57 = load ptr, ptr %6, align 8
  store ptr %57, ptr %56, align 8
  %58 = load ptr, ptr %7, align 8
  store ptr %58, ptr %55, align 8
  %59 = load ptr, ptr %8, align 8
  store ptr %59, ptr %54, align 8
  %60 = load i32, ptr %5, align 4
  store i32 %60, ptr %53, align 4
  %61 = load ptr, ptr %56, align 8
  %62 = call i32 @get_offset(ptr %61, ptr @Collection)
  store i32 %62, ptr %53, align 4
  %63 = load ptr, ptr %56, align 8
  %64 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %63, 0
  %65 = load ptr, ptr %55, align 8
  %66 = insertvalue { ptr, ptr, ptr, i32 } %64, ptr %65, 1
  %67 = load ptr, ptr %54, align 8
  %68 = insertvalue { ptr, ptr, ptr, i32 } %66, ptr %67, 2
  %69 = load i32, ptr %53, align 4
  %70 = insertvalue { ptr, ptr, ptr, i32 } %68, i32 %69, 3
  %71 = load ptr, ptr %52, align 8
  %72 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %71, 0
  %73 = load ptr, ptr %51, align 8
  %74 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr %73, 1
  %75 = load ptr, ptr %50, align 8
  %76 = insertvalue { ptr, ptr, ptr, i32 } %74, ptr %75, 2
  %77 = load i32, ptr %49, align 4
  %78 = insertvalue { ptr, ptr, ptr, i32 } %76, i32 %77, 3
  %79 = load ptr, ptr %7, align 8
  %80 = load ptr, ptr %6, align 8
  %81 = call ptr @llvm.invariant.start.p0(i64 472, ptr %80)
  %82 = load i32, ptr %5, align 4
  %83 = getelementptr ptr, ptr %80, i32 %82
  %84 = load ptr, ptr %83, align 8
  %85 = call ptr @typegetter_wrapper(ptr %84, ptr %79)
  %86 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %87 = getelementptr [3 x ptr], ptr %86, i32 0, i32 1
  store ptr %85, ptr %87, align 8
  %88 = getelementptr [3 x ptr], ptr %86, i32 0, i32 2
  store ptr null, ptr %88, align 8
  %89 = call ptr @llvm.invariant.start.p0(i64 16, ptr %86)
  store ptr @Collection, ptr %86, align 8
  %90 = alloca [1 x ptr], align 8
  %91 = getelementptr [1 x ptr], ptr %90, i32 0, i32 0
  store ptr %86, ptr %91, align 8
  %92 = call ptr @llvm.invariant.start.p0(i64 1, ptr %90)
  %93 = call ptr @llvm.invariant.start.p0(i64 976, ptr %71)
  %94 = getelementptr ptr, ptr %71, i32 %77
  %95 = getelementptr ptr, ptr %94, i32 3
  %96 = load ptr, ptr %95, align 8
  %97 = alloca { ptr }, align 8
  %98 = getelementptr { ptr }, ptr %97, i32 0, i32 0
  store ptr %63, ptr %98, align 8
  %99 = call ptr @behavior_wrapper(ptr %96, { ptr, ptr, ptr, i32 } %78, ptr %97)
  call void %99({ ptr, ptr, ptr, i32 } %78, { ptr, ptr, ptr, i32 } %78, ptr %90, { ptr, ptr, ptr, i32 } %70)
  %100 = alloca i32, align 4
  %101 = alloca ptr, align 8
  %102 = alloca ptr, align 8
  %103 = alloca ptr, align 8
  %104 = load ptr, ptr %52, align 8
  store ptr %104, ptr %103, align 8
  %105 = load ptr, ptr %51, align 8
  store ptr %105, ptr %102, align 8
  %106 = load ptr, ptr %50, align 8
  store ptr %106, ptr %101, align 8
  %107 = load i32, ptr %49, align 4
  store i32 %107, ptr %100, align 4
  %108 = load ptr, ptr %103, align 8
  %109 = call i32 @get_offset(ptr %108, ptr @Iterable)
  store i32 %109, ptr %100, align 4
  %110 = load ptr, ptr %103, align 8
  %111 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %110, 0
  %112 = load ptr, ptr %102, align 8
  %113 = insertvalue { ptr, ptr, ptr, i32 } %111, ptr %112, 1
  %114 = load ptr, ptr %101, align 8
  %115 = insertvalue { ptr, ptr, ptr, i32 } %113, ptr %114, 2
  %116 = load i32, ptr %100, align 4
  %117 = insertvalue { ptr, ptr, ptr, i32 } %115, i32 %116, 3
  ret { ptr, ptr, ptr, i32 } %117
}

define ptr @Collection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 22, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [59 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

declare { ptr, ptr, ptr, i32 } @Iterable_map_fFunctionT_to_U({ ptr })

define { ptr, ptr, ptr, i32 } @Collection_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr } %3) {
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %5, align 8
  %6 = alloca i32, align 4
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %7, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %8, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %9, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = call i32 @get_offset(ptr %18, ptr @Collection)
  store i32 %19, ptr %6, align 4
  %20 = alloca ptr, align 8
  store { ptr } %3, ptr %20, align 8
  %21 = load ptr, ptr %8, align 8
  %22 = load ptr, ptr %7, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 472, ptr %22)
  %24 = load i32, ptr %6, align 4
  %25 = getelementptr ptr, ptr %22, i32 %24
  %26 = load ptr, ptr %25, align 8
  %27 = call ptr @typegetter_wrapper(ptr %26, ptr %21)
  %28 = load ptr, ptr %2, align 8
  %29 = getelementptr [1 x ptr], ptr %28, i32 0, i32 1
  %30 = load ptr, ptr %29, align 8
  %31 = alloca [3 x ptr], align 8
  store ptr @MappedCollection, ptr %31, align 8
  %32 = getelementptr ptr, ptr %31, i32 1
  store ptr %27, ptr %32, align 8
  %33 = getelementptr ptr, ptr %31, i32 2
  store ptr %30, ptr %33, align 8
  %34 = load ptr, ptr %31, align 8
  %35 = getelementptr ptr, ptr %34, i32 6
  %36 = load ptr, ptr %35, align 8
  %37 = call { i64, i64 } @size_wrapper(ptr %36, ptr %31)
  %38 = extractvalue { i64, i64 } %37, 0
  %39 = call ptr @bump_malloc(i64 %38)
  store ptr %27, ptr %39, align 8
  %40 = getelementptr ptr, ptr %39, i32 1
  store ptr %30, ptr %40, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 16, ptr %39)
  %42 = alloca i32, align 4
  %43 = alloca ptr, align 8
  %44 = alloca ptr, align 8
  %45 = alloca ptr, align 8
  store ptr @MappedCollection, ptr %45, align 8
  store ptr %39, ptr %44, align 8
  store i32 10, ptr %42, align 4
  %46 = alloca i32, align 4
  %47 = alloca ptr, align 8
  %48 = alloca ptr, align 8
  %49 = alloca ptr, align 8
  %50 = load ptr, ptr %7, align 8
  store ptr %50, ptr %49, align 8
  %51 = load ptr, ptr %8, align 8
  store ptr %51, ptr %48, align 8
  %52 = load ptr, ptr %9, align 8
  store ptr %52, ptr %47, align 8
  %53 = load i32, ptr %6, align 4
  store i32 %53, ptr %46, align 4
  %54 = load ptr, ptr %49, align 8
  %55 = call i32 @get_offset(ptr %54, ptr @Collection)
  store i32 %55, ptr %46, align 4
  %56 = load ptr, ptr %49, align 8
  %57 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %56, 0
  %58 = load ptr, ptr %48, align 8
  %59 = insertvalue { ptr, ptr, ptr, i32 } %57, ptr %58, 1
  %60 = load ptr, ptr %47, align 8
  %61 = insertvalue { ptr, ptr, ptr, i32 } %59, ptr %60, 2
  %62 = load i32, ptr %46, align 4
  %63 = insertvalue { ptr, ptr, ptr, i32 } %61, i32 %62, 3
  %64 = load ptr, ptr %20, align 8
  %65 = insertvalue { ptr } undef, ptr %64, 0
  %66 = load ptr, ptr %45, align 8
  %67 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %66, 0
  %68 = load ptr, ptr %44, align 8
  %69 = insertvalue { ptr, ptr, ptr, i32 } %67, ptr %68, 1
  %70 = load ptr, ptr %43, align 8
  %71 = insertvalue { ptr, ptr, ptr, i32 } %69, ptr %70, 2
  %72 = load i32, ptr %42, align 4
  %73 = insertvalue { ptr, ptr, ptr, i32 } %71, i32 %72, 3
  %74 = load ptr, ptr %8, align 8
  %75 = load ptr, ptr %7, align 8
  %76 = call ptr @llvm.invariant.start.p0(i64 472, ptr %75)
  %77 = load i32, ptr %6, align 4
  %78 = getelementptr ptr, ptr %75, i32 %77
  %79 = load ptr, ptr %78, align 8
  %80 = call ptr @typegetter_wrapper(ptr %79, ptr %74)
  %81 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %82 = getelementptr [3 x ptr], ptr %81, i32 0, i32 1
  store ptr %80, ptr %82, align 8
  %83 = getelementptr [3 x ptr], ptr %81, i32 0, i32 2
  store ptr null, ptr %83, align 8
  %84 = call ptr @llvm.invariant.start.p0(i64 16, ptr %81)
  store ptr @Collection, ptr %81, align 8
  %85 = load ptr, ptr %2, align 8
  %86 = getelementptr [1 x ptr], ptr %85, i32 0, i32 1
  %87 = load ptr, ptr %86, align 8
  %88 = load ptr, ptr %8, align 8
  %89 = load ptr, ptr %7, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 472, ptr %89)
  %91 = load i32, ptr %6, align 4
  %92 = getelementptr ptr, ptr %89, i32 %91
  %93 = load ptr, ptr %92, align 8
  %94 = call ptr @typegetter_wrapper(ptr %93, ptr %88)
  %95 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([4 x ptr], ptr null, i32 1) to i64))
  %96 = getelementptr [4 x ptr], ptr %95, i32 0, i32 2
  store ptr %94, ptr %96, align 8
  %97 = getelementptr [4 x ptr], ptr %95, i32 0, i32 1
  store ptr %87, ptr %97, align 8
  %98 = getelementptr [4 x ptr], ptr %95, i32 0, i32 3
  store ptr null, ptr %98, align 8
  %99 = call ptr @llvm.invariant.start.p0(i64 24, ptr %95)
  store ptr @function_typ, ptr %95, align 8
  %100 = alloca [2 x ptr], align 8
  %101 = getelementptr [2 x ptr], ptr %100, i32 0, i32 0
  store ptr %81, ptr %101, align 8
  %102 = getelementptr [2 x ptr], ptr %100, i32 0, i32 1
  store ptr %95, ptr %102, align 8
  %103 = call ptr @llvm.invariant.start.p0(i64 4, ptr %100)
  %104 = call ptr @llvm.invariant.start.p0(i64 984, ptr %66)
  %105 = getelementptr ptr, ptr %66, i32 %72
  %106 = getelementptr ptr, ptr %105, i32 4
  %107 = load ptr, ptr %106, align 8
  %108 = alloca { ptr, ptr }, align 8
  %109 = getelementptr { ptr, ptr }, ptr %108, i32 0, i32 0
  store ptr %56, ptr %109, align 8
  %110 = getelementptr { ptr, ptr }, ptr %108, i32 0, i32 1
  store ptr @function_typ, ptr %110, align 8
  %111 = call ptr @behavior_wrapper(ptr %107, { ptr, ptr, ptr, i32 } %73, ptr %108)
  call void %111({ ptr, ptr, ptr, i32 } %73, { ptr, ptr, ptr, i32 } %73, ptr %100, { ptr, ptr, ptr, i32 } %63, { ptr } %65)
  %112 = alloca i32, align 4
  %113 = alloca ptr, align 8
  %114 = alloca ptr, align 8
  %115 = alloca ptr, align 8
  %116 = load ptr, ptr %45, align 8
  store ptr %116, ptr %115, align 8
  %117 = load ptr, ptr %44, align 8
  store ptr %117, ptr %114, align 8
  %118 = load ptr, ptr %43, align 8
  store ptr %118, ptr %113, align 8
  %119 = load i32, ptr %42, align 4
  store i32 %119, ptr %112, align 4
  %120 = load ptr, ptr %115, align 8
  %121 = call i32 @get_offset(ptr %120, ptr @Iterable)
  store i32 %121, ptr %112, align 4
  %122 = load ptr, ptr %115, align 8
  %123 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %122, 0
  %124 = load ptr, ptr %114, align 8
  %125 = insertvalue { ptr, ptr, ptr, i32 } %123, ptr %124, 1
  %126 = load ptr, ptr %113, align 8
  %127 = insertvalue { ptr, ptr, ptr, i32 } %125, ptr %126, 2
  %128 = load i32, ptr %112, align 4
  %129 = insertvalue { ptr, ptr, ptr, i32 } %127, i32 %128, 3
  ret { ptr, ptr, ptr, i32 } %129
}

define ptr @Collection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = ptrtoint ptr %7 to i64
  %9 = icmp eq i64 %8, ptrtoint (ptr @function_typ to i64)
  %10 = zext i1 %9 to i8
  store i8 %10, ptr %3, align 1
  %11 = load i8, ptr %3, align 1
  %12 = trunc i8 %11 to i1
  %13 = select i1 %12, i32 64, i32 63
  br i1 %12, label %14, label %15

14:                                               ; preds = %2
  br label %20

15:                                               ; preds = %2
  %16 = load ptr, ptr %1, align 8
  %17 = ptrtoint ptr %16 to i64
  %18 = icmp eq i64 %17, ptrtoint (ptr @function_typ to i64)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %4, align 1
  br label %20

20:                                               ; preds = %14, %15
  store i32 %13, ptr %6, align 4
  %21 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %22 = load i32, ptr %6, align 4
  %23 = getelementptr [59 x ptr], ptr %21, i32 0, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 10
  %25 = load ptr, ptr %24, align 8
  ret ptr %25
}

declare { ptr, ptr, ptr, i32 } @Iterable_filter_fFunctionT_to_Bool({ ptr })

define ptr @Collection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 25, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [59 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define { ptr, ptr, ptr, i32 } @Collection_chain_otherCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3) {
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %5, align 8
  %6 = alloca i32, align 4
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %7, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %8, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %9, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = call i32 @get_offset(ptr %18, ptr @Collection)
  store i32 %19, ptr %6, align 4
  %20 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %20, align 8
  %21 = alloca i32, align 4
  %22 = alloca ptr, align 8
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  store ptr %26, ptr %24, align 8
  %27 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 1
  %28 = load ptr, ptr %27, align 8
  store ptr %28, ptr %23, align 8
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 2
  %30 = load ptr, ptr %29, align 8
  store ptr %30, ptr %22, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 3
  %32 = load i32, ptr %31, align 4
  store i32 %32, ptr %21, align 4
  %33 = load ptr, ptr %24, align 8
  %34 = call i32 @get_offset(ptr %33, ptr @Collection)
  store i32 %34, ptr %21, align 4
  %35 = load ptr, ptr %8, align 8
  %36 = load ptr, ptr %7, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 472, ptr %36)
  %38 = load i32, ptr %6, align 4
  %39 = getelementptr ptr, ptr %36, i32 %38
  %40 = load ptr, ptr %39, align 8
  %41 = call ptr @typegetter_wrapper(ptr %40, ptr %35)
  %42 = alloca [2 x ptr], align 8
  store ptr @ChainedCollection, ptr %42, align 8
  %43 = getelementptr ptr, ptr %42, i32 1
  store ptr %41, ptr %43, align 8
  %44 = load ptr, ptr %42, align 8
  %45 = getelementptr ptr, ptr %44, i32 6
  %46 = load ptr, ptr %45, align 8
  %47 = call { i64, i64 } @size_wrapper(ptr %46, ptr %42)
  %48 = extractvalue { i64, i64 } %47, 0
  %49 = call ptr @bump_malloc(i64 %48)
  store ptr %41, ptr %49, align 8
  %50 = call ptr @llvm.invariant.start.p0(i64 8, ptr %49)
  %51 = alloca i32, align 4
  %52 = alloca ptr, align 8
  %53 = alloca ptr, align 8
  %54 = alloca ptr, align 8
  store ptr @ChainedCollection, ptr %54, align 8
  store ptr %49, ptr %53, align 8
  store i32 10, ptr %51, align 4
  %55 = alloca i32, align 4
  %56 = alloca ptr, align 8
  %57 = alloca ptr, align 8
  %58 = alloca ptr, align 8
  %59 = load ptr, ptr %7, align 8
  store ptr %59, ptr %58, align 8
  %60 = load ptr, ptr %8, align 8
  store ptr %60, ptr %57, align 8
  %61 = load ptr, ptr %9, align 8
  store ptr %61, ptr %56, align 8
  %62 = load i32, ptr %6, align 4
  store i32 %62, ptr %55, align 4
  %63 = load ptr, ptr %58, align 8
  %64 = call i32 @get_offset(ptr %63, ptr @Collection)
  store i32 %64, ptr %55, align 4
  %65 = load ptr, ptr %58, align 8
  %66 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %65, 0
  %67 = load ptr, ptr %57, align 8
  %68 = insertvalue { ptr, ptr, ptr, i32 } %66, ptr %67, 1
  %69 = load ptr, ptr %56, align 8
  %70 = insertvalue { ptr, ptr, ptr, i32 } %68, ptr %69, 2
  %71 = load i32, ptr %55, align 4
  %72 = insertvalue { ptr, ptr, ptr, i32 } %70, i32 %71, 3
  %73 = alloca i32, align 4
  %74 = alloca ptr, align 8
  %75 = alloca ptr, align 8
  %76 = alloca ptr, align 8
  %77 = load ptr, ptr %24, align 8
  store ptr %77, ptr %76, align 8
  %78 = load ptr, ptr %23, align 8
  store ptr %78, ptr %75, align 8
  %79 = load ptr, ptr %22, align 8
  store ptr %79, ptr %74, align 8
  %80 = load i32, ptr %21, align 4
  store i32 %80, ptr %73, align 4
  %81 = load ptr, ptr %76, align 8
  %82 = call i32 @get_offset(ptr %81, ptr @Collection)
  store i32 %82, ptr %73, align 4
  %83 = load ptr, ptr %76, align 8
  %84 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %83, 0
  %85 = load ptr, ptr %75, align 8
  %86 = insertvalue { ptr, ptr, ptr, i32 } %84, ptr %85, 1
  %87 = load ptr, ptr %74, align 8
  %88 = insertvalue { ptr, ptr, ptr, i32 } %86, ptr %87, 2
  %89 = load i32, ptr %73, align 4
  %90 = insertvalue { ptr, ptr, ptr, i32 } %88, i32 %89, 3
  %91 = load ptr, ptr %54, align 8
  %92 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %91, 0
  %93 = load ptr, ptr %53, align 8
  %94 = insertvalue { ptr, ptr, ptr, i32 } %92, ptr %93, 1
  %95 = load ptr, ptr %52, align 8
  %96 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr %95, 2
  %97 = load i32, ptr %51, align 4
  %98 = insertvalue { ptr, ptr, ptr, i32 } %96, i32 %97, 3
  %99 = load ptr, ptr %8, align 8
  %100 = load ptr, ptr %7, align 8
  %101 = call ptr @llvm.invariant.start.p0(i64 472, ptr %100)
  %102 = load i32, ptr %6, align 4
  %103 = getelementptr ptr, ptr %100, i32 %102
  %104 = load ptr, ptr %103, align 8
  %105 = call ptr @typegetter_wrapper(ptr %104, ptr %99)
  %106 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %107 = getelementptr [3 x ptr], ptr %106, i32 0, i32 1
  store ptr %105, ptr %107, align 8
  %108 = getelementptr [3 x ptr], ptr %106, i32 0, i32 2
  store ptr null, ptr %108, align 8
  %109 = call ptr @llvm.invariant.start.p0(i64 16, ptr %106)
  store ptr @Collection, ptr %106, align 8
  %110 = load ptr, ptr %8, align 8
  %111 = load ptr, ptr %7, align 8
  %112 = call ptr @llvm.invariant.start.p0(i64 472, ptr %111)
  %113 = load i32, ptr %6, align 4
  %114 = getelementptr ptr, ptr %111, i32 %113
  %115 = load ptr, ptr %114, align 8
  %116 = call ptr @typegetter_wrapper(ptr %115, ptr %110)
  %117 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %118 = getelementptr [3 x ptr], ptr %117, i32 0, i32 1
  store ptr %116, ptr %118, align 8
  %119 = getelementptr [3 x ptr], ptr %117, i32 0, i32 2
  store ptr null, ptr %119, align 8
  %120 = call ptr @llvm.invariant.start.p0(i64 16, ptr %117)
  store ptr @Collection, ptr %117, align 8
  %121 = alloca [2 x ptr], align 8
  %122 = getelementptr [2 x ptr], ptr %121, i32 0, i32 0
  store ptr %106, ptr %122, align 8
  %123 = getelementptr [2 x ptr], ptr %121, i32 0, i32 1
  store ptr %117, ptr %123, align 8
  %124 = call ptr @llvm.invariant.start.p0(i64 4, ptr %121)
  %125 = call ptr @llvm.invariant.start.p0(i64 976, ptr %91)
  %126 = getelementptr ptr, ptr %91, i32 %97
  %127 = getelementptr ptr, ptr %126, i32 3
  %128 = load ptr, ptr %127, align 8
  %129 = alloca { ptr, ptr }, align 8
  %130 = getelementptr { ptr, ptr }, ptr %129, i32 0, i32 0
  store ptr %65, ptr %130, align 8
  %131 = getelementptr { ptr, ptr }, ptr %129, i32 0, i32 1
  store ptr %83, ptr %131, align 8
  %132 = call ptr @behavior_wrapper(ptr %128, { ptr, ptr, ptr, i32 } %98, ptr %129)
  call void %132({ ptr, ptr, ptr, i32 } %98, { ptr, ptr, ptr, i32 } %98, ptr %121, { ptr, ptr, ptr, i32 } %72, { ptr, ptr, ptr, i32 } %90)
  %133 = alloca i32, align 4
  %134 = alloca ptr, align 8
  %135 = alloca ptr, align 8
  %136 = alloca ptr, align 8
  %137 = load ptr, ptr %54, align 8
  store ptr %137, ptr %136, align 8
  %138 = load ptr, ptr %53, align 8
  store ptr %138, ptr %135, align 8
  %139 = load ptr, ptr %52, align 8
  store ptr %139, ptr %134, align 8
  %140 = load i32, ptr %51, align 4
  store i32 %140, ptr %133, align 4
  %141 = load ptr, ptr %136, align 8
  %142 = call i32 @get_offset(ptr %141, ptr @Iterable)
  store i32 %142, ptr %133, align 4
  %143 = load ptr, ptr %136, align 8
  %144 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %143, 0
  %145 = load ptr, ptr %135, align 8
  %146 = insertvalue { ptr, ptr, ptr, i32 } %144, ptr %145, 1
  %147 = load ptr, ptr %134, align 8
  %148 = insertvalue { ptr, ptr, ptr, i32 } %146, ptr %147, 2
  %149 = load i32, ptr %133, align 4
  %150 = insertvalue { ptr, ptr, ptr, i32 } %148, i32 %149, 3
  ret { ptr, ptr, ptr, i32 } %150
}

declare { ptr, ptr, ptr, i32 } @Iterable_chain_otherIterableT({ ptr, ptr, ptr, i32 })

define ptr @Collection_B_chain_otherCollectionT_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 26, i32 27
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [59 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

define { ptr, ptr, ptr, i32 } @Collection_interleave_otherCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3) {
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %5, align 8
  %6 = alloca i32, align 4
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %7, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %8, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %9, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = call i32 @get_offset(ptr %18, ptr @Collection)
  store i32 %19, ptr %6, align 4
  %20 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %20, align 8
  %21 = alloca i32, align 4
  %22 = alloca ptr, align 8
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  store ptr %26, ptr %24, align 8
  %27 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 1
  %28 = load ptr, ptr %27, align 8
  store ptr %28, ptr %23, align 8
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 2
  %30 = load ptr, ptr %29, align 8
  store ptr %30, ptr %22, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 3
  %32 = load i32, ptr %31, align 4
  store i32 %32, ptr %21, align 4
  %33 = load ptr, ptr %24, align 8
  %34 = call i32 @get_offset(ptr %33, ptr @Collection)
  store i32 %34, ptr %21, align 4
  %35 = load ptr, ptr %8, align 8
  %36 = load ptr, ptr %7, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 472, ptr %36)
  %38 = load i32, ptr %6, align 4
  %39 = getelementptr ptr, ptr %36, i32 %38
  %40 = load ptr, ptr %39, align 8
  %41 = call ptr @typegetter_wrapper(ptr %40, ptr %35)
  %42 = alloca [2 x ptr], align 8
  store ptr @InterleavedCollection, ptr %42, align 8
  %43 = getelementptr ptr, ptr %42, i32 1
  store ptr %41, ptr %43, align 8
  %44 = load ptr, ptr %42, align 8
  %45 = getelementptr ptr, ptr %44, i32 6
  %46 = load ptr, ptr %45, align 8
  %47 = call { i64, i64 } @size_wrapper(ptr %46, ptr %42)
  %48 = extractvalue { i64, i64 } %47, 0
  %49 = call ptr @bump_malloc(i64 %48)
  store ptr %41, ptr %49, align 8
  %50 = call ptr @llvm.invariant.start.p0(i64 8, ptr %49)
  %51 = alloca i32, align 4
  %52 = alloca ptr, align 8
  %53 = alloca ptr, align 8
  %54 = alloca ptr, align 8
  store ptr @InterleavedCollection, ptr %54, align 8
  store ptr %49, ptr %53, align 8
  store i32 10, ptr %51, align 4
  %55 = alloca i32, align 4
  %56 = alloca ptr, align 8
  %57 = alloca ptr, align 8
  %58 = alloca ptr, align 8
  %59 = load ptr, ptr %7, align 8
  store ptr %59, ptr %58, align 8
  %60 = load ptr, ptr %8, align 8
  store ptr %60, ptr %57, align 8
  %61 = load ptr, ptr %9, align 8
  store ptr %61, ptr %56, align 8
  %62 = load i32, ptr %6, align 4
  store i32 %62, ptr %55, align 4
  %63 = load ptr, ptr %58, align 8
  %64 = call i32 @get_offset(ptr %63, ptr @Collection)
  store i32 %64, ptr %55, align 4
  %65 = load ptr, ptr %58, align 8
  %66 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %65, 0
  %67 = load ptr, ptr %57, align 8
  %68 = insertvalue { ptr, ptr, ptr, i32 } %66, ptr %67, 1
  %69 = load ptr, ptr %56, align 8
  %70 = insertvalue { ptr, ptr, ptr, i32 } %68, ptr %69, 2
  %71 = load i32, ptr %55, align 4
  %72 = insertvalue { ptr, ptr, ptr, i32 } %70, i32 %71, 3
  %73 = alloca i32, align 4
  %74 = alloca ptr, align 8
  %75 = alloca ptr, align 8
  %76 = alloca ptr, align 8
  %77 = load ptr, ptr %24, align 8
  store ptr %77, ptr %76, align 8
  %78 = load ptr, ptr %23, align 8
  store ptr %78, ptr %75, align 8
  %79 = load ptr, ptr %22, align 8
  store ptr %79, ptr %74, align 8
  %80 = load i32, ptr %21, align 4
  store i32 %80, ptr %73, align 4
  %81 = load ptr, ptr %76, align 8
  %82 = call i32 @get_offset(ptr %81, ptr @Collection)
  store i32 %82, ptr %73, align 4
  %83 = load ptr, ptr %76, align 8
  %84 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %83, 0
  %85 = load ptr, ptr %75, align 8
  %86 = insertvalue { ptr, ptr, ptr, i32 } %84, ptr %85, 1
  %87 = load ptr, ptr %74, align 8
  %88 = insertvalue { ptr, ptr, ptr, i32 } %86, ptr %87, 2
  %89 = load i32, ptr %73, align 4
  %90 = insertvalue { ptr, ptr, ptr, i32 } %88, i32 %89, 3
  %91 = load ptr, ptr %54, align 8
  %92 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %91, 0
  %93 = load ptr, ptr %53, align 8
  %94 = insertvalue { ptr, ptr, ptr, i32 } %92, ptr %93, 1
  %95 = load ptr, ptr %52, align 8
  %96 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr %95, 2
  %97 = load i32, ptr %51, align 4
  %98 = insertvalue { ptr, ptr, ptr, i32 } %96, i32 %97, 3
  %99 = load ptr, ptr %8, align 8
  %100 = load ptr, ptr %7, align 8
  %101 = call ptr @llvm.invariant.start.p0(i64 472, ptr %100)
  %102 = load i32, ptr %6, align 4
  %103 = getelementptr ptr, ptr %100, i32 %102
  %104 = load ptr, ptr %103, align 8
  %105 = call ptr @typegetter_wrapper(ptr %104, ptr %99)
  %106 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %107 = getelementptr [3 x ptr], ptr %106, i32 0, i32 1
  store ptr %105, ptr %107, align 8
  %108 = getelementptr [3 x ptr], ptr %106, i32 0, i32 2
  store ptr null, ptr %108, align 8
  %109 = call ptr @llvm.invariant.start.p0(i64 16, ptr %106)
  store ptr @Collection, ptr %106, align 8
  %110 = load ptr, ptr %8, align 8
  %111 = load ptr, ptr %7, align 8
  %112 = call ptr @llvm.invariant.start.p0(i64 472, ptr %111)
  %113 = load i32, ptr %6, align 4
  %114 = getelementptr ptr, ptr %111, i32 %113
  %115 = load ptr, ptr %114, align 8
  %116 = call ptr @typegetter_wrapper(ptr %115, ptr %110)
  %117 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %118 = getelementptr [3 x ptr], ptr %117, i32 0, i32 1
  store ptr %116, ptr %118, align 8
  %119 = getelementptr [3 x ptr], ptr %117, i32 0, i32 2
  store ptr null, ptr %119, align 8
  %120 = call ptr @llvm.invariant.start.p0(i64 16, ptr %117)
  store ptr @Collection, ptr %117, align 8
  %121 = alloca [2 x ptr], align 8
  %122 = getelementptr [2 x ptr], ptr %121, i32 0, i32 0
  store ptr %106, ptr %122, align 8
  %123 = getelementptr [2 x ptr], ptr %121, i32 0, i32 1
  store ptr %117, ptr %123, align 8
  %124 = call ptr @llvm.invariant.start.p0(i64 4, ptr %121)
  %125 = call ptr @llvm.invariant.start.p0(i64 976, ptr %91)
  %126 = getelementptr ptr, ptr %91, i32 %97
  %127 = getelementptr ptr, ptr %126, i32 3
  %128 = load ptr, ptr %127, align 8
  %129 = alloca { ptr, ptr }, align 8
  %130 = getelementptr { ptr, ptr }, ptr %129, i32 0, i32 0
  store ptr %65, ptr %130, align 8
  %131 = getelementptr { ptr, ptr }, ptr %129, i32 0, i32 1
  store ptr %83, ptr %131, align 8
  %132 = call ptr @behavior_wrapper(ptr %128, { ptr, ptr, ptr, i32 } %98, ptr %129)
  call void %132({ ptr, ptr, ptr, i32 } %98, { ptr, ptr, ptr, i32 } %98, ptr %121, { ptr, ptr, ptr, i32 } %72, { ptr, ptr, ptr, i32 } %90)
  %133 = alloca i32, align 4
  %134 = alloca ptr, align 8
  %135 = alloca ptr, align 8
  %136 = alloca ptr, align 8
  %137 = load ptr, ptr %54, align 8
  store ptr %137, ptr %136, align 8
  %138 = load ptr, ptr %53, align 8
  store ptr %138, ptr %135, align 8
  %139 = load ptr, ptr %52, align 8
  store ptr %139, ptr %134, align 8
  %140 = load i32, ptr %51, align 4
  store i32 %140, ptr %133, align 4
  %141 = load ptr, ptr %136, align 8
  %142 = call i32 @get_offset(ptr %141, ptr @Iterable)
  store i32 %142, ptr %133, align 4
  %143 = load ptr, ptr %136, align 8
  %144 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %143, 0
  %145 = load ptr, ptr %135, align 8
  %146 = insertvalue { ptr, ptr, ptr, i32 } %144, ptr %145, 1
  %147 = load ptr, ptr %134, align 8
  %148 = insertvalue { ptr, ptr, ptr, i32 } %146, ptr %147, 2
  %149 = load i32, ptr %133, align 4
  %150 = insertvalue { ptr, ptr, ptr, i32 } %148, i32 %149, 3
  ret { ptr, ptr, ptr, i32 } %150
}

declare { ptr, ptr, ptr, i32 } @Iterable_interleave_otherIterableT({ ptr, ptr, ptr, i32 })

define ptr @Collection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 28, i32 29
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [59 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

declare { ptr, ptr, ptr, i32 } @Iterable_zip_otherIterableU({ ptr, ptr, ptr, i32 })

define { ptr, ptr, ptr, i32 } @Collection_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3) {
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %5, align 8
  %6 = alloca i32, align 4
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %7, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %8, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %9, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = call i32 @get_offset(ptr %18, ptr @Collection)
  store i32 %19, ptr %6, align 4
  %20 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %20, align 8
  %21 = alloca i32, align 4
  %22 = alloca ptr, align 8
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  store ptr %26, ptr %24, align 8
  %27 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 1
  %28 = load ptr, ptr %27, align 8
  store ptr %28, ptr %23, align 8
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 2
  %30 = load ptr, ptr %29, align 8
  store ptr %30, ptr %22, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 3
  %32 = load i32, ptr %31, align 4
  store i32 %32, ptr %21, align 4
  %33 = load ptr, ptr %24, align 8
  %34 = call i32 @get_offset(ptr %33, ptr @Collection)
  store i32 %34, ptr %21, align 4
  %35 = load ptr, ptr %8, align 8
  %36 = load ptr, ptr %7, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 472, ptr %36)
  %38 = load i32, ptr %6, align 4
  %39 = getelementptr ptr, ptr %36, i32 %38
  %40 = load ptr, ptr %39, align 8
  %41 = call ptr @typegetter_wrapper(ptr %40, ptr %35)
  %42 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %42, align 8
  %43 = getelementptr { ptr, ptr, ptr, i32 }, ptr %42, i32 0, i32 1
  %44 = load ptr, ptr %43, align 8
  %45 = load ptr, ptr %42, align 8
  %46 = call ptr @llvm.invariant.start.p0(i64 472, ptr %45)
  %47 = getelementptr { ptr, ptr, ptr, i32 }, ptr %42, i32 0, i32 3
  %48 = load i32, ptr %47, align 4
  %49 = getelementptr ptr, ptr %45, i32 %48
  %50 = load ptr, ptr %49, align 8
  %51 = call ptr @typegetter_wrapper(ptr %50, ptr %44)
  %52 = load ptr, ptr %8, align 8
  %53 = load ptr, ptr %7, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 472, ptr %53)
  %55 = load i32, ptr %6, align 4
  %56 = getelementptr ptr, ptr %53, i32 %55
  %57 = load ptr, ptr %56, align 8
  %58 = call ptr @typegetter_wrapper(ptr %57, ptr %52)
  %59 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %59, align 8
  %60 = getelementptr { ptr, ptr, ptr, i32 }, ptr %59, i32 0, i32 1
  %61 = load ptr, ptr %60, align 8
  %62 = load ptr, ptr %59, align 8
  %63 = call ptr @llvm.invariant.start.p0(i64 472, ptr %62)
  %64 = getelementptr { ptr, ptr, ptr, i32 }, ptr %59, i32 0, i32 3
  %65 = load i32, ptr %64, align 4
  %66 = getelementptr ptr, ptr %62, i32 %65
  %67 = load ptr, ptr %66, align 8
  %68 = call ptr @typegetter_wrapper(ptr %67, ptr %61)
  %69 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([4 x ptr], ptr null, i32 1) to i64))
  %70 = getelementptr [4 x ptr], ptr %69, i32 0, i32 2
  store ptr %68, ptr %70, align 8
  %71 = getelementptr [4 x ptr], ptr %69, i32 0, i32 1
  store ptr %58, ptr %71, align 8
  %72 = getelementptr [4 x ptr], ptr %69, i32 0, i32 3
  store ptr null, ptr %72, align 8
  %73 = call ptr @llvm.invariant.start.p0(i64 24, ptr %69)
  store ptr @Pair, ptr %69, align 8
  %74 = alloca [4 x ptr], align 8
  store ptr @ZippedCollection, ptr %74, align 8
  %75 = getelementptr ptr, ptr %74, i32 1
  store ptr %41, ptr %75, align 8
  %76 = getelementptr ptr, ptr %74, i32 2
  store ptr %51, ptr %76, align 8
  %77 = getelementptr ptr, ptr %74, i32 3
  store ptr %69, ptr %77, align 8
  %78 = load ptr, ptr %74, align 8
  %79 = getelementptr ptr, ptr %78, i32 6
  %80 = load ptr, ptr %79, align 8
  %81 = call { i64, i64 } @size_wrapper(ptr %80, ptr %74)
  %82 = extractvalue { i64, i64 } %81, 0
  %83 = call ptr @bump_malloc(i64 %82)
  store ptr %41, ptr %83, align 8
  %84 = getelementptr ptr, ptr %83, i32 1
  store ptr %51, ptr %84, align 8
  %85 = getelementptr ptr, ptr %83, i32 2
  store ptr %69, ptr %85, align 8
  %86 = call ptr @llvm.invariant.start.p0(i64 24, ptr %83)
  %87 = alloca i32, align 4
  %88 = alloca ptr, align 8
  %89 = alloca ptr, align 8
  %90 = alloca ptr, align 8
  store ptr @ZippedCollection, ptr %90, align 8
  store ptr %83, ptr %89, align 8
  store i32 10, ptr %87, align 4
  %91 = alloca i32, align 4
  %92 = alloca ptr, align 8
  %93 = alloca ptr, align 8
  %94 = alloca ptr, align 8
  %95 = load ptr, ptr %7, align 8
  store ptr %95, ptr %94, align 8
  %96 = load ptr, ptr %8, align 8
  store ptr %96, ptr %93, align 8
  %97 = load ptr, ptr %9, align 8
  store ptr %97, ptr %92, align 8
  %98 = load i32, ptr %6, align 4
  store i32 %98, ptr %91, align 4
  %99 = load ptr, ptr %94, align 8
  %100 = call i32 @get_offset(ptr %99, ptr @Collection)
  store i32 %100, ptr %91, align 4
  %101 = load ptr, ptr %94, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %101, 0
  %103 = load ptr, ptr %93, align 8
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, ptr %103, 1
  %105 = load ptr, ptr %92, align 8
  %106 = insertvalue { ptr, ptr, ptr, i32 } %104, ptr %105, 2
  %107 = load i32, ptr %91, align 4
  %108 = insertvalue { ptr, ptr, ptr, i32 } %106, i32 %107, 3
  %109 = alloca i32, align 4
  %110 = alloca ptr, align 8
  %111 = alloca ptr, align 8
  %112 = alloca ptr, align 8
  %113 = load ptr, ptr %24, align 8
  store ptr %113, ptr %112, align 8
  %114 = load ptr, ptr %23, align 8
  store ptr %114, ptr %111, align 8
  %115 = load ptr, ptr %22, align 8
  store ptr %115, ptr %110, align 8
  %116 = load i32, ptr %21, align 4
  store i32 %116, ptr %109, align 4
  %117 = load ptr, ptr %112, align 8
  %118 = call i32 @get_offset(ptr %117, ptr @Collection)
  store i32 %118, ptr %109, align 4
  %119 = load ptr, ptr %112, align 8
  %120 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %119, 0
  %121 = load ptr, ptr %111, align 8
  %122 = insertvalue { ptr, ptr, ptr, i32 } %120, ptr %121, 1
  %123 = load ptr, ptr %110, align 8
  %124 = insertvalue { ptr, ptr, ptr, i32 } %122, ptr %123, 2
  %125 = load i32, ptr %109, align 4
  %126 = insertvalue { ptr, ptr, ptr, i32 } %124, i32 %125, 3
  %127 = load ptr, ptr %90, align 8
  %128 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %127, 0
  %129 = load ptr, ptr %89, align 8
  %130 = insertvalue { ptr, ptr, ptr, i32 } %128, ptr %129, 1
  %131 = load ptr, ptr %88, align 8
  %132 = insertvalue { ptr, ptr, ptr, i32 } %130, ptr %131, 2
  %133 = load i32, ptr %87, align 4
  %134 = insertvalue { ptr, ptr, ptr, i32 } %132, i32 %133, 3
  %135 = load ptr, ptr %8, align 8
  %136 = load ptr, ptr %7, align 8
  %137 = call ptr @llvm.invariant.start.p0(i64 472, ptr %136)
  %138 = load i32, ptr %6, align 4
  %139 = getelementptr ptr, ptr %136, i32 %138
  %140 = load ptr, ptr %139, align 8
  %141 = call ptr @typegetter_wrapper(ptr %140, ptr %135)
  %142 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %143 = getelementptr [3 x ptr], ptr %142, i32 0, i32 1
  store ptr %141, ptr %143, align 8
  %144 = getelementptr [3 x ptr], ptr %142, i32 0, i32 2
  store ptr null, ptr %144, align 8
  %145 = call ptr @llvm.invariant.start.p0(i64 16, ptr %142)
  store ptr @Collection, ptr %142, align 8
  %146 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %146, align 8
  %147 = getelementptr { ptr, ptr, ptr, i32 }, ptr %146, i32 0, i32 1
  %148 = load ptr, ptr %147, align 8
  %149 = load ptr, ptr %146, align 8
  %150 = call ptr @llvm.invariant.start.p0(i64 472, ptr %149)
  %151 = getelementptr { ptr, ptr, ptr, i32 }, ptr %146, i32 0, i32 3
  %152 = load i32, ptr %151, align 4
  %153 = getelementptr ptr, ptr %149, i32 %152
  %154 = load ptr, ptr %153, align 8
  %155 = call ptr @typegetter_wrapper(ptr %154, ptr %148)
  %156 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %157 = getelementptr [3 x ptr], ptr %156, i32 0, i32 1
  store ptr %155, ptr %157, align 8
  %158 = getelementptr [3 x ptr], ptr %156, i32 0, i32 2
  store ptr null, ptr %158, align 8
  %159 = call ptr @llvm.invariant.start.p0(i64 16, ptr %156)
  store ptr @Collection, ptr %156, align 8
  %160 = alloca [2 x ptr], align 8
  %161 = getelementptr [2 x ptr], ptr %160, i32 0, i32 0
  store ptr %142, ptr %161, align 8
  %162 = getelementptr [2 x ptr], ptr %160, i32 0, i32 1
  store ptr %156, ptr %162, align 8
  %163 = call ptr @llvm.invariant.start.p0(i64 4, ptr %160)
  %164 = call ptr @llvm.invariant.start.p0(i64 992, ptr %127)
  %165 = getelementptr ptr, ptr %127, i32 %133
  %166 = getelementptr ptr, ptr %165, i32 5
  %167 = load ptr, ptr %166, align 8
  %168 = alloca { ptr, ptr }, align 8
  %169 = getelementptr { ptr, ptr }, ptr %168, i32 0, i32 0
  store ptr %101, ptr %169, align 8
  %170 = getelementptr { ptr, ptr }, ptr %168, i32 0, i32 1
  store ptr %119, ptr %170, align 8
  %171 = call ptr @behavior_wrapper(ptr %167, { ptr, ptr, ptr, i32 } %134, ptr %168)
  call void %171({ ptr, ptr, ptr, i32 } %134, { ptr, ptr, ptr, i32 } %134, ptr %160, { ptr, ptr, ptr, i32 } %108, { ptr, ptr, ptr, i32 } %126)
  %172 = alloca i32, align 4
  %173 = alloca ptr, align 8
  %174 = alloca ptr, align 8
  %175 = alloca ptr, align 8
  %176 = load ptr, ptr %90, align 8
  store ptr %176, ptr %175, align 8
  %177 = load ptr, ptr %89, align 8
  store ptr %177, ptr %174, align 8
  %178 = load ptr, ptr %88, align 8
  store ptr %178, ptr %173, align 8
  %179 = load i32, ptr %87, align 4
  store i32 %179, ptr %172, align 4
  %180 = load ptr, ptr %175, align 8
  %181 = call i32 @get_offset(ptr %180, ptr @Iterable)
  store i32 %181, ptr %172, align 4
  %182 = load ptr, ptr %175, align 8
  %183 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %182, 0
  %184 = load ptr, ptr %174, align 8
  %185 = insertvalue { ptr, ptr, ptr, i32 } %183, ptr %184, 1
  %186 = load ptr, ptr %173, align 8
  %187 = insertvalue { ptr, ptr, ptr, i32 } %185, ptr %186, 2
  %188 = load i32, ptr %172, align 4
  %189 = insertvalue { ptr, ptr, ptr, i32 } %187, i32 %188, 3
  ret { ptr, ptr, ptr, i32 } %189
}

define ptr @Collection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 69, i32 68
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [59 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

declare { ptr, ptr, ptr, i32 } @Iterable_product_otherIterableU({ ptr, ptr, ptr, i32 })

define { ptr, ptr, ptr, i32 } @Collection_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3) {
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %5, align 8
  %6 = alloca i32, align 4
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %7, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %8, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %9, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = call i32 @get_offset(ptr %18, ptr @Collection)
  store i32 %19, ptr %6, align 4
  %20 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %20, align 8
  %21 = alloca i32, align 4
  %22 = alloca ptr, align 8
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  store ptr %26, ptr %24, align 8
  %27 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 1
  %28 = load ptr, ptr %27, align 8
  store ptr %28, ptr %23, align 8
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 2
  %30 = load ptr, ptr %29, align 8
  store ptr %30, ptr %22, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 3
  %32 = load i32, ptr %31, align 4
  store i32 %32, ptr %21, align 4
  %33 = load ptr, ptr %24, align 8
  %34 = call i32 @get_offset(ptr %33, ptr @Collection)
  store i32 %34, ptr %21, align 4
  %35 = load ptr, ptr %8, align 8
  %36 = load ptr, ptr %7, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 472, ptr %36)
  %38 = load i32, ptr %6, align 4
  %39 = getelementptr ptr, ptr %36, i32 %38
  %40 = load ptr, ptr %39, align 8
  %41 = call ptr @typegetter_wrapper(ptr %40, ptr %35)
  %42 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %42, align 8
  %43 = getelementptr { ptr, ptr, ptr, i32 }, ptr %42, i32 0, i32 1
  %44 = load ptr, ptr %43, align 8
  %45 = load ptr, ptr %42, align 8
  %46 = call ptr @llvm.invariant.start.p0(i64 472, ptr %45)
  %47 = getelementptr { ptr, ptr, ptr, i32 }, ptr %42, i32 0, i32 3
  %48 = load i32, ptr %47, align 4
  %49 = getelementptr ptr, ptr %45, i32 %48
  %50 = load ptr, ptr %49, align 8
  %51 = call ptr @typegetter_wrapper(ptr %50, ptr %44)
  %52 = load ptr, ptr %8, align 8
  %53 = load ptr, ptr %7, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 472, ptr %53)
  %55 = load i32, ptr %6, align 4
  %56 = getelementptr ptr, ptr %53, i32 %55
  %57 = load ptr, ptr %56, align 8
  %58 = call ptr @typegetter_wrapper(ptr %57, ptr %52)
  %59 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %59, align 8
  %60 = getelementptr { ptr, ptr, ptr, i32 }, ptr %59, i32 0, i32 1
  %61 = load ptr, ptr %60, align 8
  %62 = load ptr, ptr %59, align 8
  %63 = call ptr @llvm.invariant.start.p0(i64 472, ptr %62)
  %64 = getelementptr { ptr, ptr, ptr, i32 }, ptr %59, i32 0, i32 3
  %65 = load i32, ptr %64, align 4
  %66 = getelementptr ptr, ptr %62, i32 %65
  %67 = load ptr, ptr %66, align 8
  %68 = call ptr @typegetter_wrapper(ptr %67, ptr %61)
  %69 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([4 x ptr], ptr null, i32 1) to i64))
  %70 = getelementptr [4 x ptr], ptr %69, i32 0, i32 2
  store ptr %68, ptr %70, align 8
  %71 = getelementptr [4 x ptr], ptr %69, i32 0, i32 1
  store ptr %58, ptr %71, align 8
  %72 = getelementptr [4 x ptr], ptr %69, i32 0, i32 3
  store ptr null, ptr %72, align 8
  %73 = call ptr @llvm.invariant.start.p0(i64 24, ptr %69)
  store ptr @Pair, ptr %69, align 8
  %74 = alloca [4 x ptr], align 8
  store ptr @ProductCollection, ptr %74, align 8
  %75 = getelementptr ptr, ptr %74, i32 1
  store ptr %41, ptr %75, align 8
  %76 = getelementptr ptr, ptr %74, i32 2
  store ptr %51, ptr %76, align 8
  %77 = getelementptr ptr, ptr %74, i32 3
  store ptr %69, ptr %77, align 8
  %78 = load ptr, ptr %74, align 8
  %79 = getelementptr ptr, ptr %78, i32 6
  %80 = load ptr, ptr %79, align 8
  %81 = call { i64, i64 } @size_wrapper(ptr %80, ptr %74)
  %82 = extractvalue { i64, i64 } %81, 0
  %83 = call ptr @bump_malloc(i64 %82)
  store ptr %41, ptr %83, align 8
  %84 = getelementptr ptr, ptr %83, i32 1
  store ptr %51, ptr %84, align 8
  %85 = getelementptr ptr, ptr %83, i32 2
  store ptr %69, ptr %85, align 8
  %86 = call ptr @llvm.invariant.start.p0(i64 24, ptr %83)
  %87 = alloca i32, align 4
  %88 = alloca ptr, align 8
  %89 = alloca ptr, align 8
  %90 = alloca ptr, align 8
  store ptr @ProductCollection, ptr %90, align 8
  store ptr %83, ptr %89, align 8
  store i32 10, ptr %87, align 4
  %91 = alloca i32, align 4
  %92 = alloca ptr, align 8
  %93 = alloca ptr, align 8
  %94 = alloca ptr, align 8
  %95 = load ptr, ptr %7, align 8
  store ptr %95, ptr %94, align 8
  %96 = load ptr, ptr %8, align 8
  store ptr %96, ptr %93, align 8
  %97 = load ptr, ptr %9, align 8
  store ptr %97, ptr %92, align 8
  %98 = load i32, ptr %6, align 4
  store i32 %98, ptr %91, align 4
  %99 = load ptr, ptr %94, align 8
  %100 = call i32 @get_offset(ptr %99, ptr @Collection)
  store i32 %100, ptr %91, align 4
  %101 = load ptr, ptr %94, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %101, 0
  %103 = load ptr, ptr %93, align 8
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, ptr %103, 1
  %105 = load ptr, ptr %92, align 8
  %106 = insertvalue { ptr, ptr, ptr, i32 } %104, ptr %105, 2
  %107 = load i32, ptr %91, align 4
  %108 = insertvalue { ptr, ptr, ptr, i32 } %106, i32 %107, 3
  %109 = alloca i32, align 4
  %110 = alloca ptr, align 8
  %111 = alloca ptr, align 8
  %112 = alloca ptr, align 8
  %113 = load ptr, ptr %24, align 8
  store ptr %113, ptr %112, align 8
  %114 = load ptr, ptr %23, align 8
  store ptr %114, ptr %111, align 8
  %115 = load ptr, ptr %22, align 8
  store ptr %115, ptr %110, align 8
  %116 = load i32, ptr %21, align 4
  store i32 %116, ptr %109, align 4
  %117 = load ptr, ptr %112, align 8
  %118 = call i32 @get_offset(ptr %117, ptr @Collection)
  store i32 %118, ptr %109, align 4
  %119 = load ptr, ptr %112, align 8
  %120 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %119, 0
  %121 = load ptr, ptr %111, align 8
  %122 = insertvalue { ptr, ptr, ptr, i32 } %120, ptr %121, 1
  %123 = load ptr, ptr %110, align 8
  %124 = insertvalue { ptr, ptr, ptr, i32 } %122, ptr %123, 2
  %125 = load i32, ptr %109, align 4
  %126 = insertvalue { ptr, ptr, ptr, i32 } %124, i32 %125, 3
  %127 = load ptr, ptr %90, align 8
  %128 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %127, 0
  %129 = load ptr, ptr %89, align 8
  %130 = insertvalue { ptr, ptr, ptr, i32 } %128, ptr %129, 1
  %131 = load ptr, ptr %88, align 8
  %132 = insertvalue { ptr, ptr, ptr, i32 } %130, ptr %131, 2
  %133 = load i32, ptr %87, align 4
  %134 = insertvalue { ptr, ptr, ptr, i32 } %132, i32 %133, 3
  %135 = load ptr, ptr %8, align 8
  %136 = load ptr, ptr %7, align 8
  %137 = call ptr @llvm.invariant.start.p0(i64 472, ptr %136)
  %138 = load i32, ptr %6, align 4
  %139 = getelementptr ptr, ptr %136, i32 %138
  %140 = load ptr, ptr %139, align 8
  %141 = call ptr @typegetter_wrapper(ptr %140, ptr %135)
  %142 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %143 = getelementptr [3 x ptr], ptr %142, i32 0, i32 1
  store ptr %141, ptr %143, align 8
  %144 = getelementptr [3 x ptr], ptr %142, i32 0, i32 2
  store ptr null, ptr %144, align 8
  %145 = call ptr @llvm.invariant.start.p0(i64 16, ptr %142)
  store ptr @Collection, ptr %142, align 8
  %146 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %146, align 8
  %147 = getelementptr { ptr, ptr, ptr, i32 }, ptr %146, i32 0, i32 1
  %148 = load ptr, ptr %147, align 8
  %149 = load ptr, ptr %146, align 8
  %150 = call ptr @llvm.invariant.start.p0(i64 472, ptr %149)
  %151 = getelementptr { ptr, ptr, ptr, i32 }, ptr %146, i32 0, i32 3
  %152 = load i32, ptr %151, align 4
  %153 = getelementptr ptr, ptr %149, i32 %152
  %154 = load ptr, ptr %153, align 8
  %155 = call ptr @typegetter_wrapper(ptr %154, ptr %148)
  %156 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %157 = getelementptr [3 x ptr], ptr %156, i32 0, i32 1
  store ptr %155, ptr %157, align 8
  %158 = getelementptr [3 x ptr], ptr %156, i32 0, i32 2
  store ptr null, ptr %158, align 8
  %159 = call ptr @llvm.invariant.start.p0(i64 16, ptr %156)
  store ptr @Collection, ptr %156, align 8
  %160 = alloca [2 x ptr], align 8
  %161 = getelementptr [2 x ptr], ptr %160, i32 0, i32 0
  store ptr %142, ptr %161, align 8
  %162 = getelementptr [2 x ptr], ptr %160, i32 0, i32 1
  store ptr %156, ptr %162, align 8
  %163 = call ptr @llvm.invariant.start.p0(i64 4, ptr %160)
  %164 = call ptr @llvm.invariant.start.p0(i64 992, ptr %127)
  %165 = getelementptr ptr, ptr %127, i32 %133
  %166 = getelementptr ptr, ptr %165, i32 5
  %167 = load ptr, ptr %166, align 8
  %168 = alloca { ptr, ptr }, align 8
  %169 = getelementptr { ptr, ptr }, ptr %168, i32 0, i32 0
  store ptr %101, ptr %169, align 8
  %170 = getelementptr { ptr, ptr }, ptr %168, i32 0, i32 1
  store ptr %119, ptr %170, align 8
  %171 = call ptr @behavior_wrapper(ptr %167, { ptr, ptr, ptr, i32 } %134, ptr %168)
  call void %171({ ptr, ptr, ptr, i32 } %134, { ptr, ptr, ptr, i32 } %134, ptr %160, { ptr, ptr, ptr, i32 } %108, { ptr, ptr, ptr, i32 } %126)
  %172 = alloca i32, align 4
  %173 = alloca ptr, align 8
  %174 = alloca ptr, align 8
  %175 = alloca ptr, align 8
  %176 = load ptr, ptr %90, align 8
  store ptr %176, ptr %175, align 8
  %177 = load ptr, ptr %89, align 8
  store ptr %177, ptr %174, align 8
  %178 = load ptr, ptr %88, align 8
  store ptr %178, ptr %173, align 8
  %179 = load i32, ptr %87, align 4
  store i32 %179, ptr %172, align 4
  %180 = load ptr, ptr %175, align 8
  %181 = call i32 @get_offset(ptr %180, ptr @Iterable)
  store i32 %181, ptr %172, align 4
  %182 = load ptr, ptr %175, align 8
  %183 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %182, 0
  %184 = load ptr, ptr %174, align 8
  %185 = insertvalue { ptr, ptr, ptr, i32 } %183, ptr %184, 1
  %186 = load ptr, ptr %173, align 8
  %187 = insertvalue { ptr, ptr, ptr, i32 } %185, ptr %186, 2
  %188 = load i32, ptr %172, align 4
  %189 = insertvalue { ptr, ptr, ptr, i32 } %187, i32 %188, 3
  ret { ptr, ptr, ptr, i32 } %189
}

define ptr @Collection_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 71, i32 70
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [59 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

define { i64, i64 } @_data_size_EnumeratedCollection(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %10
  %12 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %5
  %13 = select i1 %12, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %5
  %14 = urem i64 %11, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %17
  %19 = add i64 %11, %18
  %20 = urem i64 %19, %13
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 %13, %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = add i64 %19, %23
  %25 = insertvalue { i64, i64 } undef, i64 %24, 0
  %26 = insertvalue { i64, i64 } %25, i64 %13, 1
  ret { i64, i64 } %26
}

define ptr @EnumeratedCollection_field_EnumeratedCollection_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define ptr @EnumeratedCollection_field_EnumeratedCollection_1(ptr %0) {
  %2 = getelementptr ptr, ptr %0, i32 1
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

define { ptr, ptr, ptr, i32 } @EnumeratedCollection_getter_iterable(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %7, %11
  %13 = getelementptr i8, ptr %0, i64 %12
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %15, 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 1
  %18 = load ptr, ptr %17, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %18, 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 2
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %21, 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 3
  %24 = load i32, ptr %23, align 4
  %25 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %24, 3
  ret { ptr, ptr, ptr, i32 } %25
}

define void @EnumeratedCollection_setter_iterable(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %8, %12
  %14 = getelementptr i8, ptr %0, i64 %13
  %15 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %15, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 0
  %18 = load ptr, ptr %16, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 1
  %21 = load ptr, ptr %19, align 8
  store ptr %21, ptr %20, align 8
  %22 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 2
  %24 = load ptr, ptr %22, align 8
  store ptr %24, ptr %23, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 3
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 3
  %27 = load i32, ptr %25, align 4
  store i32 %27, ptr %26, align 4
  ret void
}

define void @EnumeratedCollection_init_iterableCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3) {
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %5, align 8
  %6 = alloca i32, align 4
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %7, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %8, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %9, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = call i32 @get_offset(ptr %18, ptr @EnumeratedCollection)
  store i32 %19, ptr %6, align 4
  %20 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %20, align 8
  %21 = alloca i32, align 4
  %22 = alloca ptr, align 8
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  store ptr %26, ptr %24, align 8
  %27 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 1
  %28 = load ptr, ptr %27, align 8
  store ptr %28, ptr %23, align 8
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 2
  %30 = load ptr, ptr %29, align 8
  store ptr %30, ptr %22, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 3
  %32 = load i32, ptr %31, align 4
  store i32 %32, ptr %21, align 4
  %33 = load ptr, ptr %24, align 8
  %34 = call i32 @get_offset(ptr %33, ptr @Collection)
  store i32 %34, ptr %21, align 4
  %35 = alloca i32, align 4
  %36 = alloca ptr, align 8
  %37 = alloca ptr, align 8
  %38 = alloca ptr, align 8
  %39 = load ptr, ptr %24, align 8
  store ptr %39, ptr %38, align 8
  %40 = load ptr, ptr %23, align 8
  store ptr %40, ptr %37, align 8
  %41 = load ptr, ptr %22, align 8
  store ptr %41, ptr %36, align 8
  %42 = load i32, ptr %21, align 4
  store i32 %42, ptr %35, align 4
  %43 = load ptr, ptr %38, align 8
  %44 = call i32 @get_offset(ptr %43, ptr @Collection)
  store i32 %44, ptr %35, align 4
  %45 = load ptr, ptr %8, align 8
  %46 = load ptr, ptr %7, align 8
  %47 = call ptr @llvm.invariant.start.p0(i64 976, ptr %46)
  %48 = load i32, ptr %6, align 4
  %49 = getelementptr ptr, ptr %46, i32 %48
  %50 = getelementptr ptr, ptr %49, i32 2
  %51 = load ptr, ptr %50, align 8
  %52 = getelementptr { ptr, ptr }, ptr %51, i32 0, i32 1
  %53 = load ptr, ptr %52, align 8
  %54 = load ptr, ptr %38, align 8
  %55 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %54, 0
  %56 = load ptr, ptr %37, align 8
  %57 = insertvalue { ptr, ptr, ptr, i32 } %55, ptr %56, 1
  %58 = load ptr, ptr %36, align 8
  %59 = insertvalue { ptr, ptr, ptr, i32 } %57, ptr %58, 2
  %60 = load i32, ptr %35, align 4
  %61 = insertvalue { ptr, ptr, ptr, i32 } %59, i32 %60, 3
  call void %53(ptr %45, { ptr, ptr, ptr, i32 } %61) #1
  ret void
}

define ptr @EnumeratedCollection_B_init_iterableCollectionT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Collection, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Collection to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 18, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [122 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define i32 @EnumeratedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @EnumeratedCollection)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 976, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 2
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr { ptr, ptr }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = call { ptr, ptr, ptr, i32 } %27(ptr %19) #2
  %29 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %28, ptr %29, align 8
  call void @assume_offset(ptr %29, ptr @Collection)
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 1
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %34, 1
  %36 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 2
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %37, 2
  %39 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 3
  %40 = load i32, ptr %39, align 4
  %41 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %40, 3
  %42 = alloca [0 x ptr], align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 0, ptr %42)
  %44 = call ptr @llvm.invariant.start.p0(i64 472, ptr %31)
  %45 = getelementptr ptr, ptr %31, i32 %40
  %46 = getelementptr ptr, ptr %45, i32 1
  %47 = load ptr, ptr %46, align 8
  %48 = alloca {}, align 8
  %49 = call ptr @behavior_wrapper(ptr %47, { ptr, ptr, ptr, i32 } %41, ptr %48)
  %50 = call i32 %49({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr %42)
  %51 = alloca i32, align 4
  store i32 %50, ptr %51, align 4
  %52 = load i32, ptr %51, align 4
  ret i32 %52
}

define ptr @EnumeratedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 19, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [122 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @EnumeratedCollection_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 20, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [122 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { ptr, ptr, ptr, i32 } @EnumeratedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @EnumeratedCollection)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 976, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 2
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr { ptr, ptr }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = call { ptr, ptr, ptr, i32 } %27(ptr %19) #2
  %29 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %28, ptr %29, align 8
  call void @assume_offset(ptr %29, ptr @Collection)
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 1
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %34, 1
  %36 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 2
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %37, 2
  %39 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 3
  %40 = load i32, ptr %39, align 4
  %41 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %40, 3
  %42 = alloca [0 x ptr], align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 0, ptr %42)
  %44 = call ptr @llvm.invariant.start.p0(i64 472, ptr %31)
  %45 = getelementptr ptr, ptr %31, i32 %40
  %46 = getelementptr ptr, ptr %45, i32 3
  %47 = load ptr, ptr %46, align 8
  %48 = alloca {}, align 8
  %49 = call ptr @behavior_wrapper(ptr %47, { ptr, ptr, ptr, i32 } %41, ptr %48)
  %50 = call { ptr, ptr, ptr, i32 } %49({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr %42)
  %51 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %50, ptr %51, align 8
  %52 = alloca i32, align 4
  %53 = alloca ptr, align 8
  %54 = alloca ptr, align 8
  %55 = alloca ptr, align 8
  %56 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 0
  %57 = load ptr, ptr %56, align 8
  store ptr %57, ptr %53, align 8
  %58 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 1
  %59 = load ptr, ptr %58, align 8
  store ptr %59, ptr %55, align 8
  %60 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 2
  %61 = load ptr, ptr %60, align 8
  store ptr %61, ptr %54, align 8
  %62 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 3
  %63 = load i32, ptr %62, align 4
  store i32 %63, ptr %52, align 4
  %64 = load ptr, ptr %53, align 8
  %65 = call i32 @get_offset(ptr %64, ptr @Iterator)
  store i32 %65, ptr %52, align 4
  %66 = load ptr, ptr %7, align 8
  %67 = load ptr, ptr %6, align 8
  %68 = call ptr @llvm.invariant.start.p0(i64 976, ptr %67)
  %69 = load i32, ptr %5, align 4
  %70 = getelementptr ptr, ptr %67, i32 %69
  %71 = load ptr, ptr %70, align 8
  %72 = call ptr @typegetter_wrapper(ptr %71, ptr %66)
  %73 = load ptr, ptr %7, align 8
  %74 = load ptr, ptr %6, align 8
  %75 = call ptr @llvm.invariant.start.p0(i64 976, ptr %74)
  %76 = load i32, ptr %5, align 4
  %77 = getelementptr ptr, ptr %74, i32 %76
  %78 = load ptr, ptr %77, align 8
  %79 = call ptr @typegetter_wrapper(ptr %78, ptr %73)
  %80 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([4 x ptr], ptr null, i32 1) to i64))
  %81 = getelementptr [4 x ptr], ptr %80, i32 0, i32 2
  store ptr %79, ptr %81, align 8
  %82 = getelementptr [4 x ptr], ptr %80, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %82, align 8
  %83 = getelementptr [4 x ptr], ptr %80, i32 0, i32 3
  store ptr null, ptr %83, align 8
  %84 = call ptr @llvm.invariant.start.p0(i64 24, ptr %80)
  store ptr @Pair, ptr %80, align 8
  %85 = alloca [3 x ptr], align 8
  store ptr @Enumerator, ptr %85, align 8
  %86 = getelementptr ptr, ptr %85, i32 1
  store ptr %72, ptr %86, align 8
  %87 = getelementptr ptr, ptr %85, i32 2
  store ptr %80, ptr %87, align 8
  %88 = load ptr, ptr %85, align 8
  %89 = getelementptr ptr, ptr %88, i32 6
  %90 = load ptr, ptr %89, align 8
  %91 = call { i64, i64 } @size_wrapper(ptr %90, ptr %85)
  %92 = extractvalue { i64, i64 } %91, 0
  %93 = call ptr @bump_malloc(i64 %92)
  store ptr %72, ptr %93, align 8
  %94 = getelementptr ptr, ptr %93, i32 1
  store ptr %80, ptr %94, align 8
  %95 = call ptr @llvm.invariant.start.p0(i64 16, ptr %93)
  %96 = alloca i32, align 4
  %97 = alloca ptr, align 8
  %98 = alloca ptr, align 8
  %99 = alloca ptr, align 8
  store ptr @Enumerator, ptr %99, align 8
  store ptr %93, ptr %98, align 8
  store i32 10, ptr %96, align 4
  %100 = load ptr, ptr %7, align 8
  %101 = load ptr, ptr %6, align 8
  %102 = call ptr @llvm.invariant.start.p0(i64 976, ptr %101)
  %103 = load i32, ptr %5, align 4
  %104 = getelementptr ptr, ptr %101, i32 %103
  %105 = getelementptr ptr, ptr %104, i32 2
  %106 = load ptr, ptr %105, align 8
  %107 = getelementptr { ptr, ptr }, ptr %106, i32 0, i32 0
  %108 = load ptr, ptr %107, align 8
  %109 = call { ptr, ptr, ptr, i32 } %108(ptr %100) #2
  %110 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %109, ptr %110, align 8
  call void @assume_offset(ptr %110, ptr @Collection)
  %111 = getelementptr { ptr, ptr, ptr, i32 }, ptr %110, i32 0, i32 0
  %112 = load ptr, ptr %111, align 8
  %113 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %112, 0
  %114 = getelementptr { ptr, ptr, ptr, i32 }, ptr %110, i32 0, i32 1
  %115 = load ptr, ptr %114, align 8
  %116 = insertvalue { ptr, ptr, ptr, i32 } %113, ptr %115, 1
  %117 = getelementptr { ptr, ptr, ptr, i32 }, ptr %110, i32 0, i32 2
  %118 = load ptr, ptr %117, align 8
  %119 = insertvalue { ptr, ptr, ptr, i32 } %116, ptr %118, 2
  %120 = getelementptr { ptr, ptr, ptr, i32 }, ptr %110, i32 0, i32 3
  %121 = load i32, ptr %120, align 4
  %122 = insertvalue { ptr, ptr, ptr, i32 } %119, i32 %121, 3
  %123 = alloca [0 x ptr], align 8
  %124 = call ptr @llvm.invariant.start.p0(i64 0, ptr %123)
  %125 = call ptr @llvm.invariant.start.p0(i64 472, ptr %112)
  %126 = getelementptr ptr, ptr %112, i32 %121
  %127 = getelementptr ptr, ptr %126, i32 3
  %128 = load ptr, ptr %127, align 8
  %129 = alloca {}, align 8
  %130 = call ptr @behavior_wrapper(ptr %128, { ptr, ptr, ptr, i32 } %122, ptr %129)
  %131 = call { ptr, ptr, ptr, i32 } %130({ ptr, ptr, ptr, i32 } %122, { ptr, ptr, ptr, i32 } %122, ptr %123)
  %132 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %131, ptr %132, align 8
  %133 = alloca i32, align 4
  %134 = alloca ptr, align 8
  %135 = alloca ptr, align 8
  %136 = alloca ptr, align 8
  %137 = getelementptr { ptr, ptr, ptr, i32 }, ptr %132, i32 0, i32 0
  %138 = load ptr, ptr %137, align 8
  store ptr %138, ptr %136, align 8
  %139 = getelementptr { ptr, ptr, ptr, i32 }, ptr %132, i32 0, i32 1
  %140 = load ptr, ptr %139, align 8
  store ptr %140, ptr %135, align 8
  %141 = getelementptr { ptr, ptr, ptr, i32 }, ptr %132, i32 0, i32 2
  %142 = load ptr, ptr %141, align 8
  store ptr %142, ptr %134, align 8
  %143 = getelementptr { ptr, ptr, ptr, i32 }, ptr %132, i32 0, i32 3
  %144 = load i32, ptr %143, align 4
  store i32 %144, ptr %133, align 4
  %145 = load ptr, ptr %136, align 8
  %146 = call i32 @get_offset(ptr %145, ptr @Iterator)
  store i32 %146, ptr %133, align 4
  %147 = alloca i32, align 4
  %148 = alloca ptr, align 8
  %149 = alloca ptr, align 8
  %150 = alloca ptr, align 8
  %151 = load ptr, ptr %136, align 8
  store ptr %151, ptr %150, align 8
  %152 = load ptr, ptr %135, align 8
  store ptr %152, ptr %149, align 8
  %153 = load ptr, ptr %134, align 8
  store ptr %153, ptr %148, align 8
  %154 = load i32, ptr %133, align 4
  store i32 %154, ptr %147, align 4
  %155 = load ptr, ptr %150, align 8
  %156 = call i32 @get_offset(ptr %155, ptr @Iterator)
  store i32 %156, ptr %147, align 4
  %157 = load ptr, ptr %150, align 8
  %158 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %157, 0
  %159 = load ptr, ptr %149, align 8
  %160 = insertvalue { ptr, ptr, ptr, i32 } %158, ptr %159, 1
  %161 = load ptr, ptr %148, align 8
  %162 = insertvalue { ptr, ptr, ptr, i32 } %160, ptr %161, 2
  %163 = load i32, ptr %147, align 4
  %164 = insertvalue { ptr, ptr, ptr, i32 } %162, i32 %163, 3
  %165 = load ptr, ptr %99, align 8
  %166 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %165, 0
  %167 = load ptr, ptr %98, align 8
  %168 = insertvalue { ptr, ptr, ptr, i32 } %166, ptr %167, 1
  %169 = load ptr, ptr %97, align 8
  %170 = insertvalue { ptr, ptr, ptr, i32 } %168, ptr %169, 2
  %171 = load i32, ptr %96, align 4
  %172 = insertvalue { ptr, ptr, ptr, i32 } %170, i32 %171, 3
  %173 = load ptr, ptr %7, align 8
  %174 = load ptr, ptr %6, align 8
  %175 = call ptr @llvm.invariant.start.p0(i64 976, ptr %174)
  %176 = load i32, ptr %5, align 4
  %177 = getelementptr ptr, ptr %174, i32 %176
  %178 = load ptr, ptr %177, align 8
  %179 = call ptr @typegetter_wrapper(ptr %178, ptr %173)
  %180 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %181 = getelementptr [3 x ptr], ptr %180, i32 0, i32 1
  store ptr %179, ptr %181, align 8
  %182 = getelementptr [3 x ptr], ptr %180, i32 0, i32 2
  store ptr null, ptr %182, align 8
  %183 = call ptr @llvm.invariant.start.p0(i64 16, ptr %180)
  store ptr @Iterator, ptr %180, align 8
  %184 = alloca [1 x ptr], align 8
  %185 = getelementptr [1 x ptr], ptr %184, i32 0, i32 0
  store ptr %180, ptr %185, align 8
  %186 = call ptr @llvm.invariant.start.p0(i64 1, ptr %184)
  %187 = call ptr @llvm.invariant.start.p0(i64 88, ptr %165)
  %188 = getelementptr ptr, ptr %165, i32 %171
  %189 = getelementptr ptr, ptr %188, i32 4
  %190 = load ptr, ptr %189, align 8
  %191 = alloca { ptr }, align 8
  %192 = getelementptr { ptr }, ptr %191, i32 0, i32 0
  store ptr %157, ptr %192, align 8
  %193 = call ptr @behavior_wrapper(ptr %190, { ptr, ptr, ptr, i32 } %172, ptr %191)
  call void %193({ ptr, ptr, ptr, i32 } %172, { ptr, ptr, ptr, i32 } %172, ptr %184, { ptr, ptr, ptr, i32 } %164)
  %194 = alloca i32, align 4
  %195 = alloca ptr, align 8
  %196 = alloca ptr, align 8
  %197 = alloca ptr, align 8
  %198 = load ptr, ptr %99, align 8
  store ptr %198, ptr %197, align 8
  %199 = load ptr, ptr %98, align 8
  store ptr %199, ptr %196, align 8
  %200 = load ptr, ptr %97, align 8
  store ptr %200, ptr %195, align 8
  %201 = load i32, ptr %96, align 4
  store i32 %201, ptr %194, align 4
  %202 = load ptr, ptr %197, align 8
  %203 = call i32 @get_offset(ptr %202, ptr @Iterator)
  store i32 %203, ptr %194, align 4
  %204 = load ptr, ptr %197, align 8
  %205 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %204, 0
  %206 = load ptr, ptr %196, align 8
  %207 = insertvalue { ptr, ptr, ptr, i32 } %205, ptr %206, 1
  %208 = load ptr, ptr %195, align 8
  %209 = insertvalue { ptr, ptr, ptr, i32 } %207, ptr %208, 2
  %210 = load i32, ptr %194, align 4
  %211 = insertvalue { ptr, ptr, ptr, i32 } %209, i32 %210, 3
  ret { ptr, ptr, ptr, i32 } %211
}

define ptr @EnumeratedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 21, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [122 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @EnumeratedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 22, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [122 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @EnumeratedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @Pair, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @Pair to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = ptrtoint ptr %20 to i64
  %22 = icmp eq i64 %21, ptrtoint (ptr @function_typ to i64)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 23, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [122 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define ptr @EnumeratedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 24, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [122 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @EnumeratedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 25, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [122 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @EnumeratedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 26, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [122 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @EnumeratedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = ptrtoint ptr %7 to i64
  %9 = icmp eq i64 %8, ptrtoint (ptr @function_typ to i64)
  %10 = zext i1 %9 to i8
  store i8 %10, ptr %3, align 1
  %11 = load i8, ptr %3, align 1
  %12 = trunc i8 %11 to i1
  %13 = select i1 %12, i32 27, i32 28
  br i1 %12, label %14, label %15

14:                                               ; preds = %2
  br label %20

15:                                               ; preds = %2
  %16 = load ptr, ptr %1, align 8
  %17 = ptrtoint ptr %16 to i64
  %18 = icmp eq i64 %17, ptrtoint (ptr @function_typ to i64)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %4, align 1
  br label %20

20:                                               ; preds = %14, %15
  store i32 %13, ptr %6, align 4
  %21 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %22 = load i32, ptr %6, align 4
  %23 = getelementptr [122 x ptr], ptr %21, i32 0, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 10
  %25 = load ptr, ptr %24, align 8
  ret ptr %25
}

define ptr @EnumeratedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 29, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [122 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @EnumeratedCollection_B_chain_otherCollectionT_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 30, i32 31
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [122 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

define ptr @EnumeratedCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 32, i32 33
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [122 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

define ptr @EnumeratedCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 35, i32 34
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [122 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

define ptr @EnumeratedCollection_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 37, i32 36
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [122 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

define { i64, i64 } @_data_size_MappedCollection(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %10
  %12 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %5
  %13 = select i1 %12, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %5
  %14 = urem i64 %11, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %17
  %19 = add i64 %11, %18
  %20 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), %13
  %21 = select i1 %20, i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), i64 %13
  %22 = urem i64 %19, ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64)
  %23 = icmp eq i64 %22, 0
  %24 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), %22
  %25 = select i1 %23, i64 0, i64 %24
  %26 = add i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), %25
  %27 = add i64 %19, %26
  %28 = urem i64 %27, %21
  %29 = icmp eq i64 %28, 0
  %30 = sub i64 %21, %28
  %31 = select i1 %29, i64 0, i64 %30
  %32 = add i64 %27, %31
  %33 = insertvalue { i64, i64 } undef, i64 %32, 0
  %34 = insertvalue { i64, i64 } %33, i64 %21, 1
  ret { i64, i64 } %34
}

define ptr @MappedCollection_field_MappedCollection_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define ptr @MappedCollection_field_MappedCollection_1(ptr %0) {
  %2 = getelementptr ptr, ptr %0, i32 1
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

define { ptr, ptr, ptr, i32 } @MappedCollection_getter_iterable(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %7, %11
  %13 = getelementptr i8, ptr %0, i64 %12
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %15, 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 1
  %18 = load ptr, ptr %17, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %18, 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 2
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %21, 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 3
  %24 = load i32, ptr %23, align 4
  %25 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %24, 3
  ret { ptr, ptr, ptr, i32 } %25
}

define void @MappedCollection_setter_iterable(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %8, %12
  %14 = getelementptr i8, ptr %0, i64 %13
  %15 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %15, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 0
  %18 = load ptr, ptr %16, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 1
  %21 = load ptr, ptr %19, align 8
  store ptr %21, ptr %20, align 8
  %22 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 2
  %24 = load ptr, ptr %22, align 8
  store ptr %24, ptr %23, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 3
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 3
  %27 = load i32, ptr %25, align 4
  store i32 %27, ptr %26, align 4
  ret void
}

define { ptr } @MappedCollection_getter_f(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %11
  %13 = add i64 %7, %12
  %14 = urem i64 %13, ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 %13, %17
  %19 = getelementptr i8, ptr %0, i64 %18
  %20 = getelementptr { ptr }, ptr %19, i32 0, i32 0
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr } undef, ptr %21, 0
  ret { ptr } %22
}

define void @MappedCollection_setter_f(ptr %0, { ptr } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %12
  %14 = add i64 %8, %13
  %15 = urem i64 %14, ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64)
  %16 = icmp eq i64 %15, 0
  %17 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add i64 %14, %18
  %20 = getelementptr i8, ptr %0, i64 %19
  %21 = alloca ptr, align 8
  store { ptr } %1, ptr %21, align 8
  %22 = getelementptr { ptr }, ptr %20, i32 0, i32 0
  %23 = load ptr, ptr %21, align 8
  store ptr %23, ptr %22, align 8
  ret void
}

define void @MappedCollection_init_iterableCollectionT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3, { ptr } %4) {
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %6, align 8
  %7 = alloca i32, align 4
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = alloca ptr, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %8, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 1
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %9, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 2
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %10, align 8
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  store i32 %18, ptr %7, align 4
  %19 = load ptr, ptr %8, align 8
  %20 = call i32 @get_offset(ptr %19, ptr @MappedCollection)
  store i32 %20, ptr %7, align 4
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %21, align 8
  %22 = alloca i32, align 4
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = alloca ptr, align 8
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  store ptr %27, ptr %25, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 1
  %29 = load ptr, ptr %28, align 8
  store ptr %29, ptr %24, align 8
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 2
  %31 = load ptr, ptr %30, align 8
  store ptr %31, ptr %23, align 8
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 3
  %33 = load i32, ptr %32, align 4
  store i32 %33, ptr %22, align 4
  %34 = load ptr, ptr %25, align 8
  %35 = call i32 @get_offset(ptr %34, ptr @Collection)
  store i32 %35, ptr %22, align 4
  %36 = alloca i32, align 4
  %37 = alloca ptr, align 8
  %38 = alloca ptr, align 8
  %39 = alloca ptr, align 8
  %40 = load ptr, ptr %25, align 8
  store ptr %40, ptr %39, align 8
  %41 = load ptr, ptr %24, align 8
  store ptr %41, ptr %38, align 8
  %42 = load ptr, ptr %23, align 8
  store ptr %42, ptr %37, align 8
  %43 = load i32, ptr %22, align 4
  store i32 %43, ptr %36, align 4
  %44 = load ptr, ptr %39, align 8
  %45 = call i32 @get_offset(ptr %44, ptr @Collection)
  store i32 %45, ptr %36, align 4
  %46 = load ptr, ptr %9, align 8
  %47 = load ptr, ptr %8, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 984, ptr %47)
  %49 = load i32, ptr %7, align 4
  %50 = getelementptr ptr, ptr %47, i32 %49
  %51 = getelementptr ptr, ptr %50, i32 2
  %52 = load ptr, ptr %51, align 8
  %53 = getelementptr { ptr, ptr }, ptr %52, i32 0, i32 1
  %54 = load ptr, ptr %53, align 8
  %55 = load ptr, ptr %39, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %55, 0
  %57 = load ptr, ptr %38, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %57, 1
  %59 = load ptr, ptr %37, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %59, 2
  %61 = load i32, ptr %36, align 4
  %62 = insertvalue { ptr, ptr, ptr, i32 } %60, i32 %61, 3
  call void %54(ptr %46, { ptr, ptr, ptr, i32 } %62) #1
  %63 = alloca ptr, align 8
  store { ptr } %4, ptr %63, align 8
  %64 = load ptr, ptr %9, align 8
  %65 = load ptr, ptr %8, align 8
  %66 = call ptr @llvm.invariant.start.p0(i64 984, ptr %65)
  %67 = load i32, ptr %7, align 4
  %68 = getelementptr ptr, ptr %65, i32 %67
  %69 = getelementptr ptr, ptr %68, i32 3
  %70 = load ptr, ptr %69, align 8
  %71 = getelementptr { ptr, ptr }, ptr %70, i32 0, i32 1
  %72 = load ptr, ptr %71, align 8
  %73 = load ptr, ptr %63, align 8
  %74 = insertvalue { ptr } undef, ptr %73, 0
  call void %72(ptr %64, { ptr } %74) #1
  ret void
}

define ptr @MappedCollection_B_init_iterableCollectionT_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @Collection, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @Collection to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = ptrtoint ptr %20 to i64
  %22 = icmp eq i64 %21, ptrtoint (ptr @function_typ to i64)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 19, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [123 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define i32 @MappedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @MappedCollection)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 984, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 2
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr { ptr, ptr }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = call { ptr, ptr, ptr, i32 } %27(ptr %19) #2
  %29 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %28, ptr %29, align 8
  call void @assume_offset(ptr %29, ptr @Collection)
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 1
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %34, 1
  %36 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 2
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %37, 2
  %39 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 3
  %40 = load i32, ptr %39, align 4
  %41 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %40, 3
  %42 = alloca [0 x ptr], align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 0, ptr %42)
  %44 = call ptr @llvm.invariant.start.p0(i64 472, ptr %31)
  %45 = getelementptr ptr, ptr %31, i32 %40
  %46 = getelementptr ptr, ptr %45, i32 1
  %47 = load ptr, ptr %46, align 8
  %48 = alloca {}, align 8
  %49 = call ptr @behavior_wrapper(ptr %47, { ptr, ptr, ptr, i32 } %41, ptr %48)
  %50 = call i32 %49({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr %42)
  %51 = alloca i32, align 4
  store i32 %50, ptr %51, align 4
  %52 = load i32, ptr %51, align 4
  ret i32 %52
}

define ptr @MappedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 20, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [123 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @MappedCollection_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 21, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [123 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { ptr, ptr, ptr, i32 } @MappedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @MappedCollection)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 984, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 2
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr { ptr, ptr }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = call { ptr, ptr, ptr, i32 } %27(ptr %19) #2
  %29 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %28, ptr %29, align 8
  call void @assume_offset(ptr %29, ptr @Collection)
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 1
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %34, 1
  %36 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 2
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %37, 2
  %39 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 3
  %40 = load i32, ptr %39, align 4
  %41 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %40, 3
  %42 = alloca [0 x ptr], align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 0, ptr %42)
  %44 = call ptr @llvm.invariant.start.p0(i64 472, ptr %31)
  %45 = getelementptr ptr, ptr %31, i32 %40
  %46 = getelementptr ptr, ptr %45, i32 3
  %47 = load ptr, ptr %46, align 8
  %48 = alloca {}, align 8
  %49 = call ptr @behavior_wrapper(ptr %47, { ptr, ptr, ptr, i32 } %41, ptr %48)
  %50 = call { ptr, ptr, ptr, i32 } %49({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr %42)
  %51 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %50, ptr %51, align 8
  %52 = alloca i32, align 4
  %53 = alloca ptr, align 8
  %54 = alloca ptr, align 8
  %55 = alloca ptr, align 8
  %56 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 0
  %57 = load ptr, ptr %56, align 8
  store ptr %57, ptr %53, align 8
  %58 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 1
  %59 = load ptr, ptr %58, align 8
  store ptr %59, ptr %55, align 8
  %60 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 2
  %61 = load ptr, ptr %60, align 8
  store ptr %61, ptr %54, align 8
  %62 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 3
  %63 = load i32, ptr %62, align 4
  store i32 %63, ptr %52, align 4
  %64 = load ptr, ptr %53, align 8
  %65 = call i32 @get_offset(ptr %64, ptr @Iterator)
  store i32 %65, ptr %52, align 4
  %66 = load ptr, ptr %7, align 8
  %67 = load ptr, ptr %6, align 8
  %68 = call ptr @llvm.invariant.start.p0(i64 984, ptr %67)
  %69 = load i32, ptr %5, align 4
  %70 = getelementptr ptr, ptr %67, i32 %69
  %71 = getelementptr ptr, ptr %70, i32 3
  %72 = load ptr, ptr %71, align 8
  %73 = getelementptr { ptr, ptr }, ptr %72, i32 0, i32 0
  %74 = load ptr, ptr %73, align 8
  %75 = call { ptr } %74(ptr %66) #2
  %76 = alloca ptr, align 8
  store { ptr } %75, ptr %76, align 8
  %77 = load ptr, ptr %7, align 8
  %78 = load ptr, ptr %6, align 8
  %79 = call ptr @llvm.invariant.start.p0(i64 984, ptr %78)
  %80 = load i32, ptr %5, align 4
  %81 = getelementptr ptr, ptr %78, i32 %80
  %82 = load ptr, ptr %81, align 8
  %83 = call ptr @typegetter_wrapper(ptr %82, ptr %77)
  %84 = load ptr, ptr %7, align 8
  %85 = load ptr, ptr %6, align 8
  %86 = call ptr @llvm.invariant.start.p0(i64 984, ptr %85)
  %87 = load i32, ptr %5, align 4
  %88 = getelementptr ptr, ptr %85, i32 %87
  %89 = getelementptr ptr, ptr %88, i32 1
  %90 = load ptr, ptr %89, align 8
  %91 = call ptr @typegetter_wrapper(ptr %90, ptr %84)
  %92 = alloca [3 x ptr], align 8
  store ptr @Mapper, ptr %92, align 8
  %93 = getelementptr ptr, ptr %92, i32 1
  store ptr %83, ptr %93, align 8
  %94 = getelementptr ptr, ptr %92, i32 2
  store ptr %91, ptr %94, align 8
  %95 = load ptr, ptr %92, align 8
  %96 = getelementptr ptr, ptr %95, i32 6
  %97 = load ptr, ptr %96, align 8
  %98 = call { i64, i64 } @size_wrapper(ptr %97, ptr %92)
  %99 = extractvalue { i64, i64 } %98, 0
  %100 = call ptr @bump_malloc(i64 %99)
  store ptr %83, ptr %100, align 8
  %101 = getelementptr ptr, ptr %100, i32 1
  store ptr %91, ptr %101, align 8
  %102 = call ptr @llvm.invariant.start.p0(i64 16, ptr %100)
  %103 = alloca i32, align 4
  %104 = alloca ptr, align 8
  %105 = alloca ptr, align 8
  %106 = alloca ptr, align 8
  store ptr @Mapper, ptr %106, align 8
  store ptr %100, ptr %105, align 8
  store i32 10, ptr %103, align 4
  %107 = load ptr, ptr %7, align 8
  %108 = load ptr, ptr %6, align 8
  %109 = call ptr @llvm.invariant.start.p0(i64 984, ptr %108)
  %110 = load i32, ptr %5, align 4
  %111 = getelementptr ptr, ptr %108, i32 %110
  %112 = getelementptr ptr, ptr %111, i32 2
  %113 = load ptr, ptr %112, align 8
  %114 = getelementptr { ptr, ptr }, ptr %113, i32 0, i32 0
  %115 = load ptr, ptr %114, align 8
  %116 = call { ptr, ptr, ptr, i32 } %115(ptr %107) #2
  %117 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %116, ptr %117, align 8
  call void @assume_offset(ptr %117, ptr @Collection)
  %118 = getelementptr { ptr, ptr, ptr, i32 }, ptr %117, i32 0, i32 0
  %119 = load ptr, ptr %118, align 8
  %120 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %119, 0
  %121 = getelementptr { ptr, ptr, ptr, i32 }, ptr %117, i32 0, i32 1
  %122 = load ptr, ptr %121, align 8
  %123 = insertvalue { ptr, ptr, ptr, i32 } %120, ptr %122, 1
  %124 = getelementptr { ptr, ptr, ptr, i32 }, ptr %117, i32 0, i32 2
  %125 = load ptr, ptr %124, align 8
  %126 = insertvalue { ptr, ptr, ptr, i32 } %123, ptr %125, 2
  %127 = getelementptr { ptr, ptr, ptr, i32 }, ptr %117, i32 0, i32 3
  %128 = load i32, ptr %127, align 4
  %129 = insertvalue { ptr, ptr, ptr, i32 } %126, i32 %128, 3
  %130 = alloca [0 x ptr], align 8
  %131 = call ptr @llvm.invariant.start.p0(i64 0, ptr %130)
  %132 = call ptr @llvm.invariant.start.p0(i64 472, ptr %119)
  %133 = getelementptr ptr, ptr %119, i32 %128
  %134 = getelementptr ptr, ptr %133, i32 3
  %135 = load ptr, ptr %134, align 8
  %136 = alloca {}, align 8
  %137 = call ptr @behavior_wrapper(ptr %135, { ptr, ptr, ptr, i32 } %129, ptr %136)
  %138 = call { ptr, ptr, ptr, i32 } %137({ ptr, ptr, ptr, i32 } %129, { ptr, ptr, ptr, i32 } %129, ptr %130)
  %139 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %138, ptr %139, align 8
  %140 = alloca i32, align 4
  %141 = alloca ptr, align 8
  %142 = alloca ptr, align 8
  %143 = alloca ptr, align 8
  %144 = getelementptr { ptr, ptr, ptr, i32 }, ptr %139, i32 0, i32 0
  %145 = load ptr, ptr %144, align 8
  store ptr %145, ptr %143, align 8
  %146 = getelementptr { ptr, ptr, ptr, i32 }, ptr %139, i32 0, i32 1
  %147 = load ptr, ptr %146, align 8
  store ptr %147, ptr %142, align 8
  %148 = getelementptr { ptr, ptr, ptr, i32 }, ptr %139, i32 0, i32 2
  %149 = load ptr, ptr %148, align 8
  store ptr %149, ptr %141, align 8
  %150 = getelementptr { ptr, ptr, ptr, i32 }, ptr %139, i32 0, i32 3
  %151 = load i32, ptr %150, align 4
  store i32 %151, ptr %140, align 4
  %152 = load ptr, ptr %143, align 8
  %153 = call i32 @get_offset(ptr %152, ptr @Iterator)
  store i32 %153, ptr %140, align 4
  %154 = load ptr, ptr %7, align 8
  %155 = load ptr, ptr %6, align 8
  %156 = call ptr @llvm.invariant.start.p0(i64 984, ptr %155)
  %157 = load i32, ptr %5, align 4
  %158 = getelementptr ptr, ptr %155, i32 %157
  %159 = getelementptr ptr, ptr %158, i32 3
  %160 = load ptr, ptr %159, align 8
  %161 = getelementptr { ptr, ptr }, ptr %160, i32 0, i32 0
  %162 = load ptr, ptr %161, align 8
  %163 = call { ptr } %162(ptr %154) #2
  %164 = alloca ptr, align 8
  store { ptr } %163, ptr %164, align 8
  %165 = alloca i32, align 4
  %166 = alloca ptr, align 8
  %167 = alloca ptr, align 8
  %168 = alloca ptr, align 8
  %169 = load ptr, ptr %143, align 8
  store ptr %169, ptr %168, align 8
  %170 = load ptr, ptr %142, align 8
  store ptr %170, ptr %167, align 8
  %171 = load ptr, ptr %141, align 8
  store ptr %171, ptr %166, align 8
  %172 = load i32, ptr %140, align 4
  store i32 %172, ptr %165, align 4
  %173 = load ptr, ptr %168, align 8
  %174 = call i32 @get_offset(ptr %173, ptr @Iterator)
  store i32 %174, ptr %165, align 4
  %175 = load ptr, ptr %168, align 8
  %176 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %175, 0
  %177 = load ptr, ptr %167, align 8
  %178 = insertvalue { ptr, ptr, ptr, i32 } %176, ptr %177, 1
  %179 = load ptr, ptr %166, align 8
  %180 = insertvalue { ptr, ptr, ptr, i32 } %178, ptr %179, 2
  %181 = load i32, ptr %165, align 4
  %182 = insertvalue { ptr, ptr, ptr, i32 } %180, i32 %181, 3
  %183 = load ptr, ptr %164, align 8
  %184 = insertvalue { ptr } undef, ptr %183, 0
  %185 = load ptr, ptr %106, align 8
  %186 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %185, 0
  %187 = load ptr, ptr %105, align 8
  %188 = insertvalue { ptr, ptr, ptr, i32 } %186, ptr %187, 1
  %189 = load ptr, ptr %104, align 8
  %190 = insertvalue { ptr, ptr, ptr, i32 } %188, ptr %189, 2
  %191 = load i32, ptr %103, align 4
  %192 = insertvalue { ptr, ptr, ptr, i32 } %190, i32 %191, 3
  %193 = load ptr, ptr %7, align 8
  %194 = load ptr, ptr %6, align 8
  %195 = call ptr @llvm.invariant.start.p0(i64 984, ptr %194)
  %196 = load i32, ptr %5, align 4
  %197 = getelementptr ptr, ptr %194, i32 %196
  %198 = load ptr, ptr %197, align 8
  %199 = call ptr @typegetter_wrapper(ptr %198, ptr %193)
  %200 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %201 = getelementptr [3 x ptr], ptr %200, i32 0, i32 1
  store ptr %199, ptr %201, align 8
  %202 = getelementptr [3 x ptr], ptr %200, i32 0, i32 2
  store ptr null, ptr %202, align 8
  %203 = call ptr @llvm.invariant.start.p0(i64 16, ptr %200)
  store ptr @Iterator, ptr %200, align 8
  %204 = load ptr, ptr %7, align 8
  %205 = load ptr, ptr %6, align 8
  %206 = call ptr @llvm.invariant.start.p0(i64 984, ptr %205)
  %207 = load i32, ptr %5, align 4
  %208 = getelementptr ptr, ptr %205, i32 %207
  %209 = getelementptr ptr, ptr %208, i32 1
  %210 = load ptr, ptr %209, align 8
  %211 = call ptr @typegetter_wrapper(ptr %210, ptr %204)
  %212 = load ptr, ptr %7, align 8
  %213 = load ptr, ptr %6, align 8
  %214 = call ptr @llvm.invariant.start.p0(i64 984, ptr %213)
  %215 = load i32, ptr %5, align 4
  %216 = getelementptr ptr, ptr %213, i32 %215
  %217 = load ptr, ptr %216, align 8
  %218 = call ptr @typegetter_wrapper(ptr %217, ptr %212)
  %219 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([4 x ptr], ptr null, i32 1) to i64))
  %220 = getelementptr [4 x ptr], ptr %219, i32 0, i32 2
  store ptr %218, ptr %220, align 8
  %221 = getelementptr [4 x ptr], ptr %219, i32 0, i32 1
  store ptr %211, ptr %221, align 8
  %222 = getelementptr [4 x ptr], ptr %219, i32 0, i32 3
  store ptr null, ptr %222, align 8
  %223 = call ptr @llvm.invariant.start.p0(i64 24, ptr %219)
  store ptr @function_typ, ptr %219, align 8
  %224 = alloca [2 x ptr], align 8
  %225 = getelementptr [2 x ptr], ptr %224, i32 0, i32 0
  store ptr %200, ptr %225, align 8
  %226 = getelementptr [2 x ptr], ptr %224, i32 0, i32 1
  store ptr %219, ptr %226, align 8
  %227 = call ptr @llvm.invariant.start.p0(i64 4, ptr %224)
  %228 = call ptr @llvm.invariant.start.p0(i64 88, ptr %185)
  %229 = getelementptr ptr, ptr %185, i32 %191
  %230 = getelementptr ptr, ptr %229, i32 4
  %231 = load ptr, ptr %230, align 8
  %232 = alloca { ptr, ptr }, align 8
  %233 = getelementptr { ptr, ptr }, ptr %232, i32 0, i32 0
  store ptr %175, ptr %233, align 8
  %234 = getelementptr { ptr, ptr }, ptr %232, i32 0, i32 1
  store ptr @function_typ, ptr %234, align 8
  %235 = call ptr @behavior_wrapper(ptr %231, { ptr, ptr, ptr, i32 } %192, ptr %232)
  call void %235({ ptr, ptr, ptr, i32 } %192, { ptr, ptr, ptr, i32 } %192, ptr %224, { ptr, ptr, ptr, i32 } %182, { ptr } %184)
  %236 = alloca i32, align 4
  %237 = alloca ptr, align 8
  %238 = alloca ptr, align 8
  %239 = alloca ptr, align 8
  %240 = load ptr, ptr %106, align 8
  store ptr %240, ptr %239, align 8
  %241 = load ptr, ptr %105, align 8
  store ptr %241, ptr %238, align 8
  %242 = load ptr, ptr %104, align 8
  store ptr %242, ptr %237, align 8
  %243 = load i32, ptr %103, align 4
  store i32 %243, ptr %236, align 4
  %244 = load ptr, ptr %239, align 8
  %245 = call i32 @get_offset(ptr %244, ptr @Iterator)
  store i32 %245, ptr %236, align 4
  %246 = load ptr, ptr %239, align 8
  %247 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %246, 0
  %248 = load ptr, ptr %238, align 8
  %249 = insertvalue { ptr, ptr, ptr, i32 } %247, ptr %248, 1
  %250 = load ptr, ptr %237, align 8
  %251 = insertvalue { ptr, ptr, ptr, i32 } %249, ptr %250, 2
  %252 = load i32, ptr %236, align 4
  %253 = insertvalue { ptr, ptr, ptr, i32 } %251, i32 %252, 3
  ret { ptr, ptr, ptr, i32 } %253
}

define ptr @MappedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 22, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [123 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @MappedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 23, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [123 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @MappedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @any_typ, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @any_typ to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = ptrtoint ptr %20 to i64
  %22 = icmp eq i64 %21, ptrtoint (ptr @function_typ to i64)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 24, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [123 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define ptr @MappedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 25, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [123 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @MappedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 26, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [123 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @MappedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 27, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [123 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @MappedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = ptrtoint ptr %7 to i64
  %9 = icmp eq i64 %8, ptrtoint (ptr @function_typ to i64)
  %10 = zext i1 %9 to i8
  store i8 %10, ptr %3, align 1
  %11 = load i8, ptr %3, align 1
  %12 = trunc i8 %11 to i1
  %13 = select i1 %12, i32 29, i32 28
  br i1 %12, label %14, label %15

14:                                               ; preds = %2
  br label %20

15:                                               ; preds = %2
  %16 = load ptr, ptr %1, align 8
  %17 = ptrtoint ptr %16 to i64
  %18 = icmp eq i64 %17, ptrtoint (ptr @function_typ to i64)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %4, align 1
  br label %20

20:                                               ; preds = %14, %15
  store i32 %13, ptr %6, align 4
  %21 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %22 = load i32, ptr %6, align 4
  %23 = getelementptr [123 x ptr], ptr %21, i32 0, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 10
  %25 = load ptr, ptr %24, align 8
  ret ptr %25
}

define ptr @MappedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 30, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [123 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @MappedCollection_B_chain_otherCollectionT_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 31, i32 32
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [123 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

define ptr @MappedCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 33, i32 34
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [123 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

define ptr @MappedCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 36, i32 35
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [123 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

define ptr @MappedCollection_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 38, i32 37
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [123 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

define { i64, i64 } @_data_size_ChainedCollection(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %10
  %12 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %5
  %13 = select i1 %12, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %5
  %14 = urem i64 %11, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %17
  %19 = add i64 %11, %18
  %20 = urem i64 %19, %13
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 %13, %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = add i64 %19, %23
  %25 = insertvalue { i64, i64 } undef, i64 %24, 0
  %26 = insertvalue { i64, i64 } %25, i64 %13, 1
  ret { i64, i64 } %26
}

define ptr @ChainedCollection_field_ChainedCollection_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define { ptr, ptr, ptr, i32 } @ChainedCollection_getter_first(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = getelementptr i8, ptr %0, i64 %6
  %8 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %9, 0
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %12, 1
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %15, 2
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  %19 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %18, 3
  ret { ptr, ptr, ptr, i32 } %19
}

define void @ChainedCollection_setter_first(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = getelementptr i8, ptr %0, i64 %7
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %9, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 0
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 0
  %12 = load ptr, ptr %10, align 8
  store ptr %12, ptr %11, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 1
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 1
  %15 = load ptr, ptr %13, align 8
  store ptr %15, ptr %14, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 2
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 2
  %18 = load ptr, ptr %16, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 3
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 3
  %21 = load i32, ptr %19, align 4
  store i32 %21, ptr %20, align 4
  ret void
}

define { ptr, ptr, ptr, i32 } @ChainedCollection_getter_second(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %7, %11
  %13 = getelementptr i8, ptr %0, i64 %12
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %15, 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 1
  %18 = load ptr, ptr %17, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %18, 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 2
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %21, 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 3
  %24 = load i32, ptr %23, align 4
  %25 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %24, 3
  ret { ptr, ptr, ptr, i32 } %25
}

define void @ChainedCollection_setter_second(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %8, %12
  %14 = getelementptr i8, ptr %0, i64 %13
  %15 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %15, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 0
  %18 = load ptr, ptr %16, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 1
  %21 = load ptr, ptr %19, align 8
  store ptr %21, ptr %20, align 8
  %22 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 2
  %24 = load ptr, ptr %22, align 8
  store ptr %24, ptr %23, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 3
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 3
  %27 = load i32, ptr %25, align 4
  store i32 %27, ptr %26, align 4
  ret void
}

define void @ChainedCollection_init_firstCollectionT_secondCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) {
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %6, align 8
  %7 = alloca i32, align 4
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = alloca ptr, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %8, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 1
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %9, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 2
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %10, align 8
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  store i32 %18, ptr %7, align 4
  %19 = load ptr, ptr %8, align 8
  %20 = call i32 @get_offset(ptr %19, ptr @ChainedCollection)
  store i32 %20, ptr %7, align 4
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %21, align 8
  %22 = alloca i32, align 4
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = alloca ptr, align 8
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  store ptr %27, ptr %25, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 1
  %29 = load ptr, ptr %28, align 8
  store ptr %29, ptr %24, align 8
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 2
  %31 = load ptr, ptr %30, align 8
  store ptr %31, ptr %23, align 8
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 3
  %33 = load i32, ptr %32, align 4
  store i32 %33, ptr %22, align 4
  %34 = load ptr, ptr %25, align 8
  %35 = call i32 @get_offset(ptr %34, ptr @Collection)
  store i32 %35, ptr %22, align 4
  %36 = alloca i32, align 4
  %37 = alloca ptr, align 8
  %38 = alloca ptr, align 8
  %39 = alloca ptr, align 8
  %40 = load ptr, ptr %25, align 8
  store ptr %40, ptr %39, align 8
  %41 = load ptr, ptr %24, align 8
  store ptr %41, ptr %38, align 8
  %42 = load ptr, ptr %23, align 8
  store ptr %42, ptr %37, align 8
  %43 = load i32, ptr %22, align 4
  store i32 %43, ptr %36, align 4
  %44 = load ptr, ptr %39, align 8
  %45 = call i32 @get_offset(ptr %44, ptr @Collection)
  store i32 %45, ptr %36, align 4
  %46 = load ptr, ptr %9, align 8
  %47 = load ptr, ptr %8, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 976, ptr %47)
  %49 = load i32, ptr %7, align 4
  %50 = getelementptr ptr, ptr %47, i32 %49
  %51 = getelementptr ptr, ptr %50, i32 1
  %52 = load ptr, ptr %51, align 8
  %53 = getelementptr { ptr, ptr }, ptr %52, i32 0, i32 1
  %54 = load ptr, ptr %53, align 8
  %55 = load ptr, ptr %39, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %55, 0
  %57 = load ptr, ptr %38, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %57, 1
  %59 = load ptr, ptr %37, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %59, 2
  %61 = load i32, ptr %36, align 4
  %62 = insertvalue { ptr, ptr, ptr, i32 } %60, i32 %61, 3
  call void %54(ptr %46, { ptr, ptr, ptr, i32 } %62) #1
  %63 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %4, ptr %63, align 8
  %64 = alloca i32, align 4
  %65 = alloca ptr, align 8
  %66 = alloca ptr, align 8
  %67 = alloca ptr, align 8
  %68 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 0
  %69 = load ptr, ptr %68, align 8
  store ptr %69, ptr %67, align 8
  %70 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 1
  %71 = load ptr, ptr %70, align 8
  store ptr %71, ptr %66, align 8
  %72 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 2
  %73 = load ptr, ptr %72, align 8
  store ptr %73, ptr %65, align 8
  %74 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 3
  %75 = load i32, ptr %74, align 4
  store i32 %75, ptr %64, align 4
  %76 = load ptr, ptr %67, align 8
  %77 = call i32 @get_offset(ptr %76, ptr @Collection)
  store i32 %77, ptr %64, align 4
  %78 = alloca i32, align 4
  %79 = alloca ptr, align 8
  %80 = alloca ptr, align 8
  %81 = alloca ptr, align 8
  %82 = load ptr, ptr %67, align 8
  store ptr %82, ptr %81, align 8
  %83 = load ptr, ptr %66, align 8
  store ptr %83, ptr %80, align 8
  %84 = load ptr, ptr %65, align 8
  store ptr %84, ptr %79, align 8
  %85 = load i32, ptr %64, align 4
  store i32 %85, ptr %78, align 4
  %86 = load ptr, ptr %81, align 8
  %87 = call i32 @get_offset(ptr %86, ptr @Collection)
  store i32 %87, ptr %78, align 4
  %88 = load ptr, ptr %9, align 8
  %89 = load ptr, ptr %8, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 976, ptr %89)
  %91 = load i32, ptr %7, align 4
  %92 = getelementptr ptr, ptr %89, i32 %91
  %93 = getelementptr ptr, ptr %92, i32 2
  %94 = load ptr, ptr %93, align 8
  %95 = getelementptr { ptr, ptr }, ptr %94, i32 0, i32 1
  %96 = load ptr, ptr %95, align 8
  %97 = load ptr, ptr %81, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %97, 0
  %99 = load ptr, ptr %80, align 8
  %100 = insertvalue { ptr, ptr, ptr, i32 } %98, ptr %99, 1
  %101 = load ptr, ptr %79, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } %100, ptr %101, 2
  %103 = load i32, ptr %78, align 4
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, i32 %103, 3
  call void %96(ptr %88, { ptr, ptr, ptr, i32 } %104) #1
  ret void
}

define ptr @ChainedCollection_B_init_firstCollectionT_secondCollectionT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @Collection, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @Collection to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 1
  %22 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 2
  %23 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 0
  %24 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 1
  %25 = load i64, ptr %21, align 4
  %26 = load i64, ptr %22, align 4
  %27 = load ptr, ptr %23, align 8
  %28 = load ptr, ptr %24, align 8
  %29 = load i64, ptr @Collection, align 4
  %30 = call i1 @subtype_test_wrapper(ptr %27, i64 %26, i64 %25, i64 %29, i64 ptrtoint (ptr @Collection to i64), ptr %28)
  %31 = zext i1 %30 to i8
  store i8 %31, ptr %3, align 1
  store i32 18, ptr %6, align 4
  %32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %33 = load i32, ptr %6, align 4
  %34 = getelementptr [122 x ptr], ptr %32, i32 0, i32 %33
  %35 = getelementptr ptr, ptr %34, i32 10
  %36 = load ptr, ptr %35, align 8
  ret ptr %36
}

define i32 @ChainedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @ChainedCollection)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 976, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 1
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr { ptr, ptr }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = call { ptr, ptr, ptr, i32 } %27(ptr %19) #2
  %29 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %28, ptr %29, align 8
  call void @assume_offset(ptr %29, ptr @Collection)
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 1
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %34, 1
  %36 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 2
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %37, 2
  %39 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 3
  %40 = load i32, ptr %39, align 4
  %41 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %40, 3
  %42 = alloca [0 x ptr], align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 0, ptr %42)
  %44 = call ptr @llvm.invariant.start.p0(i64 472, ptr %31)
  %45 = getelementptr ptr, ptr %31, i32 %40
  %46 = getelementptr ptr, ptr %45, i32 1
  %47 = load ptr, ptr %46, align 8
  %48 = alloca {}, align 8
  %49 = call ptr @behavior_wrapper(ptr %47, { ptr, ptr, ptr, i32 } %41, ptr %48)
  %50 = call i32 %49({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr %42)
  %51 = alloca i32, align 4
  store i32 %50, ptr %51, align 4
  %52 = load ptr, ptr %7, align 8
  %53 = load ptr, ptr %6, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 976, ptr %53)
  %55 = load i32, ptr %5, align 4
  %56 = getelementptr ptr, ptr %53, i32 %55
  %57 = getelementptr ptr, ptr %56, i32 2
  %58 = load ptr, ptr %57, align 8
  %59 = getelementptr { ptr, ptr }, ptr %58, i32 0, i32 0
  %60 = load ptr, ptr %59, align 8
  %61 = call { ptr, ptr, ptr, i32 } %60(ptr %52) #2
  %62 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %61, ptr %62, align 8
  call void @assume_offset(ptr %62, ptr @Collection)
  %63 = getelementptr { ptr, ptr, ptr, i32 }, ptr %62, i32 0, i32 0
  %64 = load ptr, ptr %63, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %64, 0
  %66 = getelementptr { ptr, ptr, ptr, i32 }, ptr %62, i32 0, i32 1
  %67 = load ptr, ptr %66, align 8
  %68 = insertvalue { ptr, ptr, ptr, i32 } %65, ptr %67, 1
  %69 = getelementptr { ptr, ptr, ptr, i32 }, ptr %62, i32 0, i32 2
  %70 = load ptr, ptr %69, align 8
  %71 = insertvalue { ptr, ptr, ptr, i32 } %68, ptr %70, 2
  %72 = getelementptr { ptr, ptr, ptr, i32 }, ptr %62, i32 0, i32 3
  %73 = load i32, ptr %72, align 4
  %74 = insertvalue { ptr, ptr, ptr, i32 } %71, i32 %73, 3
  %75 = alloca [0 x ptr], align 8
  %76 = call ptr @llvm.invariant.start.p0(i64 0, ptr %75)
  %77 = call ptr @llvm.invariant.start.p0(i64 472, ptr %64)
  %78 = getelementptr ptr, ptr %64, i32 %73
  %79 = getelementptr ptr, ptr %78, i32 1
  %80 = load ptr, ptr %79, align 8
  %81 = alloca {}, align 8
  %82 = call ptr @behavior_wrapper(ptr %80, { ptr, ptr, ptr, i32 } %74, ptr %81)
  %83 = call i32 %82({ ptr, ptr, ptr, i32 } %74, { ptr, ptr, ptr, i32 } %74, ptr %75)
  %84 = alloca i32, align 4
  store i32 %83, ptr %84, align 4
  %85 = load i32, ptr %51, align 4
  %86 = load i32, ptr %84, align 4
  %87 = add i32 %85, %86
  %88 = alloca i32, align 4
  store i32 %87, ptr %88, align 4
  %89 = load i32, ptr %88, align 4
  ret i32 %89
}

define ptr @ChainedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 19, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [122 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @ChainedCollection_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 20, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [122 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { ptr, ptr, ptr, i32 } @ChainedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @ChainedCollection)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 976, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 1
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr { ptr, ptr }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = call { ptr, ptr, ptr, i32 } %27(ptr %19) #2
  %29 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %28, ptr %29, align 8
  call void @assume_offset(ptr %29, ptr @Collection)
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 1
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %34, 1
  %36 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 2
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %37, 2
  %39 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 3
  %40 = load i32, ptr %39, align 4
  %41 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %40, 3
  %42 = alloca [0 x ptr], align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 0, ptr %42)
  %44 = call ptr @llvm.invariant.start.p0(i64 472, ptr %31)
  %45 = getelementptr ptr, ptr %31, i32 %40
  %46 = getelementptr ptr, ptr %45, i32 3
  %47 = load ptr, ptr %46, align 8
  %48 = alloca {}, align 8
  %49 = call ptr @behavior_wrapper(ptr %47, { ptr, ptr, ptr, i32 } %41, ptr %48)
  %50 = call { ptr, ptr, ptr, i32 } %49({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr %42)
  %51 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %50, ptr %51, align 8
  %52 = alloca i32, align 4
  %53 = alloca ptr, align 8
  %54 = alloca ptr, align 8
  %55 = alloca ptr, align 8
  %56 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 0
  %57 = load ptr, ptr %56, align 8
  store ptr %57, ptr %53, align 8
  %58 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 1
  %59 = load ptr, ptr %58, align 8
  store ptr %59, ptr %55, align 8
  %60 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 2
  %61 = load ptr, ptr %60, align 8
  store ptr %61, ptr %54, align 8
  %62 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 3
  %63 = load i32, ptr %62, align 4
  store i32 %63, ptr %52, align 4
  %64 = load ptr, ptr %53, align 8
  %65 = call i32 @get_offset(ptr %64, ptr @Iterator)
  store i32 %65, ptr %52, align 4
  %66 = load ptr, ptr %7, align 8
  %67 = load ptr, ptr %6, align 8
  %68 = call ptr @llvm.invariant.start.p0(i64 976, ptr %67)
  %69 = load i32, ptr %5, align 4
  %70 = getelementptr ptr, ptr %67, i32 %69
  %71 = getelementptr ptr, ptr %70, i32 2
  %72 = load ptr, ptr %71, align 8
  %73 = getelementptr { ptr, ptr }, ptr %72, i32 0, i32 0
  %74 = load ptr, ptr %73, align 8
  %75 = call { ptr, ptr, ptr, i32 } %74(ptr %66) #2
  %76 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %75, ptr %76, align 8
  call void @assume_offset(ptr %76, ptr @Collection)
  %77 = getelementptr { ptr, ptr, ptr, i32 }, ptr %76, i32 0, i32 0
  %78 = load ptr, ptr %77, align 8
  %79 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %78, 0
  %80 = getelementptr { ptr, ptr, ptr, i32 }, ptr %76, i32 0, i32 1
  %81 = load ptr, ptr %80, align 8
  %82 = insertvalue { ptr, ptr, ptr, i32 } %79, ptr %81, 1
  %83 = getelementptr { ptr, ptr, ptr, i32 }, ptr %76, i32 0, i32 2
  %84 = load ptr, ptr %83, align 8
  %85 = insertvalue { ptr, ptr, ptr, i32 } %82, ptr %84, 2
  %86 = getelementptr { ptr, ptr, ptr, i32 }, ptr %76, i32 0, i32 3
  %87 = load i32, ptr %86, align 4
  %88 = insertvalue { ptr, ptr, ptr, i32 } %85, i32 %87, 3
  %89 = alloca [0 x ptr], align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 0, ptr %89)
  %91 = call ptr @llvm.invariant.start.p0(i64 472, ptr %78)
  %92 = getelementptr ptr, ptr %78, i32 %87
  %93 = getelementptr ptr, ptr %92, i32 3
  %94 = load ptr, ptr %93, align 8
  %95 = alloca {}, align 8
  %96 = call ptr @behavior_wrapper(ptr %94, { ptr, ptr, ptr, i32 } %88, ptr %95)
  %97 = call { ptr, ptr, ptr, i32 } %96({ ptr, ptr, ptr, i32 } %88, { ptr, ptr, ptr, i32 } %88, ptr %89)
  %98 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %97, ptr %98, align 8
  %99 = alloca i32, align 4
  %100 = alloca ptr, align 8
  %101 = alloca ptr, align 8
  %102 = alloca ptr, align 8
  %103 = getelementptr { ptr, ptr, ptr, i32 }, ptr %98, i32 0, i32 0
  %104 = load ptr, ptr %103, align 8
  store ptr %104, ptr %100, align 8
  %105 = getelementptr { ptr, ptr, ptr, i32 }, ptr %98, i32 0, i32 1
  %106 = load ptr, ptr %105, align 8
  store ptr %106, ptr %102, align 8
  %107 = getelementptr { ptr, ptr, ptr, i32 }, ptr %98, i32 0, i32 2
  %108 = load ptr, ptr %107, align 8
  store ptr %108, ptr %101, align 8
  %109 = getelementptr { ptr, ptr, ptr, i32 }, ptr %98, i32 0, i32 3
  %110 = load i32, ptr %109, align 4
  store i32 %110, ptr %99, align 4
  %111 = load ptr, ptr %100, align 8
  %112 = call i32 @get_offset(ptr %111, ptr @Iterator)
  store i32 %112, ptr %99, align 4
  %113 = load ptr, ptr %7, align 8
  %114 = load ptr, ptr %6, align 8
  %115 = call ptr @llvm.invariant.start.p0(i64 976, ptr %114)
  %116 = load i32, ptr %5, align 4
  %117 = getelementptr ptr, ptr %114, i32 %116
  %118 = load ptr, ptr %117, align 8
  %119 = call ptr @typegetter_wrapper(ptr %118, ptr %113)
  %120 = alloca [2 x ptr], align 8
  store ptr @Chainer, ptr %120, align 8
  %121 = getelementptr ptr, ptr %120, i32 1
  store ptr %119, ptr %121, align 8
  %122 = load ptr, ptr %120, align 8
  %123 = getelementptr ptr, ptr %122, i32 6
  %124 = load ptr, ptr %123, align 8
  %125 = call { i64, i64 } @size_wrapper(ptr %124, ptr %120)
  %126 = extractvalue { i64, i64 } %125, 0
  %127 = call ptr @bump_malloc(i64 %126)
  store ptr %119, ptr %127, align 8
  %128 = call ptr @llvm.invariant.start.p0(i64 8, ptr %127)
  %129 = alloca i32, align 4
  %130 = alloca ptr, align 8
  %131 = alloca ptr, align 8
  %132 = alloca ptr, align 8
  store ptr @Chainer, ptr %132, align 8
  store ptr %127, ptr %131, align 8
  store i32 10, ptr %129, align 4
  %133 = load ptr, ptr %7, align 8
  %134 = load ptr, ptr %6, align 8
  %135 = call ptr @llvm.invariant.start.p0(i64 976, ptr %134)
  %136 = load i32, ptr %5, align 4
  %137 = getelementptr ptr, ptr %134, i32 %136
  %138 = getelementptr ptr, ptr %137, i32 1
  %139 = load ptr, ptr %138, align 8
  %140 = getelementptr { ptr, ptr }, ptr %139, i32 0, i32 0
  %141 = load ptr, ptr %140, align 8
  %142 = call { ptr, ptr, ptr, i32 } %141(ptr %133) #2
  %143 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %142, ptr %143, align 8
  call void @assume_offset(ptr %143, ptr @Collection)
  %144 = getelementptr { ptr, ptr, ptr, i32 }, ptr %143, i32 0, i32 0
  %145 = load ptr, ptr %144, align 8
  %146 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %145, 0
  %147 = getelementptr { ptr, ptr, ptr, i32 }, ptr %143, i32 0, i32 1
  %148 = load ptr, ptr %147, align 8
  %149 = insertvalue { ptr, ptr, ptr, i32 } %146, ptr %148, 1
  %150 = getelementptr { ptr, ptr, ptr, i32 }, ptr %143, i32 0, i32 2
  %151 = load ptr, ptr %150, align 8
  %152 = insertvalue { ptr, ptr, ptr, i32 } %149, ptr %151, 2
  %153 = getelementptr { ptr, ptr, ptr, i32 }, ptr %143, i32 0, i32 3
  %154 = load i32, ptr %153, align 4
  %155 = insertvalue { ptr, ptr, ptr, i32 } %152, i32 %154, 3
  %156 = alloca [0 x ptr], align 8
  %157 = call ptr @llvm.invariant.start.p0(i64 0, ptr %156)
  %158 = call ptr @llvm.invariant.start.p0(i64 472, ptr %145)
  %159 = getelementptr ptr, ptr %145, i32 %154
  %160 = getelementptr ptr, ptr %159, i32 3
  %161 = load ptr, ptr %160, align 8
  %162 = alloca {}, align 8
  %163 = call ptr @behavior_wrapper(ptr %161, { ptr, ptr, ptr, i32 } %155, ptr %162)
  %164 = call { ptr, ptr, ptr, i32 } %163({ ptr, ptr, ptr, i32 } %155, { ptr, ptr, ptr, i32 } %155, ptr %156)
  %165 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %164, ptr %165, align 8
  %166 = alloca i32, align 4
  %167 = alloca ptr, align 8
  %168 = alloca ptr, align 8
  %169 = alloca ptr, align 8
  %170 = getelementptr { ptr, ptr, ptr, i32 }, ptr %165, i32 0, i32 0
  %171 = load ptr, ptr %170, align 8
  store ptr %171, ptr %169, align 8
  %172 = getelementptr { ptr, ptr, ptr, i32 }, ptr %165, i32 0, i32 1
  %173 = load ptr, ptr %172, align 8
  store ptr %173, ptr %168, align 8
  %174 = getelementptr { ptr, ptr, ptr, i32 }, ptr %165, i32 0, i32 2
  %175 = load ptr, ptr %174, align 8
  store ptr %175, ptr %167, align 8
  %176 = getelementptr { ptr, ptr, ptr, i32 }, ptr %165, i32 0, i32 3
  %177 = load i32, ptr %176, align 4
  store i32 %177, ptr %166, align 4
  %178 = load ptr, ptr %169, align 8
  %179 = call i32 @get_offset(ptr %178, ptr @Iterator)
  store i32 %179, ptr %166, align 4
  %180 = load ptr, ptr %7, align 8
  %181 = load ptr, ptr %6, align 8
  %182 = call ptr @llvm.invariant.start.p0(i64 976, ptr %181)
  %183 = load i32, ptr %5, align 4
  %184 = getelementptr ptr, ptr %181, i32 %183
  %185 = getelementptr ptr, ptr %184, i32 2
  %186 = load ptr, ptr %185, align 8
  %187 = getelementptr { ptr, ptr }, ptr %186, i32 0, i32 0
  %188 = load ptr, ptr %187, align 8
  %189 = call { ptr, ptr, ptr, i32 } %188(ptr %180) #2
  %190 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %189, ptr %190, align 8
  call void @assume_offset(ptr %190, ptr @Collection)
  %191 = getelementptr { ptr, ptr, ptr, i32 }, ptr %190, i32 0, i32 0
  %192 = load ptr, ptr %191, align 8
  %193 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %192, 0
  %194 = getelementptr { ptr, ptr, ptr, i32 }, ptr %190, i32 0, i32 1
  %195 = load ptr, ptr %194, align 8
  %196 = insertvalue { ptr, ptr, ptr, i32 } %193, ptr %195, 1
  %197 = getelementptr { ptr, ptr, ptr, i32 }, ptr %190, i32 0, i32 2
  %198 = load ptr, ptr %197, align 8
  %199 = insertvalue { ptr, ptr, ptr, i32 } %196, ptr %198, 2
  %200 = getelementptr { ptr, ptr, ptr, i32 }, ptr %190, i32 0, i32 3
  %201 = load i32, ptr %200, align 4
  %202 = insertvalue { ptr, ptr, ptr, i32 } %199, i32 %201, 3
  %203 = alloca [0 x ptr], align 8
  %204 = call ptr @llvm.invariant.start.p0(i64 0, ptr %203)
  %205 = call ptr @llvm.invariant.start.p0(i64 472, ptr %192)
  %206 = getelementptr ptr, ptr %192, i32 %201
  %207 = getelementptr ptr, ptr %206, i32 3
  %208 = load ptr, ptr %207, align 8
  %209 = alloca {}, align 8
  %210 = call ptr @behavior_wrapper(ptr %208, { ptr, ptr, ptr, i32 } %202, ptr %209)
  %211 = call { ptr, ptr, ptr, i32 } %210({ ptr, ptr, ptr, i32 } %202, { ptr, ptr, ptr, i32 } %202, ptr %203)
  %212 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %211, ptr %212, align 8
  %213 = alloca i32, align 4
  %214 = alloca ptr, align 8
  %215 = alloca ptr, align 8
  %216 = alloca ptr, align 8
  %217 = getelementptr { ptr, ptr, ptr, i32 }, ptr %212, i32 0, i32 0
  %218 = load ptr, ptr %217, align 8
  store ptr %218, ptr %216, align 8
  %219 = getelementptr { ptr, ptr, ptr, i32 }, ptr %212, i32 0, i32 1
  %220 = load ptr, ptr %219, align 8
  store ptr %220, ptr %215, align 8
  %221 = getelementptr { ptr, ptr, ptr, i32 }, ptr %212, i32 0, i32 2
  %222 = load ptr, ptr %221, align 8
  store ptr %222, ptr %214, align 8
  %223 = getelementptr { ptr, ptr, ptr, i32 }, ptr %212, i32 0, i32 3
  %224 = load i32, ptr %223, align 4
  store i32 %224, ptr %213, align 4
  %225 = load ptr, ptr %216, align 8
  %226 = call i32 @get_offset(ptr %225, ptr @Iterator)
  store i32 %226, ptr %213, align 4
  %227 = alloca i32, align 4
  %228 = alloca ptr, align 8
  %229 = alloca ptr, align 8
  %230 = alloca ptr, align 8
  %231 = load ptr, ptr %169, align 8
  store ptr %231, ptr %230, align 8
  %232 = load ptr, ptr %168, align 8
  store ptr %232, ptr %229, align 8
  %233 = load ptr, ptr %167, align 8
  store ptr %233, ptr %228, align 8
  %234 = load i32, ptr %166, align 4
  store i32 %234, ptr %227, align 4
  %235 = load ptr, ptr %230, align 8
  %236 = call i32 @get_offset(ptr %235, ptr @Iterator)
  store i32 %236, ptr %227, align 4
  %237 = load ptr, ptr %230, align 8
  %238 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %237, 0
  %239 = load ptr, ptr %229, align 8
  %240 = insertvalue { ptr, ptr, ptr, i32 } %238, ptr %239, 1
  %241 = load ptr, ptr %228, align 8
  %242 = insertvalue { ptr, ptr, ptr, i32 } %240, ptr %241, 2
  %243 = load i32, ptr %227, align 4
  %244 = insertvalue { ptr, ptr, ptr, i32 } %242, i32 %243, 3
  %245 = alloca i32, align 4
  %246 = alloca ptr, align 8
  %247 = alloca ptr, align 8
  %248 = alloca ptr, align 8
  %249 = load ptr, ptr %216, align 8
  store ptr %249, ptr %248, align 8
  %250 = load ptr, ptr %215, align 8
  store ptr %250, ptr %247, align 8
  %251 = load ptr, ptr %214, align 8
  store ptr %251, ptr %246, align 8
  %252 = load i32, ptr %213, align 4
  store i32 %252, ptr %245, align 4
  %253 = load ptr, ptr %248, align 8
  %254 = call i32 @get_offset(ptr %253, ptr @Iterator)
  store i32 %254, ptr %245, align 4
  %255 = load ptr, ptr %248, align 8
  %256 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %255, 0
  %257 = load ptr, ptr %247, align 8
  %258 = insertvalue { ptr, ptr, ptr, i32 } %256, ptr %257, 1
  %259 = load ptr, ptr %246, align 8
  %260 = insertvalue { ptr, ptr, ptr, i32 } %258, ptr %259, 2
  %261 = load i32, ptr %245, align 4
  %262 = insertvalue { ptr, ptr, ptr, i32 } %260, i32 %261, 3
  %263 = load ptr, ptr %132, align 8
  %264 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %263, 0
  %265 = load ptr, ptr %131, align 8
  %266 = insertvalue { ptr, ptr, ptr, i32 } %264, ptr %265, 1
  %267 = load ptr, ptr %130, align 8
  %268 = insertvalue { ptr, ptr, ptr, i32 } %266, ptr %267, 2
  %269 = load i32, ptr %129, align 4
  %270 = insertvalue { ptr, ptr, ptr, i32 } %268, i32 %269, 3
  %271 = load ptr, ptr %7, align 8
  %272 = load ptr, ptr %6, align 8
  %273 = call ptr @llvm.invariant.start.p0(i64 976, ptr %272)
  %274 = load i32, ptr %5, align 4
  %275 = getelementptr ptr, ptr %272, i32 %274
  %276 = load ptr, ptr %275, align 8
  %277 = call ptr @typegetter_wrapper(ptr %276, ptr %271)
  %278 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %279 = getelementptr [3 x ptr], ptr %278, i32 0, i32 1
  store ptr %277, ptr %279, align 8
  %280 = getelementptr [3 x ptr], ptr %278, i32 0, i32 2
  store ptr null, ptr %280, align 8
  %281 = call ptr @llvm.invariant.start.p0(i64 16, ptr %278)
  store ptr @Iterator, ptr %278, align 8
  %282 = load ptr, ptr %7, align 8
  %283 = load ptr, ptr %6, align 8
  %284 = call ptr @llvm.invariant.start.p0(i64 976, ptr %283)
  %285 = load i32, ptr %5, align 4
  %286 = getelementptr ptr, ptr %283, i32 %285
  %287 = load ptr, ptr %286, align 8
  %288 = call ptr @typegetter_wrapper(ptr %287, ptr %282)
  %289 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %290 = getelementptr [3 x ptr], ptr %289, i32 0, i32 1
  store ptr %288, ptr %290, align 8
  %291 = getelementptr [3 x ptr], ptr %289, i32 0, i32 2
  store ptr null, ptr %291, align 8
  %292 = call ptr @llvm.invariant.start.p0(i64 16, ptr %289)
  store ptr @Iterator, ptr %289, align 8
  %293 = alloca [2 x ptr], align 8
  %294 = getelementptr [2 x ptr], ptr %293, i32 0, i32 0
  store ptr %278, ptr %294, align 8
  %295 = getelementptr [2 x ptr], ptr %293, i32 0, i32 1
  store ptr %289, ptr %295, align 8
  %296 = call ptr @llvm.invariant.start.p0(i64 4, ptr %293)
  %297 = call ptr @llvm.invariant.start.p0(i64 88, ptr %263)
  %298 = getelementptr ptr, ptr %263, i32 %269
  %299 = getelementptr ptr, ptr %298, i32 4
  %300 = load ptr, ptr %299, align 8
  %301 = alloca { ptr, ptr }, align 8
  %302 = getelementptr { ptr, ptr }, ptr %301, i32 0, i32 0
  store ptr %237, ptr %302, align 8
  %303 = getelementptr { ptr, ptr }, ptr %301, i32 0, i32 1
  store ptr %255, ptr %303, align 8
  %304 = call ptr @behavior_wrapper(ptr %300, { ptr, ptr, ptr, i32 } %270, ptr %301)
  call void %304({ ptr, ptr, ptr, i32 } %270, { ptr, ptr, ptr, i32 } %270, ptr %293, { ptr, ptr, ptr, i32 } %244, { ptr, ptr, ptr, i32 } %262)
  %305 = alloca i32, align 4
  %306 = alloca ptr, align 8
  %307 = alloca ptr, align 8
  %308 = alloca ptr, align 8
  %309 = load ptr, ptr %132, align 8
  store ptr %309, ptr %308, align 8
  %310 = load ptr, ptr %131, align 8
  store ptr %310, ptr %307, align 8
  %311 = load ptr, ptr %130, align 8
  store ptr %311, ptr %306, align 8
  %312 = load i32, ptr %129, align 4
  store i32 %312, ptr %305, align 4
  %313 = load ptr, ptr %308, align 8
  %314 = call i32 @get_offset(ptr %313, ptr @Iterator)
  store i32 %314, ptr %305, align 4
  %315 = load ptr, ptr %308, align 8
  %316 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %315, 0
  %317 = load ptr, ptr %307, align 8
  %318 = insertvalue { ptr, ptr, ptr, i32 } %316, ptr %317, 1
  %319 = load ptr, ptr %306, align 8
  %320 = insertvalue { ptr, ptr, ptr, i32 } %318, ptr %319, 2
  %321 = load i32, ptr %305, align 4
  %322 = insertvalue { ptr, ptr, ptr, i32 } %320, i32 %321, 3
  ret { ptr, ptr, ptr, i32 } %322
}

define ptr @ChainedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 21, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [122 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @ChainedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 22, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [122 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @ChainedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @any_typ, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @any_typ to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = ptrtoint ptr %20 to i64
  %22 = icmp eq i64 %21, ptrtoint (ptr @function_typ to i64)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 23, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [122 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define ptr @ChainedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 24, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [122 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @ChainedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 25, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [122 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @ChainedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 26, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [122 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @ChainedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = ptrtoint ptr %7 to i64
  %9 = icmp eq i64 %8, ptrtoint (ptr @function_typ to i64)
  %10 = zext i1 %9 to i8
  store i8 %10, ptr %3, align 1
  %11 = load i8, ptr %3, align 1
  %12 = trunc i8 %11 to i1
  %13 = select i1 %12, i32 27, i32 28
  br i1 %12, label %14, label %15

14:                                               ; preds = %2
  br label %20

15:                                               ; preds = %2
  %16 = load ptr, ptr %1, align 8
  %17 = ptrtoint ptr %16 to i64
  %18 = icmp eq i64 %17, ptrtoint (ptr @function_typ to i64)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %4, align 1
  br label %20

20:                                               ; preds = %14, %15
  store i32 %13, ptr %6, align 4
  %21 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %22 = load i32, ptr %6, align 4
  %23 = getelementptr [122 x ptr], ptr %21, i32 0, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 10
  %25 = load ptr, ptr %24, align 8
  ret ptr %25
}

define ptr @ChainedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 29, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [122 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @ChainedCollection_B_chain_otherCollectionT_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 30, i32 31
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [122 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

define ptr @ChainedCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 32, i32 33
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [122 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

define ptr @ChainedCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 35, i32 34
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [122 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

define ptr @ChainedCollection_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 37, i32 36
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [122 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

define { i64, i64 } @_data_size_InterleavedCollection(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %10
  %12 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %5
  %13 = select i1 %12, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %5
  %14 = urem i64 %11, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %17
  %19 = add i64 %11, %18
  %20 = urem i64 %19, %13
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 %13, %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = add i64 %19, %23
  %25 = insertvalue { i64, i64 } undef, i64 %24, 0
  %26 = insertvalue { i64, i64 } %25, i64 %13, 1
  ret { i64, i64 } %26
}

define ptr @InterleavedCollection_field_InterleavedCollection_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define { ptr, ptr, ptr, i32 } @InterleavedCollection_getter_first(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = getelementptr i8, ptr %0, i64 %6
  %8 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %9, 0
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %12, 1
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %15, 2
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  %19 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %18, 3
  ret { ptr, ptr, ptr, i32 } %19
}

define void @InterleavedCollection_setter_first(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = getelementptr i8, ptr %0, i64 %7
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %9, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 0
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 0
  %12 = load ptr, ptr %10, align 8
  store ptr %12, ptr %11, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 1
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 1
  %15 = load ptr, ptr %13, align 8
  store ptr %15, ptr %14, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 2
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 2
  %18 = load ptr, ptr %16, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 3
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 3
  %21 = load i32, ptr %19, align 4
  store i32 %21, ptr %20, align 4
  ret void
}

define { ptr, ptr, ptr, i32 } @InterleavedCollection_getter_second(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %7, %11
  %13 = getelementptr i8, ptr %0, i64 %12
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %15, 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 1
  %18 = load ptr, ptr %17, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %18, 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 2
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %21, 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 3
  %24 = load i32, ptr %23, align 4
  %25 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %24, 3
  ret { ptr, ptr, ptr, i32 } %25
}

define void @InterleavedCollection_setter_second(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %8, %12
  %14 = getelementptr i8, ptr %0, i64 %13
  %15 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %15, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 0
  %18 = load ptr, ptr %16, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 1
  %21 = load ptr, ptr %19, align 8
  store ptr %21, ptr %20, align 8
  %22 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 2
  %24 = load ptr, ptr %22, align 8
  store ptr %24, ptr %23, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 3
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 3
  %27 = load i32, ptr %25, align 4
  store i32 %27, ptr %26, align 4
  ret void
}

define void @InterleavedCollection_init_firstCollectionT_secondCollectionT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) {
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %6, align 8
  %7 = alloca i32, align 4
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = alloca ptr, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %8, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 1
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %9, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 2
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %10, align 8
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  store i32 %18, ptr %7, align 4
  %19 = load ptr, ptr %8, align 8
  %20 = call i32 @get_offset(ptr %19, ptr @InterleavedCollection)
  store i32 %20, ptr %7, align 4
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %21, align 8
  %22 = alloca i32, align 4
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = alloca ptr, align 8
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  store ptr %27, ptr %25, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 1
  %29 = load ptr, ptr %28, align 8
  store ptr %29, ptr %24, align 8
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 2
  %31 = load ptr, ptr %30, align 8
  store ptr %31, ptr %23, align 8
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 3
  %33 = load i32, ptr %32, align 4
  store i32 %33, ptr %22, align 4
  %34 = load ptr, ptr %25, align 8
  %35 = call i32 @get_offset(ptr %34, ptr @Collection)
  store i32 %35, ptr %22, align 4
  %36 = alloca i32, align 4
  %37 = alloca ptr, align 8
  %38 = alloca ptr, align 8
  %39 = alloca ptr, align 8
  %40 = load ptr, ptr %25, align 8
  store ptr %40, ptr %39, align 8
  %41 = load ptr, ptr %24, align 8
  store ptr %41, ptr %38, align 8
  %42 = load ptr, ptr %23, align 8
  store ptr %42, ptr %37, align 8
  %43 = load i32, ptr %22, align 4
  store i32 %43, ptr %36, align 4
  %44 = load ptr, ptr %39, align 8
  %45 = call i32 @get_offset(ptr %44, ptr @Collection)
  store i32 %45, ptr %36, align 4
  %46 = load ptr, ptr %9, align 8
  %47 = load ptr, ptr %8, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 976, ptr %47)
  %49 = load i32, ptr %7, align 4
  %50 = getelementptr ptr, ptr %47, i32 %49
  %51 = getelementptr ptr, ptr %50, i32 1
  %52 = load ptr, ptr %51, align 8
  %53 = getelementptr { ptr, ptr }, ptr %52, i32 0, i32 1
  %54 = load ptr, ptr %53, align 8
  %55 = load ptr, ptr %39, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %55, 0
  %57 = load ptr, ptr %38, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %57, 1
  %59 = load ptr, ptr %37, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %59, 2
  %61 = load i32, ptr %36, align 4
  %62 = insertvalue { ptr, ptr, ptr, i32 } %60, i32 %61, 3
  call void %54(ptr %46, { ptr, ptr, ptr, i32 } %62) #1
  %63 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %4, ptr %63, align 8
  %64 = alloca i32, align 4
  %65 = alloca ptr, align 8
  %66 = alloca ptr, align 8
  %67 = alloca ptr, align 8
  %68 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 0
  %69 = load ptr, ptr %68, align 8
  store ptr %69, ptr %67, align 8
  %70 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 1
  %71 = load ptr, ptr %70, align 8
  store ptr %71, ptr %66, align 8
  %72 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 2
  %73 = load ptr, ptr %72, align 8
  store ptr %73, ptr %65, align 8
  %74 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 3
  %75 = load i32, ptr %74, align 4
  store i32 %75, ptr %64, align 4
  %76 = load ptr, ptr %67, align 8
  %77 = call i32 @get_offset(ptr %76, ptr @Collection)
  store i32 %77, ptr %64, align 4
  %78 = alloca i32, align 4
  %79 = alloca ptr, align 8
  %80 = alloca ptr, align 8
  %81 = alloca ptr, align 8
  %82 = load ptr, ptr %67, align 8
  store ptr %82, ptr %81, align 8
  %83 = load ptr, ptr %66, align 8
  store ptr %83, ptr %80, align 8
  %84 = load ptr, ptr %65, align 8
  store ptr %84, ptr %79, align 8
  %85 = load i32, ptr %64, align 4
  store i32 %85, ptr %78, align 4
  %86 = load ptr, ptr %81, align 8
  %87 = call i32 @get_offset(ptr %86, ptr @Collection)
  store i32 %87, ptr %78, align 4
  %88 = load ptr, ptr %9, align 8
  %89 = load ptr, ptr %8, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 976, ptr %89)
  %91 = load i32, ptr %7, align 4
  %92 = getelementptr ptr, ptr %89, i32 %91
  %93 = getelementptr ptr, ptr %92, i32 2
  %94 = load ptr, ptr %93, align 8
  %95 = getelementptr { ptr, ptr }, ptr %94, i32 0, i32 1
  %96 = load ptr, ptr %95, align 8
  %97 = load ptr, ptr %81, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %97, 0
  %99 = load ptr, ptr %80, align 8
  %100 = insertvalue { ptr, ptr, ptr, i32 } %98, ptr %99, 1
  %101 = load ptr, ptr %79, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } %100, ptr %101, 2
  %103 = load i32, ptr %78, align 4
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, i32 %103, 3
  call void %96(ptr %88, { ptr, ptr, ptr, i32 } %104) #1
  ret void
}

define ptr @InterleavedCollection_B_init_firstCollectionT_secondCollectionT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @Collection, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @Collection to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 1
  %22 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 2
  %23 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 0
  %24 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 1
  %25 = load i64, ptr %21, align 4
  %26 = load i64, ptr %22, align 4
  %27 = load ptr, ptr %23, align 8
  %28 = load ptr, ptr %24, align 8
  %29 = load i64, ptr @Collection, align 4
  %30 = call i1 @subtype_test_wrapper(ptr %27, i64 %26, i64 %25, i64 %29, i64 ptrtoint (ptr @Collection to i64), ptr %28)
  %31 = zext i1 %30 to i8
  store i8 %31, ptr %3, align 1
  store i32 18, ptr %6, align 4
  %32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %33 = load i32, ptr %6, align 4
  %34 = getelementptr [122 x ptr], ptr %32, i32 0, i32 %33
  %35 = getelementptr ptr, ptr %34, i32 10
  %36 = load ptr, ptr %35, align 8
  ret ptr %36
}

define i32 @InterleavedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @InterleavedCollection)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 976, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 1
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr { ptr, ptr }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = call { ptr, ptr, ptr, i32 } %27(ptr %19) #2
  %29 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %28, ptr %29, align 8
  call void @assume_offset(ptr %29, ptr @Collection)
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 1
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %34, 1
  %36 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 2
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %37, 2
  %39 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 3
  %40 = load i32, ptr %39, align 4
  %41 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %40, 3
  %42 = alloca [0 x ptr], align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 0, ptr %42)
  %44 = call ptr @llvm.invariant.start.p0(i64 472, ptr %31)
  %45 = getelementptr ptr, ptr %31, i32 %40
  %46 = getelementptr ptr, ptr %45, i32 1
  %47 = load ptr, ptr %46, align 8
  %48 = alloca {}, align 8
  %49 = call ptr @behavior_wrapper(ptr %47, { ptr, ptr, ptr, i32 } %41, ptr %48)
  %50 = call i32 %49({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr %42)
  %51 = alloca i32, align 4
  store i32 %50, ptr %51, align 4
  %52 = load ptr, ptr %7, align 8
  %53 = load ptr, ptr %6, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 976, ptr %53)
  %55 = load i32, ptr %5, align 4
  %56 = getelementptr ptr, ptr %53, i32 %55
  %57 = getelementptr ptr, ptr %56, i32 2
  %58 = load ptr, ptr %57, align 8
  %59 = getelementptr { ptr, ptr }, ptr %58, i32 0, i32 0
  %60 = load ptr, ptr %59, align 8
  %61 = call { ptr, ptr, ptr, i32 } %60(ptr %52) #2
  %62 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %61, ptr %62, align 8
  call void @assume_offset(ptr %62, ptr @Collection)
  %63 = getelementptr { ptr, ptr, ptr, i32 }, ptr %62, i32 0, i32 0
  %64 = load ptr, ptr %63, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %64, 0
  %66 = getelementptr { ptr, ptr, ptr, i32 }, ptr %62, i32 0, i32 1
  %67 = load ptr, ptr %66, align 8
  %68 = insertvalue { ptr, ptr, ptr, i32 } %65, ptr %67, 1
  %69 = getelementptr { ptr, ptr, ptr, i32 }, ptr %62, i32 0, i32 2
  %70 = load ptr, ptr %69, align 8
  %71 = insertvalue { ptr, ptr, ptr, i32 } %68, ptr %70, 2
  %72 = getelementptr { ptr, ptr, ptr, i32 }, ptr %62, i32 0, i32 3
  %73 = load i32, ptr %72, align 4
  %74 = insertvalue { ptr, ptr, ptr, i32 } %71, i32 %73, 3
  %75 = alloca [0 x ptr], align 8
  %76 = call ptr @llvm.invariant.start.p0(i64 0, ptr %75)
  %77 = call ptr @llvm.invariant.start.p0(i64 472, ptr %64)
  %78 = getelementptr ptr, ptr %64, i32 %73
  %79 = getelementptr ptr, ptr %78, i32 1
  %80 = load ptr, ptr %79, align 8
  %81 = alloca {}, align 8
  %82 = call ptr @behavior_wrapper(ptr %80, { ptr, ptr, ptr, i32 } %74, ptr %81)
  %83 = call i32 %82({ ptr, ptr, ptr, i32 } %74, { ptr, ptr, ptr, i32 } %74, ptr %75)
  %84 = alloca i32, align 4
  store i32 %83, ptr %84, align 4
  %85 = load i32, ptr %51, align 4
  %86 = load i32, ptr %84, align 4
  %87 = add i32 %85, %86
  %88 = alloca i32, align 4
  store i32 %87, ptr %88, align 4
  %89 = load i32, ptr %88, align 4
  ret i32 %89
}

define ptr @InterleavedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 19, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [122 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @InterleavedCollection_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 20, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [122 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { ptr, ptr, ptr, i32 } @InterleavedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @InterleavedCollection)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 976, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 1
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr { ptr, ptr }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = call { ptr, ptr, ptr, i32 } %27(ptr %19) #2
  %29 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %28, ptr %29, align 8
  call void @assume_offset(ptr %29, ptr @Collection)
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 1
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %34, 1
  %36 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 2
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %37, 2
  %39 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 3
  %40 = load i32, ptr %39, align 4
  %41 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %40, 3
  %42 = alloca [0 x ptr], align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 0, ptr %42)
  %44 = call ptr @llvm.invariant.start.p0(i64 472, ptr %31)
  %45 = getelementptr ptr, ptr %31, i32 %40
  %46 = getelementptr ptr, ptr %45, i32 3
  %47 = load ptr, ptr %46, align 8
  %48 = alloca {}, align 8
  %49 = call ptr @behavior_wrapper(ptr %47, { ptr, ptr, ptr, i32 } %41, ptr %48)
  %50 = call { ptr, ptr, ptr, i32 } %49({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr %42)
  %51 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %50, ptr %51, align 8
  %52 = alloca i32, align 4
  %53 = alloca ptr, align 8
  %54 = alloca ptr, align 8
  %55 = alloca ptr, align 8
  %56 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 0
  %57 = load ptr, ptr %56, align 8
  store ptr %57, ptr %53, align 8
  %58 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 1
  %59 = load ptr, ptr %58, align 8
  store ptr %59, ptr %55, align 8
  %60 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 2
  %61 = load ptr, ptr %60, align 8
  store ptr %61, ptr %54, align 8
  %62 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 3
  %63 = load i32, ptr %62, align 4
  store i32 %63, ptr %52, align 4
  %64 = load ptr, ptr %53, align 8
  %65 = call i32 @get_offset(ptr %64, ptr @Iterator)
  store i32 %65, ptr %52, align 4
  %66 = load ptr, ptr %7, align 8
  %67 = load ptr, ptr %6, align 8
  %68 = call ptr @llvm.invariant.start.p0(i64 976, ptr %67)
  %69 = load i32, ptr %5, align 4
  %70 = getelementptr ptr, ptr %67, i32 %69
  %71 = getelementptr ptr, ptr %70, i32 2
  %72 = load ptr, ptr %71, align 8
  %73 = getelementptr { ptr, ptr }, ptr %72, i32 0, i32 0
  %74 = load ptr, ptr %73, align 8
  %75 = call { ptr, ptr, ptr, i32 } %74(ptr %66) #2
  %76 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %75, ptr %76, align 8
  call void @assume_offset(ptr %76, ptr @Collection)
  %77 = getelementptr { ptr, ptr, ptr, i32 }, ptr %76, i32 0, i32 0
  %78 = load ptr, ptr %77, align 8
  %79 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %78, 0
  %80 = getelementptr { ptr, ptr, ptr, i32 }, ptr %76, i32 0, i32 1
  %81 = load ptr, ptr %80, align 8
  %82 = insertvalue { ptr, ptr, ptr, i32 } %79, ptr %81, 1
  %83 = getelementptr { ptr, ptr, ptr, i32 }, ptr %76, i32 0, i32 2
  %84 = load ptr, ptr %83, align 8
  %85 = insertvalue { ptr, ptr, ptr, i32 } %82, ptr %84, 2
  %86 = getelementptr { ptr, ptr, ptr, i32 }, ptr %76, i32 0, i32 3
  %87 = load i32, ptr %86, align 4
  %88 = insertvalue { ptr, ptr, ptr, i32 } %85, i32 %87, 3
  %89 = alloca [0 x ptr], align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 0, ptr %89)
  %91 = call ptr @llvm.invariant.start.p0(i64 472, ptr %78)
  %92 = getelementptr ptr, ptr %78, i32 %87
  %93 = getelementptr ptr, ptr %92, i32 3
  %94 = load ptr, ptr %93, align 8
  %95 = alloca {}, align 8
  %96 = call ptr @behavior_wrapper(ptr %94, { ptr, ptr, ptr, i32 } %88, ptr %95)
  %97 = call { ptr, ptr, ptr, i32 } %96({ ptr, ptr, ptr, i32 } %88, { ptr, ptr, ptr, i32 } %88, ptr %89)
  %98 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %97, ptr %98, align 8
  %99 = alloca i32, align 4
  %100 = alloca ptr, align 8
  %101 = alloca ptr, align 8
  %102 = alloca ptr, align 8
  %103 = getelementptr { ptr, ptr, ptr, i32 }, ptr %98, i32 0, i32 0
  %104 = load ptr, ptr %103, align 8
  store ptr %104, ptr %100, align 8
  %105 = getelementptr { ptr, ptr, ptr, i32 }, ptr %98, i32 0, i32 1
  %106 = load ptr, ptr %105, align 8
  store ptr %106, ptr %102, align 8
  %107 = getelementptr { ptr, ptr, ptr, i32 }, ptr %98, i32 0, i32 2
  %108 = load ptr, ptr %107, align 8
  store ptr %108, ptr %101, align 8
  %109 = getelementptr { ptr, ptr, ptr, i32 }, ptr %98, i32 0, i32 3
  %110 = load i32, ptr %109, align 4
  store i32 %110, ptr %99, align 4
  %111 = load ptr, ptr %100, align 8
  %112 = call i32 @get_offset(ptr %111, ptr @Iterator)
  store i32 %112, ptr %99, align 4
  %113 = load ptr, ptr %7, align 8
  %114 = load ptr, ptr %6, align 8
  %115 = call ptr @llvm.invariant.start.p0(i64 976, ptr %114)
  %116 = load i32, ptr %5, align 4
  %117 = getelementptr ptr, ptr %114, i32 %116
  %118 = load ptr, ptr %117, align 8
  %119 = call ptr @typegetter_wrapper(ptr %118, ptr %113)
  %120 = alloca [2 x ptr], align 8
  store ptr @Interleaver, ptr %120, align 8
  %121 = getelementptr ptr, ptr %120, i32 1
  store ptr %119, ptr %121, align 8
  %122 = load ptr, ptr %120, align 8
  %123 = getelementptr ptr, ptr %122, i32 6
  %124 = load ptr, ptr %123, align 8
  %125 = call { i64, i64 } @size_wrapper(ptr %124, ptr %120)
  %126 = extractvalue { i64, i64 } %125, 0
  %127 = call ptr @bump_malloc(i64 %126)
  store ptr %119, ptr %127, align 8
  %128 = call ptr @llvm.invariant.start.p0(i64 8, ptr %127)
  %129 = alloca i32, align 4
  %130 = alloca ptr, align 8
  %131 = alloca ptr, align 8
  %132 = alloca ptr, align 8
  store ptr @Interleaver, ptr %132, align 8
  store ptr %127, ptr %131, align 8
  store i32 10, ptr %129, align 4
  %133 = load ptr, ptr %7, align 8
  %134 = load ptr, ptr %6, align 8
  %135 = call ptr @llvm.invariant.start.p0(i64 976, ptr %134)
  %136 = load i32, ptr %5, align 4
  %137 = getelementptr ptr, ptr %134, i32 %136
  %138 = getelementptr ptr, ptr %137, i32 1
  %139 = load ptr, ptr %138, align 8
  %140 = getelementptr { ptr, ptr }, ptr %139, i32 0, i32 0
  %141 = load ptr, ptr %140, align 8
  %142 = call { ptr, ptr, ptr, i32 } %141(ptr %133) #2
  %143 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %142, ptr %143, align 8
  call void @assume_offset(ptr %143, ptr @Collection)
  %144 = getelementptr { ptr, ptr, ptr, i32 }, ptr %143, i32 0, i32 0
  %145 = load ptr, ptr %144, align 8
  %146 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %145, 0
  %147 = getelementptr { ptr, ptr, ptr, i32 }, ptr %143, i32 0, i32 1
  %148 = load ptr, ptr %147, align 8
  %149 = insertvalue { ptr, ptr, ptr, i32 } %146, ptr %148, 1
  %150 = getelementptr { ptr, ptr, ptr, i32 }, ptr %143, i32 0, i32 2
  %151 = load ptr, ptr %150, align 8
  %152 = insertvalue { ptr, ptr, ptr, i32 } %149, ptr %151, 2
  %153 = getelementptr { ptr, ptr, ptr, i32 }, ptr %143, i32 0, i32 3
  %154 = load i32, ptr %153, align 4
  %155 = insertvalue { ptr, ptr, ptr, i32 } %152, i32 %154, 3
  %156 = alloca [0 x ptr], align 8
  %157 = call ptr @llvm.invariant.start.p0(i64 0, ptr %156)
  %158 = call ptr @llvm.invariant.start.p0(i64 472, ptr %145)
  %159 = getelementptr ptr, ptr %145, i32 %154
  %160 = getelementptr ptr, ptr %159, i32 3
  %161 = load ptr, ptr %160, align 8
  %162 = alloca {}, align 8
  %163 = call ptr @behavior_wrapper(ptr %161, { ptr, ptr, ptr, i32 } %155, ptr %162)
  %164 = call { ptr, ptr, ptr, i32 } %163({ ptr, ptr, ptr, i32 } %155, { ptr, ptr, ptr, i32 } %155, ptr %156)
  %165 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %164, ptr %165, align 8
  %166 = alloca i32, align 4
  %167 = alloca ptr, align 8
  %168 = alloca ptr, align 8
  %169 = alloca ptr, align 8
  %170 = getelementptr { ptr, ptr, ptr, i32 }, ptr %165, i32 0, i32 0
  %171 = load ptr, ptr %170, align 8
  store ptr %171, ptr %169, align 8
  %172 = getelementptr { ptr, ptr, ptr, i32 }, ptr %165, i32 0, i32 1
  %173 = load ptr, ptr %172, align 8
  store ptr %173, ptr %168, align 8
  %174 = getelementptr { ptr, ptr, ptr, i32 }, ptr %165, i32 0, i32 2
  %175 = load ptr, ptr %174, align 8
  store ptr %175, ptr %167, align 8
  %176 = getelementptr { ptr, ptr, ptr, i32 }, ptr %165, i32 0, i32 3
  %177 = load i32, ptr %176, align 4
  store i32 %177, ptr %166, align 4
  %178 = load ptr, ptr %169, align 8
  %179 = call i32 @get_offset(ptr %178, ptr @Iterator)
  store i32 %179, ptr %166, align 4
  %180 = load ptr, ptr %7, align 8
  %181 = load ptr, ptr %6, align 8
  %182 = call ptr @llvm.invariant.start.p0(i64 976, ptr %181)
  %183 = load i32, ptr %5, align 4
  %184 = getelementptr ptr, ptr %181, i32 %183
  %185 = getelementptr ptr, ptr %184, i32 2
  %186 = load ptr, ptr %185, align 8
  %187 = getelementptr { ptr, ptr }, ptr %186, i32 0, i32 0
  %188 = load ptr, ptr %187, align 8
  %189 = call { ptr, ptr, ptr, i32 } %188(ptr %180) #2
  %190 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %189, ptr %190, align 8
  call void @assume_offset(ptr %190, ptr @Collection)
  %191 = getelementptr { ptr, ptr, ptr, i32 }, ptr %190, i32 0, i32 0
  %192 = load ptr, ptr %191, align 8
  %193 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %192, 0
  %194 = getelementptr { ptr, ptr, ptr, i32 }, ptr %190, i32 0, i32 1
  %195 = load ptr, ptr %194, align 8
  %196 = insertvalue { ptr, ptr, ptr, i32 } %193, ptr %195, 1
  %197 = getelementptr { ptr, ptr, ptr, i32 }, ptr %190, i32 0, i32 2
  %198 = load ptr, ptr %197, align 8
  %199 = insertvalue { ptr, ptr, ptr, i32 } %196, ptr %198, 2
  %200 = getelementptr { ptr, ptr, ptr, i32 }, ptr %190, i32 0, i32 3
  %201 = load i32, ptr %200, align 4
  %202 = insertvalue { ptr, ptr, ptr, i32 } %199, i32 %201, 3
  %203 = alloca [0 x ptr], align 8
  %204 = call ptr @llvm.invariant.start.p0(i64 0, ptr %203)
  %205 = call ptr @llvm.invariant.start.p0(i64 472, ptr %192)
  %206 = getelementptr ptr, ptr %192, i32 %201
  %207 = getelementptr ptr, ptr %206, i32 3
  %208 = load ptr, ptr %207, align 8
  %209 = alloca {}, align 8
  %210 = call ptr @behavior_wrapper(ptr %208, { ptr, ptr, ptr, i32 } %202, ptr %209)
  %211 = call { ptr, ptr, ptr, i32 } %210({ ptr, ptr, ptr, i32 } %202, { ptr, ptr, ptr, i32 } %202, ptr %203)
  %212 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %211, ptr %212, align 8
  %213 = alloca i32, align 4
  %214 = alloca ptr, align 8
  %215 = alloca ptr, align 8
  %216 = alloca ptr, align 8
  %217 = getelementptr { ptr, ptr, ptr, i32 }, ptr %212, i32 0, i32 0
  %218 = load ptr, ptr %217, align 8
  store ptr %218, ptr %216, align 8
  %219 = getelementptr { ptr, ptr, ptr, i32 }, ptr %212, i32 0, i32 1
  %220 = load ptr, ptr %219, align 8
  store ptr %220, ptr %215, align 8
  %221 = getelementptr { ptr, ptr, ptr, i32 }, ptr %212, i32 0, i32 2
  %222 = load ptr, ptr %221, align 8
  store ptr %222, ptr %214, align 8
  %223 = getelementptr { ptr, ptr, ptr, i32 }, ptr %212, i32 0, i32 3
  %224 = load i32, ptr %223, align 4
  store i32 %224, ptr %213, align 4
  %225 = load ptr, ptr %216, align 8
  %226 = call i32 @get_offset(ptr %225, ptr @Iterator)
  store i32 %226, ptr %213, align 4
  %227 = alloca i32, align 4
  %228 = alloca ptr, align 8
  %229 = alloca ptr, align 8
  %230 = alloca ptr, align 8
  %231 = load ptr, ptr %169, align 8
  store ptr %231, ptr %230, align 8
  %232 = load ptr, ptr %168, align 8
  store ptr %232, ptr %229, align 8
  %233 = load ptr, ptr %167, align 8
  store ptr %233, ptr %228, align 8
  %234 = load i32, ptr %166, align 4
  store i32 %234, ptr %227, align 4
  %235 = load ptr, ptr %230, align 8
  %236 = call i32 @get_offset(ptr %235, ptr @Iterator)
  store i32 %236, ptr %227, align 4
  %237 = load ptr, ptr %230, align 8
  %238 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %237, 0
  %239 = load ptr, ptr %229, align 8
  %240 = insertvalue { ptr, ptr, ptr, i32 } %238, ptr %239, 1
  %241 = load ptr, ptr %228, align 8
  %242 = insertvalue { ptr, ptr, ptr, i32 } %240, ptr %241, 2
  %243 = load i32, ptr %227, align 4
  %244 = insertvalue { ptr, ptr, ptr, i32 } %242, i32 %243, 3
  %245 = alloca i32, align 4
  %246 = alloca ptr, align 8
  %247 = alloca ptr, align 8
  %248 = alloca ptr, align 8
  %249 = load ptr, ptr %216, align 8
  store ptr %249, ptr %248, align 8
  %250 = load ptr, ptr %215, align 8
  store ptr %250, ptr %247, align 8
  %251 = load ptr, ptr %214, align 8
  store ptr %251, ptr %246, align 8
  %252 = load i32, ptr %213, align 4
  store i32 %252, ptr %245, align 4
  %253 = load ptr, ptr %248, align 8
  %254 = call i32 @get_offset(ptr %253, ptr @Iterator)
  store i32 %254, ptr %245, align 4
  %255 = load ptr, ptr %248, align 8
  %256 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %255, 0
  %257 = load ptr, ptr %247, align 8
  %258 = insertvalue { ptr, ptr, ptr, i32 } %256, ptr %257, 1
  %259 = load ptr, ptr %246, align 8
  %260 = insertvalue { ptr, ptr, ptr, i32 } %258, ptr %259, 2
  %261 = load i32, ptr %245, align 4
  %262 = insertvalue { ptr, ptr, ptr, i32 } %260, i32 %261, 3
  %263 = load ptr, ptr %132, align 8
  %264 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %263, 0
  %265 = load ptr, ptr %131, align 8
  %266 = insertvalue { ptr, ptr, ptr, i32 } %264, ptr %265, 1
  %267 = load ptr, ptr %130, align 8
  %268 = insertvalue { ptr, ptr, ptr, i32 } %266, ptr %267, 2
  %269 = load i32, ptr %129, align 4
  %270 = insertvalue { ptr, ptr, ptr, i32 } %268, i32 %269, 3
  %271 = load ptr, ptr %7, align 8
  %272 = load ptr, ptr %6, align 8
  %273 = call ptr @llvm.invariant.start.p0(i64 976, ptr %272)
  %274 = load i32, ptr %5, align 4
  %275 = getelementptr ptr, ptr %272, i32 %274
  %276 = load ptr, ptr %275, align 8
  %277 = call ptr @typegetter_wrapper(ptr %276, ptr %271)
  %278 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %279 = getelementptr [3 x ptr], ptr %278, i32 0, i32 1
  store ptr %277, ptr %279, align 8
  %280 = getelementptr [3 x ptr], ptr %278, i32 0, i32 2
  store ptr null, ptr %280, align 8
  %281 = call ptr @llvm.invariant.start.p0(i64 16, ptr %278)
  store ptr @Iterator, ptr %278, align 8
  %282 = load ptr, ptr %7, align 8
  %283 = load ptr, ptr %6, align 8
  %284 = call ptr @llvm.invariant.start.p0(i64 976, ptr %283)
  %285 = load i32, ptr %5, align 4
  %286 = getelementptr ptr, ptr %283, i32 %285
  %287 = load ptr, ptr %286, align 8
  %288 = call ptr @typegetter_wrapper(ptr %287, ptr %282)
  %289 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %290 = getelementptr [3 x ptr], ptr %289, i32 0, i32 1
  store ptr %288, ptr %290, align 8
  %291 = getelementptr [3 x ptr], ptr %289, i32 0, i32 2
  store ptr null, ptr %291, align 8
  %292 = call ptr @llvm.invariant.start.p0(i64 16, ptr %289)
  store ptr @Iterator, ptr %289, align 8
  %293 = alloca [2 x ptr], align 8
  %294 = getelementptr [2 x ptr], ptr %293, i32 0, i32 0
  store ptr %278, ptr %294, align 8
  %295 = getelementptr [2 x ptr], ptr %293, i32 0, i32 1
  store ptr %289, ptr %295, align 8
  %296 = call ptr @llvm.invariant.start.p0(i64 4, ptr %293)
  %297 = call ptr @llvm.invariant.start.p0(i64 88, ptr %263)
  %298 = getelementptr ptr, ptr %263, i32 %269
  %299 = getelementptr ptr, ptr %298, i32 4
  %300 = load ptr, ptr %299, align 8
  %301 = alloca { ptr, ptr }, align 8
  %302 = getelementptr { ptr, ptr }, ptr %301, i32 0, i32 0
  store ptr %237, ptr %302, align 8
  %303 = getelementptr { ptr, ptr }, ptr %301, i32 0, i32 1
  store ptr %255, ptr %303, align 8
  %304 = call ptr @behavior_wrapper(ptr %300, { ptr, ptr, ptr, i32 } %270, ptr %301)
  call void %304({ ptr, ptr, ptr, i32 } %270, { ptr, ptr, ptr, i32 } %270, ptr %293, { ptr, ptr, ptr, i32 } %244, { ptr, ptr, ptr, i32 } %262)
  %305 = alloca i32, align 4
  %306 = alloca ptr, align 8
  %307 = alloca ptr, align 8
  %308 = alloca ptr, align 8
  %309 = load ptr, ptr %132, align 8
  store ptr %309, ptr %308, align 8
  %310 = load ptr, ptr %131, align 8
  store ptr %310, ptr %307, align 8
  %311 = load ptr, ptr %130, align 8
  store ptr %311, ptr %306, align 8
  %312 = load i32, ptr %129, align 4
  store i32 %312, ptr %305, align 4
  %313 = load ptr, ptr %308, align 8
  %314 = call i32 @get_offset(ptr %313, ptr @Iterator)
  store i32 %314, ptr %305, align 4
  %315 = load ptr, ptr %308, align 8
  %316 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %315, 0
  %317 = load ptr, ptr %307, align 8
  %318 = insertvalue { ptr, ptr, ptr, i32 } %316, ptr %317, 1
  %319 = load ptr, ptr %306, align 8
  %320 = insertvalue { ptr, ptr, ptr, i32 } %318, ptr %319, 2
  %321 = load i32, ptr %305, align 4
  %322 = insertvalue { ptr, ptr, ptr, i32 } %320, i32 %321, 3
  ret { ptr, ptr, ptr, i32 } %322
}

define ptr @InterleavedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 21, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [122 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @InterleavedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 22, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [122 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @InterleavedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @any_typ, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @any_typ to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = ptrtoint ptr %20 to i64
  %22 = icmp eq i64 %21, ptrtoint (ptr @function_typ to i64)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 23, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [122 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define ptr @InterleavedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 24, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [122 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @InterleavedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 25, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [122 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @InterleavedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 26, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [122 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @InterleavedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = ptrtoint ptr %7 to i64
  %9 = icmp eq i64 %8, ptrtoint (ptr @function_typ to i64)
  %10 = zext i1 %9 to i8
  store i8 %10, ptr %3, align 1
  %11 = load i8, ptr %3, align 1
  %12 = trunc i8 %11 to i1
  %13 = select i1 %12, i32 27, i32 28
  br i1 %12, label %14, label %15

14:                                               ; preds = %2
  br label %20

15:                                               ; preds = %2
  %16 = load ptr, ptr %1, align 8
  %17 = ptrtoint ptr %16 to i64
  %18 = icmp eq i64 %17, ptrtoint (ptr @function_typ to i64)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %4, align 1
  br label %20

20:                                               ; preds = %14, %15
  store i32 %13, ptr %6, align 4
  %21 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %22 = load i32, ptr %6, align 4
  %23 = getelementptr [122 x ptr], ptr %21, i32 0, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 10
  %25 = load ptr, ptr %24, align 8
  ret ptr %25
}

define ptr @InterleavedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 29, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [122 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @InterleavedCollection_B_chain_otherCollectionT_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 30, i32 31
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [122 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

define ptr @InterleavedCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 32, i32 33
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [122 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

define ptr @InterleavedCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 35, i32 34
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [122 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

define ptr @InterleavedCollection_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 37, i32 36
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [122 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

define { i64, i64 } @_data_size_ZippedCollection(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %10
  %12 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %5
  %13 = select i1 %12, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 %5
  %14 = urem i64 %11, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %17
  %19 = add i64 %11, %18
  %20 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %13
  %21 = select i1 %20, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %13
  %22 = urem i64 %19, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %23 = icmp eq i64 %22, 0
  %24 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %22
  %25 = select i1 %23, i64 0, i64 %24
  %26 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %25
  %27 = add i64 %19, %26
  %28 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %21
  %29 = select i1 %28, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %21
  %30 = urem i64 %27, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %31 = icmp eq i64 %30, 0
  %32 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %30
  %33 = select i1 %31, i64 0, i64 %32
  %34 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %33
  %35 = add i64 %27, %34
  %36 = urem i64 %35, %29
  %37 = icmp eq i64 %36, 0
  %38 = sub i64 %29, %36
  %39 = select i1 %37, i64 0, i64 %38
  %40 = add i64 %35, %39
  %41 = insertvalue { i64, i64 } undef, i64 %40, 0
  %42 = insertvalue { i64, i64 } %41, i64 %29, 1
  ret { i64, i64 } %42
}

define ptr @ZippedCollection_field_ZippedCollection_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define ptr @ZippedCollection_field_ZippedCollection_1(ptr %0) {
  %2 = getelementptr ptr, ptr %0, i32 1
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

define ptr @ZippedCollection_field_ZippedCollection_2(ptr %0) {
  %2 = getelementptr ptr, ptr %0, i32 2
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

define { ptr, ptr, ptr, i32 } @ZippedCollection_getter_first(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %11
  %13 = add i64 %7, %12
  %14 = urem i64 %13, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 %13, %17
  %19 = getelementptr i8, ptr %0, i64 %18
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 0
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %21, 0
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 1
  %24 = load ptr, ptr %23, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %24, 1
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 2
  %27 = load ptr, ptr %26, align 8
  %28 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %27, 2
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 3
  %30 = load i32, ptr %29, align 4
  %31 = insertvalue { ptr, ptr, ptr, i32 } %28, i32 %30, 3
  ret { ptr, ptr, ptr, i32 } %31
}

define void @ZippedCollection_setter_first(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %12
  %14 = add i64 %8, %13
  %15 = urem i64 %14, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %16 = icmp eq i64 %15, 0
  %17 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add i64 %14, %18
  %20 = getelementptr i8, ptr %0, i64 %19
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %21, align 8
  %22 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 0
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 0
  %24 = load ptr, ptr %22, align 8
  store ptr %24, ptr %23, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 1
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 1
  %27 = load ptr, ptr %25, align 8
  store ptr %27, ptr %26, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 2
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 2
  %30 = load ptr, ptr %28, align 8
  store ptr %30, ptr %29, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 3
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 3
  %33 = load i32, ptr %31, align 4
  store i32 %33, ptr %32, align 4
  ret void
}

define { ptr, ptr, ptr, i32 } @ZippedCollection_getter_second(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %11
  %13 = add i64 %7, %12
  %14 = urem i64 %13, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %17
  %19 = add i64 %13, %18
  %20 = urem i64 %19, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = add i64 %19, %23
  %25 = getelementptr i8, ptr %0, i64 %24
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %27, 0
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 1
  %30 = load ptr, ptr %29, align 8
  %31 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %30, 1
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 2
  %33 = load ptr, ptr %32, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %33, 2
  %35 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 3
  %36 = load i32, ptr %35, align 4
  %37 = insertvalue { ptr, ptr, ptr, i32 } %34, i32 %36, 3
  ret { ptr, ptr, ptr, i32 } %37
}

define void @ZippedCollection_setter_second(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %12
  %14 = add i64 %8, %13
  %15 = urem i64 %14, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %16 = icmp eq i64 %15, 0
  %17 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %18
  %20 = add i64 %14, %19
  %21 = urem i64 %20, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %22 = icmp eq i64 %21, 0
  %23 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %21
  %24 = select i1 %22, i64 0, i64 %23
  %25 = add i64 %20, %24
  %26 = getelementptr i8, ptr %0, i64 %25
  %27 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %27, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 0
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 0
  %30 = load ptr, ptr %28, align 8
  store ptr %30, ptr %29, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 1
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 1
  %33 = load ptr, ptr %31, align 8
  store ptr %33, ptr %32, align 8
  %34 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 2
  %35 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 2
  %36 = load ptr, ptr %34, align 8
  store ptr %36, ptr %35, align 8
  %37 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 3
  %38 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 3
  %39 = load i32, ptr %37, align 4
  store i32 %39, ptr %38, align 4
  ret void
}

define void @ZippedCollection_init_firstCollectionT_secondCollectionU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) {
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %6, align 8
  %7 = alloca i32, align 4
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = alloca ptr, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %8, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 1
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %9, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 2
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %10, align 8
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  store i32 %18, ptr %7, align 4
  %19 = load ptr, ptr %8, align 8
  %20 = call i32 @get_offset(ptr %19, ptr @ZippedCollection)
  store i32 %20, ptr %7, align 4
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %21, align 8
  %22 = alloca i32, align 4
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = alloca ptr, align 8
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  store ptr %27, ptr %25, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 1
  %29 = load ptr, ptr %28, align 8
  store ptr %29, ptr %24, align 8
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 2
  %31 = load ptr, ptr %30, align 8
  store ptr %31, ptr %23, align 8
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 3
  %33 = load i32, ptr %32, align 4
  store i32 %33, ptr %22, align 4
  %34 = load ptr, ptr %25, align 8
  %35 = call i32 @get_offset(ptr %34, ptr @Collection)
  store i32 %35, ptr %22, align 4
  %36 = alloca i32, align 4
  %37 = alloca ptr, align 8
  %38 = alloca ptr, align 8
  %39 = alloca ptr, align 8
  %40 = load ptr, ptr %25, align 8
  store ptr %40, ptr %39, align 8
  %41 = load ptr, ptr %24, align 8
  store ptr %41, ptr %38, align 8
  %42 = load ptr, ptr %23, align 8
  store ptr %42, ptr %37, align 8
  %43 = load i32, ptr %22, align 4
  store i32 %43, ptr %36, align 4
  %44 = load ptr, ptr %39, align 8
  %45 = call i32 @get_offset(ptr %44, ptr @Collection)
  store i32 %45, ptr %36, align 4
  %46 = load ptr, ptr %9, align 8
  %47 = load ptr, ptr %8, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 992, ptr %47)
  %49 = load i32, ptr %7, align 4
  %50 = getelementptr ptr, ptr %47, i32 %49
  %51 = getelementptr ptr, ptr %50, i32 3
  %52 = load ptr, ptr %51, align 8
  %53 = getelementptr { ptr, ptr }, ptr %52, i32 0, i32 1
  %54 = load ptr, ptr %53, align 8
  %55 = load ptr, ptr %39, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %55, 0
  %57 = load ptr, ptr %38, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %57, 1
  %59 = load ptr, ptr %37, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %59, 2
  %61 = load i32, ptr %36, align 4
  %62 = insertvalue { ptr, ptr, ptr, i32 } %60, i32 %61, 3
  call void %54(ptr %46, { ptr, ptr, ptr, i32 } %62) #1
  %63 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %4, ptr %63, align 8
  %64 = alloca i32, align 4
  %65 = alloca ptr, align 8
  %66 = alloca ptr, align 8
  %67 = alloca ptr, align 8
  %68 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 0
  %69 = load ptr, ptr %68, align 8
  store ptr %69, ptr %67, align 8
  %70 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 1
  %71 = load ptr, ptr %70, align 8
  store ptr %71, ptr %66, align 8
  %72 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 2
  %73 = load ptr, ptr %72, align 8
  store ptr %73, ptr %65, align 8
  %74 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 3
  %75 = load i32, ptr %74, align 4
  store i32 %75, ptr %64, align 4
  %76 = load ptr, ptr %67, align 8
  %77 = call i32 @get_offset(ptr %76, ptr @Collection)
  store i32 %77, ptr %64, align 4
  %78 = alloca i32, align 4
  %79 = alloca ptr, align 8
  %80 = alloca ptr, align 8
  %81 = alloca ptr, align 8
  %82 = load ptr, ptr %67, align 8
  store ptr %82, ptr %81, align 8
  %83 = load ptr, ptr %66, align 8
  store ptr %83, ptr %80, align 8
  %84 = load ptr, ptr %65, align 8
  store ptr %84, ptr %79, align 8
  %85 = load i32, ptr %64, align 4
  store i32 %85, ptr %78, align 4
  %86 = load ptr, ptr %81, align 8
  %87 = call i32 @get_offset(ptr %86, ptr @Collection)
  store i32 %87, ptr %78, align 4
  %88 = load ptr, ptr %9, align 8
  %89 = load ptr, ptr %8, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 992, ptr %89)
  %91 = load i32, ptr %7, align 4
  %92 = getelementptr ptr, ptr %89, i32 %91
  %93 = getelementptr ptr, ptr %92, i32 4
  %94 = load ptr, ptr %93, align 8
  %95 = getelementptr { ptr, ptr }, ptr %94, i32 0, i32 1
  %96 = load ptr, ptr %95, align 8
  %97 = load ptr, ptr %81, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %97, 0
  %99 = load ptr, ptr %80, align 8
  %100 = insertvalue { ptr, ptr, ptr, i32 } %98, ptr %99, 1
  %101 = load ptr, ptr %79, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } %100, ptr %101, 2
  %103 = load i32, ptr %78, align 4
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, i32 %103, 3
  call void %96(ptr %88, { ptr, ptr, ptr, i32 } %104) #1
  ret void
}

define ptr @ZippedCollection_B_init_firstCollectionT_secondCollectionU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @Collection, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @Collection to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 1
  %22 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 2
  %23 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 0
  %24 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 1
  %25 = load i64, ptr %21, align 4
  %26 = load i64, ptr %22, align 4
  %27 = load ptr, ptr %23, align 8
  %28 = load ptr, ptr %24, align 8
  %29 = load i64, ptr @Collection, align 4
  %30 = call i1 @subtype_test_wrapper(ptr %27, i64 %26, i64 %25, i64 %29, i64 ptrtoint (ptr @Collection to i64), ptr %28)
  %31 = zext i1 %30 to i8
  store i8 %31, ptr %3, align 1
  store i32 20, ptr %6, align 4
  %32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %33 = load i32, ptr %6, align 4
  %34 = getelementptr [124 x ptr], ptr %32, i32 0, i32 %33
  %35 = getelementptr ptr, ptr %34, i32 10
  %36 = load ptr, ptr %35, align 8
  ret ptr %36
}

define i32 @ZippedCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @ZippedCollection)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 992, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 3
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr { ptr, ptr }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = call { ptr, ptr, ptr, i32 } %27(ptr %19) #2
  %29 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %28, ptr %29, align 8
  call void @assume_offset(ptr %29, ptr @Collection)
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 1
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %34, 1
  %36 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 2
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %37, 2
  %39 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 3
  %40 = load i32, ptr %39, align 4
  %41 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %40, 3
  %42 = alloca [0 x ptr], align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 0, ptr %42)
  %44 = call ptr @llvm.invariant.start.p0(i64 472, ptr %31)
  %45 = getelementptr ptr, ptr %31, i32 %40
  %46 = getelementptr ptr, ptr %45, i32 1
  %47 = load ptr, ptr %46, align 8
  %48 = alloca {}, align 8
  %49 = call ptr @behavior_wrapper(ptr %47, { ptr, ptr, ptr, i32 } %41, ptr %48)
  %50 = call i32 %49({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr %42)
  %51 = alloca i32, align 4
  store i32 %50, ptr %51, align 4
  %52 = load ptr, ptr %7, align 8
  %53 = load ptr, ptr %6, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 992, ptr %53)
  %55 = load i32, ptr %5, align 4
  %56 = getelementptr ptr, ptr %53, i32 %55
  %57 = getelementptr ptr, ptr %56, i32 4
  %58 = load ptr, ptr %57, align 8
  %59 = getelementptr { ptr, ptr }, ptr %58, i32 0, i32 0
  %60 = load ptr, ptr %59, align 8
  %61 = call { ptr, ptr, ptr, i32 } %60(ptr %52) #2
  %62 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %61, ptr %62, align 8
  call void @assume_offset(ptr %62, ptr @Collection)
  %63 = getelementptr { ptr, ptr, ptr, i32 }, ptr %62, i32 0, i32 0
  %64 = load ptr, ptr %63, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %64, 0
  %66 = getelementptr { ptr, ptr, ptr, i32 }, ptr %62, i32 0, i32 1
  %67 = load ptr, ptr %66, align 8
  %68 = insertvalue { ptr, ptr, ptr, i32 } %65, ptr %67, 1
  %69 = getelementptr { ptr, ptr, ptr, i32 }, ptr %62, i32 0, i32 2
  %70 = load ptr, ptr %69, align 8
  %71 = insertvalue { ptr, ptr, ptr, i32 } %68, ptr %70, 2
  %72 = getelementptr { ptr, ptr, ptr, i32 }, ptr %62, i32 0, i32 3
  %73 = load i32, ptr %72, align 4
  %74 = insertvalue { ptr, ptr, ptr, i32 } %71, i32 %73, 3
  %75 = alloca [0 x ptr], align 8
  %76 = call ptr @llvm.invariant.start.p0(i64 0, ptr %75)
  %77 = call ptr @llvm.invariant.start.p0(i64 472, ptr %64)
  %78 = getelementptr ptr, ptr %64, i32 %73
  %79 = getelementptr ptr, ptr %78, i32 1
  %80 = load ptr, ptr %79, align 8
  %81 = alloca {}, align 8
  %82 = call ptr @behavior_wrapper(ptr %80, { ptr, ptr, ptr, i32 } %74, ptr %81)
  %83 = call i32 %82({ ptr, ptr, ptr, i32 } %74, { ptr, ptr, ptr, i32 } %74, ptr %75)
  %84 = alloca i32, align 4
  store i32 %83, ptr %84, align 4
  %85 = load i32, ptr %51, align 4
  %86 = load i32, ptr %84, align 4
  %87 = icmp slt i32 %85, %86
  %88 = alloca i1, align 1
  %89 = zext i1 %87 to i8
  store i8 %89, ptr %88, align 1
  %90 = load i8, ptr %88, align 1
  %91 = trunc i8 %90 to i1
  %92 = select i1 %91, ptr %51, ptr %84
  %93 = load i32, ptr %92, align 4
  ret i32 %93
}

define ptr @ZippedCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 21, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [124 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @ZippedCollection_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 22, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [124 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { ptr, ptr, ptr, i32 } @ZippedCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @ZippedCollection)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 992, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 3
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr { ptr, ptr }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = call { ptr, ptr, ptr, i32 } %27(ptr %19) #2
  %29 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %28, ptr %29, align 8
  call void @assume_offset(ptr %29, ptr @Collection)
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 1
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %34, 1
  %36 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 2
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %37, 2
  %39 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 3
  %40 = load i32, ptr %39, align 4
  %41 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %40, 3
  %42 = alloca [0 x ptr], align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 0, ptr %42)
  %44 = call ptr @llvm.invariant.start.p0(i64 472, ptr %31)
  %45 = getelementptr ptr, ptr %31, i32 %40
  %46 = getelementptr ptr, ptr %45, i32 3
  %47 = load ptr, ptr %46, align 8
  %48 = alloca {}, align 8
  %49 = call ptr @behavior_wrapper(ptr %47, { ptr, ptr, ptr, i32 } %41, ptr %48)
  %50 = call { ptr, ptr, ptr, i32 } %49({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr %42)
  %51 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %50, ptr %51, align 8
  %52 = alloca i32, align 4
  %53 = alloca ptr, align 8
  %54 = alloca ptr, align 8
  %55 = alloca ptr, align 8
  %56 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 0
  %57 = load ptr, ptr %56, align 8
  store ptr %57, ptr %53, align 8
  %58 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 1
  %59 = load ptr, ptr %58, align 8
  store ptr %59, ptr %55, align 8
  %60 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 2
  %61 = load ptr, ptr %60, align 8
  store ptr %61, ptr %54, align 8
  %62 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 3
  %63 = load i32, ptr %62, align 4
  store i32 %63, ptr %52, align 4
  %64 = load ptr, ptr %53, align 8
  %65 = call i32 @get_offset(ptr %64, ptr @Iterator)
  store i32 %65, ptr %52, align 4
  %66 = load ptr, ptr %7, align 8
  %67 = load ptr, ptr %6, align 8
  %68 = call ptr @llvm.invariant.start.p0(i64 992, ptr %67)
  %69 = load i32, ptr %5, align 4
  %70 = getelementptr ptr, ptr %67, i32 %69
  %71 = getelementptr ptr, ptr %70, i32 4
  %72 = load ptr, ptr %71, align 8
  %73 = getelementptr { ptr, ptr }, ptr %72, i32 0, i32 0
  %74 = load ptr, ptr %73, align 8
  %75 = call { ptr, ptr, ptr, i32 } %74(ptr %66) #2
  %76 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %75, ptr %76, align 8
  call void @assume_offset(ptr %76, ptr @Collection)
  %77 = getelementptr { ptr, ptr, ptr, i32 }, ptr %76, i32 0, i32 0
  %78 = load ptr, ptr %77, align 8
  %79 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %78, 0
  %80 = getelementptr { ptr, ptr, ptr, i32 }, ptr %76, i32 0, i32 1
  %81 = load ptr, ptr %80, align 8
  %82 = insertvalue { ptr, ptr, ptr, i32 } %79, ptr %81, 1
  %83 = getelementptr { ptr, ptr, ptr, i32 }, ptr %76, i32 0, i32 2
  %84 = load ptr, ptr %83, align 8
  %85 = insertvalue { ptr, ptr, ptr, i32 } %82, ptr %84, 2
  %86 = getelementptr { ptr, ptr, ptr, i32 }, ptr %76, i32 0, i32 3
  %87 = load i32, ptr %86, align 4
  %88 = insertvalue { ptr, ptr, ptr, i32 } %85, i32 %87, 3
  %89 = alloca [0 x ptr], align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 0, ptr %89)
  %91 = call ptr @llvm.invariant.start.p0(i64 472, ptr %78)
  %92 = getelementptr ptr, ptr %78, i32 %87
  %93 = getelementptr ptr, ptr %92, i32 3
  %94 = load ptr, ptr %93, align 8
  %95 = alloca {}, align 8
  %96 = call ptr @behavior_wrapper(ptr %94, { ptr, ptr, ptr, i32 } %88, ptr %95)
  %97 = call { ptr, ptr, ptr, i32 } %96({ ptr, ptr, ptr, i32 } %88, { ptr, ptr, ptr, i32 } %88, ptr %89)
  %98 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %97, ptr %98, align 8
  %99 = alloca i32, align 4
  %100 = alloca ptr, align 8
  %101 = alloca ptr, align 8
  %102 = alloca ptr, align 8
  %103 = getelementptr { ptr, ptr, ptr, i32 }, ptr %98, i32 0, i32 0
  %104 = load ptr, ptr %103, align 8
  store ptr %104, ptr %100, align 8
  %105 = getelementptr { ptr, ptr, ptr, i32 }, ptr %98, i32 0, i32 1
  %106 = load ptr, ptr %105, align 8
  store ptr %106, ptr %102, align 8
  %107 = getelementptr { ptr, ptr, ptr, i32 }, ptr %98, i32 0, i32 2
  %108 = load ptr, ptr %107, align 8
  store ptr %108, ptr %101, align 8
  %109 = getelementptr { ptr, ptr, ptr, i32 }, ptr %98, i32 0, i32 3
  %110 = load i32, ptr %109, align 4
  store i32 %110, ptr %99, align 4
  %111 = load ptr, ptr %100, align 8
  %112 = call i32 @get_offset(ptr %111, ptr @Iterator)
  store i32 %112, ptr %99, align 4
  %113 = load ptr, ptr %7, align 8
  %114 = load ptr, ptr %6, align 8
  %115 = call ptr @llvm.invariant.start.p0(i64 992, ptr %114)
  %116 = load i32, ptr %5, align 4
  %117 = getelementptr ptr, ptr %114, i32 %116
  %118 = load ptr, ptr %117, align 8
  %119 = call ptr @typegetter_wrapper(ptr %118, ptr %113)
  %120 = load ptr, ptr %7, align 8
  %121 = load ptr, ptr %6, align 8
  %122 = call ptr @llvm.invariant.start.p0(i64 992, ptr %121)
  %123 = load i32, ptr %5, align 4
  %124 = getelementptr ptr, ptr %121, i32 %123
  %125 = getelementptr ptr, ptr %124, i32 1
  %126 = load ptr, ptr %125, align 8
  %127 = call ptr @typegetter_wrapper(ptr %126, ptr %120)
  %128 = load ptr, ptr %7, align 8
  %129 = load ptr, ptr %6, align 8
  %130 = call ptr @llvm.invariant.start.p0(i64 992, ptr %129)
  %131 = load i32, ptr %5, align 4
  %132 = getelementptr ptr, ptr %129, i32 %131
  %133 = load ptr, ptr %132, align 8
  %134 = call ptr @typegetter_wrapper(ptr %133, ptr %128)
  %135 = load ptr, ptr %7, align 8
  %136 = load ptr, ptr %6, align 8
  %137 = call ptr @llvm.invariant.start.p0(i64 992, ptr %136)
  %138 = load i32, ptr %5, align 4
  %139 = getelementptr ptr, ptr %136, i32 %138
  %140 = getelementptr ptr, ptr %139, i32 1
  %141 = load ptr, ptr %140, align 8
  %142 = call ptr @typegetter_wrapper(ptr %141, ptr %135)
  %143 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([4 x ptr], ptr null, i32 1) to i64))
  %144 = getelementptr [4 x ptr], ptr %143, i32 0, i32 2
  store ptr %142, ptr %144, align 8
  %145 = getelementptr [4 x ptr], ptr %143, i32 0, i32 1
  store ptr %134, ptr %145, align 8
  %146 = getelementptr [4 x ptr], ptr %143, i32 0, i32 3
  store ptr null, ptr %146, align 8
  %147 = call ptr @llvm.invariant.start.p0(i64 24, ptr %143)
  store ptr @Pair, ptr %143, align 8
  %148 = alloca [4 x ptr], align 8
  store ptr @Zipper, ptr %148, align 8
  %149 = getelementptr ptr, ptr %148, i32 1
  store ptr %119, ptr %149, align 8
  %150 = getelementptr ptr, ptr %148, i32 2
  store ptr %127, ptr %150, align 8
  %151 = getelementptr ptr, ptr %148, i32 3
  store ptr %143, ptr %151, align 8
  %152 = load ptr, ptr %148, align 8
  %153 = getelementptr ptr, ptr %152, i32 6
  %154 = load ptr, ptr %153, align 8
  %155 = call { i64, i64 } @size_wrapper(ptr %154, ptr %148)
  %156 = extractvalue { i64, i64 } %155, 0
  %157 = call ptr @bump_malloc(i64 %156)
  store ptr %119, ptr %157, align 8
  %158 = getelementptr ptr, ptr %157, i32 1
  store ptr %127, ptr %158, align 8
  %159 = getelementptr ptr, ptr %157, i32 2
  store ptr %143, ptr %159, align 8
  %160 = call ptr @llvm.invariant.start.p0(i64 24, ptr %157)
  %161 = alloca i32, align 4
  %162 = alloca ptr, align 8
  %163 = alloca ptr, align 8
  %164 = alloca ptr, align 8
  store ptr @Zipper, ptr %164, align 8
  store ptr %157, ptr %163, align 8
  store i32 10, ptr %161, align 4
  %165 = load ptr, ptr %7, align 8
  %166 = load ptr, ptr %6, align 8
  %167 = call ptr @llvm.invariant.start.p0(i64 992, ptr %166)
  %168 = load i32, ptr %5, align 4
  %169 = getelementptr ptr, ptr %166, i32 %168
  %170 = getelementptr ptr, ptr %169, i32 3
  %171 = load ptr, ptr %170, align 8
  %172 = getelementptr { ptr, ptr }, ptr %171, i32 0, i32 0
  %173 = load ptr, ptr %172, align 8
  %174 = call { ptr, ptr, ptr, i32 } %173(ptr %165) #2
  %175 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %174, ptr %175, align 8
  call void @assume_offset(ptr %175, ptr @Collection)
  %176 = getelementptr { ptr, ptr, ptr, i32 }, ptr %175, i32 0, i32 0
  %177 = load ptr, ptr %176, align 8
  %178 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %177, 0
  %179 = getelementptr { ptr, ptr, ptr, i32 }, ptr %175, i32 0, i32 1
  %180 = load ptr, ptr %179, align 8
  %181 = insertvalue { ptr, ptr, ptr, i32 } %178, ptr %180, 1
  %182 = getelementptr { ptr, ptr, ptr, i32 }, ptr %175, i32 0, i32 2
  %183 = load ptr, ptr %182, align 8
  %184 = insertvalue { ptr, ptr, ptr, i32 } %181, ptr %183, 2
  %185 = getelementptr { ptr, ptr, ptr, i32 }, ptr %175, i32 0, i32 3
  %186 = load i32, ptr %185, align 4
  %187 = insertvalue { ptr, ptr, ptr, i32 } %184, i32 %186, 3
  %188 = alloca [0 x ptr], align 8
  %189 = call ptr @llvm.invariant.start.p0(i64 0, ptr %188)
  %190 = call ptr @llvm.invariant.start.p0(i64 472, ptr %177)
  %191 = getelementptr ptr, ptr %177, i32 %186
  %192 = getelementptr ptr, ptr %191, i32 3
  %193 = load ptr, ptr %192, align 8
  %194 = alloca {}, align 8
  %195 = call ptr @behavior_wrapper(ptr %193, { ptr, ptr, ptr, i32 } %187, ptr %194)
  %196 = call { ptr, ptr, ptr, i32 } %195({ ptr, ptr, ptr, i32 } %187, { ptr, ptr, ptr, i32 } %187, ptr %188)
  %197 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %196, ptr %197, align 8
  %198 = alloca i32, align 4
  %199 = alloca ptr, align 8
  %200 = alloca ptr, align 8
  %201 = alloca ptr, align 8
  %202 = getelementptr { ptr, ptr, ptr, i32 }, ptr %197, i32 0, i32 0
  %203 = load ptr, ptr %202, align 8
  store ptr %203, ptr %201, align 8
  %204 = getelementptr { ptr, ptr, ptr, i32 }, ptr %197, i32 0, i32 1
  %205 = load ptr, ptr %204, align 8
  store ptr %205, ptr %200, align 8
  %206 = getelementptr { ptr, ptr, ptr, i32 }, ptr %197, i32 0, i32 2
  %207 = load ptr, ptr %206, align 8
  store ptr %207, ptr %199, align 8
  %208 = getelementptr { ptr, ptr, ptr, i32 }, ptr %197, i32 0, i32 3
  %209 = load i32, ptr %208, align 4
  store i32 %209, ptr %198, align 4
  %210 = load ptr, ptr %201, align 8
  %211 = call i32 @get_offset(ptr %210, ptr @Iterator)
  store i32 %211, ptr %198, align 4
  %212 = load ptr, ptr %7, align 8
  %213 = load ptr, ptr %6, align 8
  %214 = call ptr @llvm.invariant.start.p0(i64 992, ptr %213)
  %215 = load i32, ptr %5, align 4
  %216 = getelementptr ptr, ptr %213, i32 %215
  %217 = getelementptr ptr, ptr %216, i32 4
  %218 = load ptr, ptr %217, align 8
  %219 = getelementptr { ptr, ptr }, ptr %218, i32 0, i32 0
  %220 = load ptr, ptr %219, align 8
  %221 = call { ptr, ptr, ptr, i32 } %220(ptr %212) #2
  %222 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %221, ptr %222, align 8
  call void @assume_offset(ptr %222, ptr @Collection)
  %223 = getelementptr { ptr, ptr, ptr, i32 }, ptr %222, i32 0, i32 0
  %224 = load ptr, ptr %223, align 8
  %225 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %224, 0
  %226 = getelementptr { ptr, ptr, ptr, i32 }, ptr %222, i32 0, i32 1
  %227 = load ptr, ptr %226, align 8
  %228 = insertvalue { ptr, ptr, ptr, i32 } %225, ptr %227, 1
  %229 = getelementptr { ptr, ptr, ptr, i32 }, ptr %222, i32 0, i32 2
  %230 = load ptr, ptr %229, align 8
  %231 = insertvalue { ptr, ptr, ptr, i32 } %228, ptr %230, 2
  %232 = getelementptr { ptr, ptr, ptr, i32 }, ptr %222, i32 0, i32 3
  %233 = load i32, ptr %232, align 4
  %234 = insertvalue { ptr, ptr, ptr, i32 } %231, i32 %233, 3
  %235 = alloca [0 x ptr], align 8
  %236 = call ptr @llvm.invariant.start.p0(i64 0, ptr %235)
  %237 = call ptr @llvm.invariant.start.p0(i64 472, ptr %224)
  %238 = getelementptr ptr, ptr %224, i32 %233
  %239 = getelementptr ptr, ptr %238, i32 3
  %240 = load ptr, ptr %239, align 8
  %241 = alloca {}, align 8
  %242 = call ptr @behavior_wrapper(ptr %240, { ptr, ptr, ptr, i32 } %234, ptr %241)
  %243 = call { ptr, ptr, ptr, i32 } %242({ ptr, ptr, ptr, i32 } %234, { ptr, ptr, ptr, i32 } %234, ptr %235)
  %244 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %243, ptr %244, align 8
  %245 = alloca i32, align 4
  %246 = alloca ptr, align 8
  %247 = alloca ptr, align 8
  %248 = alloca ptr, align 8
  %249 = getelementptr { ptr, ptr, ptr, i32 }, ptr %244, i32 0, i32 0
  %250 = load ptr, ptr %249, align 8
  store ptr %250, ptr %248, align 8
  %251 = getelementptr { ptr, ptr, ptr, i32 }, ptr %244, i32 0, i32 1
  %252 = load ptr, ptr %251, align 8
  store ptr %252, ptr %247, align 8
  %253 = getelementptr { ptr, ptr, ptr, i32 }, ptr %244, i32 0, i32 2
  %254 = load ptr, ptr %253, align 8
  store ptr %254, ptr %246, align 8
  %255 = getelementptr { ptr, ptr, ptr, i32 }, ptr %244, i32 0, i32 3
  %256 = load i32, ptr %255, align 4
  store i32 %256, ptr %245, align 4
  %257 = load ptr, ptr %248, align 8
  %258 = call i32 @get_offset(ptr %257, ptr @Iterator)
  store i32 %258, ptr %245, align 4
  %259 = alloca i32, align 4
  %260 = alloca ptr, align 8
  %261 = alloca ptr, align 8
  %262 = alloca ptr, align 8
  %263 = load ptr, ptr %201, align 8
  store ptr %263, ptr %262, align 8
  %264 = load ptr, ptr %200, align 8
  store ptr %264, ptr %261, align 8
  %265 = load ptr, ptr %199, align 8
  store ptr %265, ptr %260, align 8
  %266 = load i32, ptr %198, align 4
  store i32 %266, ptr %259, align 4
  %267 = load ptr, ptr %262, align 8
  %268 = call i32 @get_offset(ptr %267, ptr @Iterator)
  store i32 %268, ptr %259, align 4
  %269 = load ptr, ptr %262, align 8
  %270 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %269, 0
  %271 = load ptr, ptr %261, align 8
  %272 = insertvalue { ptr, ptr, ptr, i32 } %270, ptr %271, 1
  %273 = load ptr, ptr %260, align 8
  %274 = insertvalue { ptr, ptr, ptr, i32 } %272, ptr %273, 2
  %275 = load i32, ptr %259, align 4
  %276 = insertvalue { ptr, ptr, ptr, i32 } %274, i32 %275, 3
  %277 = alloca i32, align 4
  %278 = alloca ptr, align 8
  %279 = alloca ptr, align 8
  %280 = alloca ptr, align 8
  %281 = load ptr, ptr %248, align 8
  store ptr %281, ptr %280, align 8
  %282 = load ptr, ptr %247, align 8
  store ptr %282, ptr %279, align 8
  %283 = load ptr, ptr %246, align 8
  store ptr %283, ptr %278, align 8
  %284 = load i32, ptr %245, align 4
  store i32 %284, ptr %277, align 4
  %285 = load ptr, ptr %280, align 8
  %286 = call i32 @get_offset(ptr %285, ptr @Iterator)
  store i32 %286, ptr %277, align 4
  %287 = load ptr, ptr %280, align 8
  %288 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %287, 0
  %289 = load ptr, ptr %279, align 8
  %290 = insertvalue { ptr, ptr, ptr, i32 } %288, ptr %289, 1
  %291 = load ptr, ptr %278, align 8
  %292 = insertvalue { ptr, ptr, ptr, i32 } %290, ptr %291, 2
  %293 = load i32, ptr %277, align 4
  %294 = insertvalue { ptr, ptr, ptr, i32 } %292, i32 %293, 3
  %295 = load ptr, ptr %164, align 8
  %296 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %295, 0
  %297 = load ptr, ptr %163, align 8
  %298 = insertvalue { ptr, ptr, ptr, i32 } %296, ptr %297, 1
  %299 = load ptr, ptr %162, align 8
  %300 = insertvalue { ptr, ptr, ptr, i32 } %298, ptr %299, 2
  %301 = load i32, ptr %161, align 4
  %302 = insertvalue { ptr, ptr, ptr, i32 } %300, i32 %301, 3
  %303 = load ptr, ptr %7, align 8
  %304 = load ptr, ptr %6, align 8
  %305 = call ptr @llvm.invariant.start.p0(i64 992, ptr %304)
  %306 = load i32, ptr %5, align 4
  %307 = getelementptr ptr, ptr %304, i32 %306
  %308 = load ptr, ptr %307, align 8
  %309 = call ptr @typegetter_wrapper(ptr %308, ptr %303)
  %310 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %311 = getelementptr [3 x ptr], ptr %310, i32 0, i32 1
  store ptr %309, ptr %311, align 8
  %312 = getelementptr [3 x ptr], ptr %310, i32 0, i32 2
  store ptr null, ptr %312, align 8
  %313 = call ptr @llvm.invariant.start.p0(i64 16, ptr %310)
  store ptr @Iterator, ptr %310, align 8
  %314 = load ptr, ptr %7, align 8
  %315 = load ptr, ptr %6, align 8
  %316 = call ptr @llvm.invariant.start.p0(i64 992, ptr %315)
  %317 = load i32, ptr %5, align 4
  %318 = getelementptr ptr, ptr %315, i32 %317
  %319 = getelementptr ptr, ptr %318, i32 1
  %320 = load ptr, ptr %319, align 8
  %321 = call ptr @typegetter_wrapper(ptr %320, ptr %314)
  %322 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %323 = getelementptr [3 x ptr], ptr %322, i32 0, i32 1
  store ptr %321, ptr %323, align 8
  %324 = getelementptr [3 x ptr], ptr %322, i32 0, i32 2
  store ptr null, ptr %324, align 8
  %325 = call ptr @llvm.invariant.start.p0(i64 16, ptr %322)
  store ptr @Iterator, ptr %322, align 8
  %326 = alloca [2 x ptr], align 8
  %327 = getelementptr [2 x ptr], ptr %326, i32 0, i32 0
  store ptr %310, ptr %327, align 8
  %328 = getelementptr [2 x ptr], ptr %326, i32 0, i32 1
  store ptr %322, ptr %328, align 8
  %329 = call ptr @llvm.invariant.start.p0(i64 4, ptr %326)
  %330 = call ptr @llvm.invariant.start.p0(i64 96, ptr %295)
  %331 = getelementptr ptr, ptr %295, i32 %301
  %332 = getelementptr ptr, ptr %331, i32 5
  %333 = load ptr, ptr %332, align 8
  %334 = alloca { ptr, ptr }, align 8
  %335 = getelementptr { ptr, ptr }, ptr %334, i32 0, i32 0
  store ptr %269, ptr %335, align 8
  %336 = getelementptr { ptr, ptr }, ptr %334, i32 0, i32 1
  store ptr %287, ptr %336, align 8
  %337 = call ptr @behavior_wrapper(ptr %333, { ptr, ptr, ptr, i32 } %302, ptr %334)
  call void %337({ ptr, ptr, ptr, i32 } %302, { ptr, ptr, ptr, i32 } %302, ptr %326, { ptr, ptr, ptr, i32 } %276, { ptr, ptr, ptr, i32 } %294)
  %338 = alloca i32, align 4
  %339 = alloca ptr, align 8
  %340 = alloca ptr, align 8
  %341 = alloca ptr, align 8
  %342 = load ptr, ptr %164, align 8
  store ptr %342, ptr %341, align 8
  %343 = load ptr, ptr %163, align 8
  store ptr %343, ptr %340, align 8
  %344 = load ptr, ptr %162, align 8
  store ptr %344, ptr %339, align 8
  %345 = load i32, ptr %161, align 4
  store i32 %345, ptr %338, align 4
  %346 = load ptr, ptr %341, align 8
  %347 = call i32 @get_offset(ptr %346, ptr @Iterator)
  store i32 %347, ptr %338, align 4
  %348 = load ptr, ptr %341, align 8
  %349 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %348, 0
  %350 = load ptr, ptr %340, align 8
  %351 = insertvalue { ptr, ptr, ptr, i32 } %349, ptr %350, 1
  %352 = load ptr, ptr %339, align 8
  %353 = insertvalue { ptr, ptr, ptr, i32 } %351, ptr %352, 2
  %354 = load i32, ptr %338, align 4
  %355 = insertvalue { ptr, ptr, ptr, i32 } %353, i32 %354, 3
  ret { ptr, ptr, ptr, i32 } %355
}

define ptr @ZippedCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 23, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [124 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @ZippedCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 24, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [124 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @ZippedCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @Pair, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @Pair to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = ptrtoint ptr %20 to i64
  %22 = icmp eq i64 %21, ptrtoint (ptr @function_typ to i64)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 25, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [124 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define ptr @ZippedCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 26, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [124 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @ZippedCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 27, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [124 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @ZippedCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 28, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [124 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @ZippedCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = ptrtoint ptr %7 to i64
  %9 = icmp eq i64 %8, ptrtoint (ptr @function_typ to i64)
  %10 = zext i1 %9 to i8
  store i8 %10, ptr %3, align 1
  %11 = load i8, ptr %3, align 1
  %12 = trunc i8 %11 to i1
  %13 = select i1 %12, i32 29, i32 30
  br i1 %12, label %14, label %15

14:                                               ; preds = %2
  br label %20

15:                                               ; preds = %2
  %16 = load ptr, ptr %1, align 8
  %17 = ptrtoint ptr %16 to i64
  %18 = icmp eq i64 %17, ptrtoint (ptr @function_typ to i64)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %4, align 1
  br label %20

20:                                               ; preds = %14, %15
  store i32 %13, ptr %6, align 4
  %21 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %22 = load i32, ptr %6, align 4
  %23 = getelementptr [124 x ptr], ptr %21, i32 0, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 10
  %25 = load ptr, ptr %24, align 8
  ret ptr %25
}

define ptr @ZippedCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 31, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [124 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @ZippedCollection_B_chain_otherCollectionT_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 32, i32 33
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [124 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

define ptr @ZippedCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 34, i32 35
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [124 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

define ptr @ZippedCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 37, i32 36
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [124 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

define ptr @ZippedCollection_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 39, i32 38
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [124 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

define { i64, i64 } @_data_size_ProductCollection(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %10
  %12 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %5
  %13 = select i1 %12, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 %5
  %14 = urem i64 %11, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %17
  %19 = add i64 %11, %18
  %20 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %13
  %21 = select i1 %20, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %13
  %22 = urem i64 %19, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %23 = icmp eq i64 %22, 0
  %24 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %22
  %25 = select i1 %23, i64 0, i64 %24
  %26 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %25
  %27 = add i64 %19, %26
  %28 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %21
  %29 = select i1 %28, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %21
  %30 = urem i64 %27, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %31 = icmp eq i64 %30, 0
  %32 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %30
  %33 = select i1 %31, i64 0, i64 %32
  %34 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %33
  %35 = add i64 %27, %34
  %36 = urem i64 %35, %29
  %37 = icmp eq i64 %36, 0
  %38 = sub i64 %29, %36
  %39 = select i1 %37, i64 0, i64 %38
  %40 = add i64 %35, %39
  %41 = insertvalue { i64, i64 } undef, i64 %40, 0
  %42 = insertvalue { i64, i64 } %41, i64 %29, 1
  ret { i64, i64 } %42
}

define ptr @ProductCollection_field_ProductCollection_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define ptr @ProductCollection_field_ProductCollection_1(ptr %0) {
  %2 = getelementptr ptr, ptr %0, i32 1
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

define ptr @ProductCollection_field_ProductCollection_2(ptr %0) {
  %2 = getelementptr ptr, ptr %0, i32 2
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

define { ptr, ptr, ptr, i32 } @ProductCollection_getter_first(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %11
  %13 = add i64 %7, %12
  %14 = urem i64 %13, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 %13, %17
  %19 = getelementptr i8, ptr %0, i64 %18
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 0
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %21, 0
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 1
  %24 = load ptr, ptr %23, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %24, 1
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 2
  %27 = load ptr, ptr %26, align 8
  %28 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %27, 2
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 3
  %30 = load i32, ptr %29, align 4
  %31 = insertvalue { ptr, ptr, ptr, i32 } %28, i32 %30, 3
  ret { ptr, ptr, ptr, i32 } %31
}

define void @ProductCollection_setter_first(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %12
  %14 = add i64 %8, %13
  %15 = urem i64 %14, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %16 = icmp eq i64 %15, 0
  %17 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add i64 %14, %18
  %20 = getelementptr i8, ptr %0, i64 %19
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %21, align 8
  %22 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 0
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 0
  %24 = load ptr, ptr %22, align 8
  store ptr %24, ptr %23, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 1
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 1
  %27 = load ptr, ptr %25, align 8
  store ptr %27, ptr %26, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 2
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 2
  %30 = load ptr, ptr %28, align 8
  store ptr %30, ptr %29, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 3
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 3
  %33 = load i32, ptr %31, align 4
  store i32 %33, ptr %32, align 4
  ret void
}

define { ptr, ptr, ptr, i32 } @ProductCollection_getter_second(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %11
  %13 = add i64 %7, %12
  %14 = urem i64 %13, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %17
  %19 = add i64 %13, %18
  %20 = urem i64 %19, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = add i64 %19, %23
  %25 = getelementptr i8, ptr %0, i64 %24
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %27, 0
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 1
  %30 = load ptr, ptr %29, align 8
  %31 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %30, 1
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 2
  %33 = load ptr, ptr %32, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %33, 2
  %35 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 3
  %36 = load i32, ptr %35, align 4
  %37 = insertvalue { ptr, ptr, ptr, i32 } %34, i32 %36, 3
  ret { ptr, ptr, ptr, i32 } %37
}

define void @ProductCollection_setter_second(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %12
  %14 = add i64 %8, %13
  %15 = urem i64 %14, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %16 = icmp eq i64 %15, 0
  %17 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %18
  %20 = add i64 %14, %19
  %21 = urem i64 %20, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %22 = icmp eq i64 %21, 0
  %23 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %21
  %24 = select i1 %22, i64 0, i64 %23
  %25 = add i64 %20, %24
  %26 = getelementptr i8, ptr %0, i64 %25
  %27 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %27, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 0
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 0
  %30 = load ptr, ptr %28, align 8
  store ptr %30, ptr %29, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 1
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 1
  %33 = load ptr, ptr %31, align 8
  store ptr %33, ptr %32, align 8
  %34 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 2
  %35 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 2
  %36 = load ptr, ptr %34, align 8
  store ptr %36, ptr %35, align 8
  %37 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 3
  %38 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 3
  %39 = load i32, ptr %37, align 4
  store i32 %39, ptr %38, align 4
  ret void
}

define void @ProductCollection_init_firstCollectionT_secondCollectionU({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3, { ptr, ptr, ptr, i32 } %4) {
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %6, align 8
  %7 = alloca i32, align 4
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = alloca ptr, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %8, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 1
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %9, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 2
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %10, align 8
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  store i32 %18, ptr %7, align 4
  %19 = load ptr, ptr %8, align 8
  %20 = call i32 @get_offset(ptr %19, ptr @ProductCollection)
  store i32 %20, ptr %7, align 4
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %21, align 8
  %22 = alloca i32, align 4
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = alloca ptr, align 8
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  store ptr %27, ptr %25, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 1
  %29 = load ptr, ptr %28, align 8
  store ptr %29, ptr %24, align 8
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 2
  %31 = load ptr, ptr %30, align 8
  store ptr %31, ptr %23, align 8
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 3
  %33 = load i32, ptr %32, align 4
  store i32 %33, ptr %22, align 4
  %34 = load ptr, ptr %25, align 8
  %35 = call i32 @get_offset(ptr %34, ptr @Collection)
  store i32 %35, ptr %22, align 4
  %36 = alloca i32, align 4
  %37 = alloca ptr, align 8
  %38 = alloca ptr, align 8
  %39 = alloca ptr, align 8
  %40 = load ptr, ptr %25, align 8
  store ptr %40, ptr %39, align 8
  %41 = load ptr, ptr %24, align 8
  store ptr %41, ptr %38, align 8
  %42 = load ptr, ptr %23, align 8
  store ptr %42, ptr %37, align 8
  %43 = load i32, ptr %22, align 4
  store i32 %43, ptr %36, align 4
  %44 = load ptr, ptr %39, align 8
  %45 = call i32 @get_offset(ptr %44, ptr @Collection)
  store i32 %45, ptr %36, align 4
  %46 = load ptr, ptr %9, align 8
  %47 = load ptr, ptr %8, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 992, ptr %47)
  %49 = load i32, ptr %7, align 4
  %50 = getelementptr ptr, ptr %47, i32 %49
  %51 = getelementptr ptr, ptr %50, i32 3
  %52 = load ptr, ptr %51, align 8
  %53 = getelementptr { ptr, ptr }, ptr %52, i32 0, i32 1
  %54 = load ptr, ptr %53, align 8
  %55 = load ptr, ptr %39, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %55, 0
  %57 = load ptr, ptr %38, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %57, 1
  %59 = load ptr, ptr %37, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } %58, ptr %59, 2
  %61 = load i32, ptr %36, align 4
  %62 = insertvalue { ptr, ptr, ptr, i32 } %60, i32 %61, 3
  call void %54(ptr %46, { ptr, ptr, ptr, i32 } %62) #1
  %63 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %4, ptr %63, align 8
  %64 = alloca i32, align 4
  %65 = alloca ptr, align 8
  %66 = alloca ptr, align 8
  %67 = alloca ptr, align 8
  %68 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 0
  %69 = load ptr, ptr %68, align 8
  store ptr %69, ptr %67, align 8
  %70 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 1
  %71 = load ptr, ptr %70, align 8
  store ptr %71, ptr %66, align 8
  %72 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 2
  %73 = load ptr, ptr %72, align 8
  store ptr %73, ptr %65, align 8
  %74 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 3
  %75 = load i32, ptr %74, align 4
  store i32 %75, ptr %64, align 4
  %76 = load ptr, ptr %67, align 8
  %77 = call i32 @get_offset(ptr %76, ptr @Collection)
  store i32 %77, ptr %64, align 4
  %78 = alloca i32, align 4
  %79 = alloca ptr, align 8
  %80 = alloca ptr, align 8
  %81 = alloca ptr, align 8
  %82 = load ptr, ptr %67, align 8
  store ptr %82, ptr %81, align 8
  %83 = load ptr, ptr %66, align 8
  store ptr %83, ptr %80, align 8
  %84 = load ptr, ptr %65, align 8
  store ptr %84, ptr %79, align 8
  %85 = load i32, ptr %64, align 4
  store i32 %85, ptr %78, align 4
  %86 = load ptr, ptr %81, align 8
  %87 = call i32 @get_offset(ptr %86, ptr @Collection)
  store i32 %87, ptr %78, align 4
  %88 = load ptr, ptr %9, align 8
  %89 = load ptr, ptr %8, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 992, ptr %89)
  %91 = load i32, ptr %7, align 4
  %92 = getelementptr ptr, ptr %89, i32 %91
  %93 = getelementptr ptr, ptr %92, i32 4
  %94 = load ptr, ptr %93, align 8
  %95 = getelementptr { ptr, ptr }, ptr %94, i32 0, i32 1
  %96 = load ptr, ptr %95, align 8
  %97 = load ptr, ptr %81, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %97, 0
  %99 = load ptr, ptr %80, align 8
  %100 = insertvalue { ptr, ptr, ptr, i32 } %98, ptr %99, 1
  %101 = load ptr, ptr %79, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } %100, ptr %101, 2
  %103 = load i32, ptr %78, align 4
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, i32 %103, 3
  call void %96(ptr %88, { ptr, ptr, ptr, i32 } %104) #1
  ret void
}

define ptr @ProductCollection_B_init_firstCollectionT_secondCollectionU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @Collection, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @Collection to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 1
  %22 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 2
  %23 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 0
  %24 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 1
  %25 = load i64, ptr %21, align 4
  %26 = load i64, ptr %22, align 4
  %27 = load ptr, ptr %23, align 8
  %28 = load ptr, ptr %24, align 8
  %29 = load i64, ptr @Collection, align 4
  %30 = call i1 @subtype_test_wrapper(ptr %27, i64 %26, i64 %25, i64 %29, i64 ptrtoint (ptr @Collection to i64), ptr %28)
  %31 = zext i1 %30 to i8
  store i8 %31, ptr %3, align 1
  store i32 20, ptr %6, align 4
  %32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %33 = load i32, ptr %6, align 4
  %34 = getelementptr [124 x ptr], ptr %32, i32 0, i32 %33
  %35 = getelementptr ptr, ptr %34, i32 10
  %36 = load ptr, ptr %35, align 8
  ret ptr %36
}

define i32 @ProductCollection_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @ProductCollection)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 992, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 3
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr { ptr, ptr }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = call { ptr, ptr, ptr, i32 } %27(ptr %19) #2
  %29 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %28, ptr %29, align 8
  call void @assume_offset(ptr %29, ptr @Collection)
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 1
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %34, 1
  %36 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 2
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %37, 2
  %39 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 3
  %40 = load i32, ptr %39, align 4
  %41 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %40, 3
  %42 = alloca [0 x ptr], align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 0, ptr %42)
  %44 = call ptr @llvm.invariant.start.p0(i64 472, ptr %31)
  %45 = getelementptr ptr, ptr %31, i32 %40
  %46 = getelementptr ptr, ptr %45, i32 1
  %47 = load ptr, ptr %46, align 8
  %48 = alloca {}, align 8
  %49 = call ptr @behavior_wrapper(ptr %47, { ptr, ptr, ptr, i32 } %41, ptr %48)
  %50 = call i32 %49({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr %42)
  %51 = alloca i32, align 4
  store i32 %50, ptr %51, align 4
  %52 = load ptr, ptr %7, align 8
  %53 = load ptr, ptr %6, align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 992, ptr %53)
  %55 = load i32, ptr %5, align 4
  %56 = getelementptr ptr, ptr %53, i32 %55
  %57 = getelementptr ptr, ptr %56, i32 4
  %58 = load ptr, ptr %57, align 8
  %59 = getelementptr { ptr, ptr }, ptr %58, i32 0, i32 0
  %60 = load ptr, ptr %59, align 8
  %61 = call { ptr, ptr, ptr, i32 } %60(ptr %52) #2
  %62 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %61, ptr %62, align 8
  call void @assume_offset(ptr %62, ptr @Collection)
  %63 = getelementptr { ptr, ptr, ptr, i32 }, ptr %62, i32 0, i32 0
  %64 = load ptr, ptr %63, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %64, 0
  %66 = getelementptr { ptr, ptr, ptr, i32 }, ptr %62, i32 0, i32 1
  %67 = load ptr, ptr %66, align 8
  %68 = insertvalue { ptr, ptr, ptr, i32 } %65, ptr %67, 1
  %69 = getelementptr { ptr, ptr, ptr, i32 }, ptr %62, i32 0, i32 2
  %70 = load ptr, ptr %69, align 8
  %71 = insertvalue { ptr, ptr, ptr, i32 } %68, ptr %70, 2
  %72 = getelementptr { ptr, ptr, ptr, i32 }, ptr %62, i32 0, i32 3
  %73 = load i32, ptr %72, align 4
  %74 = insertvalue { ptr, ptr, ptr, i32 } %71, i32 %73, 3
  %75 = alloca [0 x ptr], align 8
  %76 = call ptr @llvm.invariant.start.p0(i64 0, ptr %75)
  %77 = call ptr @llvm.invariant.start.p0(i64 472, ptr %64)
  %78 = getelementptr ptr, ptr %64, i32 %73
  %79 = getelementptr ptr, ptr %78, i32 1
  %80 = load ptr, ptr %79, align 8
  %81 = alloca {}, align 8
  %82 = call ptr @behavior_wrapper(ptr %80, { ptr, ptr, ptr, i32 } %74, ptr %81)
  %83 = call i32 %82({ ptr, ptr, ptr, i32 } %74, { ptr, ptr, ptr, i32 } %74, ptr %75)
  %84 = alloca i32, align 4
  store i32 %83, ptr %84, align 4
  %85 = load i32, ptr %51, align 4
  %86 = load i32, ptr %84, align 4
  %87 = mul i32 %85, %86
  %88 = alloca i32, align 4
  store i32 %87, ptr %88, align 4
  %89 = load i32, ptr %88, align 4
  ret i32 %89
}

define ptr @ProductCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 21, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [124 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @ProductCollection_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 22, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [124 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { ptr, ptr, ptr, i32 } @ProductCollection_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @ProductCollection)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 992, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 3
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr { ptr, ptr }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = call { ptr, ptr, ptr, i32 } %27(ptr %19) #2
  %29 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %28, ptr %29, align 8
  call void @assume_offset(ptr %29, ptr @Collection)
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 1
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %34, 1
  %36 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 2
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %37, 2
  %39 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 3
  %40 = load i32, ptr %39, align 4
  %41 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %40, 3
  %42 = alloca [0 x ptr], align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 0, ptr %42)
  %44 = call ptr @llvm.invariant.start.p0(i64 472, ptr %31)
  %45 = getelementptr ptr, ptr %31, i32 %40
  %46 = getelementptr ptr, ptr %45, i32 3
  %47 = load ptr, ptr %46, align 8
  %48 = alloca {}, align 8
  %49 = call ptr @behavior_wrapper(ptr %47, { ptr, ptr, ptr, i32 } %41, ptr %48)
  %50 = call { ptr, ptr, ptr, i32 } %49({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr %42)
  %51 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %50, ptr %51, align 8
  %52 = alloca i32, align 4
  %53 = alloca ptr, align 8
  %54 = alloca ptr, align 8
  %55 = alloca ptr, align 8
  %56 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 0
  %57 = load ptr, ptr %56, align 8
  store ptr %57, ptr %53, align 8
  %58 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 1
  %59 = load ptr, ptr %58, align 8
  store ptr %59, ptr %55, align 8
  %60 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 2
  %61 = load ptr, ptr %60, align 8
  store ptr %61, ptr %54, align 8
  %62 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 3
  %63 = load i32, ptr %62, align 4
  store i32 %63, ptr %52, align 4
  %64 = load ptr, ptr %53, align 8
  %65 = call i32 @get_offset(ptr %64, ptr @Iterator)
  store i32 %65, ptr %52, align 4
  %66 = load ptr, ptr %7, align 8
  %67 = load ptr, ptr %6, align 8
  %68 = call ptr @llvm.invariant.start.p0(i64 992, ptr %67)
  %69 = load i32, ptr %5, align 4
  %70 = getelementptr ptr, ptr %67, i32 %69
  %71 = getelementptr ptr, ptr %70, i32 4
  %72 = load ptr, ptr %71, align 8
  %73 = getelementptr { ptr, ptr }, ptr %72, i32 0, i32 0
  %74 = load ptr, ptr %73, align 8
  %75 = call { ptr, ptr, ptr, i32 } %74(ptr %66) #2
  %76 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %75, ptr %76, align 8
  call void @assume_offset(ptr %76, ptr @Collection)
  %77 = load ptr, ptr %7, align 8
  %78 = load ptr, ptr %6, align 8
  %79 = call ptr @llvm.invariant.start.p0(i64 992, ptr %78)
  %80 = load i32, ptr %5, align 4
  %81 = getelementptr ptr, ptr %78, i32 %80
  %82 = load ptr, ptr %81, align 8
  %83 = call ptr @typegetter_wrapper(ptr %82, ptr %77)
  %84 = load ptr, ptr %7, align 8
  %85 = load ptr, ptr %6, align 8
  %86 = call ptr @llvm.invariant.start.p0(i64 992, ptr %85)
  %87 = load i32, ptr %5, align 4
  %88 = getelementptr ptr, ptr %85, i32 %87
  %89 = getelementptr ptr, ptr %88, i32 1
  %90 = load ptr, ptr %89, align 8
  %91 = call ptr @typegetter_wrapper(ptr %90, ptr %84)
  %92 = load ptr, ptr %7, align 8
  %93 = load ptr, ptr %6, align 8
  %94 = call ptr @llvm.invariant.start.p0(i64 992, ptr %93)
  %95 = load i32, ptr %5, align 4
  %96 = getelementptr ptr, ptr %93, i32 %95
  %97 = load ptr, ptr %96, align 8
  %98 = call ptr @typegetter_wrapper(ptr %97, ptr %92)
  %99 = load ptr, ptr %7, align 8
  %100 = load ptr, ptr %6, align 8
  %101 = call ptr @llvm.invariant.start.p0(i64 992, ptr %100)
  %102 = load i32, ptr %5, align 4
  %103 = getelementptr ptr, ptr %100, i32 %102
  %104 = getelementptr ptr, ptr %103, i32 1
  %105 = load ptr, ptr %104, align 8
  %106 = call ptr @typegetter_wrapper(ptr %105, ptr %99)
  %107 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([4 x ptr], ptr null, i32 1) to i64))
  %108 = getelementptr [4 x ptr], ptr %107, i32 0, i32 2
  store ptr %106, ptr %108, align 8
  %109 = getelementptr [4 x ptr], ptr %107, i32 0, i32 1
  store ptr %98, ptr %109, align 8
  %110 = getelementptr [4 x ptr], ptr %107, i32 0, i32 3
  store ptr null, ptr %110, align 8
  %111 = call ptr @llvm.invariant.start.p0(i64 24, ptr %107)
  store ptr @Pair, ptr %107, align 8
  %112 = alloca [4 x ptr], align 8
  store ptr @Productizer, ptr %112, align 8
  %113 = getelementptr ptr, ptr %112, i32 1
  store ptr %83, ptr %113, align 8
  %114 = getelementptr ptr, ptr %112, i32 2
  store ptr %91, ptr %114, align 8
  %115 = getelementptr ptr, ptr %112, i32 3
  store ptr %107, ptr %115, align 8
  %116 = load ptr, ptr %112, align 8
  %117 = getelementptr ptr, ptr %116, i32 6
  %118 = load ptr, ptr %117, align 8
  %119 = call { i64, i64 } @size_wrapper(ptr %118, ptr %112)
  %120 = extractvalue { i64, i64 } %119, 0
  %121 = call ptr @bump_malloc(i64 %120)
  store ptr %83, ptr %121, align 8
  %122 = getelementptr ptr, ptr %121, i32 1
  store ptr %91, ptr %122, align 8
  %123 = getelementptr ptr, ptr %121, i32 2
  store ptr %107, ptr %123, align 8
  %124 = call ptr @llvm.invariant.start.p0(i64 24, ptr %121)
  %125 = alloca i32, align 4
  %126 = alloca ptr, align 8
  %127 = alloca ptr, align 8
  %128 = alloca ptr, align 8
  store ptr @Productizer, ptr %128, align 8
  store ptr %121, ptr %127, align 8
  store i32 10, ptr %125, align 4
  %129 = load ptr, ptr %7, align 8
  %130 = load ptr, ptr %6, align 8
  %131 = call ptr @llvm.invariant.start.p0(i64 992, ptr %130)
  %132 = load i32, ptr %5, align 4
  %133 = getelementptr ptr, ptr %130, i32 %132
  %134 = getelementptr ptr, ptr %133, i32 3
  %135 = load ptr, ptr %134, align 8
  %136 = getelementptr { ptr, ptr }, ptr %135, i32 0, i32 0
  %137 = load ptr, ptr %136, align 8
  %138 = call { ptr, ptr, ptr, i32 } %137(ptr %129) #2
  %139 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %138, ptr %139, align 8
  call void @assume_offset(ptr %139, ptr @Collection)
  %140 = getelementptr { ptr, ptr, ptr, i32 }, ptr %139, i32 0, i32 0
  %141 = load ptr, ptr %140, align 8
  %142 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %141, 0
  %143 = getelementptr { ptr, ptr, ptr, i32 }, ptr %139, i32 0, i32 1
  %144 = load ptr, ptr %143, align 8
  %145 = insertvalue { ptr, ptr, ptr, i32 } %142, ptr %144, 1
  %146 = getelementptr { ptr, ptr, ptr, i32 }, ptr %139, i32 0, i32 2
  %147 = load ptr, ptr %146, align 8
  %148 = insertvalue { ptr, ptr, ptr, i32 } %145, ptr %147, 2
  %149 = getelementptr { ptr, ptr, ptr, i32 }, ptr %139, i32 0, i32 3
  %150 = load i32, ptr %149, align 4
  %151 = insertvalue { ptr, ptr, ptr, i32 } %148, i32 %150, 3
  %152 = alloca [0 x ptr], align 8
  %153 = call ptr @llvm.invariant.start.p0(i64 0, ptr %152)
  %154 = call ptr @llvm.invariant.start.p0(i64 472, ptr %141)
  %155 = getelementptr ptr, ptr %141, i32 %150
  %156 = getelementptr ptr, ptr %155, i32 3
  %157 = load ptr, ptr %156, align 8
  %158 = alloca {}, align 8
  %159 = call ptr @behavior_wrapper(ptr %157, { ptr, ptr, ptr, i32 } %151, ptr %158)
  %160 = call { ptr, ptr, ptr, i32 } %159({ ptr, ptr, ptr, i32 } %151, { ptr, ptr, ptr, i32 } %151, ptr %152)
  %161 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %160, ptr %161, align 8
  %162 = alloca i32, align 4
  %163 = alloca ptr, align 8
  %164 = alloca ptr, align 8
  %165 = alloca ptr, align 8
  %166 = getelementptr { ptr, ptr, ptr, i32 }, ptr %161, i32 0, i32 0
  %167 = load ptr, ptr %166, align 8
  store ptr %167, ptr %165, align 8
  %168 = getelementptr { ptr, ptr, ptr, i32 }, ptr %161, i32 0, i32 1
  %169 = load ptr, ptr %168, align 8
  store ptr %169, ptr %164, align 8
  %170 = getelementptr { ptr, ptr, ptr, i32 }, ptr %161, i32 0, i32 2
  %171 = load ptr, ptr %170, align 8
  store ptr %171, ptr %163, align 8
  %172 = getelementptr { ptr, ptr, ptr, i32 }, ptr %161, i32 0, i32 3
  %173 = load i32, ptr %172, align 4
  store i32 %173, ptr %162, align 4
  %174 = load ptr, ptr %165, align 8
  %175 = call i32 @get_offset(ptr %174, ptr @Iterator)
  store i32 %175, ptr %162, align 4
  %176 = load ptr, ptr %7, align 8
  %177 = load ptr, ptr %6, align 8
  %178 = call ptr @llvm.invariant.start.p0(i64 992, ptr %177)
  %179 = load i32, ptr %5, align 4
  %180 = getelementptr ptr, ptr %177, i32 %179
  %181 = getelementptr ptr, ptr %180, i32 4
  %182 = load ptr, ptr %181, align 8
  %183 = getelementptr { ptr, ptr }, ptr %182, i32 0, i32 0
  %184 = load ptr, ptr %183, align 8
  %185 = call { ptr, ptr, ptr, i32 } %184(ptr %176) #2
  %186 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %185, ptr %186, align 8
  call void @assume_offset(ptr %186, ptr @Collection)
  %187 = alloca i32, align 4
  %188 = alloca ptr, align 8
  %189 = alloca ptr, align 8
  %190 = alloca ptr, align 8
  %191 = load ptr, ptr %165, align 8
  store ptr %191, ptr %190, align 8
  %192 = load ptr, ptr %164, align 8
  store ptr %192, ptr %189, align 8
  %193 = load ptr, ptr %163, align 8
  store ptr %193, ptr %188, align 8
  %194 = load i32, ptr %162, align 4
  store i32 %194, ptr %187, align 4
  %195 = load ptr, ptr %190, align 8
  %196 = call i32 @get_offset(ptr %195, ptr @Iterator)
  store i32 %196, ptr %187, align 4
  %197 = load ptr, ptr %190, align 8
  %198 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %197, 0
  %199 = load ptr, ptr %189, align 8
  %200 = insertvalue { ptr, ptr, ptr, i32 } %198, ptr %199, 1
  %201 = load ptr, ptr %188, align 8
  %202 = insertvalue { ptr, ptr, ptr, i32 } %200, ptr %201, 2
  %203 = load i32, ptr %187, align 4
  %204 = insertvalue { ptr, ptr, ptr, i32 } %202, i32 %203, 3
  %205 = alloca i32, align 4
  %206 = alloca ptr, align 8
  %207 = alloca ptr, align 8
  %208 = alloca ptr, align 8
  %209 = getelementptr { ptr, ptr, ptr, i32 }, ptr %186, i32 0, i32 0
  %210 = load ptr, ptr %209, align 8
  store ptr %210, ptr %208, align 8
  %211 = getelementptr { ptr, ptr, ptr, i32 }, ptr %186, i32 0, i32 1
  %212 = load ptr, ptr %211, align 8
  store ptr %212, ptr %207, align 8
  %213 = getelementptr { ptr, ptr, ptr, i32 }, ptr %186, i32 0, i32 2
  %214 = load ptr, ptr %213, align 8
  store ptr %214, ptr %206, align 8
  %215 = getelementptr { ptr, ptr, ptr, i32 }, ptr %186, i32 0, i32 3
  %216 = load i32, ptr %215, align 4
  store i32 %216, ptr %205, align 4
  %217 = load ptr, ptr %208, align 8
  %218 = call i32 @get_offset(ptr %217, ptr @Iterable)
  store i32 %218, ptr %205, align 4
  %219 = load ptr, ptr %208, align 8
  %220 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %219, 0
  %221 = load ptr, ptr %207, align 8
  %222 = insertvalue { ptr, ptr, ptr, i32 } %220, ptr %221, 1
  %223 = load ptr, ptr %206, align 8
  %224 = insertvalue { ptr, ptr, ptr, i32 } %222, ptr %223, 2
  %225 = load i32, ptr %205, align 4
  %226 = insertvalue { ptr, ptr, ptr, i32 } %224, i32 %225, 3
  %227 = load ptr, ptr %128, align 8
  %228 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %227, 0
  %229 = load ptr, ptr %127, align 8
  %230 = insertvalue { ptr, ptr, ptr, i32 } %228, ptr %229, 1
  %231 = load ptr, ptr %126, align 8
  %232 = insertvalue { ptr, ptr, ptr, i32 } %230, ptr %231, 2
  %233 = load i32, ptr %125, align 4
  %234 = insertvalue { ptr, ptr, ptr, i32 } %232, i32 %233, 3
  %235 = load ptr, ptr %7, align 8
  %236 = load ptr, ptr %6, align 8
  %237 = call ptr @llvm.invariant.start.p0(i64 992, ptr %236)
  %238 = load i32, ptr %5, align 4
  %239 = getelementptr ptr, ptr %236, i32 %238
  %240 = load ptr, ptr %239, align 8
  %241 = call ptr @typegetter_wrapper(ptr %240, ptr %235)
  %242 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %243 = getelementptr [3 x ptr], ptr %242, i32 0, i32 1
  store ptr %241, ptr %243, align 8
  %244 = getelementptr [3 x ptr], ptr %242, i32 0, i32 2
  store ptr null, ptr %244, align 8
  %245 = call ptr @llvm.invariant.start.p0(i64 16, ptr %242)
  store ptr @Iterator, ptr %242, align 8
  %246 = load ptr, ptr %7, align 8
  %247 = load ptr, ptr %6, align 8
  %248 = call ptr @llvm.invariant.start.p0(i64 992, ptr %247)
  %249 = load i32, ptr %5, align 4
  %250 = getelementptr ptr, ptr %247, i32 %249
  %251 = getelementptr ptr, ptr %250, i32 1
  %252 = load ptr, ptr %251, align 8
  %253 = call ptr @typegetter_wrapper(ptr %252, ptr %246)
  %254 = call ptr @bump_malloc(i64 ptrtoint (ptr getelementptr ([3 x ptr], ptr null, i32 1) to i64))
  %255 = getelementptr [3 x ptr], ptr %254, i32 0, i32 1
  store ptr %253, ptr %255, align 8
  %256 = getelementptr [3 x ptr], ptr %254, i32 0, i32 2
  store ptr null, ptr %256, align 8
  %257 = call ptr @llvm.invariant.start.p0(i64 16, ptr %254)
  store ptr @Collection, ptr %254, align 8
  %258 = alloca [2 x ptr], align 8
  %259 = getelementptr [2 x ptr], ptr %258, i32 0, i32 0
  store ptr %242, ptr %259, align 8
  %260 = getelementptr [2 x ptr], ptr %258, i32 0, i32 1
  store ptr %254, ptr %260, align 8
  %261 = call ptr @llvm.invariant.start.p0(i64 4, ptr %258)
  %262 = call ptr @llvm.invariant.start.p0(i64 112, ptr %227)
  %263 = getelementptr ptr, ptr %227, i32 %233
  %264 = getelementptr ptr, ptr %263, i32 7
  %265 = load ptr, ptr %264, align 8
  %266 = alloca { ptr, ptr }, align 8
  %267 = getelementptr { ptr, ptr }, ptr %266, i32 0, i32 0
  store ptr %197, ptr %267, align 8
  %268 = getelementptr { ptr, ptr }, ptr %266, i32 0, i32 1
  store ptr %219, ptr %268, align 8
  %269 = call ptr @behavior_wrapper(ptr %265, { ptr, ptr, ptr, i32 } %234, ptr %266)
  call void %269({ ptr, ptr, ptr, i32 } %234, { ptr, ptr, ptr, i32 } %234, ptr %258, { ptr, ptr, ptr, i32 } %204, { ptr, ptr, ptr, i32 } %226)
  %270 = alloca i32, align 4
  %271 = alloca ptr, align 8
  %272 = alloca ptr, align 8
  %273 = alloca ptr, align 8
  %274 = load ptr, ptr %128, align 8
  store ptr %274, ptr %273, align 8
  %275 = load ptr, ptr %127, align 8
  store ptr %275, ptr %272, align 8
  %276 = load ptr, ptr %126, align 8
  store ptr %276, ptr %271, align 8
  %277 = load i32, ptr %125, align 4
  store i32 %277, ptr %270, align 4
  %278 = load ptr, ptr %273, align 8
  %279 = call i32 @get_offset(ptr %278, ptr @Iterator)
  store i32 %279, ptr %270, align 4
  %280 = load ptr, ptr %273, align 8
  %281 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %280, 0
  %282 = load ptr, ptr %272, align 8
  %283 = insertvalue { ptr, ptr, ptr, i32 } %281, ptr %282, 1
  %284 = load ptr, ptr %271, align 8
  %285 = insertvalue { ptr, ptr, ptr, i32 } %283, ptr %284, 2
  %286 = load i32, ptr %270, align 4
  %287 = insertvalue { ptr, ptr, ptr, i32 } %285, i32 %286, 3
  ret { ptr, ptr, ptr, i32 } %287
}

define ptr @ProductCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 23, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [124 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @ProductCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 24, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [124 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @ProductCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @Pair, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @Pair to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = ptrtoint ptr %20 to i64
  %22 = icmp eq i64 %21, ptrtoint (ptr @function_typ to i64)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 25, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [124 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define ptr @ProductCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 26, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [124 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @ProductCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 27, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [124 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @ProductCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 28, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [124 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @ProductCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = ptrtoint ptr %7 to i64
  %9 = icmp eq i64 %8, ptrtoint (ptr @function_typ to i64)
  %10 = zext i1 %9 to i8
  store i8 %10, ptr %3, align 1
  %11 = load i8, ptr %3, align 1
  %12 = trunc i8 %11 to i1
  %13 = select i1 %12, i32 29, i32 30
  br i1 %12, label %14, label %15

14:                                               ; preds = %2
  br label %20

15:                                               ; preds = %2
  %16 = load ptr, ptr %1, align 8
  %17 = ptrtoint ptr %16 to i64
  %18 = icmp eq i64 %17, ptrtoint (ptr @function_typ to i64)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %4, align 1
  br label %20

20:                                               ; preds = %14, %15
  store i32 %13, ptr %6, align 4
  %21 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %22 = load i32, ptr %6, align 4
  %23 = getelementptr [124 x ptr], ptr %21, i32 0, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 10
  %25 = load ptr, ptr %24, align 8
  ret ptr %25
}

define ptr @ProductCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 31, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [124 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define ptr @ProductCollection_B_chain_otherCollectionT_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 32, i32 33
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [124 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

define ptr @ProductCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 34, i32 35
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [124 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

define ptr @ProductCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 37, i32 36
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [124 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

define ptr @ProductCollection_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 39, i32 38
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [124 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare ptr @llvm.invariant.start.p0(i64 immarg, ptr nocapture) #0

attributes #0 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #1 = { nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { nounwind willreturn memory(argmem: read, inaccessiblemem: readwrite) }

!llvm.module.flags = !{!0}

!0 = !{i32 2, !"Debug Info Version", i32 3}
// -----
; ModuleID = 'LLVMDialectModule'
source_filename = "LLVMDialectModule"

%bool_typ = type opaque
%i1_typ = type opaque
%i8_typ = type opaque
%i32_typ = type opaque
%i64_typ = type opaque
%i128_typ = type opaque
%f64_typ = type opaque
%nil_typ = type opaque
%any_typ = type opaque
%nothing_typ = type opaque
%coroutine_typ = type opaque
%function_typ = type opaque
%buffer_typ = type opaque
%tuple_typ = type opaque
%union_typ = type opaque
%Object = type opaque
%Pair = type opaque
%Iterator = type opaque
%Iterable = type opaque
%ConstantTimeIterator = type opaque
%CoroIterator = type opaque
%Enumerated = type opaque
%Enumerator = type opaque
%Mapped = type opaque
%Mapper = type opaque
%Filtered = type opaque
%Filterer = type opaque
%Chained = type opaque
%Chainer = type opaque
%Interleaved = type opaque
%Interleaver = type opaque
%Zipped = type opaque
%Zipper = type opaque
%Products = type opaque
%Productizer = type opaque
%Collection = type opaque
%EnumeratedCollection = type opaque
%MappedCollection = type opaque
%ChainedCollection = type opaque
%InterleavedCollection = type opaque
%ZippedCollection = type opaque
%ProductCollection = type opaque

@_parameterization_i32 = linkonce_odr constant [2 x ptr] [ptr @i32_typ, ptr null]
@i32_string = linkonce_odr constant [4 x i8] c"%d\0A\00"
@i64_string = linkonce_odr constant [6 x i8] c"%lld\0A\00"
@float_string = linkonce_odr constant [4 x i8] c"%f\0A\00"
@string_string = linkonce_odr constant [4 x i8] c"%s\0A\00"
@bool_typ = external constant %bool_typ
@i1_typ = external constant %i1_typ
@i8_typ = external constant %i8_typ
@i32_typ = external constant %i32_typ
@i64_typ = external constant %i64_typ
@i128_typ = external constant %i128_typ
@f64_typ = external constant %f64_typ
@nil_typ = external constant %nil_typ
@any_typ = external constant %any_typ
@nothing_typ = external constant %nothing_typ
@coroutine_typ = external constant %coroutine_typ
@function_typ = external constant %function_typ
@buffer_typ = external constant %buffer_typ
@tuple_typ = external constant %tuple_typ
@union_typ = external constant %union_typ
@Object = external constant %Object
@Pair = external constant %Pair
@Iterator = external constant %Iterator
@Iterable = external constant %Iterable
@ConstantTimeIterator = external constant %ConstantTimeIterator
@CoroIterator = external constant %CoroIterator
@Enumerated = external constant %Enumerated
@Enumerator = external constant %Enumerator
@Mapped = external constant %Mapped
@Mapper = external constant %Mapper
@Filtered = external constant %Filtered
@Filterer = external constant %Filterer
@Chained = external constant %Chained
@Chainer = external constant %Chainer
@Interleaved = external constant %Interleaved
@Interleaver = external constant %Interleaver
@Zipped = external constant %Zipped
@Zipper = external constant %Zipper
@Products = external constant %Products
@Productizer = external constant %Productizer
@Collection = external constant %Collection
@EnumeratedCollection = external constant %EnumeratedCollection
@MappedCollection = external constant %MappedCollection
@ChainedCollection = external constant %ChainedCollection
@InterleavedCollection = external constant %InterleavedCollection
@ZippedCollection = external constant %ZippedCollection
@ProductCollection = external constant %ProductCollection
@List_hashtbl = constant [8 x ptr] [ptr null, ptr @Collection, ptr @Iterable, ptr @Object, ptr @any_typ, ptr @List, ptr null, ptr null]
@List_offset_tbl = constant [8 x i32] [i32 0, i32 62, i32 121, i32 146, i32 10, i32 10, i32 0, i32 0]
@List = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -83120161364696977, i64 -697284027674382885, i64 7], [7 x ptr] [ptr @subtype_test, ptr @List_hashtbl, ptr @List_offset_tbl, ptr @_data_size_List, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }

declare i32 @printf(ptr, ...)

declare ptr @bump_malloc(i64)

declare void @free(ptr)

declare void @setup_landing_pad()

declare void @anoint_trampoline(ptr)

declare ptr @adjust_trampoline(ptr)

declare ptr @coroutine_create(ptr, ptr)

declare void @arg_passer(ptr)

declare void @arg_buffer_filler(ptr)

declare void @coroutine_yield(ptr)

declare void @coroutine_yield_cold(ptr)

declare ptr @get_current_coroutine()

declare i32 @get_offset(ptr, ptr)

declare void @assume_offset(ptr, ptr)

declare { ptr, i160 } @_box_Default(ptr, ptr)

declare void @_unbox_Default({ ptr, i160 }, ptr, ptr)

declare { i64, i64 } @_size_Default(ptr)

declare void @_unbox_union_typ({ ptr, i160 }, ptr, ptr)

declare { i64, i64 } @_data_size_tuple_typ(ptr)

declare { i64, i64 } @_data_size_union_typ(ptr)

declare i1 @subtype_test(i64, i64, i64, i64, ptr)

declare i1 @subtype_test_wrapper(ptr, i64, i64, i64, i64, ptr)

declare { i64, i64 } @size_wrapper(ptr, ptr)

declare ptr @typegetter_wrapper(ptr, ptr)

declare { ptr, i160 } @box_wrapper(ptr, ptr, ptr)

declare void @unbox_wrapper(ptr, { ptr, i160 }, ptr, ptr)

declare ptr @behavior_wrapper(ptr, { ptr, ptr, ptr, i32 }, ptr)

declare ptr @class_behavior_wrapper(ptr, ptr)

declare void @coroutine_call(ptr)

define { i64, i64 } @_data_size_List(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %3
  %5 = icmp eq i64 %4, 0
  %6 = sub i64 %3, %4
  %7 = select i1 %5, i64 0, i64 %6
  %8 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %7
  %9 = insertvalue { i64, i64 } undef, i64 %8, 0
  %10 = insertvalue { i64, i64 } %9, i64 %3, 1
  ret { i64, i64 } %10
}

define ptr @List_field_List_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define ptr @List_B__Self_empty_(ptr %0) {
  %2 = call ptr @llvm.invariant.start.p0(i64 0, ptr %0)
  %3 = alloca ptr, align 8
  store i32 24, ptr %3, align 4
  %4 = load i32, ptr %3, align 4
  %5 = getelementptr [136 x ptr], ptr @List, i32 0, i32 %4
  %6 = getelementptr ptr, ptr %5, i32 10
  %7 = load ptr, ptr %6, align 8
  ret ptr %7
}

define ptr @List_B__Self_from_iterable_iterableIterableT(ptr %0) {
  %2 = alloca i1, align 1
  %3 = call ptr @llvm.invariant.start.p0(i64 8, ptr %0)
  %4 = alloca ptr, align 8
  %5 = load ptr, ptr %0, align 8
  %6 = getelementptr { [3 x i64], [3 x ptr] }, ptr %5, i32 0, i32 0, i32 1
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %5, i32 0, i32 0, i32 2
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %5, i32 0, i32 1, i32 0
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %5, i32 0, i32 1, i32 1
  %10 = load i64, ptr %6, align 4
  %11 = load i64, ptr %7, align 4
  %12 = load ptr, ptr %8, align 8
  %13 = load ptr, ptr %9, align 8
  %14 = load i64, ptr @Iterable, align 4
  %15 = call i1 @subtype_test_wrapper(ptr %12, i64 %11, i64 %10, i64 %14, i64 ptrtoint (ptr @Iterable to i64), ptr %13)
  %16 = zext i1 %15 to i8
  store i8 %16, ptr %2, align 1
  store i32 25, ptr %4, align 4
  %17 = load i32, ptr %4, align 4
  %18 = getelementptr [136 x ptr], ptr @List, i32 0, i32 %17
  %19 = getelementptr ptr, ptr %18, i32 10
  %20 = load ptr, ptr %19, align 8
  ret ptr %20
}

define ptr @List_B_append_xT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @any_typ, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @any_typ to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 26, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [136 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define i32 @List_length_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %8, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %6, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %8, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @List)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %8, align 8
  %20 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %19, 0
  %21 = load ptr, ptr %7, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %21, 1
  %23 = load ptr, ptr %6, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %23, 2
  %25 = load i32, ptr %5, align 4
  %26 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %25, 3
  %27 = alloca [0 x ptr], align 8
  %28 = call ptr @llvm.invariant.start.p0(i64 0, ptr %27)
  %29 = call ptr @llvm.invariant.start.p0(i64 1088, ptr %19)
  %30 = getelementptr ptr, ptr %19, i32 %25
  %31 = getelementptr ptr, ptr %30, i32 10
  %32 = load ptr, ptr %31, align 8
  %33 = alloca {}, align 8
  %34 = call ptr @behavior_wrapper(ptr %32, { ptr, ptr, ptr, i32 } %26, ptr %33)
  %35 = call i32 %34({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr %27)
  %36 = alloca i32, align 4
  store i32 %35, ptr %36, align 4
  %37 = load i32, ptr %36, align 4
  ret i32 %37
}

define ptr @List_B_length_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 27, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [136 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { ptr, i160 } @List_first_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca [0 x i8], align 1
  %5 = alloca i160, align 8
  %6 = alloca ptr, align 8
  %7 = alloca [0 x ptr], align 8
  %8 = alloca {}, align 8
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  %10 = alloca i32, align 4
  %11 = alloca ptr, align 8
  %12 = alloca ptr, align 8
  %13 = alloca ptr, align 8
  %14 = alloca i32, align 4
  %15 = alloca ptr, align 8
  %16 = alloca ptr, align 8
  %17 = alloca ptr, align 8
  %18 = alloca [0 x ptr], align 8
  %19 = alloca {}, align 8
  %20 = alloca { ptr, i160 }, align 8
  %21 = alloca i1, align 1
  %22 = alloca i1, align 1
  %23 = alloca i1, align 1
  %24 = alloca i160, align 8
  %25 = alloca ptr, align 8
  %26 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %26, align 8
  %27 = alloca i32, align 4
  %28 = alloca ptr, align 8
  %29 = alloca ptr, align 8
  %30 = alloca ptr, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 0
  %32 = load ptr, ptr %31, align 8
  store ptr %32, ptr %30, align 8
  %33 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 1
  %34 = load ptr, ptr %33, align 8
  store ptr %34, ptr %29, align 8
  %35 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 2
  %36 = load ptr, ptr %35, align 8
  store ptr %36, ptr %28, align 8
  %37 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 3
  %38 = load i32, ptr %37, align 4
  store i32 %38, ptr %27, align 4
  %39 = load ptr, ptr %30, align 8
  %40 = call i32 @get_offset(ptr %39, ptr @List)
  store i32 %40, ptr %27, align 4
  %41 = load ptr, ptr %30, align 8
  %42 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %41, 0
  %43 = load ptr, ptr %29, align 8
  %44 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %43, 1
  %45 = load ptr, ptr %28, align 8
  %46 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %45, 2
  %47 = load i32, ptr %27, align 4
  %48 = insertvalue { ptr, ptr, ptr, i32 } %46, i32 %47, 3
  %49 = alloca [0 x ptr], align 8
  %50 = call ptr @llvm.invariant.start.p0(i64 0, ptr %49)
  %51 = call ptr @llvm.invariant.start.p0(i64 1088, ptr %41)
  %52 = getelementptr ptr, ptr %41, i32 %47
  %53 = getelementptr ptr, ptr %52, i32 11
  %54 = load ptr, ptr %53, align 8
  %55 = alloca {}, align 8
  %56 = call ptr @behavior_wrapper(ptr %54, { ptr, ptr, ptr, i32 } %48, ptr %55)
  %57 = call i1 %56({ ptr, ptr, ptr, i32 } %48, { ptr, ptr, ptr, i32 } %48, ptr %49)
  %58 = alloca i1, align 1
  %59 = zext i1 %57 to i8
  store i8 %59, ptr %58, align 1
  %60 = load i8, ptr %58, align 1
  %61 = trunc i8 %60 to i1
  br i1 %61, label %62, label %68

62:                                               ; preds = %3
  %63 = load [0 x i8], ptr %4, align 1
  store [0 x i8] %63, ptr %5, align 1
  store ptr @nil_typ, ptr %6, align 8
  %64 = load ptr, ptr %6, align 8
  %65 = insertvalue { ptr, i160 } undef, ptr %64, 0
  %66 = load i160, ptr %5, align 4
  %67 = insertvalue { ptr, i160 } %65, i160 %66, 1
  br label %142

68:                                               ; preds = %3
  %69 = load ptr, ptr %30, align 8
  %70 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %69, 0
  %71 = load ptr, ptr %29, align 8
  %72 = insertvalue { ptr, ptr, ptr, i32 } %70, ptr %71, 1
  %73 = load ptr, ptr %28, align 8
  %74 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr %73, 2
  %75 = load i32, ptr %27, align 4
  %76 = insertvalue { ptr, ptr, ptr, i32 } %74, i32 %75, 3
  %77 = call ptr @llvm.invariant.start.p0(i64 0, ptr %7)
  %78 = call ptr @llvm.invariant.start.p0(i64 1088, ptr %69)
  %79 = getelementptr ptr, ptr %69, i32 %75
  %80 = getelementptr ptr, ptr %79, i32 12
  %81 = load ptr, ptr %80, align 8
  %82 = call ptr @behavior_wrapper(ptr %81, { ptr, ptr, ptr, i32 } %76, ptr %8)
  %83 = call { ptr, ptr, ptr, i32 } %82({ ptr, ptr, ptr, i32 } %76, { ptr, ptr, ptr, i32 } %76, ptr %7)
  store { ptr, ptr, ptr, i32 } %83, ptr %9, align 8
  %84 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 0
  %85 = load ptr, ptr %84, align 8
  store ptr %85, ptr %13, align 8
  %86 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 1
  %87 = load ptr, ptr %86, align 8
  store ptr %87, ptr %12, align 8
  %88 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 2
  %89 = load ptr, ptr %88, align 8
  store ptr %89, ptr %11, align 8
  %90 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 3
  %91 = load i32, ptr %90, align 4
  store i32 %91, ptr %10, align 4
  %92 = load ptr, ptr %13, align 8
  %93 = call i32 @get_offset(ptr %92, ptr @ConstantTimeIterator)
  store i32 %93, ptr %10, align 4
  %94 = load ptr, ptr %13, align 8
  store ptr %94, ptr %17, align 8
  %95 = load ptr, ptr %12, align 8
  store ptr %95, ptr %16, align 8
  %96 = load ptr, ptr %11, align 8
  store ptr %96, ptr %15, align 8
  %97 = load i32, ptr %10, align 4
  store i32 %97, ptr %14, align 4
  %98 = load ptr, ptr %17, align 8
  %99 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %98, 0
  %100 = load ptr, ptr %16, align 8
  %101 = insertvalue { ptr, ptr, ptr, i32 } %99, ptr %100, 1
  %102 = load ptr, ptr %15, align 8
  %103 = insertvalue { ptr, ptr, ptr, i32 } %101, ptr %102, 2
  %104 = load i32, ptr %14, align 4
  %105 = insertvalue { ptr, ptr, ptr, i32 } %103, i32 %104, 3
  %106 = call ptr @llvm.invariant.start.p0(i64 0, ptr %18)
  %107 = call ptr @llvm.invariant.start.p0(i64 48, ptr %98)
  %108 = getelementptr ptr, ptr %98, i32 %104
  %109 = getelementptr ptr, ptr %108, i32 1
  %110 = load ptr, ptr %109, align 8
  %111 = call ptr @behavior_wrapper(ptr %110, { ptr, ptr, ptr, i32 } %105, ptr %19)
  %112 = call { ptr, i160 } %111({ ptr, ptr, ptr, i32 } %105, { ptr, ptr, ptr, i32 } %105, ptr %18)
  store { ptr, i160 } %112, ptr %20, align 8
  store i8 0, ptr %21, align 1
  %113 = load ptr, ptr %20, align 8
  %114 = ptrtoint ptr %113 to i64
  %115 = icmp eq i64 %114, ptrtoint (ptr @nil_typ to i64)
  %116 = icmp eq i64 %114, 0
  %117 = or i1 %115, %116
  %118 = zext i1 %117 to i8
  store i8 %118, ptr %22, align 1
  %119 = load i8, ptr %21, align 1
  %120 = trunc i8 %119 to i1
  %121 = load i8, ptr %22, align 1
  %122 = trunc i8 %121 to i1
  %123 = icmp eq i1 %120, %122
  %124 = zext i1 %123 to i8
  store i8 %124, ptr %23, align 1
  %125 = load i8, ptr %23, align 1
  %126 = trunc i8 %125 to i1
  %127 = xor i1 %126, true
  %128 = zext i1 %127 to i32
  br i1 %126, label %129, label %138

129:                                              ; preds = %68
  %130 = getelementptr { ptr, i160 }, ptr %20, i32 0, i32 0
  %131 = load ptr, ptr %130, align 8
  store ptr %131, ptr %25, align 8
  %132 = getelementptr { ptr, i160 }, ptr %20, i32 0, i32 1
  %133 = load i160, ptr %132, align 4
  store i160 %133, ptr %24, align 4
  %134 = load ptr, ptr %25, align 8
  %135 = insertvalue { ptr, i160 } undef, ptr %134, 0
  %136 = load i160, ptr %24, align 4
  %137 = insertvalue { ptr, i160 } %135, i160 %136, 1
  br label %139

138:                                              ; preds = %68
  br label %139

139:                                              ; preds = %129, %138
  %140 = phi { ptr, i160 } [ poison, %138 ], [ %137, %129 ]
  br label %141

141:                                              ; preds = %139
  br label %142

142:                                              ; preds = %62, %141
  %143 = phi { ptr, i160 } [ %140, %141 ], [ %67, %62 ]
  %144 = phi i32 [ %128, %141 ], [ 0, %62 ]
  br label %145

145:                                              ; preds = %142
  %146 = zext i32 %144 to i64
  %147 = trunc i64 %146 to i32
  switch i32 %147, label %148 [
    i32 0, label %151
  ]

148:                                              ; preds = %151, %145
  %149 = phi { ptr, i160 } [ %152, %151 ], [ poison, %145 ]
  br label %150

150:                                              ; preds = %148
  ret { ptr, i160 } %149

151:                                              ; preds = %145
  %152 = phi { ptr, i160 } [ %143, %145 ]
  br label %148
}

define ptr @List_B_first_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 28, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [136 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { ptr, i160 } @List_last_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %8, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %6, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %8, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @List)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %8, align 8
  %20 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %19, 0
  %21 = load ptr, ptr %7, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %20, ptr %21, 1
  %23 = load ptr, ptr %6, align 8
  %24 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %23, 2
  %25 = load i32, ptr %5, align 4
  %26 = insertvalue { ptr, ptr, ptr, i32 } %24, i32 %25, 3
  %27 = alloca [0 x ptr], align 8
  %28 = call ptr @llvm.invariant.start.p0(i64 0, ptr %27)
  %29 = call ptr @llvm.invariant.start.p0(i64 1088, ptr %19)
  %30 = getelementptr ptr, ptr %19, i32 %25
  %31 = getelementptr ptr, ptr %30, i32 10
  %32 = load ptr, ptr %31, align 8
  %33 = alloca {}, align 8
  %34 = call ptr @behavior_wrapper(ptr %32, { ptr, ptr, ptr, i32 } %26, ptr %33)
  %35 = call i32 %34({ ptr, ptr, ptr, i32 } %26, { ptr, ptr, ptr, i32 } %26, ptr %27)
  %36 = alloca i32, align 4
  store i32 %35, ptr %36, align 4
  %37 = alloca i32, align 4
  store i32 1, ptr %37, align 4
  %38 = load i32, ptr %36, align 4
  %39 = load i32, ptr %37, align 4
  %40 = sub i32 %38, %39
  %41 = alloca i32, align 4
  store i32 %40, ptr %41, align 4
  %42 = load i32, ptr %41, align 4
  %43 = load ptr, ptr %8, align 8
  %44 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %43, 0
  %45 = load ptr, ptr %7, align 8
  %46 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %45, 1
  %47 = load ptr, ptr %6, align 8
  %48 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %47, 2
  %49 = load i32, ptr %5, align 4
  %50 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %49, 3
  %51 = alloca [1 x ptr], align 8
  %52 = getelementptr [1 x ptr], ptr %51, i32 0, i32 0
  store ptr @_parameterization_i32, ptr %52, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 1, ptr %51)
  %54 = call ptr @llvm.invariant.start.p0(i64 1088, ptr %43)
  %55 = getelementptr ptr, ptr %43, i32 %49
  %56 = getelementptr ptr, ptr %55, i32 8
  %57 = load ptr, ptr %56, align 8
  %58 = alloca { ptr }, align 8
  %59 = getelementptr { ptr }, ptr %58, i32 0, i32 0
  store ptr @i32_typ, ptr %59, align 8
  %60 = call ptr @behavior_wrapper(ptr %57, { ptr, ptr, ptr, i32 } %50, ptr %58)
  %61 = call { ptr, i160 } %60({ ptr, ptr, ptr, i32 } %50, { ptr, ptr, ptr, i32 } %50, ptr %51, i32 %42)
  %62 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %61, ptr %62, align 8
  %63 = getelementptr { ptr, i160 }, ptr %62, i32 0, i32 0
  %64 = load ptr, ptr %63, align 8
  %65 = insertvalue { ptr, i160 } undef, ptr %64, 0
  %66 = getelementptr { ptr, i160 }, ptr %62, i32 0, i32 1
  %67 = load i160, ptr %66, align 4
  %68 = insertvalue { ptr, i160 } %65, i160 %67, 1
  ret { ptr, i160 } %68
}

define ptr @List_B_last_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 29, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [136 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { ptr, ptr, ptr, i32 } @List_extend_otherIterableT({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3) {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca {}, align 8
  %7 = alloca { ptr, i160 }, align 8
  %8 = alloca i1, align 1
  %9 = alloca i1, align 1
  %10 = alloca i1, align 1
  %11 = alloca i160, align 8
  %12 = alloca ptr, align 8
  %13 = alloca i160, align 8
  %14 = alloca ptr, align 8
  %15 = alloca [1 x ptr], align 8
  %16 = alloca { ptr }, align 8
  %17 = alloca { ptr, ptr, ptr, i32 }, align 8
  %18 = alloca i32, align 4
  %19 = alloca ptr, align 8
  %20 = alloca ptr, align 8
  %21 = alloca ptr, align 8
  %22 = alloca i32, align 4
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = alloca ptr, align 8
  %26 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %26, align 8
  %27 = alloca i32, align 4
  %28 = alloca ptr, align 8
  %29 = alloca ptr, align 8
  %30 = alloca ptr, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 0
  %32 = load ptr, ptr %31, align 8
  store ptr %32, ptr %30, align 8
  %33 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 1
  %34 = load ptr, ptr %33, align 8
  store ptr %34, ptr %29, align 8
  %35 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 2
  %36 = load ptr, ptr %35, align 8
  store ptr %36, ptr %28, align 8
  %37 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 3
  %38 = load i32, ptr %37, align 4
  store i32 %38, ptr %27, align 4
  %39 = load ptr, ptr %30, align 8
  %40 = call i32 @get_offset(ptr %39, ptr @List)
  store i32 %40, ptr %27, align 4
  %41 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %41, align 8
  %42 = alloca i32, align 4
  %43 = alloca ptr, align 8
  %44 = alloca ptr, align 8
  %45 = alloca ptr, align 8
  %46 = getelementptr { ptr, ptr, ptr, i32 }, ptr %41, i32 0, i32 0
  %47 = load ptr, ptr %46, align 8
  store ptr %47, ptr %45, align 8
  %48 = getelementptr { ptr, ptr, ptr, i32 }, ptr %41, i32 0, i32 1
  %49 = load ptr, ptr %48, align 8
  store ptr %49, ptr %44, align 8
  %50 = getelementptr { ptr, ptr, ptr, i32 }, ptr %41, i32 0, i32 2
  %51 = load ptr, ptr %50, align 8
  store ptr %51, ptr %43, align 8
  %52 = getelementptr { ptr, ptr, ptr, i32 }, ptr %41, i32 0, i32 3
  %53 = load i32, ptr %52, align 4
  store i32 %53, ptr %42, align 4
  %54 = load ptr, ptr %45, align 8
  %55 = call i32 @get_offset(ptr %54, ptr @Iterable)
  store i32 %55, ptr %42, align 4
  %56 = load ptr, ptr %45, align 8
  %57 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %56, 0
  %58 = load ptr, ptr %44, align 8
  %59 = insertvalue { ptr, ptr, ptr, i32 } %57, ptr %58, 1
  %60 = load ptr, ptr %43, align 8
  %61 = insertvalue { ptr, ptr, ptr, i32 } %59, ptr %60, 2
  %62 = load i32, ptr %42, align 4
  %63 = insertvalue { ptr, ptr, ptr, i32 } %61, i32 %62, 3
  %64 = alloca [0 x ptr], align 8
  %65 = call ptr @llvm.invariant.start.p0(i64 0, ptr %64)
  %66 = call ptr @llvm.invariant.start.p0(i64 200, ptr %56)
  %67 = getelementptr ptr, ptr %56, i32 %62
  %68 = getelementptr ptr, ptr %67, i32 1
  %69 = load ptr, ptr %68, align 8
  %70 = alloca {}, align 8
  %71 = call ptr @behavior_wrapper(ptr %69, { ptr, ptr, ptr, i32 } %63, ptr %70)
  %72 = call { ptr, ptr, ptr, i32 } %71({ ptr, ptr, ptr, i32 } %63, { ptr, ptr, ptr, i32 } %63, ptr %64)
  %73 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %72, ptr %73, align 8
  %74 = alloca i32, align 4
  %75 = alloca ptr, align 8
  %76 = alloca ptr, align 8
  %77 = alloca ptr, align 8
  %78 = getelementptr { ptr, ptr, ptr, i32 }, ptr %73, i32 0, i32 0
  %79 = load ptr, ptr %78, align 8
  store ptr %79, ptr %77, align 8
  %80 = getelementptr { ptr, ptr, ptr, i32 }, ptr %73, i32 0, i32 1
  %81 = load ptr, ptr %80, align 8
  store ptr %81, ptr %76, align 8
  %82 = getelementptr { ptr, ptr, ptr, i32 }, ptr %73, i32 0, i32 2
  %83 = load ptr, ptr %82, align 8
  store ptr %83, ptr %75, align 8
  %84 = getelementptr { ptr, ptr, ptr, i32 }, ptr %73, i32 0, i32 3
  %85 = load i32, ptr %84, align 4
  store i32 %85, ptr %74, align 4
  %86 = load ptr, ptr %77, align 8
  %87 = call i32 @get_offset(ptr %86, ptr @Iterator)
  store i32 %87, ptr %74, align 4
  %88 = alloca i32, align 4
  %89 = alloca ptr, align 8
  %90 = alloca ptr, align 8
  %91 = alloca ptr, align 8
  %92 = load ptr, ptr %77, align 8
  store ptr %92, ptr %91, align 8
  %93 = load ptr, ptr %76, align 8
  store ptr %93, ptr %90, align 8
  %94 = load ptr, ptr %75, align 8
  store ptr %94, ptr %89, align 8
  %95 = load i32, ptr %74, align 4
  store i32 %95, ptr %88, align 4
  br label %96

96:                                               ; preds = %171, %4
  %97 = load ptr, ptr %91, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %97, 0
  %99 = load ptr, ptr %90, align 8
  %100 = insertvalue { ptr, ptr, ptr, i32 } %98, ptr %99, 1
  %101 = load ptr, ptr %89, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } %100, ptr %101, 2
  %103 = load i32, ptr %88, align 4
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, i32 %103, 3
  %105 = call ptr @llvm.invariant.start.p0(i64 0, ptr %5)
  %106 = call ptr @llvm.invariant.start.p0(i64 24, ptr %97)
  %107 = getelementptr ptr, ptr %97, i32 %103
  %108 = getelementptr ptr, ptr %107, i32 1
  %109 = load ptr, ptr %108, align 8
  %110 = call ptr @behavior_wrapper(ptr %109, { ptr, ptr, ptr, i32 } %104, ptr %6)
  %111 = call { ptr, i160 } %110({ ptr, ptr, ptr, i32 } %104, { ptr, ptr, ptr, i32 } %104, ptr %5)
  store { ptr, i160 } %111, ptr %7, align 8
  store i8 0, ptr %8, align 1
  %112 = load ptr, ptr %7, align 8
  %113 = ptrtoint ptr %112 to i64
  %114 = icmp eq i64 %113, ptrtoint (ptr @nil_typ to i64)
  %115 = icmp eq i64 %113, 0
  %116 = or i1 %114, %115
  %117 = zext i1 %116 to i8
  store i8 %117, ptr %9, align 1
  %118 = load i8, ptr %8, align 1
  %119 = trunc i8 %118 to i1
  %120 = load i8, ptr %9, align 1
  %121 = trunc i8 %120 to i1
  %122 = icmp eq i1 %119, %121
  %123 = zext i1 %122 to i8
  store i8 %123, ptr %10, align 1
  %124 = load i8, ptr %10, align 1
  %125 = trunc i8 %124 to i1
  br i1 %125, label %126, label %171

126:                                              ; preds = %96
  %127 = getelementptr { ptr, i160 }, ptr %7, i32 0, i32 0
  %128 = load ptr, ptr %127, align 8
  store ptr %128, ptr %12, align 8
  %129 = getelementptr { ptr, i160 }, ptr %7, i32 0, i32 1
  %130 = load i160, ptr %129, align 4
  store i160 %130, ptr %11, align 4
  %131 = load ptr, ptr %12, align 8
  store ptr %131, ptr %14, align 8
  %132 = load i160, ptr %11, align 4
  store i160 %132, ptr %13, align 4
  %133 = load ptr, ptr %14, align 8
  %134 = insertvalue { ptr, i160 } undef, ptr %133, 0
  %135 = load i160, ptr %13, align 4
  %136 = insertvalue { ptr, i160 } %134, i160 %135, 1
  %137 = load ptr, ptr %30, align 8
  %138 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %137, 0
  %139 = load ptr, ptr %29, align 8
  %140 = insertvalue { ptr, ptr, ptr, i32 } %138, ptr %139, 1
  %141 = load ptr, ptr %28, align 8
  %142 = insertvalue { ptr, ptr, ptr, i32 } %140, ptr %141, 2
  %143 = load i32, ptr %27, align 4
  %144 = insertvalue { ptr, ptr, ptr, i32 } %142, i32 %143, 3
  %145 = call ptr @llvm.invariant.start.p0(i64 1088, ptr %137)
  %146 = load i32, ptr %27, align 4
  %147 = getelementptr ptr, ptr %137, i32 %146
  %148 = load ptr, ptr %147, align 8
  %149 = call ptr @typegetter_wrapper(ptr %148, ptr %139)
  %150 = getelementptr [1 x ptr], ptr %15, i32 0, i32 0
  store ptr %149, ptr %150, align 8
  %151 = call ptr @llvm.invariant.start.p0(i64 1, ptr %15)
  %152 = call ptr @llvm.invariant.start.p0(i64 1088, ptr %137)
  %153 = getelementptr ptr, ptr %137, i32 %143
  %154 = getelementptr ptr, ptr %153, i32 3
  %155 = load ptr, ptr %154, align 8
  %156 = getelementptr { ptr }, ptr %16, i32 0, i32 0
  store ptr %133, ptr %156, align 8
  %157 = call ptr @behavior_wrapper(ptr %155, { ptr, ptr, ptr, i32 } %144, ptr %16)
  %158 = call { ptr, ptr, ptr, i32 } %157({ ptr, ptr, ptr, i32 } %144, { ptr, ptr, ptr, i32 } %144, ptr %15, { ptr, i160 } %136)
  store { ptr, ptr, ptr, i32 } %158, ptr %17, align 8
  %159 = getelementptr { ptr, ptr, ptr, i32 }, ptr %17, i32 0, i32 0
  %160 = load ptr, ptr %159, align 8
  store ptr %160, ptr %19, align 8
  %161 = getelementptr { ptr, ptr, ptr, i32 }, ptr %17, i32 0, i32 1
  %162 = load ptr, ptr %161, align 8
  store ptr %162, ptr %21, align 8
  %163 = getelementptr { ptr, ptr, ptr, i32 }, ptr %17, i32 0, i32 2
  %164 = load ptr, ptr %163, align 8
  store ptr %164, ptr %20, align 8
  %165 = getelementptr { ptr, ptr, ptr, i32 }, ptr %17, i32 0, i32 3
  %166 = load i32, ptr %165, align 4
  store i32 %166, ptr %18, align 4
  %167 = load ptr, ptr %19, align 8
  %168 = call i32 @get_offset(ptr %167, ptr @List)
  store i32 %168, ptr %18, align 4
  %169 = load ptr, ptr %12, align 8
  store ptr %169, ptr %127, align 8
  %170 = load i160, ptr %11, align 4
  store i160 %170, ptr %129, align 4
  br label %171

171:                                              ; preds = %126, %96
  br i1 %125, label %96, label %172

172:                                              ; preds = %171
  %173 = load ptr, ptr %30, align 8
  store ptr %173, ptr %25, align 8
  %174 = load ptr, ptr %29, align 8
  store ptr %174, ptr %24, align 8
  %175 = load ptr, ptr %28, align 8
  store ptr %175, ptr %23, align 8
  %176 = load i32, ptr %27, align 4
  store i32 %176, ptr %22, align 4
  %177 = load ptr, ptr %25, align 8
  %178 = call i32 @get_offset(ptr %177, ptr @List)
  store i32 %178, ptr %22, align 4
  %179 = load ptr, ptr %25, align 8
  %180 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %179, 0
  %181 = load ptr, ptr %24, align 8
  %182 = insertvalue { ptr, ptr, ptr, i32 } %180, ptr %181, 1
  %183 = load ptr, ptr %23, align 8
  %184 = insertvalue { ptr, ptr, ptr, i32 } %182, ptr %183, 2
  %185 = load i32, ptr %22, align 4
  %186 = insertvalue { ptr, ptr, ptr, i32 } %184, i32 %185, 3
  ret { ptr, ptr, ptr, i32 } %186
}

define ptr @List_B_extend_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Iterable, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Iterable to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 30, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [136 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define { ptr, i160 } @List_get_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, i32 %3) {
  %5 = alloca [0 x i8], align 1
  %6 = alloca i160, align 8
  %7 = alloca ptr, align 8
  %8 = alloca [0 x ptr], align 8
  %9 = alloca {}, align 8
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  %11 = alloca i32, align 4
  %12 = alloca ptr, align 8
  %13 = alloca ptr, align 8
  %14 = alloca ptr, align 8
  %15 = alloca [0 x ptr], align 8
  %16 = alloca {}, align 8
  %17 = alloca { ptr, ptr, ptr, i32 }, align 8
  %18 = alloca i32, align 4
  %19 = alloca ptr, align 8
  %20 = alloca ptr, align 8
  %21 = alloca ptr, align 8
  %22 = alloca i32, align 4
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = alloca ptr, align 8
  %26 = alloca [0 x ptr], align 8
  %27 = alloca {}, align 8
  %28 = alloca { ptr, i160 }, align 8
  %29 = alloca i1, align 1
  %30 = alloca i1, align 1
  %31 = alloca i1, align 1
  %32 = alloca { ptr, ptr, ptr, i32 }, align 8
  %33 = alloca i32, align 4
  %34 = alloca ptr, align 8
  %35 = alloca ptr, align 8
  %36 = alloca ptr, align 8
  %37 = alloca [0 x ptr], align 8
  %38 = alloca {}, align 8
  %39 = alloca { ptr, i160 }, align 8
  %40 = alloca i32, align 4
  %41 = alloca [0 x ptr], align 8
  %42 = alloca {}, align 8
  %43 = alloca { ptr, i160 }, align 8
  %44 = alloca i160, align 8
  %45 = alloca ptr, align 8
  %46 = alloca i1, align 1
  %47 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %47, align 8
  %48 = alloca i32, align 4
  %49 = alloca ptr, align 8
  %50 = alloca ptr, align 8
  %51 = alloca ptr, align 8
  %52 = getelementptr { ptr, ptr, ptr, i32 }, ptr %47, i32 0, i32 0
  %53 = load ptr, ptr %52, align 8
  store ptr %53, ptr %51, align 8
  %54 = getelementptr { ptr, ptr, ptr, i32 }, ptr %47, i32 0, i32 1
  %55 = load ptr, ptr %54, align 8
  store ptr %55, ptr %50, align 8
  %56 = getelementptr { ptr, ptr, ptr, i32 }, ptr %47, i32 0, i32 2
  %57 = load ptr, ptr %56, align 8
  store ptr %57, ptr %49, align 8
  %58 = getelementptr { ptr, ptr, ptr, i32 }, ptr %47, i32 0, i32 3
  %59 = load i32, ptr %58, align 4
  store i32 %59, ptr %48, align 4
  %60 = load ptr, ptr %51, align 8
  %61 = call i32 @get_offset(ptr %60, ptr @List)
  store i32 %61, ptr %48, align 4
  %62 = alloca i32, align 4
  store i32 %3, ptr %62, align 4
  %63 = load ptr, ptr %51, align 8
  %64 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %63, 0
  %65 = load ptr, ptr %50, align 8
  %66 = insertvalue { ptr, ptr, ptr, i32 } %64, ptr %65, 1
  %67 = load ptr, ptr %49, align 8
  %68 = insertvalue { ptr, ptr, ptr, i32 } %66, ptr %67, 2
  %69 = load i32, ptr %48, align 4
  %70 = insertvalue { ptr, ptr, ptr, i32 } %68, i32 %69, 3
  %71 = alloca [0 x ptr], align 8
  %72 = call ptr @llvm.invariant.start.p0(i64 0, ptr %71)
  %73 = call ptr @llvm.invariant.start.p0(i64 1088, ptr %63)
  %74 = getelementptr ptr, ptr %63, i32 %69
  %75 = getelementptr ptr, ptr %74, i32 10
  %76 = load ptr, ptr %75, align 8
  %77 = alloca {}, align 8
  %78 = call ptr @behavior_wrapper(ptr %76, { ptr, ptr, ptr, i32 } %70, ptr %77)
  %79 = call i32 %78({ ptr, ptr, ptr, i32 } %70, { ptr, ptr, ptr, i32 } %70, ptr %71)
  %80 = alloca i32, align 4
  store i32 %79, ptr %80, align 4
  %81 = load i32, ptr %62, align 4
  %82 = load i32, ptr %80, align 4
  %83 = icmp sge i32 %81, %82
  %84 = alloca i1, align 1
  %85 = zext i1 %83 to i8
  store i8 %85, ptr %84, align 1
  %86 = load i8, ptr %84, align 1
  %87 = trunc i8 %86 to i1
  br i1 %87, label %88, label %94

88:                                               ; preds = %4
  %89 = load [0 x i8], ptr %5, align 1
  store [0 x i8] %89, ptr %6, align 1
  store ptr @nil_typ, ptr %7, align 8
  %90 = load ptr, ptr %7, align 8
  %91 = insertvalue { ptr, i160 } undef, ptr %90, 0
  %92 = load i160, ptr %6, align 4
  %93 = insertvalue { ptr, i160 } %91, i160 %92, 1
  br label %264

94:                                               ; preds = %4
  %95 = load ptr, ptr %51, align 8
  %96 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %95, 0
  %97 = load ptr, ptr %50, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } %96, ptr %97, 1
  %99 = load ptr, ptr %49, align 8
  %100 = insertvalue { ptr, ptr, ptr, i32 } %98, ptr %99, 2
  %101 = load i32, ptr %48, align 4
  %102 = insertvalue { ptr, ptr, ptr, i32 } %100, i32 %101, 3
  %103 = call ptr @llvm.invariant.start.p0(i64 0, ptr %8)
  %104 = call ptr @llvm.invariant.start.p0(i64 1088, ptr %95)
  %105 = getelementptr ptr, ptr %95, i32 %101
  %106 = getelementptr ptr, ptr %105, i32 17
  %107 = load ptr, ptr %106, align 8
  %108 = call ptr @behavior_wrapper(ptr %107, { ptr, ptr, ptr, i32 } %102, ptr %9)
  %109 = call { ptr, ptr, ptr, i32 } %108({ ptr, ptr, ptr, i32 } %102, { ptr, ptr, ptr, i32 } %102, ptr %8)
  store { ptr, ptr, ptr, i32 } %109, ptr %10, align 8
  %110 = getelementptr { ptr, ptr, ptr, i32 }, ptr %10, i32 0, i32 0
  %111 = load ptr, ptr %110, align 8
  store ptr %111, ptr %14, align 8
  %112 = getelementptr { ptr, ptr, ptr, i32 }, ptr %10, i32 0, i32 1
  %113 = load ptr, ptr %112, align 8
  store ptr %113, ptr %13, align 8
  %114 = getelementptr { ptr, ptr, ptr, i32 }, ptr %10, i32 0, i32 2
  %115 = load ptr, ptr %114, align 8
  store ptr %115, ptr %12, align 8
  %116 = getelementptr { ptr, ptr, ptr, i32 }, ptr %10, i32 0, i32 3
  %117 = load i32, ptr %116, align 4
  store i32 %117, ptr %11, align 4
  %118 = load ptr, ptr %14, align 8
  %119 = call i32 @get_offset(ptr %118, ptr @Collection)
  store i32 %119, ptr %11, align 4
  %120 = load ptr, ptr %14, align 8
  %121 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %120, 0
  %122 = load ptr, ptr %13, align 8
  %123 = insertvalue { ptr, ptr, ptr, i32 } %121, ptr %122, 1
  %124 = load ptr, ptr %12, align 8
  %125 = insertvalue { ptr, ptr, ptr, i32 } %123, ptr %124, 2
  %126 = load i32, ptr %11, align 4
  %127 = insertvalue { ptr, ptr, ptr, i32 } %125, i32 %126, 3
  %128 = call ptr @llvm.invariant.start.p0(i64 0, ptr %15)
  %129 = call ptr @llvm.invariant.start.p0(i64 472, ptr %120)
  %130 = getelementptr ptr, ptr %120, i32 %126
  %131 = getelementptr ptr, ptr %130, i32 3
  %132 = load ptr, ptr %131, align 8
  %133 = call ptr @behavior_wrapper(ptr %132, { ptr, ptr, ptr, i32 } %127, ptr %16)
  %134 = call { ptr, ptr, ptr, i32 } %133({ ptr, ptr, ptr, i32 } %127, { ptr, ptr, ptr, i32 } %127, ptr %15)
  store { ptr, ptr, ptr, i32 } %134, ptr %17, align 8
  %135 = getelementptr { ptr, ptr, ptr, i32 }, ptr %17, i32 0, i32 0
  %136 = load ptr, ptr %135, align 8
  store ptr %136, ptr %21, align 8
  %137 = getelementptr { ptr, ptr, ptr, i32 }, ptr %17, i32 0, i32 1
  %138 = load ptr, ptr %137, align 8
  store ptr %138, ptr %20, align 8
  %139 = getelementptr { ptr, ptr, ptr, i32 }, ptr %17, i32 0, i32 2
  %140 = load ptr, ptr %139, align 8
  store ptr %140, ptr %19, align 8
  %141 = getelementptr { ptr, ptr, ptr, i32 }, ptr %17, i32 0, i32 3
  %142 = load i32, ptr %141, align 4
  store i32 %142, ptr %18, align 4
  %143 = load ptr, ptr %21, align 8
  %144 = call i32 @get_offset(ptr %143, ptr @Iterator)
  store i32 %144, ptr %18, align 4
  %145 = load ptr, ptr %21, align 8
  store ptr %145, ptr %25, align 8
  %146 = load ptr, ptr %20, align 8
  store ptr %146, ptr %24, align 8
  %147 = load ptr, ptr %19, align 8
  store ptr %147, ptr %23, align 8
  %148 = load i32, ptr %18, align 4
  store i32 %148, ptr %22, align 4
  br label %149

149:                                              ; preds = %251, %94
  %150 = load ptr, ptr %25, align 8
  %151 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %150, 0
  %152 = load ptr, ptr %24, align 8
  %153 = insertvalue { ptr, ptr, ptr, i32 } %151, ptr %152, 1
  %154 = load ptr, ptr %23, align 8
  %155 = insertvalue { ptr, ptr, ptr, i32 } %153, ptr %154, 2
  %156 = load i32, ptr %22, align 4
  %157 = insertvalue { ptr, ptr, ptr, i32 } %155, i32 %156, 3
  %158 = call ptr @llvm.invariant.start.p0(i64 0, ptr %26)
  %159 = call ptr @llvm.invariant.start.p0(i64 24, ptr %150)
  %160 = getelementptr ptr, ptr %150, i32 %156
  %161 = getelementptr ptr, ptr %160, i32 1
  %162 = load ptr, ptr %161, align 8
  %163 = call ptr @behavior_wrapper(ptr %162, { ptr, ptr, ptr, i32 } %157, ptr %27)
  %164 = call { ptr, i160 } %163({ ptr, ptr, ptr, i32 } %157, { ptr, ptr, ptr, i32 } %157, ptr %26)
  store { ptr, i160 } %164, ptr %28, align 8
  store i8 0, ptr %29, align 1
  %165 = load ptr, ptr %28, align 8
  %166 = ptrtoint ptr %165 to i64
  %167 = icmp eq i64 %166, ptrtoint (ptr @nil_typ to i64)
  %168 = icmp eq i64 %166, 0
  %169 = or i1 %167, %168
  %170 = zext i1 %169 to i8
  store i8 %170, ptr %30, align 1
  %171 = load i8, ptr %29, align 1
  %172 = trunc i8 %171 to i1
  %173 = load i8, ptr %30, align 1
  %174 = trunc i8 %173 to i1
  %175 = icmp eq i1 %172, %174
  %176 = zext i1 %175 to i8
  store i8 %176, ptr %31, align 1
  %177 = load i8, ptr %31, align 1
  %178 = trunc i8 %177 to i1
  br i1 %178, label %179, label %245

179:                                              ; preds = %149
  %180 = getelementptr { ptr, i160 }, ptr %28, i32 0, i32 0
  %181 = getelementptr { ptr, i160 }, ptr %32, i32 0, i32 0
  %182 = load ptr, ptr %180, align 8
  store ptr %182, ptr %181, align 8
  %183 = getelementptr { ptr, i160 }, ptr %28, i32 0, i32 1
  %184 = getelementptr { ptr, i160 }, ptr %32, i32 0, i32 1
  %185 = load i160, ptr %183, align 4
  store i160 %185, ptr %184, align 4
  %186 = load ptr, ptr %32, align 8
  %187 = call i32 @get_offset(ptr %186, ptr @Pair)
  %188 = getelementptr { ptr, ptr, ptr, i32 }, ptr %32, i32 0, i32 3
  store i32 %187, ptr %188, align 4
  %189 = getelementptr { ptr, ptr, ptr, i32 }, ptr %32, i32 0, i32 0
  %190 = load ptr, ptr %189, align 8
  store ptr %190, ptr %36, align 8
  %191 = getelementptr { ptr, ptr, ptr, i32 }, ptr %32, i32 0, i32 1
  %192 = load ptr, ptr %191, align 8
  store ptr %192, ptr %35, align 8
  %193 = getelementptr { ptr, ptr, ptr, i32 }, ptr %32, i32 0, i32 2
  %194 = load ptr, ptr %193, align 8
  store ptr %194, ptr %34, align 8
  %195 = load i32, ptr %188, align 4
  store i32 %195, ptr %33, align 4
  %196 = load ptr, ptr %36, align 8
  %197 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %196, 0
  %198 = load ptr, ptr %35, align 8
  %199 = insertvalue { ptr, ptr, ptr, i32 } %197, ptr %198, 1
  %200 = load ptr, ptr %34, align 8
  %201 = insertvalue { ptr, ptr, ptr, i32 } %199, ptr %200, 2
  %202 = load i32, ptr %33, align 4
  %203 = insertvalue { ptr, ptr, ptr, i32 } %201, i32 %202, 3
  %204 = call ptr @llvm.invariant.start.p0(i64 0, ptr %37)
  %205 = call ptr @llvm.invariant.start.p0(i64 112, ptr %196)
  %206 = getelementptr ptr, ptr %196, i32 %202
  %207 = getelementptr ptr, ptr %206, i32 4
  %208 = load ptr, ptr %207, align 8
  %209 = call ptr @behavior_wrapper(ptr %208, { ptr, ptr, ptr, i32 } %203, ptr %38)
  %210 = call { ptr, i160 } %209({ ptr, ptr, ptr, i32 } %203, { ptr, ptr, ptr, i32 } %203, ptr %37)
  store { ptr, i160 } %210, ptr %39, align 8
  %211 = getelementptr { ptr, i160 }, ptr %39, i32 0, i32 1
  %212 = load i32, ptr %211, align 4
  store i32 %212, ptr %40, align 4
  %213 = load ptr, ptr %36, align 8
  %214 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %213, 0
  %215 = load ptr, ptr %35, align 8
  %216 = insertvalue { ptr, ptr, ptr, i32 } %214, ptr %215, 1
  %217 = load ptr, ptr %34, align 8
  %218 = insertvalue { ptr, ptr, ptr, i32 } %216, ptr %217, 2
  %219 = load i32, ptr %33, align 4
  %220 = insertvalue { ptr, ptr, ptr, i32 } %218, i32 %219, 3
  %221 = call ptr @llvm.invariant.start.p0(i64 0, ptr %41)
  %222 = call ptr @llvm.invariant.start.p0(i64 112, ptr %213)
  %223 = getelementptr ptr, ptr %213, i32 %219
  %224 = getelementptr ptr, ptr %223, i32 5
  %225 = load ptr, ptr %224, align 8
  %226 = call ptr @behavior_wrapper(ptr %225, { ptr, ptr, ptr, i32 } %220, ptr %42)
  %227 = call { ptr, i160 } %226({ ptr, ptr, ptr, i32 } %220, { ptr, ptr, ptr, i32 } %220, ptr %41)
  store { ptr, i160 } %227, ptr %43, align 8
  %228 = getelementptr { ptr, i160 }, ptr %43, i32 0, i32 0
  %229 = load ptr, ptr %228, align 8
  store ptr %229, ptr %45, align 8
  %230 = getelementptr { ptr, i160 }, ptr %43, i32 0, i32 1
  %231 = load i160, ptr %230, align 4
  store i160 %231, ptr %44, align 4
  %232 = load i32, ptr %40, align 4
  %233 = load i32, ptr %62, align 4
  %234 = icmp eq i32 %232, %233
  %235 = zext i1 %234 to i8
  store i8 %235, ptr %46, align 1
  %236 = load i8, ptr %46, align 1
  %237 = trunc i8 %236 to i1
  %238 = zext i1 %237 to i32
  %239 = xor i1 %237, true
  %240 = zext i1 %239 to i32
  br i1 %237, label %241, label %242

241:                                              ; preds = %179
  br label %245

242:                                              ; preds = %179
  %243 = load ptr, ptr %181, align 8
  store ptr %243, ptr %180, align 8
  %244 = load i160, ptr %184, align 4
  store i160 %244, ptr %183, align 4
  br label %245

245:                                              ; preds = %241, %242, %149
  %246 = phi i32 [ %238, %242 ], [ %238, %241 ], [ 2, %149 ]
  %247 = phi i32 [ %240, %242 ], [ %240, %241 ], [ 0, %149 ]
  br label %248

248:                                              ; preds = %245
  br label %249

249:                                              ; preds = %248
  %250 = trunc i32 %247 to i1
  br i1 %250, label %251, label %252

251:                                              ; preds = %249
  br label %149

252:                                              ; preds = %249
  %253 = zext i32 %246 to i64
  %254 = trunc i64 %253 to i32
  switch i32 %254, label %260 [
    i32 1, label %255
  ]

255:                                              ; preds = %252
  %256 = load ptr, ptr %45, align 8
  %257 = insertvalue { ptr, i160 } undef, ptr %256, 0
  %258 = load i160, ptr %44, align 4
  %259 = insertvalue { ptr, i160 } %257, i160 %258, 1
  br label %261

260:                                              ; preds = %252
  br label %261

261:                                              ; preds = %260, %255
  %262 = phi { ptr, i160 } [ poison, %260 ], [ %259, %255 ]
  %263 = phi i32 [ 1, %260 ], [ 0, %255 ]
  br label %264

264:                                              ; preds = %88, %261
  %265 = phi { ptr, i160 } [ %262, %261 ], [ %93, %88 ]
  %266 = phi i32 [ %263, %261 ], [ 0, %88 ]
  br label %267

267:                                              ; preds = %264
  %268 = zext i32 %266 to i64
  %269 = trunc i64 %268 to i32
  switch i32 %269, label %270 [
    i32 0, label %273
  ]

270:                                              ; preds = %273, %267
  %271 = phi { ptr, i160 } [ %274, %273 ], [ poison, %267 ]
  br label %272

272:                                              ; preds = %270
  ret { ptr, i160 } %271

273:                                              ; preds = %267
  %274 = phi { ptr, i160 } [ %265, %267 ]
  br label %270
}

define ptr @List_B_get_indexi32({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @i32_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 31, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [136 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define { ptr, i32 } @List_index_of_targetT_eqFunctionT._T_to_Bool({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, i160 } %3, { ptr } %4) {
  %6 = alloca [0 x i8], align 1
  %7 = alloca { ptr, i32 }, align 8
  %8 = alloca [0 x ptr], align 8
  %9 = alloca {}, align 8
  %10 = alloca { ptr, ptr, ptr, i32 }, align 8
  %11 = alloca i32, align 4
  %12 = alloca ptr, align 8
  %13 = alloca ptr, align 8
  %14 = alloca ptr, align 8
  %15 = alloca [0 x ptr], align 8
  %16 = alloca {}, align 8
  %17 = alloca { ptr, ptr, ptr, i32 }, align 8
  %18 = alloca i32, align 4
  %19 = alloca ptr, align 8
  %20 = alloca ptr, align 8
  %21 = alloca ptr, align 8
  %22 = alloca i32, align 4
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = alloca ptr, align 8
  %26 = alloca [0 x ptr], align 8
  %27 = alloca {}, align 8
  %28 = alloca { ptr, i160 }, align 8
  %29 = alloca i1, align 1
  %30 = alloca i1, align 1
  %31 = alloca i1, align 1
  %32 = alloca { ptr, ptr, ptr, i32 }, align 8
  %33 = alloca i32, align 4
  %34 = alloca ptr, align 8
  %35 = alloca ptr, align 8
  %36 = alloca ptr, align 8
  %37 = alloca [0 x ptr], align 8
  %38 = alloca {}, align 8
  %39 = alloca { ptr, i160 }, align 8
  %40 = alloca i32, align 4
  %41 = alloca [0 x ptr], align 8
  %42 = alloca {}, align 8
  %43 = alloca { ptr, i160 }, align 8
  %44 = alloca i160, align 8
  %45 = alloca ptr, align 8
  %46 = alloca i160, align 8
  %47 = alloca ptr, align 8
  %48 = alloca i160, align 8
  %49 = alloca ptr, align 8
  %50 = alloca i1, align 1
  %51 = alloca i32, align 4
  %52 = alloca ptr, align 8
  %53 = alloca [0 x i8], align 1
  %54 = alloca { ptr, i32 }, align 8
  %55 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %55, align 8
  %56 = alloca i32, align 4
  %57 = alloca ptr, align 8
  %58 = alloca ptr, align 8
  %59 = alloca ptr, align 8
  %60 = getelementptr { ptr, ptr, ptr, i32 }, ptr %55, i32 0, i32 0
  %61 = load ptr, ptr %60, align 8
  store ptr %61, ptr %59, align 8
  %62 = getelementptr { ptr, ptr, ptr, i32 }, ptr %55, i32 0, i32 1
  %63 = load ptr, ptr %62, align 8
  store ptr %63, ptr %58, align 8
  %64 = getelementptr { ptr, ptr, ptr, i32 }, ptr %55, i32 0, i32 2
  %65 = load ptr, ptr %64, align 8
  store ptr %65, ptr %57, align 8
  %66 = getelementptr { ptr, ptr, ptr, i32 }, ptr %55, i32 0, i32 3
  %67 = load i32, ptr %66, align 4
  store i32 %67, ptr %56, align 4
  %68 = load ptr, ptr %59, align 8
  %69 = call i32 @get_offset(ptr %68, ptr @List)
  store i32 %69, ptr %56, align 4
  %70 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %3, ptr %70, align 8
  %71 = alloca i160, align 8
  %72 = alloca ptr, align 8
  %73 = getelementptr { ptr, i160 }, ptr %70, i32 0, i32 0
  %74 = load ptr, ptr %73, align 8
  store ptr %74, ptr %72, align 8
  %75 = getelementptr { ptr, i160 }, ptr %70, i32 0, i32 1
  %76 = load i160, ptr %75, align 4
  store i160 %76, ptr %71, align 4
  %77 = alloca ptr, align 8
  store { ptr } %4, ptr %77, align 8
  %78 = load ptr, ptr %59, align 8
  %79 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %78, 0
  %80 = load ptr, ptr %58, align 8
  %81 = insertvalue { ptr, ptr, ptr, i32 } %79, ptr %80, 1
  %82 = load ptr, ptr %57, align 8
  %83 = insertvalue { ptr, ptr, ptr, i32 } %81, ptr %82, 2
  %84 = load i32, ptr %56, align 4
  %85 = insertvalue { ptr, ptr, ptr, i32 } %83, i32 %84, 3
  %86 = alloca [0 x ptr], align 8
  %87 = call ptr @llvm.invariant.start.p0(i64 0, ptr %86)
  %88 = call ptr @llvm.invariant.start.p0(i64 1088, ptr %78)
  %89 = getelementptr ptr, ptr %78, i32 %84
  %90 = getelementptr ptr, ptr %89, i32 11
  %91 = load ptr, ptr %90, align 8
  %92 = alloca {}, align 8
  %93 = call ptr @behavior_wrapper(ptr %91, { ptr, ptr, ptr, i32 } %85, ptr %92)
  %94 = call i1 %93({ ptr, ptr, ptr, i32 } %85, { ptr, ptr, ptr, i32 } %85, ptr %86)
  %95 = alloca i1, align 1
  %96 = zext i1 %94 to i8
  store i8 %96, ptr %95, align 1
  %97 = load i8, ptr %95, align 1
  %98 = trunc i8 %97 to i1
  br i1 %98, label %99, label %100

99:                                               ; preds = %5
  br label %284

100:                                              ; preds = %5
  %101 = load ptr, ptr %59, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %101, 0
  %103 = load ptr, ptr %58, align 8
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, ptr %103, 1
  %105 = load ptr, ptr %57, align 8
  %106 = insertvalue { ptr, ptr, ptr, i32 } %104, ptr %105, 2
  %107 = load i32, ptr %56, align 4
  %108 = insertvalue { ptr, ptr, ptr, i32 } %106, i32 %107, 3
  %109 = call ptr @llvm.invariant.start.p0(i64 0, ptr %8)
  %110 = call ptr @llvm.invariant.start.p0(i64 1088, ptr %101)
  %111 = getelementptr ptr, ptr %101, i32 %107
  %112 = getelementptr ptr, ptr %111, i32 17
  %113 = load ptr, ptr %112, align 8
  %114 = call ptr @behavior_wrapper(ptr %113, { ptr, ptr, ptr, i32 } %108, ptr %9)
  %115 = call { ptr, ptr, ptr, i32 } %114({ ptr, ptr, ptr, i32 } %108, { ptr, ptr, ptr, i32 } %108, ptr %8)
  store { ptr, ptr, ptr, i32 } %115, ptr %10, align 8
  %116 = getelementptr { ptr, ptr, ptr, i32 }, ptr %10, i32 0, i32 0
  %117 = load ptr, ptr %116, align 8
  store ptr %117, ptr %14, align 8
  %118 = getelementptr { ptr, ptr, ptr, i32 }, ptr %10, i32 0, i32 1
  %119 = load ptr, ptr %118, align 8
  store ptr %119, ptr %13, align 8
  %120 = getelementptr { ptr, ptr, ptr, i32 }, ptr %10, i32 0, i32 2
  %121 = load ptr, ptr %120, align 8
  store ptr %121, ptr %12, align 8
  %122 = getelementptr { ptr, ptr, ptr, i32 }, ptr %10, i32 0, i32 3
  %123 = load i32, ptr %122, align 4
  store i32 %123, ptr %11, align 4
  %124 = load ptr, ptr %14, align 8
  %125 = call i32 @get_offset(ptr %124, ptr @Collection)
  store i32 %125, ptr %11, align 4
  %126 = load ptr, ptr %14, align 8
  %127 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %126, 0
  %128 = load ptr, ptr %13, align 8
  %129 = insertvalue { ptr, ptr, ptr, i32 } %127, ptr %128, 1
  %130 = load ptr, ptr %12, align 8
  %131 = insertvalue { ptr, ptr, ptr, i32 } %129, ptr %130, 2
  %132 = load i32, ptr %11, align 4
  %133 = insertvalue { ptr, ptr, ptr, i32 } %131, i32 %132, 3
  %134 = call ptr @llvm.invariant.start.p0(i64 0, ptr %15)
  %135 = call ptr @llvm.invariant.start.p0(i64 472, ptr %126)
  %136 = getelementptr ptr, ptr %126, i32 %132
  %137 = getelementptr ptr, ptr %136, i32 3
  %138 = load ptr, ptr %137, align 8
  %139 = call ptr @behavior_wrapper(ptr %138, { ptr, ptr, ptr, i32 } %133, ptr %16)
  %140 = call { ptr, ptr, ptr, i32 } %139({ ptr, ptr, ptr, i32 } %133, { ptr, ptr, ptr, i32 } %133, ptr %15)
  store { ptr, ptr, ptr, i32 } %140, ptr %17, align 8
  %141 = getelementptr { ptr, ptr, ptr, i32 }, ptr %17, i32 0, i32 0
  %142 = load ptr, ptr %141, align 8
  store ptr %142, ptr %21, align 8
  %143 = getelementptr { ptr, ptr, ptr, i32 }, ptr %17, i32 0, i32 1
  %144 = load ptr, ptr %143, align 8
  store ptr %144, ptr %20, align 8
  %145 = getelementptr { ptr, ptr, ptr, i32 }, ptr %17, i32 0, i32 2
  %146 = load ptr, ptr %145, align 8
  store ptr %146, ptr %19, align 8
  %147 = getelementptr { ptr, ptr, ptr, i32 }, ptr %17, i32 0, i32 3
  %148 = load i32, ptr %147, align 4
  store i32 %148, ptr %18, align 4
  %149 = load ptr, ptr %21, align 8
  %150 = call i32 @get_offset(ptr %149, ptr @Iterator)
  store i32 %150, ptr %18, align 4
  %151 = load ptr, ptr %21, align 8
  store ptr %151, ptr %25, align 8
  %152 = load ptr, ptr %20, align 8
  store ptr %152, ptr %24, align 8
  %153 = load ptr, ptr %19, align 8
  store ptr %153, ptr %23, align 8
  %154 = load i32, ptr %18, align 4
  store i32 %154, ptr %22, align 4
  br label %155

155:                                              ; preds = %268, %100
  %156 = load ptr, ptr %25, align 8
  %157 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %156, 0
  %158 = load ptr, ptr %24, align 8
  %159 = insertvalue { ptr, ptr, ptr, i32 } %157, ptr %158, 1
  %160 = load ptr, ptr %23, align 8
  %161 = insertvalue { ptr, ptr, ptr, i32 } %159, ptr %160, 2
  %162 = load i32, ptr %22, align 4
  %163 = insertvalue { ptr, ptr, ptr, i32 } %161, i32 %162, 3
  %164 = call ptr @llvm.invariant.start.p0(i64 0, ptr %26)
  %165 = call ptr @llvm.invariant.start.p0(i64 24, ptr %156)
  %166 = getelementptr ptr, ptr %156, i32 %162
  %167 = getelementptr ptr, ptr %166, i32 1
  %168 = load ptr, ptr %167, align 8
  %169 = call ptr @behavior_wrapper(ptr %168, { ptr, ptr, ptr, i32 } %163, ptr %27)
  %170 = call { ptr, i160 } %169({ ptr, ptr, ptr, i32 } %163, { ptr, ptr, ptr, i32 } %163, ptr %26)
  store { ptr, i160 } %170, ptr %28, align 8
  store i8 0, ptr %29, align 1
  %171 = load ptr, ptr %28, align 8
  %172 = ptrtoint ptr %171 to i64
  %173 = icmp eq i64 %172, ptrtoint (ptr @nil_typ to i64)
  %174 = icmp eq i64 %172, 0
  %175 = or i1 %173, %174
  %176 = zext i1 %175 to i8
  store i8 %176, ptr %30, align 1
  %177 = load i8, ptr %29, align 1
  %178 = trunc i8 %177 to i1
  %179 = load i8, ptr %30, align 1
  %180 = trunc i8 %179 to i1
  %181 = icmp eq i1 %178, %180
  %182 = zext i1 %181 to i8
  store i8 %182, ptr %31, align 1
  %183 = load i8, ptr %31, align 1
  %184 = trunc i8 %183 to i1
  br i1 %184, label %185, label %262

185:                                              ; preds = %155
  %186 = getelementptr { ptr, i160 }, ptr %28, i32 0, i32 0
  %187 = getelementptr { ptr, i160 }, ptr %32, i32 0, i32 0
  %188 = load ptr, ptr %186, align 8
  store ptr %188, ptr %187, align 8
  %189 = getelementptr { ptr, i160 }, ptr %28, i32 0, i32 1
  %190 = getelementptr { ptr, i160 }, ptr %32, i32 0, i32 1
  %191 = load i160, ptr %189, align 4
  store i160 %191, ptr %190, align 4
  %192 = load ptr, ptr %32, align 8
  %193 = call i32 @get_offset(ptr %192, ptr @Pair)
  %194 = getelementptr { ptr, ptr, ptr, i32 }, ptr %32, i32 0, i32 3
  store i32 %193, ptr %194, align 4
  %195 = getelementptr { ptr, ptr, ptr, i32 }, ptr %32, i32 0, i32 0
  %196 = load ptr, ptr %195, align 8
  store ptr %196, ptr %36, align 8
  %197 = getelementptr { ptr, ptr, ptr, i32 }, ptr %32, i32 0, i32 1
  %198 = load ptr, ptr %197, align 8
  store ptr %198, ptr %35, align 8
  %199 = getelementptr { ptr, ptr, ptr, i32 }, ptr %32, i32 0, i32 2
  %200 = load ptr, ptr %199, align 8
  store ptr %200, ptr %34, align 8
  %201 = load i32, ptr %194, align 4
  store i32 %201, ptr %33, align 4
  %202 = load ptr, ptr %36, align 8
  %203 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %202, 0
  %204 = load ptr, ptr %35, align 8
  %205 = insertvalue { ptr, ptr, ptr, i32 } %203, ptr %204, 1
  %206 = load ptr, ptr %34, align 8
  %207 = insertvalue { ptr, ptr, ptr, i32 } %205, ptr %206, 2
  %208 = load i32, ptr %33, align 4
  %209 = insertvalue { ptr, ptr, ptr, i32 } %207, i32 %208, 3
  %210 = call ptr @llvm.invariant.start.p0(i64 0, ptr %37)
  %211 = call ptr @llvm.invariant.start.p0(i64 112, ptr %202)
  %212 = getelementptr ptr, ptr %202, i32 %208
  %213 = getelementptr ptr, ptr %212, i32 4
  %214 = load ptr, ptr %213, align 8
  %215 = call ptr @behavior_wrapper(ptr %214, { ptr, ptr, ptr, i32 } %209, ptr %38)
  %216 = call { ptr, i160 } %215({ ptr, ptr, ptr, i32 } %209, { ptr, ptr, ptr, i32 } %209, ptr %37)
  store { ptr, i160 } %216, ptr %39, align 8
  %217 = getelementptr { ptr, i160 }, ptr %39, i32 0, i32 1
  %218 = load i32, ptr %217, align 4
  store i32 %218, ptr %40, align 4
  %219 = load ptr, ptr %36, align 8
  %220 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %219, 0
  %221 = load ptr, ptr %35, align 8
  %222 = insertvalue { ptr, ptr, ptr, i32 } %220, ptr %221, 1
  %223 = load ptr, ptr %34, align 8
  %224 = insertvalue { ptr, ptr, ptr, i32 } %222, ptr %223, 2
  %225 = load i32, ptr %33, align 4
  %226 = insertvalue { ptr, ptr, ptr, i32 } %224, i32 %225, 3
  %227 = call ptr @llvm.invariant.start.p0(i64 0, ptr %41)
  %228 = call ptr @llvm.invariant.start.p0(i64 112, ptr %219)
  %229 = getelementptr ptr, ptr %219, i32 %225
  %230 = getelementptr ptr, ptr %229, i32 5
  %231 = load ptr, ptr %230, align 8
  %232 = call ptr @behavior_wrapper(ptr %231, { ptr, ptr, ptr, i32 } %226, ptr %42)
  %233 = call { ptr, i160 } %232({ ptr, ptr, ptr, i32 } %226, { ptr, ptr, ptr, i32 } %226, ptr %41)
  store { ptr, i160 } %233, ptr %43, align 8
  %234 = getelementptr { ptr, i160 }, ptr %43, i32 0, i32 0
  %235 = load ptr, ptr %234, align 8
  store ptr %235, ptr %45, align 8
  %236 = getelementptr { ptr, i160 }, ptr %43, i32 0, i32 1
  %237 = load i160, ptr %236, align 4
  store i160 %237, ptr %44, align 4
  %238 = load ptr, ptr %45, align 8
  store ptr %238, ptr %47, align 8
  %239 = load i160, ptr %44, align 4
  store i160 %239, ptr %46, align 4
  %240 = load ptr, ptr %47, align 8
  %241 = insertvalue { ptr, i160 } undef, ptr %240, 0
  %242 = load i160, ptr %46, align 4
  %243 = insertvalue { ptr, i160 } %241, i160 %242, 1
  %244 = load ptr, ptr %72, align 8
  store ptr %244, ptr %49, align 8
  %245 = load i160, ptr %71, align 4
  store i160 %245, ptr %48, align 4
  %246 = load ptr, ptr %49, align 8
  %247 = insertvalue { ptr, i160 } undef, ptr %246, 0
  %248 = load i160, ptr %48, align 4
  %249 = insertvalue { ptr, i160 } %247, i160 %248, 1
  %250 = load ptr, ptr %77, align 8
  %251 = call i1 %250({ ptr, i160 } %243, { ptr, i160 } %249)
  %252 = zext i1 %251 to i8
  store i8 %252, ptr %50, align 1
  %253 = load i8, ptr %50, align 1
  %254 = trunc i8 %253 to i1
  %255 = zext i1 %254 to i32
  %256 = xor i1 %254, true
  %257 = zext i1 %256 to i32
  br i1 %254, label %258, label %259

258:                                              ; preds = %185
  br label %262

259:                                              ; preds = %185
  %260 = load ptr, ptr %187, align 8
  store ptr %260, ptr %186, align 8
  %261 = load i160, ptr %190, align 4
  store i160 %261, ptr %189, align 4
  br label %262

262:                                              ; preds = %258, %259, %155
  %263 = phi i32 [ %255, %259 ], [ %255, %258 ], [ 2, %155 ]
  %264 = phi i32 [ %257, %259 ], [ %257, %258 ], [ 0, %155 ]
  br label %265

265:                                              ; preds = %262
  br label %266

266:                                              ; preds = %265
  %267 = trunc i32 %264 to i1
  br i1 %267, label %268, label %269

268:                                              ; preds = %266
  br label %155

269:                                              ; preds = %266
  %270 = zext i32 %263 to i64
  %271 = trunc i64 %270 to i32
  switch i32 %271, label %278 [
    i32 1, label %272
  ]

272:                                              ; preds = %269
  %273 = load i32, ptr %40, align 4
  store i32 %273, ptr %51, align 4
  store ptr @i32_typ, ptr %52, align 8
  %274 = load ptr, ptr %52, align 8
  %275 = insertvalue { ptr, i32 } undef, ptr %274, 0
  %276 = load i32, ptr %51, align 4
  %277 = insertvalue { ptr, i32 } %275, i32 %276, 1
  br label %279

278:                                              ; preds = %269
  br label %279

279:                                              ; preds = %278, %272
  %280 = phi ptr [ %54, %278 ], [ poison, %272 ]
  %281 = phi ptr [ %53, %278 ], [ poison, %272 ]
  %282 = phi { ptr, i32 } [ poison, %278 ], [ %277, %272 ]
  %283 = phi i32 [ 0, %278 ], [ 1, %272 ]
  br label %284

284:                                              ; preds = %99, %279
  %285 = phi ptr [ %280, %279 ], [ %7, %99 ]
  %286 = phi ptr [ %281, %279 ], [ %6, %99 ]
  %287 = phi { ptr, i32 } [ %282, %279 ], [ poison, %99 ]
  %288 = phi i32 [ %283, %279 ], [ 0, %99 ]
  br label %289

289:                                              ; preds = %284
  %290 = zext i32 %288 to i64
  %291 = trunc i64 %290 to i32
  switch i32 %291, label %300 [
    i32 0, label %292
  ]

292:                                              ; preds = %289
  %293 = getelementptr { ptr, i32 }, ptr %285, i32 0, i32 1
  %294 = load [0 x i8], ptr %286, align 1
  store [0 x i8] %294, ptr %293, align 1
  store ptr @nil_typ, ptr %285, align 8
  %295 = getelementptr { ptr, i32 }, ptr %285, i32 0, i32 0
  %296 = load ptr, ptr %295, align 8
  %297 = insertvalue { ptr, i32 } undef, ptr %296, 0
  %298 = load i32, ptr %293, align 4
  %299 = insertvalue { ptr, i32 } %297, i32 %298, 1
  br label %301

300:                                              ; preds = %289
  br label %301

301:                                              ; preds = %300, %292
  %302 = phi { ptr, i32 } [ %287, %300 ], [ %299, %292 ]
  ret { ptr, i32 } %302
}

define ptr @List_B_index_of_targetT_eqFunctionT._T_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @any_typ, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @any_typ to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = ptrtoint ptr %20 to i64
  %22 = icmp eq i64 %21, ptrtoint (ptr @function_typ to i64)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 32, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [136 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

declare i32 @Collection_size_()

define ptr @List_B_size_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 33, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [136 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

declare i1 @Collection_is_empty_()

define ptr @List_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 34, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [136 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @List_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 35, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [136 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

declare void @Iterable_each_fFunctionT_to_Nothing({ ptr })

define ptr @List_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 36, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [136 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

declare { ptr, i160 } @Iterable_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, i160 }, { ptr })

define ptr @List_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @any_typ, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @any_typ to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = ptrtoint ptr %20 to i64
  %22 = icmp eq i64 %21, ptrtoint (ptr @function_typ to i64)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 37, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [136 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

declare i1 @Iterable_all_fFunctionT_to_Bool({ ptr })

define ptr @List_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 38, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [136 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

declare i1 @Iterable_any_fFunctionT_to_Bool({ ptr })

define ptr @List_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 39, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [136 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

declare { ptr, ptr, ptr, i32 } @Collection_enumerate_()

define ptr @List_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 40, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [136 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

declare { ptr, ptr, ptr, i32 } @Iterable_map_fFunctionT_to_U({ ptr })

declare { ptr, ptr, ptr, i32 } @Collection_map_fFunctionT_to_U({ ptr })

define ptr @List_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = ptrtoint ptr %7 to i64
  %9 = icmp eq i64 %8, ptrtoint (ptr @function_typ to i64)
  %10 = zext i1 %9 to i8
  store i8 %10, ptr %3, align 1
  %11 = load i8, ptr %3, align 1
  %12 = trunc i8 %11 to i1
  %13 = select i1 %12, i32 42, i32 41
  br i1 %12, label %14, label %15

14:                                               ; preds = %2
  br label %20

15:                                               ; preds = %2
  %16 = load ptr, ptr %1, align 8
  %17 = ptrtoint ptr %16 to i64
  %18 = icmp eq i64 %17, ptrtoint (ptr @function_typ to i64)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %4, align 1
  br label %20

20:                                               ; preds = %14, %15
  store i32 %13, ptr %6, align 4
  %21 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %22 = load i32, ptr %6, align 4
  %23 = getelementptr [136 x ptr], ptr %21, i32 0, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 10
  %25 = load ptr, ptr %24, align 8
  ret ptr %25
}

declare { ptr, ptr, ptr, i32 } @Iterable_filter_fFunctionT_to_Bool({ ptr })

define ptr @List_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 43, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [136 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

declare { ptr, ptr, ptr, i32 } @Collection_chain_otherCollectionT({ ptr, ptr, ptr, i32 })

declare { ptr, ptr, ptr, i32 } @Iterable_chain_otherIterableT({ ptr, ptr, ptr, i32 })

define ptr @List_B_chain_otherCollectionT_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 44, i32 45
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [136 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

declare { ptr, ptr, ptr, i32 } @Collection_interleave_otherCollectionT({ ptr, ptr, ptr, i32 })

declare { ptr, ptr, ptr, i32 } @Iterable_interleave_otherIterableT({ ptr, ptr, ptr, i32 })

define ptr @List_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 46, i32 47
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [136 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

declare { ptr, ptr, ptr, i32 } @Iterable_zip_otherIterableU({ ptr, ptr, ptr, i32 })

declare { ptr, ptr, ptr, i32 } @Collection_zip_otherCollectionU({ ptr, ptr, ptr, i32 })

define ptr @List_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 49, i32 48
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [136 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

declare { ptr, ptr, ptr, i32 } @Iterable_product_otherIterableU({ ptr, ptr, ptr, i32 })

declare { ptr, ptr, ptr, i32 } @Collection_product_otherCollectionU({ ptr, ptr, ptr, i32 })

define ptr @List_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 51, i32 50
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [136 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare ptr @llvm.invariant.start.p0(i64 immarg, ptr nocapture) #0

attributes #0 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0}

!0 = !{i32 2, !"Debug Info Version", i32 3}
// -----
; ModuleID = 'LLVMDialectModule'
source_filename = "LLVMDialectModule"

%bool_typ = type opaque
%i1_typ = type opaque
%i8_typ = type opaque
%i32_typ = type opaque
%i64_typ = type opaque
%i128_typ = type opaque
%f64_typ = type opaque
%nil_typ = type opaque
%any_typ = type opaque
%nothing_typ = type opaque
%coroutine_typ = type opaque
%function_typ = type opaque
%buffer_typ = type opaque
%tuple_typ = type opaque
%union_typ = type opaque
%Object = type opaque
%Pair = type opaque
%Iterator = type opaque
%Iterable = type opaque
%ConstantTimeIterator = type opaque
%CoroIterator = type opaque
%Enumerated = type opaque
%Enumerator = type opaque
%Mapped = type opaque
%Mapper = type opaque
%Filtered = type opaque
%Filterer = type opaque
%Chained = type opaque
%Chainer = type opaque
%Interleaved = type opaque
%Interleaver = type opaque
%Zipped = type opaque
%Zipper = type opaque
%Products = type opaque
%Productizer = type opaque
%Collection = type opaque
%EnumeratedCollection = type opaque
%MappedCollection = type opaque
%ChainedCollection = type opaque
%InterleavedCollection = type opaque
%ZippedCollection = type opaque
%ProductCollection = type opaque

@i32_string = linkonce_odr constant [4 x i8] c"%d\0A\00"
@i64_string = linkonce_odr constant [6 x i8] c"%lld\0A\00"
@float_string = linkonce_odr constant [4 x i8] c"%f\0A\00"
@string_string = linkonce_odr constant [4 x i8] c"%s\0A\00"
@bool_typ = external constant %bool_typ
@i1_typ = external constant %i1_typ
@i8_typ = external constant %i8_typ
@i32_typ = external constant %i32_typ
@i64_typ = external constant %i64_typ
@i128_typ = external constant %i128_typ
@f64_typ = external constant %f64_typ
@nil_typ = external constant %nil_typ
@any_typ = external constant %any_typ
@nothing_typ = external constant %nothing_typ
@coroutine_typ = external constant %coroutine_typ
@function_typ = external constant %function_typ
@buffer_typ = external constant %buffer_typ
@tuple_typ = external constant %tuple_typ
@union_typ = external constant %union_typ
@Object = external constant %Object
@Pair = external constant %Pair
@Iterator = external constant %Iterator
@Iterable = external constant %Iterable
@ConstantTimeIterator = external constant %ConstantTimeIterator
@CoroIterator = external constant %CoroIterator
@Enumerated = external constant %Enumerated
@Enumerator = external constant %Enumerator
@Mapped = external constant %Mapped
@Mapper = external constant %Mapper
@Filtered = external constant %Filtered
@Filterer = external constant %Filterer
@Chained = external constant %Chained
@Chainer = external constant %Chainer
@Interleaved = external constant %Interleaved
@Interleaver = external constant %Interleaver
@Zipped = external constant %Zipped
@Zipper = external constant %Zipper
@Products = external constant %Products
@Productizer = external constant %Productizer
@Collection = external constant %Collection
@EnumeratedCollection = external constant %EnumeratedCollection
@MappedCollection = external constant %MappedCollection
@ChainedCollection = external constant %ChainedCollection
@InterleavedCollection = external constant %InterleavedCollection
@ZippedCollection = external constant %ZippedCollection
@ProductCollection = external constant %ProductCollection
@Indexable_hashtbl = constant [4 x ptr] [ptr null, ptr @Object, ptr @any_typ, ptr @Indexable]
@Indexable_offset_tbl = constant [4 x i32] [i32 0, i32 16, i32 10, i32 10]
@Indexable = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 8246772220324864030, i64 -6324207110216537389, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Indexable_hashtbl, ptr @Indexable_offset_tbl, ptr @_data_size_Indexable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }
@IndexableCollection_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @Iterable, ptr null, ptr @Object, ptr @IndexableCollection, ptr @Indexable, ptr @Collection, ptr null]
@IndexableCollection_offset_tbl = constant [8 x i32] [i32 10, i32 119, i32 0, i32 60, i32 10, i32 54, i32 60, i32 0]
@IndexableCollection = constant { [3 x i64], [7 x ptr], [0 x ptr] } { [3 x i64] [i64 -307435881317861917, i64 6648726434607810417, i64 7], [7 x ptr] [ptr @subtype_test, ptr @IndexableCollection_hashtbl, ptr @IndexableCollection_offset_tbl, ptr @_data_size_IndexableCollection, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [0 x ptr] undef }

declare i32 @printf(ptr, ...)

declare ptr @bump_malloc(i64)

declare void @free(ptr)

declare void @setup_landing_pad()

declare void @anoint_trampoline(ptr)

declare ptr @adjust_trampoline(ptr)

declare ptr @coroutine_create(ptr, ptr)

declare void @arg_passer(ptr)

declare void @arg_buffer_filler(ptr)

declare void @coroutine_yield(ptr)

declare void @coroutine_yield_cold(ptr)

declare ptr @get_current_coroutine()

declare i32 @get_offset(ptr, ptr)

declare void @assume_offset(ptr, ptr)

declare { ptr, i160 } @_box_Default(ptr, ptr)

declare void @_unbox_Default({ ptr, i160 }, ptr, ptr)

declare { i64, i64 } @_size_Default(ptr)

declare void @_unbox_union_typ({ ptr, i160 }, ptr, ptr)

declare { i64, i64 } @_data_size_tuple_typ(ptr)

declare { i64, i64 } @_data_size_union_typ(ptr)

declare i1 @subtype_test(i64, i64, i64, i64, ptr)

declare i1 @subtype_test_wrapper(ptr, i64, i64, i64, i64, ptr)

declare { i64, i64 } @size_wrapper(ptr, ptr)

declare ptr @typegetter_wrapper(ptr, ptr)

declare { ptr, i160 } @box_wrapper(ptr, ptr, ptr)

declare void @unbox_wrapper(ptr, { ptr, i160 }, ptr, ptr)

declare ptr @behavior_wrapper(ptr, { ptr, ptr, ptr, i32 }, ptr)

declare ptr @class_behavior_wrapper(ptr, ptr)

declare void @coroutine_call(ptr)

define { i64, i64 } @_data_size_Indexable(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %10
  %12 = urem i64 %11, %5
  %13 = icmp eq i64 %12, 0
  %14 = sub i64 %5, %12
  %15 = select i1 %13, i64 0, i64 %14
  %16 = add i64 %11, %15
  %17 = insertvalue { i64, i64 } undef, i64 %16, 0
  %18 = insertvalue { i64, i64 } %17, i64 %5, 1
  ret { i64, i64 } %18
}

define ptr @Indexable_field_Indexable_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define ptr @Indexable_field_Indexable_1(ptr %0) {
  %2 = getelementptr ptr, ptr %0, i32 1
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

define ptr @Indexable_B__index_indexI({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @any_typ, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @any_typ to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 4, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [6 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define ptr @Indexable_B__set_index_indexI_valueV({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @any_typ, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @any_typ to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 1
  %22 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 2
  %23 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 0
  %24 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 1
  %25 = load i64, ptr %21, align 4
  %26 = load i64, ptr %22, align 4
  %27 = load ptr, ptr %23, align 8
  %28 = load ptr, ptr %24, align 8
  %29 = load i64, ptr @any_typ, align 4
  %30 = call i1 @subtype_test_wrapper(ptr %27, i64 %26, i64 %25, i64 %29, i64 ptrtoint (ptr @any_typ to i64), ptr %28)
  %31 = zext i1 %30 to i8
  store i8 %31, ptr %3, align 1
  store i32 5, ptr %6, align 4
  %32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %33 = load i32, ptr %6, align 4
  %34 = getelementptr [6 x ptr], ptr %32, i32 0, i32 %33
  %35 = getelementptr ptr, ptr %34, i32 10
  %36 = load ptr, ptr %35, align 8
  ret ptr %36
}

define { i64, i64 } @_data_size_IndexableCollection(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %10
  %12 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %5
  %13 = select i1 %12, i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), i64 %5
  %14 = urem i64 %11, ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, ptr }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr (ptr, ptr null, i32 1) to i64), %17
  %19 = add i64 %11, %18
  %20 = urem i64 %19, %13
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 %13, %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = add i64 %19, %23
  %25 = insertvalue { i64, i64 } undef, i64 %24, 0
  %26 = insertvalue { i64, i64 } %25, i64 %13, 1
  ret { i64, i64 } %26
}

define ptr @IndexableCollection_field_IndexableCollection_0(ptr %0) {
  %2 = load ptr, ptr %0, align 8
  ret ptr %2
}

define ptr @IndexableCollection_field_IndexableCollection_1(ptr %0) {
  %2 = getelementptr ptr, ptr %0, i32 1
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

define ptr @IndexableCollection_field_IndexableCollection_2(ptr %0) {
  %2 = getelementptr ptr, ptr %0, i32 2
  %3 = load ptr, ptr %2, align 8
  ret ptr %3
}

define ptr @IndexableCollection_B_indices_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 21, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [134 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @IndexableCollection_B_values_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 22, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [134 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @IndexableCollection_B__index_indexI({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @any_typ, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @any_typ to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 23, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [134 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define ptr @IndexableCollection_B__set_index_indexI_valueV({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @any_typ, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @any_typ to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 1
  %22 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 0, i32 2
  %23 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 0
  %24 = getelementptr { [3 x i64], [3 x ptr] }, ptr %20, i32 0, i32 1, i32 1
  %25 = load i64, ptr %21, align 4
  %26 = load i64, ptr %22, align 4
  %27 = load ptr, ptr %23, align 8
  %28 = load ptr, ptr %24, align 8
  %29 = load i64, ptr @any_typ, align 4
  %30 = call i1 @subtype_test_wrapper(ptr %27, i64 %26, i64 %25, i64 %29, i64 ptrtoint (ptr @any_typ to i64), ptr %28)
  %31 = zext i1 %30 to i8
  store i8 %31, ptr %3, align 1
  store i32 24, ptr %6, align 4
  %32 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %33 = load i32, ptr %6, align 4
  %34 = getelementptr [134 x ptr], ptr %32, i32 0, i32 %33
  %35 = getelementptr ptr, ptr %34, i32 10
  %36 = load ptr, ptr %35, align 8
  ret ptr %36
}

declare i32 @Collection_size_()

define ptr @IndexableCollection_B_size_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 25, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [134 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

declare i1 @Collection_is_empty_()

define ptr @IndexableCollection_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 26, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [134 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

declare { ptr, ptr, ptr, i32 } @Iterable_iterator_()

define ptr @IndexableCollection_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 27, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [134 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

declare void @Iterable_each_fFunctionT_to_Nothing({ ptr })

define ptr @IndexableCollection_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 28, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [134 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

declare { ptr, i160 } @Iterable_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, i160 }, { ptr })

define ptr @IndexableCollection_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @any_typ, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @any_typ to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = ptrtoint ptr %20 to i64
  %22 = icmp eq i64 %21, ptrtoint (ptr @function_typ to i64)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 29, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [134 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

declare i1 @Iterable_all_fFunctionT_to_Bool({ ptr })

define ptr @IndexableCollection_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 30, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [134 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

declare i1 @Iterable_any_fFunctionT_to_Bool({ ptr })

define ptr @IndexableCollection_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 31, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [134 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

declare { ptr, ptr, ptr, i32 } @Collection_enumerate_()

define ptr @IndexableCollection_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 32, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [134 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

declare { ptr, ptr, ptr, i32 } @Iterable_map_fFunctionT_to_U({ ptr })

declare { ptr, ptr, ptr, i32 } @Collection_map_fFunctionT_to_U({ ptr })

define ptr @IndexableCollection_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = ptrtoint ptr %7 to i64
  %9 = icmp eq i64 %8, ptrtoint (ptr @function_typ to i64)
  %10 = zext i1 %9 to i8
  store i8 %10, ptr %3, align 1
  %11 = load i8, ptr %3, align 1
  %12 = trunc i8 %11 to i1
  %13 = select i1 %12, i32 33, i32 34
  br i1 %12, label %14, label %15

14:                                               ; preds = %2
  br label %20

15:                                               ; preds = %2
  %16 = load ptr, ptr %1, align 8
  %17 = ptrtoint ptr %16 to i64
  %18 = icmp eq i64 %17, ptrtoint (ptr @function_typ to i64)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %4, align 1
  br label %20

20:                                               ; preds = %14, %15
  store i32 %13, ptr %6, align 4
  %21 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %22 = load i32, ptr %6, align 4
  %23 = getelementptr [134 x ptr], ptr %21, i32 0, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 10
  %25 = load ptr, ptr %24, align 8
  ret ptr %25
}

declare { ptr, ptr, ptr, i32 } @Iterable_filter_fFunctionT_to_Bool({ ptr })

define ptr @IndexableCollection_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 35, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [134 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

declare { ptr, ptr, ptr, i32 } @Collection_chain_otherCollectionT({ ptr, ptr, ptr, i32 })

declare { ptr, ptr, ptr, i32 } @Iterable_chain_otherIterableT({ ptr, ptr, ptr, i32 })

define ptr @IndexableCollection_B_chain_otherCollectionT_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 36, i32 37
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [134 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

declare { ptr, ptr, ptr, i32 } @Collection_interleave_otherCollectionT({ ptr, ptr, ptr, i32 })

declare { ptr, ptr, ptr, i32 } @Iterable_interleave_otherIterableT({ ptr, ptr, ptr, i32 })

define ptr @IndexableCollection_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 38, i32 39
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [134 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

declare { ptr, ptr, ptr, i32 } @Iterable_zip_otherIterableU({ ptr, ptr, ptr, i32 })

declare { ptr, ptr, ptr, i32 } @Collection_zip_otherCollectionU({ ptr, ptr, ptr, i32 })

define ptr @IndexableCollection_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 41, i32 40
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [134 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

declare { ptr, ptr, ptr, i32 } @Iterable_product_otherIterableU({ ptr, ptr, ptr, i32 })

declare { ptr, ptr, ptr, i32 } @Collection_product_otherCollectionU({ ptr, ptr, ptr, i32 })

define ptr @IndexableCollection_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 43, i32 42
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [134 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare ptr @llvm.invariant.start.p0(i64 immarg, ptr nocapture) #0

attributes #0 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0}

!0 = !{i32 2, !"Debug Info Version", i32 3}
// -----
; ModuleID = 'LLVMDialectModule'
source_filename = "LLVMDialectModule"

%bool_typ = type opaque
%i1_typ = type opaque
%i8_typ = type opaque
%i32_typ = type opaque
%i64_typ = type opaque
%i128_typ = type opaque
%f64_typ = type opaque
%nil_typ = type opaque
%any_typ = type opaque
%nothing_typ = type opaque
%coroutine_typ = type opaque
%function_typ = type opaque
%buffer_typ = type opaque
%tuple_typ = type opaque
%union_typ = type opaque
%Object = type opaque
%Pair = type opaque
%Iterator = type opaque
%Iterable = type opaque
%ConstantTimeIterator = type opaque
%CoroIterator = type opaque
%Enumerated = type opaque
%Enumerator = type opaque
%Mapped = type opaque
%Mapper = type opaque
%Filtered = type opaque
%Filterer = type opaque
%Chained = type opaque
%Chainer = type opaque
%Interleaved = type opaque
%Interleaver = type opaque
%Zipped = type opaque
%Zipper = type opaque
%Products = type opaque
%Productizer = type opaque
%Collection = type opaque
%EnumeratedCollection = type opaque
%MappedCollection = type opaque
%ChainedCollection = type opaque
%InterleavedCollection = type opaque
%ZippedCollection = type opaque
%ProductCollection = type opaque

@_parameterization_i32 = linkonce_odr constant [2 x ptr] [ptr @i32_typ, ptr null]
@i32_string = linkonce_odr constant [4 x i8] c"%d\0A\00"
@i64_string = linkonce_odr constant [6 x i8] c"%lld\0A\00"
@float_string = linkonce_odr constant [4 x i8] c"%f\0A\00"
@string_string = linkonce_odr constant [4 x i8] c"%s\0A\00"
@bool_typ = external constant %bool_typ
@i1_typ = external constant %i1_typ
@i8_typ = external constant %i8_typ
@i32_typ = external constant %i32_typ
@i64_typ = external constant %i64_typ
@i128_typ = external constant %i128_typ
@f64_typ = external constant %f64_typ
@nil_typ = external constant %nil_typ
@any_typ = external constant %any_typ
@nothing_typ = external constant %nothing_typ
@coroutine_typ = external constant %coroutine_typ
@function_typ = external constant %function_typ
@buffer_typ = external constant %buffer_typ
@tuple_typ = external constant %tuple_typ
@union_typ = external constant %union_typ
@Object = external constant %Object
@Pair = external constant %Pair
@Iterator = external constant %Iterator
@Iterable = external constant %Iterable
@ConstantTimeIterator = external constant %ConstantTimeIterator
@CoroIterator = external constant %CoroIterator
@Enumerated = external constant %Enumerated
@Enumerator = external constant %Enumerator
@Mapped = external constant %Mapped
@Mapper = external constant %Mapper
@Filtered = external constant %Filtered
@Filterer = external constant %Filterer
@Chained = external constant %Chained
@Chainer = external constant %Chainer
@Interleaved = external constant %Interleaved
@Interleaver = external constant %Interleaver
@Zipped = external constant %Zipped
@Zipper = external constant %Zipper
@Products = external constant %Products
@Productizer = external constant %Productizer
@Collection = external constant %Collection
@EnumeratedCollection = external constant %EnumeratedCollection
@MappedCollection = external constant %MappedCollection
@ChainedCollection = external constant %ChainedCollection
@InterleavedCollection = external constant %InterleavedCollection
@ZippedCollection = external constant %ZippedCollection
@ProductCollection = external constant %ProductCollection
@Range_hashtbl = constant [8 x ptr] [ptr @Collection, ptr @Iterable, ptr null, ptr @any_typ, ptr @Range, ptr null, ptr null, ptr @Object]
@Range_offset_tbl = constant [8 x i32] [i32 53, i32 112, i32 0, i32 10, i32 10, i32 0, i32 0, i32 137]
@Range = constant { [3 x i64], [7 x ptr], [127 x ptr] } { [3 x i64] [i64 5490049236840671069, i64 6098109678505137025, i64 7], [7 x ptr] [ptr @subtype_test, ptr @Range_hashtbl, ptr @Range_offset_tbl, ptr @_data_size_Range, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [127 x ptr] [ptr @Range_field_start, ptr @Range_field_end, ptr @Range_field_step, ptr @Range_field_Range_0, ptr @Range_B_init_endi32, ptr @Range_B_init_starti32_endi32, ptr @Range_B_step_stepi32, ptr @Range_B_size_, ptr @Range_B_is_empty_, ptr @Range_B_iterator_, ptr @Range_B_each_fFunctionT_to_Nothing, ptr @Range_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Range_B_all_fFunctionT_to_Bool, ptr @Range_B_any_fFunctionT_to_Bool, ptr @Range_B_enumerate_, ptr @Range_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Range_B_filter_fFunctionT_to_Bool, ptr @Range_B_chain_otherCollectionT_chain_otherIterableT, ptr @Range_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Range_B_zip_otherIterableU_zip_otherCollectionU, ptr @Range_B_product_otherIterableU_product_otherCollectionU, ptr @Range_init_endi32, ptr @Range_init_starti32_endi32, ptr @Range_step_stepi32, ptr @Range_size_, ptr @Collection_is_empty_, ptr @Range_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Collection_chain_otherCollectionT, ptr @Iterable_chain_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Range_field_Range_0, ptr @Range_B_size_, ptr @Range_B_is_empty_, ptr @Range_B_iterator_, ptr @Range_B_each_fFunctionT_to_Nothing, ptr @Range_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Range_B_all_fFunctionT_to_Bool, ptr @Range_B_any_fFunctionT_to_Bool, ptr @Range_B_enumerate_, ptr @Range_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Range_B_filter_fFunctionT_to_Bool, ptr @Range_B_chain_otherCollectionT_chain_otherIterableT, ptr @Range_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Range_B_zip_otherIterableU_zip_otherCollectionU, ptr @Range_B_product_otherIterableU_product_otherCollectionU, ptr @Range_size_, ptr @Collection_is_empty_, ptr @Range_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Collection_chain_otherCollectionT, ptr @Iterable_chain_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @Range_field_Range_0, ptr @Range_B_iterator_, ptr @Range_B_each_fFunctionT_to_Nothing, ptr @Range_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Range_B_all_fFunctionT_to_Bool, ptr @Range_B_any_fFunctionT_to_Bool, ptr @Range_B_enumerate_, ptr @Range_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Range_B_filter_fFunctionT_to_Bool, ptr @Range_B_chain_otherCollectionT_chain_otherIterableT, ptr @Range_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Range_B_zip_otherIterableU_zip_otherCollectionU, ptr @Range_B_product_otherIterableU_product_otherCollectionU, ptr @Range_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @Range_field_Range_0, ptr @Range_B_iterator_, ptr @Range_B_each_fFunctionT_to_Nothing, ptr @Range_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Range_B_all_fFunctionT_to_Bool, ptr @Range_B_any_fFunctionT_to_Bool, ptr @Range_B_enumerate_, ptr @Range_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @Range_B_filter_fFunctionT_to_Bool, ptr @Range_B_chain_otherCollectionT_chain_otherIterableT, ptr @Range_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @Range_B_zip_otherIterableU_zip_otherCollectionU, ptr @Range_B_product_otherIterableU_product_otherCollectionU, ptr @Range_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU] }
@RangeIterator_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr @Iterator, ptr @RangeIterator, ptr @Object]
@RangeIterator_offset_tbl = constant [4 x i32] [i32 10, i32 18, i32 10, i32 21]
@RangeIterator = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 -913562485944406675, i64 -8575588345227680241, i64 3], [7 x ptr] [ptr @subtype_test, ptr @RangeIterator_hashtbl, ptr @RangeIterator_offset_tbl, ptr @_data_size_RangeIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @RangeIterator_field_counter, ptr @RangeIterator_field_end, ptr @RangeIterator_field_step, ptr @RangeIterator_field_RangeIterator_0, ptr @RangeIterator_B_init_counteri32_endi32_stepi32, ptr @RangeIterator_B_next_, ptr @RangeIterator_init_counteri32_endi32_stepi32, ptr @RangeIterator_next_, ptr @RangeIterator_field_RangeIterator_0, ptr @RangeIterator_B_next_, ptr @RangeIterator_next_] }
@Range_field_start = internal constant { ptr, ptr } { ptr @Range_getter_start, ptr @Range_setter_start }
@Range_field_end = internal constant { ptr, ptr } { ptr @Range_getter_end, ptr @Range_setter_end }
@Range_field_step = internal constant { ptr, ptr } { ptr @Range_getter_step, ptr @Range_setter_step }
@RangeIterator_field_counter = internal constant { ptr, ptr } { ptr @RangeIterator_getter_counter, ptr @RangeIterator_setter_counter }
@RangeIterator_field_end = internal constant { ptr, ptr } { ptr @RangeIterator_getter_end, ptr @RangeIterator_setter_end }
@RangeIterator_field_step = internal constant { ptr, ptr } { ptr @RangeIterator_getter_step, ptr @RangeIterator_setter_step }

declare i32 @printf(ptr, ...)

declare ptr @bump_malloc(i64)

declare void @free(ptr)

declare void @setup_landing_pad()

declare void @anoint_trampoline(ptr)

declare ptr @adjust_trampoline(ptr)

declare ptr @coroutine_create(ptr, ptr)

declare void @arg_passer(ptr)

declare void @arg_buffer_filler(ptr)

declare void @coroutine_yield(ptr)

declare void @coroutine_yield_cold(ptr)

declare ptr @get_current_coroutine()

declare i32 @get_offset(ptr, ptr)

declare void @assume_offset(ptr, ptr)

declare { ptr, i160 } @_box_Default(ptr, ptr)

declare void @_unbox_Default({ ptr, i160 }, ptr, ptr)

declare { i64, i64 } @_size_Default(ptr)

declare void @_unbox_union_typ({ ptr, i160 }, ptr, ptr)

declare { i64, i64 } @_data_size_tuple_typ(ptr)

declare { i64, i64 } @_data_size_union_typ(ptr)

declare i1 @subtype_test(i64, i64, i64, i64, ptr)

declare i1 @subtype_test_wrapper(ptr, i64, i64, i64, i64, ptr)

declare { i64, i64 } @size_wrapper(ptr, ptr)

declare ptr @typegetter_wrapper(ptr, ptr)

declare { ptr, i160 } @box_wrapper(ptr, ptr, ptr)

declare void @unbox_wrapper(ptr, { ptr, i160 }, ptr, ptr)

declare ptr @behavior_wrapper(ptr, { ptr, ptr, ptr, i32 }, ptr)

declare ptr @class_behavior_wrapper(ptr, ptr)

declare void @coroutine_call(ptr)

define { i64, i64 } @_data_size_Range(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %10
  %12 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %5
  %13 = select i1 %12, i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), i64 %5
  %14 = urem i64 %11, ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %17
  %19 = add i64 %11, %18
  %20 = urem i64 %19, %13
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 %13, %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = add i64 %19, %23
  %25 = insertvalue { i64, i64 } undef, i64 %24, 0
  %26 = insertvalue { i64, i64 } %25, i64 %13, 1
  ret { i64, i64 } %26
}

define i32 @Range_getter_start(ptr %0) {
  %2 = getelementptr i8, ptr %0, i64 0
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

define void @Range_setter_start(ptr %0, i32 %1) {
  %3 = getelementptr i8, ptr %0, i64 0
  %4 = alloca i32, align 4
  store i32 %1, ptr %4, align 4
  %5 = load i32, ptr %4, align 4
  store i32 %5, ptr %3, align 4
  ret void
}

define i32 @Range_getter_end(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %5
  %7 = getelementptr i8, ptr %0, i64 %6
  %8 = load i32, ptr %7, align 4
  ret i32 %8
}

define void @Range_setter_end(ptr %0, i32 %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %6
  %8 = getelementptr i8, ptr %0, i64 %7
  %9 = alloca i32, align 4
  store i32 %1, ptr %9, align 4
  %10 = load i32, ptr %9, align 4
  store i32 %10, ptr %8, align 4
  ret void
}

define i32 @Range_getter_step(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %7, %11
  %13 = getelementptr i8, ptr %0, i64 %12
  %14 = load i32, ptr %13, align 4
  ret i32 %14
}

define void @Range_setter_step(ptr %0, i32 %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %8, %12
  %14 = getelementptr i8, ptr %0, i64 %13
  %15 = alloca i32, align 4
  store i32 %1, ptr %15, align 4
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %14, align 4
  ret void
}

define ptr @Range_field_Range_0(ptr %0) {
  ret ptr @_parameterization_i32
}

define void @Range_init_endi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, i32 %3) {
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %5, align 8
  %6 = alloca i32, align 4
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %7, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %8, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %9, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = call i32 @get_offset(ptr %18, ptr @Range)
  store i32 %19, ptr %6, align 4
  %20 = alloca i32, align 4
  store i32 %3, ptr %20, align 4
  %21 = load ptr, ptr %8, align 8
  %22 = load ptr, ptr %7, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %22)
  %24 = load i32, ptr %6, align 4
  %25 = getelementptr ptr, ptr %22, i32 %24
  %26 = getelementptr ptr, ptr %25, i32 1
  %27 = load ptr, ptr %26, align 8
  %28 = getelementptr { ptr, ptr }, ptr %27, i32 0, i32 1
  %29 = load ptr, ptr %28, align 8
  %30 = load i32, ptr %20, align 4
  call void %29(ptr %21, i32 %30) #1
  %31 = alloca i32, align 4
  store i32 0, ptr %31, align 4
  %32 = load ptr, ptr %8, align 8
  %33 = load ptr, ptr %7, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %33)
  %35 = load i32, ptr %6, align 4
  %36 = getelementptr ptr, ptr %33, i32 %35
  %37 = load ptr, ptr %36, align 8
  %38 = getelementptr { ptr, ptr }, ptr %37, i32 0, i32 1
  %39 = load ptr, ptr %38, align 8
  %40 = load i32, ptr %31, align 4
  call void %39(ptr %32, i32 %40) #1
  %41 = alloca i32, align 4
  store i32 1, ptr %41, align 4
  %42 = load ptr, ptr %8, align 8
  %43 = load ptr, ptr %7, align 8
  %44 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %43)
  %45 = load i32, ptr %6, align 4
  %46 = getelementptr ptr, ptr %43, i32 %45
  %47 = getelementptr ptr, ptr %46, i32 2
  %48 = load ptr, ptr %47, align 8
  %49 = getelementptr { ptr, ptr }, ptr %48, i32 0, i32 1
  %50 = load ptr, ptr %49, align 8
  %51 = load i32, ptr %41, align 4
  call void %50(ptr %42, i32 %51) #1
  ret void
}

define ptr @Range_B_init_endi32({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @i32_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 21, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [127 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define void @Range_init_starti32_endi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, i32 %3, i32 %4) {
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %6, align 8
  %7 = alloca i32, align 4
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = alloca ptr, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %8, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 1
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %9, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 2
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %10, align 8
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  store i32 %18, ptr %7, align 4
  %19 = load ptr, ptr %8, align 8
  %20 = call i32 @get_offset(ptr %19, ptr @Range)
  store i32 %20, ptr %7, align 4
  %21 = alloca i32, align 4
  store i32 %3, ptr %21, align 4
  %22 = load ptr, ptr %9, align 8
  %23 = load ptr, ptr %8, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %23)
  %25 = load i32, ptr %7, align 4
  %26 = getelementptr ptr, ptr %23, i32 %25
  %27 = load ptr, ptr %26, align 8
  %28 = getelementptr { ptr, ptr }, ptr %27, i32 0, i32 1
  %29 = load ptr, ptr %28, align 8
  %30 = load i32, ptr %21, align 4
  call void %29(ptr %22, i32 %30) #1
  %31 = alloca i32, align 4
  store i32 %4, ptr %31, align 4
  %32 = load ptr, ptr %9, align 8
  %33 = load ptr, ptr %8, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %33)
  %35 = load i32, ptr %7, align 4
  %36 = getelementptr ptr, ptr %33, i32 %35
  %37 = getelementptr ptr, ptr %36, i32 1
  %38 = load ptr, ptr %37, align 8
  %39 = getelementptr { ptr, ptr }, ptr %38, i32 0, i32 1
  %40 = load ptr, ptr %39, align 8
  %41 = load i32, ptr %31, align 4
  call void %40(ptr %32, i32 %41) #1
  %42 = alloca i32, align 4
  store i32 1, ptr %42, align 4
  %43 = load ptr, ptr %9, align 8
  %44 = load ptr, ptr %8, align 8
  %45 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %44)
  %46 = load i32, ptr %7, align 4
  %47 = getelementptr ptr, ptr %44, i32 %46
  %48 = getelementptr ptr, ptr %47, i32 2
  %49 = load ptr, ptr %48, align 8
  %50 = getelementptr { ptr, ptr }, ptr %49, i32 0, i32 1
  %51 = load ptr, ptr %50, align 8
  %52 = load i32, ptr %42, align 4
  call void %51(ptr %43, i32 %52) #1
  ret void
}

define ptr @Range_B_init_starti32_endi32({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = ptrtoint ptr %7 to i64
  %9 = icmp eq i64 %8, ptrtoint (ptr @i32_typ to i64)
  %10 = zext i1 %9 to i8
  store i8 %10, ptr %4, align 1
  %11 = getelementptr ptr, ptr %1, i32 1
  %12 = load ptr, ptr %11, align 8
  %13 = ptrtoint ptr %12 to i64
  %14 = icmp eq i64 %13, ptrtoint (ptr @i32_typ to i64)
  %15 = zext i1 %14 to i8
  store i8 %15, ptr %3, align 1
  store i32 22, ptr %6, align 4
  %16 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %17 = load i32, ptr %6, align 4
  %18 = getelementptr [127 x ptr], ptr %16, i32 0, i32 %17
  %19 = getelementptr ptr, ptr %18, i32 10
  %20 = load ptr, ptr %19, align 8
  ret ptr %20
}

define { ptr, ptr, ptr, i32 } @Range_step_stepi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, i32 %3) {
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %5, align 8
  %6 = alloca i32, align 4
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %9, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %8, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %7, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %6, align 4
  %18 = load ptr, ptr %9, align 8
  %19 = call i32 @get_offset(ptr %18, ptr @Range)
  store i32 %19, ptr %6, align 4
  %20 = alloca i32, align 4
  store i32 %3, ptr %20, align 4
  %21 = load ptr, ptr %8, align 8
  %22 = load ptr, ptr %9, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %22)
  %24 = load i32, ptr %6, align 4
  %25 = getelementptr ptr, ptr %22, i32 %24
  %26 = getelementptr ptr, ptr %25, i32 2
  %27 = load ptr, ptr %26, align 8
  %28 = getelementptr { ptr, ptr }, ptr %27, i32 0, i32 1
  %29 = load ptr, ptr %28, align 8
  %30 = load i32, ptr %20, align 4
  call void %29(ptr %21, i32 %30) #1
  %31 = alloca i32, align 4
  %32 = alloca ptr, align 8
  %33 = alloca ptr, align 8
  %34 = alloca ptr, align 8
  %35 = load ptr, ptr %9, align 8
  store ptr %35, ptr %34, align 8
  %36 = load ptr, ptr %8, align 8
  store ptr %36, ptr %33, align 8
  %37 = load ptr, ptr %7, align 8
  store ptr %37, ptr %32, align 8
  %38 = load i32, ptr %6, align 4
  store i32 %38, ptr %31, align 4
  %39 = load ptr, ptr %34, align 8
  %40 = call i32 @get_offset(ptr %39, ptr @Range)
  store i32 %40, ptr %31, align 4
  %41 = load ptr, ptr %34, align 8
  %42 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %41, 0
  %43 = load ptr, ptr %33, align 8
  %44 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %43, 1
  %45 = load ptr, ptr %32, align 8
  %46 = insertvalue { ptr, ptr, ptr, i32 } %44, ptr %45, 2
  %47 = load i32, ptr %31, align 4
  %48 = insertvalue { ptr, ptr, ptr, i32 } %46, i32 %47, 3
  ret { ptr, ptr, ptr, i32 } %48
}

define ptr @Range_B_step_stepi32({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @i32_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 23, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [127 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define i32 @Range_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca i32, align 4
  %11 = alloca i32, align 4
  %12 = alloca i32, align 4
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %15 = alloca i32, align 4
  %16 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %16, align 8
  %17 = alloca i32, align 4
  %18 = alloca ptr, align 8
  %19 = alloca ptr, align 8
  %20 = alloca ptr, align 8
  %21 = getelementptr { ptr, ptr, ptr, i32 }, ptr %16, i32 0, i32 0
  %22 = load ptr, ptr %21, align 8
  store ptr %22, ptr %18, align 8
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %16, i32 0, i32 1
  %24 = load ptr, ptr %23, align 8
  store ptr %24, ptr %19, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %16, i32 0, i32 2
  %26 = load ptr, ptr %25, align 8
  store ptr %26, ptr %20, align 8
  %27 = getelementptr { ptr, ptr, ptr, i32 }, ptr %16, i32 0, i32 3
  %28 = load i32, ptr %27, align 4
  store i32 %28, ptr %17, align 4
  %29 = load ptr, ptr %18, align 8
  %30 = call i32 @get_offset(ptr %29, ptr @Range)
  store i32 %30, ptr %17, align 4
  %31 = load ptr, ptr %19, align 8
  %32 = load ptr, ptr %18, align 8
  %33 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %32)
  %34 = load i32, ptr %17, align 4
  %35 = getelementptr ptr, ptr %32, i32 %34
  %36 = getelementptr ptr, ptr %35, i32 2
  %37 = load ptr, ptr %36, align 8
  %38 = getelementptr { ptr, ptr }, ptr %37, i32 0, i32 0
  %39 = load ptr, ptr %38, align 8
  %40 = call i32 %39(ptr %31) #2
  %41 = alloca i32, align 4
  store i32 %40, ptr %41, align 4
  %42 = alloca i32, align 4
  store i32 1, ptr %42, align 4
  %43 = load i32, ptr %41, align 4
  %44 = load i32, ptr %42, align 4
  %45 = icmp eq i32 %43, %44
  %46 = alloca i1, align 1
  %47 = zext i1 %45 to i8
  store i8 %47, ptr %46, align 1
  %48 = load i8, ptr %46, align 1
  %49 = trunc i8 %48 to i1
  br i1 %49, label %50, label %77

50:                                               ; preds = %3
  %51 = load ptr, ptr %19, align 8
  %52 = load ptr, ptr %18, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %52)
  %54 = load i32, ptr %17, align 4
  %55 = getelementptr ptr, ptr %52, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 1
  %57 = load ptr, ptr %56, align 8
  %58 = getelementptr { ptr, ptr }, ptr %57, i32 0, i32 0
  %59 = load ptr, ptr %58, align 8
  %60 = call i32 %59(ptr %51) #2
  store i32 %60, ptr %4, align 4
  %61 = load ptr, ptr %19, align 8
  %62 = load ptr, ptr %18, align 8
  %63 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %62)
  %64 = load i32, ptr %17, align 4
  %65 = getelementptr ptr, ptr %62, i32 %64
  %66 = load ptr, ptr %65, align 8
  %67 = getelementptr { ptr, ptr }, ptr %66, i32 0, i32 0
  %68 = load ptr, ptr %67, align 8
  %69 = call i32 %68(ptr %61) #2
  store i32 %69, ptr %5, align 4
  %70 = load i32, ptr %4, align 4
  %71 = load i32, ptr %5, align 4
  %72 = sub i32 %70, %71
  store i32 %72, ptr %6, align 4
  store i32 1, ptr %7, align 4
  %73 = load i32, ptr %6, align 4
  %74 = load i32, ptr %7, align 4
  %75 = add i32 %73, %74
  store i32 %75, ptr %8, align 4
  %76 = load i32, ptr %8, align 4
  br label %117

77:                                               ; preds = %3
  %78 = load ptr, ptr %19, align 8
  %79 = load ptr, ptr %18, align 8
  %80 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %79)
  %81 = load i32, ptr %17, align 4
  %82 = getelementptr ptr, ptr %79, i32 %81
  %83 = getelementptr ptr, ptr %82, i32 1
  %84 = load ptr, ptr %83, align 8
  %85 = getelementptr { ptr, ptr }, ptr %84, i32 0, i32 0
  %86 = load ptr, ptr %85, align 8
  %87 = call i32 %86(ptr %78) #2
  store i32 %87, ptr %9, align 4
  %88 = load ptr, ptr %19, align 8
  %89 = load ptr, ptr %18, align 8
  %90 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %89)
  %91 = load i32, ptr %17, align 4
  %92 = getelementptr ptr, ptr %89, i32 %91
  %93 = load ptr, ptr %92, align 8
  %94 = getelementptr { ptr, ptr }, ptr %93, i32 0, i32 0
  %95 = load ptr, ptr %94, align 8
  %96 = call i32 %95(ptr %88) #2
  store i32 %96, ptr %10, align 4
  %97 = load i32, ptr %9, align 4
  %98 = load i32, ptr %10, align 4
  %99 = sub i32 %97, %98
  store i32 %99, ptr %11, align 4
  %100 = load ptr, ptr %19, align 8
  %101 = load ptr, ptr %18, align 8
  %102 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %101)
  %103 = load i32, ptr %17, align 4
  %104 = getelementptr ptr, ptr %101, i32 %103
  %105 = getelementptr ptr, ptr %104, i32 2
  %106 = load ptr, ptr %105, align 8
  %107 = getelementptr { ptr, ptr }, ptr %106, i32 0, i32 0
  %108 = load ptr, ptr %107, align 8
  %109 = call i32 %108(ptr %100) #2
  store i32 %109, ptr %12, align 4
  %110 = load i32, ptr %11, align 4
  %111 = load i32, ptr %12, align 4
  %112 = sdiv i32 %110, %111
  store i32 %112, ptr %13, align 4
  store i32 1, ptr %14, align 4
  %113 = load i32, ptr %13, align 4
  %114 = load i32, ptr %14, align 4
  %115 = add i32 %113, %114
  store i32 %115, ptr %15, align 4
  %116 = load i32, ptr %15, align 4
  br label %117

117:                                              ; preds = %50, %77
  %118 = phi i32 [ %116, %77 ], [ %76, %50 ]
  br label %119

119:                                              ; preds = %117
  ret i32 %118
}

define ptr @Range_B_size_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 24, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [127 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

declare i1 @Collection_is_empty_()

define ptr @Range_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 25, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [127 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { ptr, ptr, ptr, i32 } @Range_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @Range)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = load ptr, ptr %23, align 8
  %25 = getelementptr { ptr, ptr }, ptr %24, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  %27 = call i32 %26(ptr %19) #2
  %28 = alloca i32, align 4
  store i32 %27, ptr %28, align 4
  %29 = load ptr, ptr %7, align 8
  %30 = load ptr, ptr %6, align 8
  %31 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %30)
  %32 = load i32, ptr %5, align 4
  %33 = getelementptr ptr, ptr %30, i32 %32
  %34 = getelementptr ptr, ptr %33, i32 1
  %35 = load ptr, ptr %34, align 8
  %36 = getelementptr { ptr, ptr }, ptr %35, i32 0, i32 0
  %37 = load ptr, ptr %36, align 8
  %38 = call i32 %37(ptr %29) #2
  %39 = alloca i32, align 4
  store i32 %38, ptr %39, align 4
  %40 = load ptr, ptr %7, align 8
  %41 = load ptr, ptr %6, align 8
  %42 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %41)
  %43 = load i32, ptr %5, align 4
  %44 = getelementptr ptr, ptr %41, i32 %43
  %45 = getelementptr ptr, ptr %44, i32 2
  %46 = load ptr, ptr %45, align 8
  %47 = getelementptr { ptr, ptr }, ptr %46, i32 0, i32 0
  %48 = load ptr, ptr %47, align 8
  %49 = call i32 %48(ptr %40) #2
  %50 = alloca i32, align 4
  store i32 %49, ptr %50, align 4
  %51 = alloca [1 x ptr], align 8
  store ptr @RangeIterator, ptr %51, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = getelementptr ptr, ptr %52, i32 6
  %54 = load ptr, ptr %53, align 8
  %55 = call { i64, i64 } @size_wrapper(ptr %54, ptr %51)
  %56 = extractvalue { i64, i64 } %55, 0
  %57 = call ptr @bump_malloc(i64 %56)
  %58 = alloca i32, align 4
  %59 = alloca ptr, align 8
  %60 = alloca ptr, align 8
  %61 = alloca ptr, align 8
  store ptr @RangeIterator, ptr %61, align 8
  store ptr %57, ptr %60, align 8
  store i32 10, ptr %58, align 4
  %62 = load ptr, ptr %7, align 8
  %63 = load ptr, ptr %6, align 8
  %64 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %63)
  %65 = load i32, ptr %5, align 4
  %66 = getelementptr ptr, ptr %63, i32 %65
  %67 = load ptr, ptr %66, align 8
  %68 = getelementptr { ptr, ptr }, ptr %67, i32 0, i32 0
  %69 = load ptr, ptr %68, align 8
  %70 = call i32 %69(ptr %62) #2
  %71 = alloca i32, align 4
  store i32 %70, ptr %71, align 4
  %72 = load ptr, ptr %7, align 8
  %73 = load ptr, ptr %6, align 8
  %74 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %73)
  %75 = load i32, ptr %5, align 4
  %76 = getelementptr ptr, ptr %73, i32 %75
  %77 = getelementptr ptr, ptr %76, i32 1
  %78 = load ptr, ptr %77, align 8
  %79 = getelementptr { ptr, ptr }, ptr %78, i32 0, i32 0
  %80 = load ptr, ptr %79, align 8
  %81 = call i32 %80(ptr %72) #2
  %82 = alloca i32, align 4
  store i32 %81, ptr %82, align 4
  %83 = load ptr, ptr %7, align 8
  %84 = load ptr, ptr %6, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %84)
  %86 = load i32, ptr %5, align 4
  %87 = getelementptr ptr, ptr %84, i32 %86
  %88 = getelementptr ptr, ptr %87, i32 2
  %89 = load ptr, ptr %88, align 8
  %90 = getelementptr { ptr, ptr }, ptr %89, i32 0, i32 0
  %91 = load ptr, ptr %90, align 8
  %92 = call i32 %91(ptr %83) #2
  %93 = alloca i32, align 4
  store i32 %92, ptr %93, align 4
  %94 = load i32, ptr %71, align 4
  %95 = load i32, ptr %82, align 4
  %96 = load i32, ptr %93, align 4
  %97 = load ptr, ptr %61, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %97, 0
  %99 = load ptr, ptr %60, align 8
  %100 = insertvalue { ptr, ptr, ptr, i32 } %98, ptr %99, 1
  %101 = load ptr, ptr %59, align 8
  %102 = insertvalue { ptr, ptr, ptr, i32 } %100, ptr %101, 2
  %103 = load i32, ptr %58, align 4
  %104 = insertvalue { ptr, ptr, ptr, i32 } %102, i32 %103, 3
  %105 = alloca [3 x ptr], align 8
  %106 = getelementptr [3 x ptr], ptr %105, i32 0, i32 0
  store ptr @_parameterization_i32, ptr %106, align 8
  %107 = getelementptr [3 x ptr], ptr %105, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %107, align 8
  %108 = getelementptr [3 x ptr], ptr %105, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %108, align 8
  %109 = call ptr @llvm.invariant.start.p0(i64 9, ptr %105)
  %110 = call ptr @llvm.invariant.start.p0(i64 88, ptr %97)
  %111 = getelementptr ptr, ptr %97, i32 %103
  %112 = getelementptr ptr, ptr %111, i32 4
  %113 = load ptr, ptr %112, align 8
  %114 = alloca { ptr, ptr, ptr }, align 8
  %115 = getelementptr { ptr, ptr, ptr }, ptr %114, i32 0, i32 0
  store ptr @i32_typ, ptr %115, align 8
  %116 = getelementptr { ptr, ptr, ptr }, ptr %114, i32 0, i32 1
  store ptr @i32_typ, ptr %116, align 8
  %117 = getelementptr { ptr, ptr, ptr }, ptr %114, i32 0, i32 2
  store ptr @i32_typ, ptr %117, align 8
  %118 = call ptr @behavior_wrapper(ptr %113, { ptr, ptr, ptr, i32 } %104, ptr %114)
  call void %118({ ptr, ptr, ptr, i32 } %104, { ptr, ptr, ptr, i32 } %104, ptr %105, i32 %94, i32 %95, i32 %96)
  %119 = alloca i32, align 4
  %120 = alloca ptr, align 8
  %121 = alloca ptr, align 8
  %122 = alloca ptr, align 8
  %123 = load ptr, ptr %61, align 8
  store ptr %123, ptr %122, align 8
  %124 = load ptr, ptr %60, align 8
  store ptr %124, ptr %121, align 8
  %125 = load ptr, ptr %59, align 8
  store ptr %125, ptr %120, align 8
  %126 = load i32, ptr %58, align 4
  store i32 %126, ptr %119, align 4
  %127 = load ptr, ptr %122, align 8
  %128 = call i32 @get_offset(ptr %127, ptr @Iterator)
  store i32 %128, ptr %119, align 4
  %129 = load ptr, ptr %122, align 8
  %130 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %129, 0
  %131 = load ptr, ptr %121, align 8
  %132 = insertvalue { ptr, ptr, ptr, i32 } %130, ptr %131, 1
  %133 = load ptr, ptr %120, align 8
  %134 = insertvalue { ptr, ptr, ptr, i32 } %132, ptr %133, 2
  %135 = load i32, ptr %119, align 4
  %136 = insertvalue { ptr, ptr, ptr, i32 } %134, i32 %135, 3
  ret { ptr, ptr, ptr, i32 } %136
}

define ptr @Range_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 26, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [127 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

declare void @Iterable_each_fFunctionT_to_Nothing({ ptr })

define ptr @Range_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 27, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [127 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

declare { ptr, i160 } @Iterable_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, i160 }, { ptr })

define ptr @Range_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = ptrtoint ptr %7 to i64
  %9 = icmp eq i64 %8, ptrtoint (ptr @i32_typ to i64)
  %10 = zext i1 %9 to i8
  store i8 %10, ptr %4, align 1
  %11 = getelementptr ptr, ptr %1, i32 1
  %12 = load ptr, ptr %11, align 8
  %13 = ptrtoint ptr %12 to i64
  %14 = icmp eq i64 %13, ptrtoint (ptr @function_typ to i64)
  %15 = zext i1 %14 to i8
  store i8 %15, ptr %3, align 1
  store i32 28, ptr %6, align 4
  %16 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %17 = load i32, ptr %6, align 4
  %18 = getelementptr [127 x ptr], ptr %16, i32 0, i32 %17
  %19 = getelementptr ptr, ptr %18, i32 10
  %20 = load ptr, ptr %19, align 8
  ret ptr %20
}

declare i1 @Iterable_all_fFunctionT_to_Bool({ ptr })

define ptr @Range_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 29, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [127 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

declare i1 @Iterable_any_fFunctionT_to_Bool({ ptr })

define ptr @Range_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 30, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [127 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

declare { ptr, ptr, ptr, i32 } @Collection_enumerate_()

define ptr @Range_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 31, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [127 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

declare { ptr, ptr, ptr, i32 } @Iterable_map_fFunctionT_to_U({ ptr })

declare { ptr, ptr, ptr, i32 } @Collection_map_fFunctionT_to_U({ ptr })

define ptr @Range_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = ptrtoint ptr %7 to i64
  %9 = icmp eq i64 %8, ptrtoint (ptr @function_typ to i64)
  %10 = zext i1 %9 to i8
  store i8 %10, ptr %3, align 1
  %11 = load i8, ptr %3, align 1
  %12 = trunc i8 %11 to i1
  %13 = select i1 %12, i32 32, i32 33
  br i1 %12, label %14, label %15

14:                                               ; preds = %2
  br label %20

15:                                               ; preds = %2
  %16 = load ptr, ptr %1, align 8
  %17 = ptrtoint ptr %16 to i64
  %18 = icmp eq i64 %17, ptrtoint (ptr @function_typ to i64)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %4, align 1
  br label %20

20:                                               ; preds = %14, %15
  store i32 %13, ptr %6, align 4
  %21 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %22 = load i32, ptr %6, align 4
  %23 = getelementptr [127 x ptr], ptr %21, i32 0, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 10
  %25 = load ptr, ptr %24, align 8
  ret ptr %25
}

declare { ptr, ptr, ptr, i32 } @Iterable_filter_fFunctionT_to_Bool({ ptr })

define ptr @Range_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 34, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [127 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

declare { ptr, ptr, ptr, i32 } @Collection_chain_otherCollectionT({ ptr, ptr, ptr, i32 })

declare { ptr, ptr, ptr, i32 } @Iterable_chain_otherIterableT({ ptr, ptr, ptr, i32 })

define ptr @Range_B_chain_otherCollectionT_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 35, i32 36
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [127 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

declare { ptr, ptr, ptr, i32 } @Collection_interleave_otherCollectionT({ ptr, ptr, ptr, i32 })

declare { ptr, ptr, ptr, i32 } @Iterable_interleave_otherIterableT({ ptr, ptr, ptr, i32 })

define ptr @Range_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 37, i32 38
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [127 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

declare { ptr, ptr, ptr, i32 } @Iterable_zip_otherIterableU({ ptr, ptr, ptr, i32 })

declare { ptr, ptr, ptr, i32 } @Collection_zip_otherCollectionU({ ptr, ptr, ptr, i32 })

define ptr @Range_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 40, i32 39
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [127 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

declare { ptr, ptr, ptr, i32 } @Iterable_product_otherIterableU({ ptr, ptr, ptr, i32 })

declare { ptr, ptr, ptr, i32 } @Collection_product_otherCollectionU({ ptr, ptr, ptr, i32 })

define ptr @Range_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 42, i32 41
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [127 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

define { i64, i64 } @_data_size_RangeIterator(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %10
  %12 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %5
  %13 = select i1 %12, i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), i64 %5
  %14 = urem i64 %11, ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %17
  %19 = add i64 %11, %18
  %20 = urem i64 %19, %13
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 %13, %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = add i64 %19, %23
  %25 = insertvalue { i64, i64 } undef, i64 %24, 0
  %26 = insertvalue { i64, i64 } %25, i64 %13, 1
  ret { i64, i64 } %26
}

define i32 @RangeIterator_getter_counter(ptr %0) {
  %2 = getelementptr i8, ptr %0, i64 0
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

define void @RangeIterator_setter_counter(ptr %0, i32 %1) {
  %3 = getelementptr i8, ptr %0, i64 0
  %4 = alloca i32, align 4
  store i32 %1, ptr %4, align 4
  %5 = load i32, ptr %4, align 4
  store i32 %5, ptr %3, align 4
  ret void
}

define i32 @RangeIterator_getter_end(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %5
  %7 = getelementptr i8, ptr %0, i64 %6
  %8 = load i32, ptr %7, align 4
  ret i32 %8
}

define void @RangeIterator_setter_end(ptr %0, i32 %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %6
  %8 = getelementptr i8, ptr %0, i64 %7
  %9 = alloca i32, align 4
  store i32 %1, ptr %9, align 4
  %10 = load i32, ptr %9, align 4
  store i32 %10, ptr %8, align 4
  ret void
}

define i32 @RangeIterator_getter_step(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %7, %11
  %13 = getelementptr i8, ptr %0, i64 %12
  %14 = load i32, ptr %13, align 4
  ret i32 %14
}

define void @RangeIterator_setter_step(ptr %0, i32 %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %8, %12
  %14 = getelementptr i8, ptr %0, i64 %13
  %15 = alloca i32, align 4
  store i32 %1, ptr %15, align 4
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %14, align 4
  ret void
}

define ptr @RangeIterator_field_RangeIterator_0(ptr %0) {
  ret ptr @_parameterization_i32
}

define void @RangeIterator_init_counteri32_endi32_stepi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, i32 %3, i32 %4, i32 %5) {
  %7 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %7, align 8
  %8 = alloca i32, align 4
  %9 = alloca ptr, align 8
  %10 = alloca ptr, align 8
  %11 = alloca ptr, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %9, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 1
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %10, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 2
  %17 = load ptr, ptr %16, align 8
  store ptr %17, ptr %11, align 8
  %18 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 3
  %19 = load i32, ptr %18, align 4
  store i32 %19, ptr %8, align 4
  %20 = load ptr, ptr %9, align 8
  %21 = call i32 @get_offset(ptr %20, ptr @RangeIterator)
  store i32 %21, ptr %8, align 4
  %22 = alloca i32, align 4
  store i32 %3, ptr %22, align 4
  %23 = load ptr, ptr %10, align 8
  %24 = load ptr, ptr %9, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 88, ptr %24)
  %26 = load i32, ptr %8, align 4
  %27 = getelementptr ptr, ptr %24, i32 %26
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr { ptr, ptr }, ptr %28, i32 0, i32 1
  %30 = load ptr, ptr %29, align 8
  %31 = load i32, ptr %22, align 4
  call void %30(ptr %23, i32 %31) #1
  %32 = alloca i32, align 4
  store i32 %4, ptr %32, align 4
  %33 = load ptr, ptr %10, align 8
  %34 = load ptr, ptr %9, align 8
  %35 = call ptr @llvm.invariant.start.p0(i64 88, ptr %34)
  %36 = load i32, ptr %8, align 4
  %37 = getelementptr ptr, ptr %34, i32 %36
  %38 = getelementptr ptr, ptr %37, i32 1
  %39 = load ptr, ptr %38, align 8
  %40 = getelementptr { ptr, ptr }, ptr %39, i32 0, i32 1
  %41 = load ptr, ptr %40, align 8
  %42 = load i32, ptr %32, align 4
  call void %41(ptr %33, i32 %42) #1
  %43 = alloca i32, align 4
  store i32 %5, ptr %43, align 4
  %44 = load ptr, ptr %10, align 8
  %45 = load ptr, ptr %9, align 8
  %46 = call ptr @llvm.invariant.start.p0(i64 88, ptr %45)
  %47 = load i32, ptr %8, align 4
  %48 = getelementptr ptr, ptr %45, i32 %47
  %49 = getelementptr ptr, ptr %48, i32 2
  %50 = load ptr, ptr %49, align 8
  %51 = getelementptr { ptr, ptr }, ptr %50, i32 0, i32 1
  %52 = load ptr, ptr %51, align 8
  %53 = load i32, ptr %43, align 4
  call void %52(ptr %44, i32 %53) #1
  ret void
}

define ptr @RangeIterator_B_init_counteri32_endi32_stepi32({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 24, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = ptrtoint ptr %8 to i64
  %10 = icmp eq i64 %9, ptrtoint (ptr @i32_typ to i64)
  %11 = zext i1 %10 to i8
  store i8 %11, ptr %5, align 1
  %12 = getelementptr ptr, ptr %1, i32 1
  %13 = load ptr, ptr %12, align 8
  %14 = ptrtoint ptr %13 to i64
  %15 = icmp eq i64 %14, ptrtoint (ptr @i32_typ to i64)
  %16 = zext i1 %15 to i8
  store i8 %16, ptr %4, align 1
  %17 = getelementptr ptr, ptr %1, i32 2
  %18 = load ptr, ptr %17, align 8
  %19 = ptrtoint ptr %18 to i64
  %20 = icmp eq i64 %19, ptrtoint (ptr @i32_typ to i64)
  %21 = zext i1 %20 to i8
  store i8 %21, ptr %3, align 1
  store i32 6, ptr %7, align 4
  %22 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %23 = load i32, ptr %7, align 4
  %24 = getelementptr [11 x ptr], ptr %22, i32 0, i32 %23
  %25 = getelementptr ptr, ptr %24, i32 10
  %26 = load ptr, ptr %25, align 8
  ret ptr %26
}

define { ptr, i160 } @RangeIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca [0 x i8], align 1
  %5 = alloca i160, align 8
  %6 = alloca ptr, align 8
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca i32, align 4
  %11 = alloca i32, align 4
  %12 = alloca i160, align 8
  %13 = alloca ptr, align 8
  %14 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %14, align 8
  %15 = alloca i32, align 4
  %16 = alloca ptr, align 8
  %17 = alloca ptr, align 8
  %18 = alloca ptr, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 0
  %20 = load ptr, ptr %19, align 8
  store ptr %20, ptr %16, align 8
  %21 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 1
  %22 = load ptr, ptr %21, align 8
  store ptr %22, ptr %17, align 8
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 2
  %24 = load ptr, ptr %23, align 8
  store ptr %24, ptr %18, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 3
  %26 = load i32, ptr %25, align 4
  store i32 %26, ptr %15, align 4
  %27 = load ptr, ptr %16, align 8
  %28 = call i32 @get_offset(ptr %27, ptr @RangeIterator)
  store i32 %28, ptr %15, align 4
  %29 = load ptr, ptr %17, align 8
  %30 = load ptr, ptr %16, align 8
  %31 = call ptr @llvm.invariant.start.p0(i64 88, ptr %30)
  %32 = load i32, ptr %15, align 4
  %33 = getelementptr ptr, ptr %30, i32 %32
  %34 = load ptr, ptr %33, align 8
  %35 = getelementptr { ptr, ptr }, ptr %34, i32 0, i32 0
  %36 = load ptr, ptr %35, align 8
  %37 = call i32 %36(ptr %29) #2
  %38 = alloca i32, align 4
  store i32 %37, ptr %38, align 4
  %39 = load ptr, ptr %17, align 8
  %40 = load ptr, ptr %16, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 88, ptr %40)
  %42 = load i32, ptr %15, align 4
  %43 = getelementptr ptr, ptr %40, i32 %42
  %44 = getelementptr ptr, ptr %43, i32 1
  %45 = load ptr, ptr %44, align 8
  %46 = getelementptr { ptr, ptr }, ptr %45, i32 0, i32 0
  %47 = load ptr, ptr %46, align 8
  %48 = call i32 %47(ptr %39) #2
  %49 = alloca i32, align 4
  store i32 %48, ptr %49, align 4
  %50 = load i32, ptr %38, align 4
  %51 = load i32, ptr %49, align 4
  %52 = icmp sgt i32 %50, %51
  %53 = alloca i1, align 1
  %54 = zext i1 %52 to i8
  store i8 %54, ptr %53, align 1
  %55 = load i8, ptr %53, align 1
  %56 = trunc i8 %55 to i1
  br i1 %56, label %57, label %63

57:                                               ; preds = %3
  %58 = load [0 x i8], ptr %4, align 1
  store [0 x i8] %58, ptr %5, align 1
  store ptr @nil_typ, ptr %6, align 8
  %59 = load ptr, ptr %6, align 8
  %60 = insertvalue { ptr, i160 } undef, ptr %59, 0
  %61 = load i160, ptr %5, align 4
  %62 = insertvalue { ptr, i160 } %60, i160 %61, 1
  br label %110

63:                                               ; preds = %3
  %64 = load ptr, ptr %17, align 8
  %65 = load ptr, ptr %16, align 8
  %66 = call ptr @llvm.invariant.start.p0(i64 88, ptr %65)
  %67 = load i32, ptr %15, align 4
  %68 = getelementptr ptr, ptr %65, i32 %67
  %69 = load ptr, ptr %68, align 8
  %70 = getelementptr { ptr, ptr }, ptr %69, i32 0, i32 0
  %71 = load ptr, ptr %70, align 8
  %72 = call i32 %71(ptr %64) #2
  store i32 %72, ptr %7, align 4
  %73 = load i32, ptr %7, align 4
  store i32 %73, ptr %8, align 4
  %74 = load ptr, ptr %17, align 8
  %75 = load ptr, ptr %16, align 8
  %76 = call ptr @llvm.invariant.start.p0(i64 88, ptr %75)
  %77 = load i32, ptr %15, align 4
  %78 = getelementptr ptr, ptr %75, i32 %77
  %79 = load ptr, ptr %78, align 8
  %80 = getelementptr { ptr, ptr }, ptr %79, i32 0, i32 0
  %81 = load ptr, ptr %80, align 8
  %82 = call i32 %81(ptr %74) #2
  store i32 %82, ptr %9, align 4
  %83 = load ptr, ptr %17, align 8
  %84 = load ptr, ptr %16, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 88, ptr %84)
  %86 = load i32, ptr %15, align 4
  %87 = getelementptr ptr, ptr %84, i32 %86
  %88 = getelementptr ptr, ptr %87, i32 2
  %89 = load ptr, ptr %88, align 8
  %90 = getelementptr { ptr, ptr }, ptr %89, i32 0, i32 0
  %91 = load ptr, ptr %90, align 8
  %92 = call i32 %91(ptr %83) #2
  store i32 %92, ptr %10, align 4
  %93 = load i32, ptr %9, align 4
  %94 = load i32, ptr %10, align 4
  %95 = add i32 %93, %94
  store i32 %95, ptr %11, align 4
  %96 = load ptr, ptr %17, align 8
  %97 = load ptr, ptr %16, align 8
  %98 = call ptr @llvm.invariant.start.p0(i64 88, ptr %97)
  %99 = load i32, ptr %15, align 4
  %100 = getelementptr ptr, ptr %97, i32 %99
  %101 = load ptr, ptr %100, align 8
  %102 = getelementptr { ptr, ptr }, ptr %101, i32 0, i32 1
  %103 = load ptr, ptr %102, align 8
  %104 = load i32, ptr %11, align 4
  call void %103(ptr %96, i32 %104) #1
  %105 = load i32, ptr %8, align 4
  store i32 %105, ptr %12, align 4
  store ptr @i32_typ, ptr %13, align 8
  %106 = load ptr, ptr %13, align 8
  %107 = insertvalue { ptr, i160 } undef, ptr %106, 0
  %108 = load i160, ptr %12, align 4
  %109 = insertvalue { ptr, i160 } %107, i160 %108, 1
  br label %110

110:                                              ; preds = %57, %63
  %111 = phi { ptr, i160 } [ %109, %63 ], [ %62, %57 ]
  br label %112

112:                                              ; preds = %110
  ret { ptr, i160 } %111
}

define ptr @RangeIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 7, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [11 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare ptr @llvm.invariant.start.p0(i64 immarg, ptr nocapture) #0

attributes #0 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #1 = { nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { nounwind willreturn memory(argmem: read, inaccessiblemem: readwrite) }

!llvm.module.flags = !{!0}

!0 = !{i32 2, !"Debug Info Version", i32 3}
// -----
; ModuleID = 'LLVMDialectModule'
source_filename = "LLVMDialectModule"

%bool_typ = type opaque
%i1_typ = type opaque
%i8_typ = type opaque
%i32_typ = type opaque
%i64_typ = type opaque
%i128_typ = type opaque
%f64_typ = type opaque
%nil_typ = type opaque
%any_typ = type opaque
%nothing_typ = type opaque
%coroutine_typ = type opaque
%function_typ = type opaque
%buffer_typ = type opaque
%tuple_typ = type opaque
%union_typ = type opaque
%Object = type opaque
%Pair = type opaque
%Iterator = type opaque
%Iterable = type opaque
%ConstantTimeIterator = type opaque
%CoroIterator = type opaque
%Enumerated = type opaque
%Enumerator = type opaque
%Mapped = type opaque
%Mapper = type opaque
%Filtered = type opaque
%Filterer = type opaque
%Chained = type opaque
%Chainer = type opaque
%Interleaved = type opaque
%Interleaver = type opaque
%Zipped = type opaque
%Zipper = type opaque
%Products = type opaque
%Productizer = type opaque
%Collection = type opaque
%EnumeratedCollection = type opaque
%MappedCollection = type opaque
%ChainedCollection = type opaque
%InterleavedCollection = type opaque
%ZippedCollection = type opaque
%ProductCollection = type opaque
%List = type opaque
%Indexable = type opaque
%IndexableCollection = type opaque
%Range = type opaque
%RangeIterator = type opaque

@_parameterization_i8 = linkonce_odr constant [2 x ptr] [ptr @i8_typ, ptr null]
@_parameterization_Character = linkonce_odr constant [2 x ptr] [ptr @Character, ptr null]
@_parameterization_IterableCharacter = linkonce_odr constant [3 x ptr] [ptr @Iterable, ptr @_parameterization_Character, ptr null]
@_parameterization_String = linkonce_odr constant [2 x ptr] [ptr @String, ptr null]
@_parameterization_i32 = linkonce_odr constant [2 x ptr] [ptr @i32_typ, ptr null]
@_parameterization_Bufferi8 = linkonce_odr constant [3 x ptr] [ptr @buffer_typ, ptr @_parameterization_i8, ptr null]
@i32_string = linkonce_odr constant [4 x i8] c"%d\0A\00"
@i64_string = linkonce_odr constant [6 x i8] c"%lld\0A\00"
@float_string = linkonce_odr constant [4 x i8] c"%f\0A\00"
@string_string = linkonce_odr constant [4 x i8] c"%s\0A\00"
@bool_typ = external constant %bool_typ
@i1_typ = external constant %i1_typ
@i8_typ = external constant %i8_typ
@i32_typ = external constant %i32_typ
@i64_typ = external constant %i64_typ
@i128_typ = external constant %i128_typ
@f64_typ = external constant %f64_typ
@nil_typ = external constant %nil_typ
@any_typ = external constant %any_typ
@nothing_typ = external constant %nothing_typ
@coroutine_typ = external constant %coroutine_typ
@function_typ = external constant %function_typ
@buffer_typ = external constant %buffer_typ
@tuple_typ = external constant %tuple_typ
@union_typ = external constant %union_typ
@Object = external constant %Object
@Pair = external constant %Pair
@Iterator = external constant %Iterator
@Iterable = external constant %Iterable
@ConstantTimeIterator = external constant %ConstantTimeIterator
@CoroIterator = external constant %CoroIterator
@Enumerated = external constant %Enumerated
@Enumerator = external constant %Enumerator
@Mapped = external constant %Mapped
@Mapper = external constant %Mapper
@Filtered = external constant %Filtered
@Filterer = external constant %Filterer
@Chained = external constant %Chained
@Chainer = external constant %Chainer
@Interleaved = external constant %Interleaved
@Interleaver = external constant %Interleaver
@Zipped = external constant %Zipped
@Zipper = external constant %Zipper
@Products = external constant %Products
@Productizer = external constant %Productizer
@Collection = external constant %Collection
@EnumeratedCollection = external constant %EnumeratedCollection
@MappedCollection = external constant %MappedCollection
@ChainedCollection = external constant %ChainedCollection
@InterleavedCollection = external constant %InterleavedCollection
@ZippedCollection = external constant %ZippedCollection
@ProductCollection = external constant %ProductCollection
@List = external constant %List
@Indexable = external constant %Indexable
@IndexableCollection = external constant %IndexableCollection
@Range = external constant %Range
@RangeIterator = external constant %RangeIterator
@Unicode_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr @Unicode, ptr null]
@Unicode_offset_tbl = constant [4 x i32] [i32 20, i32 10, i32 10, i32 0]
@Unicode = constant { [3 x i64], [7 x ptr], [10 x ptr] } { [3 x i64] [i64 -7454226071548845319, i64 -259478175233900911, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Unicode_hashtbl, ptr @Unicode_offset_tbl, ptr @_data_size_Unicode, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [10 x ptr] [ptr @Unicode_B__Self_replacement_codepoint_, ptr @Unicode_B__Self_replacement_str_, ptr @Unicode_B__Self_replacement_buf_, ptr @Unicode_B__Self_decode_one_bytesBufferi8_indexi32_leni32, ptr @Unicode_B__Self_encode_one_cpi32, ptr @Unicode__Self_replacement_codepoint_, ptr @Unicode__Self_replacement_str_, ptr @Unicode__Self_replacement_buf_, ptr @Unicode__Self_decode_one_bytesBufferi8_indexi32_leni32, ptr @Unicode__Self_encode_one_cpi32] }
@Representable_hashtbl = constant [4 x ptr] [ptr @Representable, ptr @any_typ, ptr @Object, ptr null]
@Representable_offset_tbl = constant [4 x i32] [i32 10, i32 10, i32 12, i32 0]
@Representable = constant { [3 x i64], [7 x ptr], [2 x ptr] } { [3 x i64] [i64 -7260840641129990118, i64 7135053065324493389, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Representable_hashtbl, ptr @Representable_offset_tbl, ptr @_data_size_Representable, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [2 x ptr] [ptr @Representable_B_repr_, ptr @Representable_repr_] }
@String_hashtbl = constant [8 x ptr] [ptr @any_typ, ptr @String, ptr @Collection, ptr @Object, ptr @Representable, ptr @List, ptr null, ptr @Iterable]
@String_offset_tbl = constant [8 x i32] [i32 10, i32 10, i32 238, i32 322, i32 322, i32 102, i32 0, i32 297]
@String = constant { [3 x i64], [7 x ptr], [314 x ptr] } { [3 x i64] [i64 6499063144389013426, i64 -37514728401388959, i64 7], [7 x ptr] [ptr @subtype_test, ptr @String_hashtbl, ptr @String_offset_tbl, ptr @_data_size_String, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [314 x ptr] [ptr @String_field_bytes, ptr @String_field_byte_length, ptr @String_field_char_length, ptr @String_field_capacity, ptr @String_field_String_0, ptr @String_B_byte_length_, ptr @String_B_capacity_, ptr @String_B__Self_from_bytes_source_bytesBufferi8_source_leni32, ptr @String_B__Self_from_bytes_lossy_source_bytesBufferi8_source_leni32, ptr @String_B__Self_from_c_string_c_stringBufferi8, ptr @String_B_init_, ptr @String_B_init_capacityi32, ptr @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, ptr @String_B_c_string_, ptr @String_B_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32, ptr @String_B_reserve_new_capacityi32, ptr @String_B__EQ_otherString, ptr @String_B_decode_at_byte_indexi32, ptr @String_B_unchecked_index_xi32, ptr @String_B_unchecked_insert_xi32_valuei8, ptr @String_B_copy_, ptr @String_B__Self_empty_, ptr @String_B__Self_from_iterable_iterableIterableCharacter, ptr @String_B_append_charCharacter, ptr @String_B_length_, ptr @String_B_first_, ptr @String_B_last_, ptr @String_B_extend_otherCollectionCharacter_extend_otherIterableT_extend_otherString, ptr @String_B_get_indexi32, ptr @String_B_index_of_targetT_eqFunctionT._T_to_Bool, ptr @String_B_size_, ptr @String_B_is_empty_, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherCollectionT_chain_otherIterableT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherIterableU_product_otherCollectionU, ptr @String_B_repr_, ptr @String_byte_length_, ptr @String_capacity_, ptr @String__Self_from_bytes_source_bytesBufferi8_source_leni32, ptr @String__Self_from_bytes_lossy_source_bytesBufferi8_source_leni32, ptr @String__Self_from_c_string_c_stringBufferi8, ptr @String_init_, ptr @String_init_capacityi32, ptr @String_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32, ptr @String_c_string_, ptr @String_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32, ptr @String_reserve_new_capacityi32, ptr @String__EQ_otherString, ptr @String_decode_at_byte_indexi32, ptr @String_unchecked_index_xi32, ptr @String_unchecked_insert_xi32_valuei8, ptr @String_copy_, ptr @String__Self_empty_, ptr @String__Self_from_iterable_iterableIterableCharacter, ptr @String_append_charCharacter, ptr @List_length_, ptr @List_first_, ptr @List_last_, ptr @String_extend_otherCollectionCharacter, ptr @List_extend_otherIterableT, ptr @String_extend_otherString, ptr @List_get_indexi32, ptr @List_index_of_targetT_eqFunctionT._T_to_Bool, ptr @String_size_, ptr @Collection_is_empty_, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Collection_chain_otherCollectionT, ptr @Iterable_chain_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @String_repr_, ptr @String_field_String_0, ptr @String_B__Self_empty_, ptr @String_B__Self_from_iterable_iterableIterableCharacter, ptr @String_B_append_charCharacter, ptr @String_B_length_, ptr @String_B_first_, ptr @String_B_last_, ptr @String_B_extend_otherCollectionCharacter_extend_otherIterableT_extend_otherString, ptr @String_B_get_indexi32, ptr @String_B_index_of_targetT_eqFunctionT._T_to_Bool, ptr @String_B_size_, ptr @String_B_is_empty_, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherCollectionT_chain_otherIterableT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherIterableU_product_otherCollectionU, ptr @String__Self_empty_, ptr @String__Self_from_iterable_iterableIterableCharacter, ptr @String_append_charCharacter, ptr @List_length_, ptr @List_first_, ptr @List_last_, ptr @List_extend_otherIterableT, ptr @List_get_indexi32, ptr @List_index_of_targetT_eqFunctionT._T_to_Bool, ptr @String_size_, ptr @Collection_is_empty_, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Collection_chain_otherCollectionT, ptr @Iterable_chain_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @String_field_String_0, ptr @String_B_size_, ptr @String_B_is_empty_, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherCollectionT_chain_otherIterableT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherIterableU_product_otherCollectionU, ptr @String_size_, ptr @Collection_is_empty_, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Collection_chain_otherCollectionT, ptr @Iterable_chain_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @String_field_String_0, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherCollectionT_chain_otherIterableT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherIterableU_product_otherCollectionU, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @String_field_String_0, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherCollectionT_chain_otherIterableT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherIterableU_product_otherCollectionU, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @String_field_String_0, ptr @String_B_size_, ptr @String_B_is_empty_, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherCollectionT_chain_otherIterableT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherIterableU_product_otherCollectionU, ptr @String_size_, ptr @Collection_is_empty_, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Collection_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Collection_chain_otherCollectionT, ptr @Iterable_chain_otherIterableT, ptr @Collection_interleave_otherCollectionT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Collection_zip_otherCollectionU, ptr @Iterable_product_otherIterableU, ptr @Collection_product_otherCollectionU, ptr @String_field_String_0, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherCollectionT_chain_otherIterableT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherIterableU_product_otherCollectionU, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @String_field_String_0, ptr @String_B_iterator_, ptr @String_B_each_fFunctionT_to_Nothing, ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T, ptr @String_B_all_fFunctionT_to_Bool, ptr @String_B_any_fFunctionT_to_Bool, ptr @String_B_enumerate_, ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U, ptr @String_B_filter_fFunctionT_to_Bool, ptr @String_B_chain_otherCollectionT_chain_otherIterableT, ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT, ptr @String_B_zip_otherIterableU_zip_otherCollectionU, ptr @String_B_product_otherIterableU_product_otherCollectionU, ptr @String_iterator_, ptr @Iterable_each_fFunctionT_to_Nothing, ptr @Iterable_reduce_accumulatorT_fFunctionT._T_to_T, ptr @Iterable_all_fFunctionT_to_Bool, ptr @Iterable_any_fFunctionT_to_Bool, ptr @Collection_enumerate_, ptr @Iterable_map_fFunctionT_to_U, ptr @Iterable_filter_fFunctionT_to_Bool, ptr @Iterable_chain_otherIterableT, ptr @Iterable_interleave_otherIterableT, ptr @Iterable_zip_otherIterableU, ptr @Iterable_product_otherIterableU, ptr @String_B_repr_, ptr @String_repr_] }
@Character_hashtbl = constant [4 x ptr] [ptr @Character, ptr @Object, ptr @any_typ, ptr null]
@Character_offset_tbl = constant [4 x i32] [i32 10, i32 21, i32 10, i32 0]
@Character = constant { [3 x i64], [7 x ptr], [11 x ptr] } { [3 x i64] [i64 6681222582356018452, i64 6627277283128185911, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Character_hashtbl, ptr @Character_offset_tbl, ptr @_data_size_Character, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [11 x ptr] [ptr @Character_field_codepoint, ptr @Character_B_codepoint_, ptr @Character_B_init_codepointi32, ptr @Character_B_to_string_, ptr @Character_B__EQ_otherCharacter, ptr @Character_B_n_bytes_, ptr @Character_codepoint_, ptr @Character_init_codepointi32, ptr @Character_to_string_, ptr @Character__EQ_otherCharacter, ptr @Character_n_bytes_] }
@StringIterator_hashtbl = constant [8 x ptr] [ptr @Object, ptr null, ptr @any_typ, ptr null, ptr null, ptr @ConstantTimeIterator, ptr @StringIterator, ptr @Iterator]
@StringIterator_offset_tbl = constant [8 x i32] [i32 26, i32 0, i32 10, i32 0, i32 0, i32 17, i32 10, i32 23]
@StringIterator = constant { [3 x i64], [7 x ptr], [16 x ptr] } { [3 x i64] [i64 -7260570988945952630, i64 1174181672135278109, i64 7], [7 x ptr] [ptr @subtype_test, ptr @StringIterator_hashtbl, ptr @StringIterator_offset_tbl, ptr @_data_size_StringIterator, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [16 x ptr] [ptr @StringIterator_field_str, ptr @StringIterator_field_byte_index, ptr @StringIterator_field_StringIterator_0, ptr @StringIterator_B_init_strString, ptr @StringIterator_B_next_, ptr @StringIterator_init_strString, ptr @StringIterator_next_, ptr @StringIterator_field_StringIterator_0, ptr @StringIterator_B_next_, ptr @StringIterator_next_, ptr @StringIterator_field_StringIterator_0, ptr @StringIterator_B_next_, ptr @StringIterator_next_, ptr @StringIterator_field_StringIterator_0, ptr @StringIterator_B_next_, ptr @StringIterator_next_] }
@Stacktrace_hashtbl = constant [4 x ptr] [ptr @Object, ptr @any_typ, ptr null, ptr @Stacktrace]
@Stacktrace_offset_tbl = constant [4 x i32] [i32 16, i32 10, i32 0, i32 10]
@Stacktrace = constant { [3 x i64], [7 x ptr], [6 x ptr] } { [3 x i64] [i64 -59384212523717097, i64 -3773895667127586019, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Stacktrace_hashtbl, ptr @Stacktrace_offset_tbl, ptr @_data_size_Stacktrace, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [6 x ptr] [ptr @Stacktrace_field_stacktrace, ptr @Stacktrace_field_n_frames, ptr @Stacktrace_B_init_, ptr @Stacktrace_B_print_, ptr @Stacktrace_init_, ptr @Stacktrace_print_] }
@Exception_hashtbl = constant [4 x ptr] [ptr @any_typ, ptr null, ptr @Exception, ptr @Object]
@Exception_offset_tbl = constant [4 x i32] [i32 10, i32 0, i32 10, i32 24]
@Exception = constant { [3 x i64], [7 x ptr], [14 x ptr] } { [3 x i64] [i64 9027164862567808692, i64 -6443054882450048017, i64 3], [7 x ptr] [ptr @subtype_test, ptr @Exception_hashtbl, ptr @Exception_offset_tbl, ptr @_data_size_Exception, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [14 x ptr] [ptr @Exception_field_line_number, ptr @Exception_field_file_name, ptr @Exception_field_message, ptr @Exception_field_stacktrace, ptr @Exception_B_init_messageString, ptr @Exception_B_init_, ptr @Exception_B_set_info_line_numberi32_file_nameString, ptr @Exception_B_report_, ptr @Exception_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_report_, ptr @Exception_print_message_] }
@InvalidUTF8Error_hashtbl = constant [4 x ptr] [ptr @InvalidUTF8Error, ptr @Exception, ptr @Object, ptr @any_typ]
@InvalidUTF8Error_offset_tbl = constant [4 x i32] [i32 10, i32 24, i32 38, i32 10]
@InvalidUTF8Error = constant { [3 x i64], [7 x ptr], [28 x ptr] } { [3 x i64] [i64 4104693287331019315, i64 -8410750387227896931, i64 3], [7 x ptr] [ptr @subtype_test, ptr @InvalidUTF8Error_hashtbl, ptr @InvalidUTF8Error_offset_tbl, ptr @_data_size_InvalidUTF8Error, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [28 x ptr] [ptr @InvalidUTF8Error_field_line_number, ptr @InvalidUTF8Error_field_file_name, ptr @InvalidUTF8Error_field_message, ptr @InvalidUTF8Error_field_stacktrace, ptr @InvalidUTF8Error_B_init_messageString, ptr @InvalidUTF8Error_B_init_, ptr @InvalidUTF8Error_B_set_info_line_numberi32_file_nameString, ptr @InvalidUTF8Error_B_report_, ptr @InvalidUTF8Error_B_print_message_, ptr @Exception_init_messageString, ptr @InvalidUTF8Error_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_report_, ptr @Exception_print_message_, ptr @InvalidUTF8Error_field_line_number, ptr @InvalidUTF8Error_field_file_name, ptr @InvalidUTF8Error_field_message, ptr @InvalidUTF8Error_field_stacktrace, ptr @InvalidUTF8Error_B_init_messageString, ptr @InvalidUTF8Error_B_init_, ptr @InvalidUTF8Error_B_set_info_line_numberi32_file_nameString, ptr @InvalidUTF8Error_B_report_, ptr @InvalidUTF8Error_B_print_message_, ptr @Exception_init_messageString, ptr @InvalidUTF8Error_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_report_, ptr @Exception_print_message_] }
@OutOfBounds_hashtbl = constant [4 x ptr] [ptr @OutOfBounds, ptr @Exception, ptr @Object, ptr @any_typ]
@OutOfBounds_offset_tbl = constant [4 x i32] [i32 10, i32 27, i32 41, i32 10]
@OutOfBounds = constant { [3 x i64], [7 x ptr], [31 x ptr] } { [3 x i64] [i64 5348403617834207535, i64 4546686148565693703, i64 3], [7 x ptr] [ptr @subtype_test, ptr @OutOfBounds_hashtbl, ptr @OutOfBounds_offset_tbl, ptr @_data_size_OutOfBounds, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [31 x ptr] [ptr @OutOfBounds_field_details, ptr @OutOfBounds_field_line_number, ptr @OutOfBounds_field_file_name, ptr @OutOfBounds_field_message, ptr @OutOfBounds_field_stacktrace, ptr @OutOfBounds_B_init_boundsi32_indexi32, ptr @OutOfBounds_B_init_messageString, ptr @OutOfBounds_B_init_, ptr @OutOfBounds_B_set_info_line_numberi32_file_nameString, ptr @OutOfBounds_B_report_, ptr @OutOfBounds_B_print_message_, ptr @OutOfBounds_init_boundsi32_indexi32, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_report_, ptr @OutOfBounds_print_message_, ptr @OutOfBounds_field_line_number, ptr @OutOfBounds_field_file_name, ptr @OutOfBounds_field_message, ptr @OutOfBounds_field_stacktrace, ptr @OutOfBounds_B_init_messageString, ptr @OutOfBounds_B_init_, ptr @OutOfBounds_B_set_info_line_numberi32_file_nameString, ptr @OutOfBounds_B_report_, ptr @OutOfBounds_B_print_message_, ptr @Exception_init_messageString, ptr @Exception_init_, ptr @Exception_set_info_line_numberi32_file_nameString, ptr @Exception_report_, ptr @OutOfBounds_print_message_] }
@OutOfBoundsDetails_hashtbl = constant [4 x ptr] [ptr null, ptr @any_typ, ptr @Object, ptr @OutOfBoundsDetails]
@OutOfBoundsDetails_offset_tbl = constant [4 x i32] [i32 0, i32 10, i32 16, i32 10]
@OutOfBoundsDetails = constant { [3 x i64], [7 x ptr], [6 x ptr] } { [3 x i64] [i64 4650630525701360429, i64 1119356342542586175, i64 3], [7 x ptr] [ptr @subtype_test, ptr @OutOfBoundsDetails_hashtbl, ptr @OutOfBoundsDetails_offset_tbl, ptr @_data_size_OutOfBoundsDetails, ptr @_box_Default, ptr @_unbox_Default, ptr @_size_Default], [6 x ptr] [ptr @OutOfBoundsDetails_field_bounds, ptr @OutOfBoundsDetails_field_index, ptr @OutOfBoundsDetails_B_init_boundsi32_indexi32, ptr @OutOfBoundsDetails_B_report_, ptr @OutOfBoundsDetails_init_boundsi32_indexi32, ptr @OutOfBoundsDetails_report_] }
@String_field_bytes = internal constant { ptr, ptr } { ptr @String_getter_bytes, ptr @String_setter_bytes }
@String_field_byte_length = internal constant { ptr, ptr } { ptr @String_getter_byte_length, ptr @String_setter_byte_length }
@String_field_char_length = internal constant { ptr, ptr } { ptr @String_getter_char_length, ptr @String_setter_char_length }
@String_field_capacity = internal constant { ptr, ptr } { ptr @String_getter_capacity, ptr @String_setter_capacity }
@Character_field_codepoint = internal constant { ptr, ptr } { ptr @Character_getter_codepoint, ptr @Character_setter_codepoint }
@StringIterator_field_str = internal constant { ptr, ptr } { ptr @StringIterator_getter_str, ptr @StringIterator_setter_str }
@StringIterator_field_byte_index = internal constant { ptr, ptr } { ptr @StringIterator_getter_byte_index, ptr @StringIterator_setter_byte_index }
@Stacktrace_field_stacktrace = internal constant { ptr, ptr } { ptr @Stacktrace_getter_stacktrace, ptr @Stacktrace_setter_stacktrace }
@Stacktrace_field_n_frames = internal constant { ptr, ptr } { ptr @Stacktrace_getter_n_frames, ptr @Stacktrace_setter_n_frames }
@Exception_field_line_number = internal constant { ptr, ptr } { ptr @Exception_getter_line_number, ptr @Exception_setter_line_number }
@Exception_field_file_name = internal constant { ptr, ptr } { ptr @Exception_getter_file_name, ptr @Exception_setter_file_name }
@Exception_field_message = internal constant { ptr, ptr } { ptr @Exception_getter_message, ptr @Exception_setter_message }
@Exception_field_stacktrace = internal constant { ptr, ptr } { ptr @Exception_getter_stacktrace, ptr @Exception_setter_stacktrace }
@InvalidUTF8Error_field_line_number = internal constant { ptr, ptr } { ptr @InvalidUTF8Error_getter_line_number, ptr @InvalidUTF8Error_setter_line_number }
@InvalidUTF8Error_field_file_name = internal constant { ptr, ptr } { ptr @InvalidUTF8Error_getter_file_name, ptr @InvalidUTF8Error_setter_file_name }
@InvalidUTF8Error_field_message = internal constant { ptr, ptr } { ptr @InvalidUTF8Error_getter_message, ptr @InvalidUTF8Error_setter_message }
@InvalidUTF8Error_field_stacktrace = internal constant { ptr, ptr } { ptr @InvalidUTF8Error_getter_stacktrace, ptr @InvalidUTF8Error_setter_stacktrace }
@OutOfBounds_field_details = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_details, ptr @OutOfBounds_setter_details }
@OutOfBounds_field_line_number = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_line_number, ptr @OutOfBounds_setter_line_number }
@OutOfBounds_field_file_name = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_file_name, ptr @OutOfBounds_setter_file_name }
@OutOfBounds_field_message = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_message, ptr @OutOfBounds_setter_message }
@OutOfBounds_field_stacktrace = internal constant { ptr, ptr } { ptr @OutOfBounds_getter_stacktrace, ptr @OutOfBounds_setter_stacktrace }
@OutOfBoundsDetails_field_bounds = internal constant { ptr, ptr } { ptr @OutOfBoundsDetails_getter_bounds, ptr @OutOfBoundsDetails_setter_bounds }
@OutOfBoundsDetails_field_index = internal constant { ptr, ptr } { ptr @OutOfBoundsDetails_getter_index, ptr @OutOfBoundsDetails_setter_index }

declare i32 @printf(ptr, ...)

declare ptr @bump_malloc(i64)

declare void @free(ptr)

declare void @setup_landing_pad()

declare void @anoint_trampoline(ptr)

declare ptr @adjust_trampoline(ptr)

declare ptr @coroutine_create(ptr, ptr)

declare void @arg_passer(ptr)

declare void @arg_buffer_filler(ptr)

declare void @coroutine_yield(ptr)

declare void @coroutine_yield_cold(ptr)

declare ptr @get_current_coroutine()

declare i32 @get_offset(ptr, ptr)

declare void @assume_offset(ptr, ptr)

declare { ptr, i160 } @_box_Default(ptr, ptr)

declare void @_unbox_Default({ ptr, i160 }, ptr, ptr)

declare { i64, i64 } @_size_Default(ptr)

declare void @_unbox_union_typ({ ptr, i160 }, ptr, ptr)

declare { i64, i64 } @_data_size_tuple_typ(ptr)

declare { i64, i64 } @_data_size_union_typ(ptr)

declare i1 @subtype_test(i64, i64, i64, i64, ptr)

declare i1 @subtype_test_wrapper(ptr, i64, i64, i64, i64, ptr)

declare { i64, i64 } @size_wrapper(ptr, ptr)

declare ptr @typegetter_wrapper(ptr, ptr)

declare { ptr, i160 } @box_wrapper(ptr, ptr, ptr)

declare void @unbox_wrapper(ptr, { ptr, i160 }, ptr, ptr)

declare ptr @behavior_wrapper(ptr, { ptr, ptr, ptr, i32 }, ptr)

declare ptr @class_behavior_wrapper(ptr, ptr)

declare void @coroutine_call(ptr)

declare i64 @capture_backtrace(i64, { ptr })

declare void @print_backtrace({ ptr }, i64)

define { i64, i64 } @_data_size_Unicode(ptr %0) {
  ret { i64, i64 } { i64 0, i64 1 }
}

define i32 @Unicode__Self_replacement_codepoint_(ptr %0) {
  %2 = alloca i32, align 4
  store i32 -3, ptr %2, align 4
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

define ptr @Unicode_B__Self_replacement_codepoint_(ptr %0) {
  %2 = call ptr @llvm.invariant.start.p0(i64 0, ptr %0)
  %3 = alloca ptr, align 8
  store i32 5, ptr %3, align 4
  %4 = load i32, ptr %3, align 4
  %5 = getelementptr [10 x ptr], ptr @Unicode, i32 0, i32 %4
  %6 = getelementptr ptr, ptr %5, i32 10
  %7 = load ptr, ptr %6, align 8
  ret ptr %7
}

define { ptr, ptr, ptr, i32 } @Unicode__Self_replacement_str_(ptr %0) {
  %2 = alloca [0 x ptr], align 8
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %2)
  %4 = call ptr @llvm.invariant.start.p0(i64 80, ptr @Unicode)
  %5 = load ptr, ptr getelementptr (ptr, ptr getelementptr (ptr, ptr @Unicode, i32 10), i32 2), align 8
  %6 = alloca {}, align 8
  %7 = call ptr @class_behavior_wrapper(ptr %5, ptr %6)
  %8 = call { ptr } %7(ptr %2)
  %9 = alloca ptr, align 8
  store { ptr } %8, ptr %9, align 8
  %10 = alloca i32, align 4
  store i32 3, ptr %10, align 4
  %11 = alloca i32, align 4
  store i32 1, ptr %11, align 4
  %12 = alloca i32, align 4
  store i32 4, ptr %12, align 4
  %13 = alloca [1 x ptr], align 8
  store ptr @String, ptr %13, align 8
  %14 = load ptr, ptr %13, align 8
  %15 = getelementptr ptr, ptr %14, i32 6
  %16 = load ptr, ptr %15, align 8
  %17 = call { i64, i64 } @size_wrapper(ptr %16, ptr %13)
  %18 = extractvalue { i64, i64 } %17, 0
  %19 = call ptr @bump_malloc(i64 %18)
  %20 = alloca i32, align 4
  %21 = alloca ptr, align 8
  %22 = alloca ptr, align 8
  %23 = alloca ptr, align 8
  store ptr @String, ptr %23, align 8
  store ptr %19, ptr %22, align 8
  store i32 10, ptr %20, align 4
  %24 = alloca [0 x ptr], align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 0, ptr %24)
  %26 = call ptr @llvm.invariant.start.p0(i64 80, ptr @Unicode)
  %27 = load ptr, ptr getelementptr (ptr, ptr getelementptr (ptr, ptr @Unicode, i32 10), i32 2), align 8
  %28 = alloca {}, align 8
  %29 = call ptr @class_behavior_wrapper(ptr %27, ptr %28)
  %30 = call { ptr } %29(ptr %24)
  %31 = alloca ptr, align 8
  store { ptr } %30, ptr %31, align 8
  %32 = alloca i32, align 4
  store i32 3, ptr %32, align 4
  %33 = alloca i32, align 4
  store i32 1, ptr %33, align 4
  %34 = alloca i32, align 4
  store i32 4, ptr %34, align 4
  %35 = load ptr, ptr %31, align 8
  %36 = insertvalue { ptr } undef, ptr %35, 0
  %37 = load i32, ptr %32, align 4
  %38 = load i32, ptr %33, align 4
  %39 = load i32, ptr %34, align 4
  %40 = load ptr, ptr %23, align 8
  %41 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %40, 0
  %42 = load ptr, ptr %22, align 8
  %43 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %42, 1
  %44 = load ptr, ptr %21, align 8
  %45 = insertvalue { ptr, ptr, ptr, i32 } %43, ptr %44, 2
  %46 = load i32, ptr %20, align 4
  %47 = insertvalue { ptr, ptr, ptr, i32 } %45, i32 %46, 3
  %48 = alloca [4 x ptr], align 8
  %49 = getelementptr [4 x ptr], ptr %48, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %49, align 8
  %50 = getelementptr [4 x ptr], ptr %48, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %50, align 8
  %51 = getelementptr [4 x ptr], ptr %48, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %51, align 8
  %52 = getelementptr [4 x ptr], ptr %48, i32 0, i32 3
  store ptr @_parameterization_i32, ptr %52, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 16, ptr %48)
  %54 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %40)
  %55 = getelementptr ptr, ptr %40, i32 %46
  %56 = getelementptr ptr, ptr %55, i32 12
  %57 = load ptr, ptr %56, align 8
  %58 = alloca { ptr, ptr, ptr, ptr }, align 8
  %59 = getelementptr { ptr, ptr, ptr, ptr }, ptr %58, i32 0, i32 0
  store ptr @buffer_typ, ptr %59, align 8
  %60 = getelementptr { ptr, ptr, ptr, ptr }, ptr %58, i32 0, i32 1
  store ptr @i32_typ, ptr %60, align 8
  %61 = getelementptr { ptr, ptr, ptr, ptr }, ptr %58, i32 0, i32 2
  store ptr @i32_typ, ptr %61, align 8
  %62 = getelementptr { ptr, ptr, ptr, ptr }, ptr %58, i32 0, i32 3
  store ptr @i32_typ, ptr %62, align 8
  %63 = call ptr @behavior_wrapper(ptr %57, { ptr, ptr, ptr, i32 } %47, ptr %58)
  call void %63({ ptr, ptr, ptr, i32 } %47, { ptr, ptr, ptr, i32 } %47, ptr %48, { ptr } %36, i32 %37, i32 %38, i32 %39)
  %64 = alloca i32, align 4
  %65 = alloca ptr, align 8
  %66 = alloca ptr, align 8
  %67 = alloca ptr, align 8
  %68 = load ptr, ptr %23, align 8
  store ptr %68, ptr %67, align 8
  %69 = load ptr, ptr %22, align 8
  store ptr %69, ptr %66, align 8
  %70 = load ptr, ptr %21, align 8
  store ptr %70, ptr %65, align 8
  %71 = load i32, ptr %20, align 4
  store i32 %71, ptr %64, align 4
  %72 = load ptr, ptr %67, align 8
  %73 = call i32 @get_offset(ptr %72, ptr @String)
  store i32 %73, ptr %64, align 4
  %74 = load ptr, ptr %67, align 8
  %75 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %74, 0
  %76 = load ptr, ptr %66, align 8
  %77 = insertvalue { ptr, ptr, ptr, i32 } %75, ptr %76, 1
  %78 = load ptr, ptr %65, align 8
  %79 = insertvalue { ptr, ptr, ptr, i32 } %77, ptr %78, 2
  %80 = load i32, ptr %64, align 4
  %81 = insertvalue { ptr, ptr, ptr, i32 } %79, i32 %80, 3
  ret { ptr, ptr, ptr, i32 } %81
}

define ptr @Unicode_B__Self_replacement_str_(ptr %0) {
  %2 = call ptr @llvm.invariant.start.p0(i64 0, ptr %0)
  %3 = alloca ptr, align 8
  store i32 6, ptr %3, align 4
  %4 = load i32, ptr %3, align 4
  %5 = getelementptr [10 x ptr], ptr @Unicode, i32 0, i32 %4
  %6 = getelementptr ptr, ptr %5, i32 10
  %7 = load ptr, ptr %6, align 8
  ret ptr %7
}

define { ptr } @Unicode__Self_replacement_buf_(ptr %0) {
  %2 = alloca i32, align 4
  store i32 3, ptr %2, align 4
  %3 = alloca i64, align 8
  %4 = load i32, ptr %2, align 4
  %5 = sext i32 %4 to i64
  store i64 %5, ptr %3, align 4
  %6 = load i64, ptr %3, align 4
  %7 = alloca ptr, align 8
  %8 = mul i64 %6, ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
  %9 = call ptr @bump_malloc(i64 %8)
  store ptr %9, ptr %7, align 8
  %10 = alloca ptr, align 8
  %11 = getelementptr { ptr }, ptr %7, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %10, align 8
  %13 = alloca i32, align 4
  store i32 0, ptr %13, align 4
  %14 = alloca i8, align 1
  store i8 -17, ptr %14, align 1
  %15 = alloca i64, align 8
  %16 = load i32, ptr %13, align 4
  %17 = sext i32 %16 to i64
  store i64 %17, ptr %15, align 4
  %18 = load ptr, ptr %10, align 8
  %19 = load i64, ptr %15, align 4
  %20 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %19
  %21 = getelementptr i8, ptr %18, i64 %20
  %22 = load i8, ptr %14, align 1
  store i8 %22, ptr %21, align 1
  %23 = alloca i32, align 4
  store i32 1, ptr %23, align 4
  %24 = alloca i8, align 1
  store i8 -65, ptr %24, align 1
  %25 = alloca i64, align 8
  %26 = load i32, ptr %23, align 4
  %27 = sext i32 %26 to i64
  store i64 %27, ptr %25, align 4
  %28 = load ptr, ptr %10, align 8
  %29 = load i64, ptr %25, align 4
  %30 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %29
  %31 = getelementptr i8, ptr %28, i64 %30
  %32 = load i8, ptr %24, align 1
  store i8 %32, ptr %31, align 1
  %33 = alloca i32, align 4
  store i32 2, ptr %33, align 4
  %34 = alloca i8, align 1
  store i8 -67, ptr %34, align 1
  %35 = alloca i64, align 8
  %36 = load i32, ptr %33, align 4
  %37 = sext i32 %36 to i64
  store i64 %37, ptr %35, align 4
  %38 = load ptr, ptr %10, align 8
  %39 = load i64, ptr %35, align 4
  %40 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %39
  %41 = getelementptr i8, ptr %38, i64 %40
  %42 = load i8, ptr %34, align 1
  store i8 %42, ptr %41, align 1
  %43 = load ptr, ptr %10, align 8
  %44 = insertvalue { ptr } undef, ptr %43, 0
  ret { ptr } %44
}

define ptr @Unicode_B__Self_replacement_buf_(ptr %0) {
  %2 = call ptr @llvm.invariant.start.p0(i64 0, ptr %0)
  %3 = alloca ptr, align 8
  store i32 7, ptr %3, align 4
  %4 = load i32, ptr %3, align 4
  %5 = getelementptr [10 x ptr], ptr @Unicode, i32 0, i32 %4
  %6 = getelementptr ptr, ptr %5, i32 10
  %7 = load ptr, ptr %6, align 8
  ret ptr %7
}

define { ptr, i64 } @Unicode__Self_decode_one_bytesBufferi8_indexi32_leni32(ptr %0, { ptr } %1, i32 %2, i32 %3) {
  %5 = alloca [0 x i8], align 1
  %6 = alloca { ptr, i64 }, align 8
  %7 = alloca i64, align 8
  %8 = alloca i8, align 1
  %9 = alloca i32, align 4
  %10 = alloca i32, align 4
  %11 = alloca i32, align 4
  %12 = alloca i32, align 4
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %15 = alloca i1, align 1
  %16 = alloca i32, align 4
  %17 = alloca i32, align 4
  %18 = alloca i32, align 4
  %19 = alloca i32, align 4
  %20 = alloca i32, align 4
  %21 = alloca i1, align 1
  %22 = alloca i32, align 4
  %23 = alloca i32, align 4
  %24 = alloca i32, align 4
  %25 = alloca i32, align 4
  %26 = alloca i32, align 4
  %27 = alloca i32, align 4
  %28 = alloca i1, align 1
  %29 = alloca i32, align 4
  %30 = alloca i32, align 4
  %31 = alloca i32, align 4
  %32 = alloca i32, align 4
  %33 = alloca i32, align 4
  %34 = alloca i32, align 4
  %35 = alloca i1, align 1
  %36 = alloca i32, align 4
  %37 = alloca i32, align 4
  %38 = alloca i32, align 4
  %39 = alloca i32, align 4
  %40 = alloca i1, align 1
  %41 = alloca i1, align 1
  %42 = alloca i32, align 4
  %43 = alloca i1, align 1
  %44 = alloca [0 x i8], align 1
  %45 = alloca { ptr, i64 }, align 8
  %46 = alloca i32, align 4
  %47 = alloca i32, align 4
  %48 = alloca i32, align 4
  %49 = alloca [1 x ptr], align 8
  %50 = alloca i32, align 4
  %51 = alloca ptr, align 8
  %52 = alloca ptr, align 8
  %53 = alloca ptr, align 8
  %54 = alloca i32, align 4
  %55 = alloca i32, align 4
  %56 = alloca i32, align 4
  %57 = alloca [2 x ptr], align 8
  %58 = alloca { ptr, ptr }, align 8
  %59 = alloca [0 x ptr], align 8
  %60 = alloca {}, align 8
  %61 = alloca { ptr, ptr, ptr, i32 }, align 8
  %62 = alloca i32, align 4
  %63 = alloca ptr, align 8
  %64 = alloca ptr, align 8
  %65 = alloca ptr, align 8
  %66 = alloca i32, align 4
  %67 = alloca ptr, align 8
  %68 = alloca ptr, align 8
  %69 = alloca ptr, align 8
  %70 = alloca [0 x ptr], align 8
  %71 = alloca {}, align 8
  %72 = alloca { ptr, i160 }, align 8
  %73 = alloca i32, align 4
  %74 = alloca ptr, align 8
  %75 = alloca i1, align 1
  %76 = alloca i1, align 1
  %77 = alloca i1, align 1
  %78 = alloca i32, align 4
  %79 = alloca i32, align 4
  %80 = alloca i64, align 8
  %81 = alloca i8, align 1
  %82 = alloca i32, align 4
  %83 = alloca i32, align 4
  %84 = alloca i32, align 4
  %85 = alloca i32, align 4
  %86 = alloca i1, align 1
  %87 = alloca [0 x i8], align 1
  %88 = alloca { ptr, i64 }, align 8
  %89 = alloca i32, align 4
  %90 = alloca i32, align 4
  %91 = alloca i32, align 4
  %92 = alloca i32, align 4
  %93 = alloca i32, align 4
  %94 = alloca i32, align 4
  %95 = alloca ptr, align 8
  %96 = alloca i32, align 4
  %97 = alloca i1, align 1
  %98 = alloca i1, align 1
  %99 = alloca i32, align 4
  %100 = alloca i1, align 1
  %101 = alloca i1, align 1
  %102 = alloca i32, align 4
  %103 = alloca i1, align 1
  %104 = alloca i1, align 1
  %105 = alloca i32, align 4
  %106 = alloca i1, align 1
  %107 = alloca i1, align 1
  %108 = alloca i32, align 4
  %109 = alloca i1, align 1
  %110 = alloca i1, align 1
  %111 = alloca i32, align 4
  %112 = alloca i1, align 1
  %113 = alloca i1, align 1
  %114 = alloca i32, align 4
  %115 = alloca i1, align 1
  %116 = alloca i1, align 1
  %117 = alloca i32, align 4
  %118 = alloca i1, align 1
  %119 = alloca i1, align 1
  %120 = alloca i32, align 4
  %121 = alloca i1, align 1
  %122 = alloca [0 x i8], align 1
  %123 = alloca { ptr, i64 }, align 8
  %124 = alloca <2 x i32>, align 8
  %125 = alloca i64, align 8
  %126 = alloca ptr, align 8
  %127 = alloca ptr, align 8
  store { ptr } %1, ptr %127, align 8
  %128 = alloca i32, align 4
  store i32 %2, ptr %128, align 4
  %129 = alloca i32, align 4
  store i32 %3, ptr %129, align 4
  %130 = load i32, ptr %128, align 4
  %131 = load i32, ptr %129, align 4
  %132 = icmp sge i32 %130, %131
  %133 = alloca i1, align 1
  %134 = zext i1 %132 to i8
  store i8 %134, ptr %133, align 1
  %135 = load i8, ptr %133, align 1
  %136 = trunc i8 %135 to i1
  br i1 %136, label %137, label %142

137:                                              ; preds = %515, %4
  %138 = phi ptr [ %237, %515 ], [ %6, %4 ]
  %139 = phi ptr [ %238, %515 ], [ %5, %4 ]
  %140 = phi { ptr, i64 } [ %239, %515 ], [ poison, %4 ]
  %141 = phi i32 [ %240, %515 ], [ 0, %4 ]
  br label %516

142:                                              ; preds = %4
  %143 = load i32, ptr %128, align 4
  %144 = sext i32 %143 to i64
  store i64 %144, ptr %7, align 4
  %145 = load ptr, ptr %127, align 8
  %146 = load i64, ptr %7, align 4
  %147 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %146
  %148 = getelementptr i8, ptr %145, i64 %147
  %149 = load i8, ptr %148, align 1
  store i8 %149, ptr %8, align 1
  %150 = load i8, ptr %8, align 1
  %151 = sext i8 %150 to i32
  store i32 %151, ptr %9, align 4
  store i32 0, ptr %10, align 4
  store i32 0, ptr %11, align 4
  store i32 -128, ptr %12, align 4
  %152 = load i32, ptr %9, align 4
  %153 = load i32, ptr %12, align 4
  %154 = and i32 %152, %153
  store i32 %154, ptr %13, align 4
  store i32 0, ptr %14, align 4
  %155 = load i32, ptr %13, align 4
  %156 = load i32, ptr %14, align 4
  %157 = icmp eq i32 %155, %156
  %158 = zext i1 %157 to i8
  store i8 %158, ptr %15, align 1
  %159 = load i8, ptr %15, align 1
  %160 = trunc i8 %159 to i1
  br i1 %160, label %161, label %165

161:                                              ; preds = %142
  %162 = load i32, ptr %9, align 4
  store i32 %162, ptr %16, align 4
  store i32 1, ptr %17, align 4
  %163 = load i32, ptr %17, align 4
  store i32 %163, ptr %11, align 4
  %164 = load i32, ptr %16, align 4
  store i32 %164, ptr %10, align 4
  br label %165

165:                                              ; preds = %161, %142
  store i32 -32, ptr %18, align 4
  %166 = load i32, ptr %9, align 4
  %167 = load i32, ptr %18, align 4
  %168 = and i32 %166, %167
  store i32 %168, ptr %19, align 4
  store i32 -64, ptr %20, align 4
  %169 = load i32, ptr %19, align 4
  %170 = load i32, ptr %20, align 4
  %171 = icmp eq i32 %169, %170
  %172 = zext i1 %171 to i8
  store i8 %172, ptr %21, align 1
  %173 = load i8, ptr %21, align 1
  %174 = trunc i8 %173 to i1
  br i1 %174, label %175, label %181

175:                                              ; preds = %165
  store i32 31, ptr %22, align 4
  %176 = load i32, ptr %9, align 4
  %177 = load i32, ptr %22, align 4
  %178 = and i32 %176, %177
  store i32 %178, ptr %23, align 4
  store i32 2, ptr %24, align 4
  %179 = load i32, ptr %24, align 4
  store i32 %179, ptr %11, align 4
  %180 = load i32, ptr %23, align 4
  store i32 %180, ptr %10, align 4
  br label %181

181:                                              ; preds = %175, %165
  store i32 -16, ptr %25, align 4
  %182 = load i32, ptr %9, align 4
  %183 = load i32, ptr %25, align 4
  %184 = and i32 %182, %183
  store i32 %184, ptr %26, align 4
  store i32 -32, ptr %27, align 4
  %185 = load i32, ptr %26, align 4
  %186 = load i32, ptr %27, align 4
  %187 = icmp eq i32 %185, %186
  %188 = zext i1 %187 to i8
  store i8 %188, ptr %28, align 1
  %189 = load i8, ptr %28, align 1
  %190 = trunc i8 %189 to i1
  br i1 %190, label %191, label %197

191:                                              ; preds = %181
  store i32 15, ptr %29, align 4
  %192 = load i32, ptr %9, align 4
  %193 = load i32, ptr %29, align 4
  %194 = and i32 %192, %193
  store i32 %194, ptr %30, align 4
  store i32 3, ptr %31, align 4
  %195 = load i32, ptr %31, align 4
  store i32 %195, ptr %11, align 4
  %196 = load i32, ptr %30, align 4
  store i32 %196, ptr %10, align 4
  br label %197

197:                                              ; preds = %191, %181
  store i32 -8, ptr %32, align 4
  %198 = load i32, ptr %9, align 4
  %199 = load i32, ptr %32, align 4
  %200 = and i32 %198, %199
  store i32 %200, ptr %33, align 4
  store i32 -16, ptr %34, align 4
  %201 = load i32, ptr %33, align 4
  %202 = load i32, ptr %34, align 4
  %203 = icmp eq i32 %201, %202
  %204 = zext i1 %203 to i8
  store i8 %204, ptr %35, align 1
  %205 = load i8, ptr %35, align 1
  %206 = trunc i8 %205 to i1
  br i1 %206, label %207, label %213

207:                                              ; preds = %197
  store i32 7, ptr %36, align 4
  %208 = load i32, ptr %9, align 4
  %209 = load i32, ptr %36, align 4
  %210 = and i32 %208, %209
  store i32 %210, ptr %37, align 4
  store i32 4, ptr %38, align 4
  %211 = load i32, ptr %38, align 4
  store i32 %211, ptr %11, align 4
  %212 = load i32, ptr %37, align 4
  store i32 %212, ptr %10, align 4
  br label %213

213:                                              ; preds = %207, %197
  store i32 0, ptr %39, align 4
  %214 = load i32, ptr %11, align 4
  %215 = load i32, ptr %39, align 4
  %216 = icmp eq i32 %214, %215
  %217 = zext i1 %216 to i8
  store i8 %217, ptr %40, align 1
  %218 = load i8, ptr %40, align 1
  %219 = trunc i8 %218 to i1
  %220 = zext i1 %219 to i8
  store i8 %220, ptr %41, align 1
  br i1 %219, label %221, label %222

221:                                              ; preds = %213
  br label %233

222:                                              ; preds = %213
  %223 = load i32, ptr %128, align 4
  %224 = load i32, ptr %11, align 4
  %225 = add i32 %223, %224
  store i32 %225, ptr %42, align 4
  %226 = load i32, ptr %42, align 4
  %227 = load i32, ptr %129, align 4
  %228 = icmp sgt i32 %226, %227
  %229 = zext i1 %228 to i8
  store i8 %229, ptr %43, align 1
  %230 = load i8, ptr %43, align 1
  %231 = trunc i8 %230 to i1
  %232 = zext i1 %231 to i8
  store i8 %232, ptr %41, align 1
  br label %233

233:                                              ; preds = %221, %222
  %234 = load i8, ptr %41, align 1
  %235 = trunc i8 %234 to i1
  br i1 %235, label %236, label %241

236:                                              ; preds = %388, %233
  %237 = phi ptr [ %389, %388 ], [ %45, %233 ]
  %238 = phi ptr [ %390, %388 ], [ %44, %233 ]
  %239 = phi { ptr, i64 } [ %391, %388 ], [ poison, %233 ]
  %240 = phi i32 [ %392, %388 ], [ 0, %233 ]
  br label %515

241:                                              ; preds = %233
  store i32 1, ptr %46, align 4
  store i32 1, ptr %47, align 4
  %242 = load i32, ptr %11, align 4
  %243 = load i32, ptr %47, align 4
  %244 = sub i32 %242, %243
  store i32 %244, ptr %48, align 4
  store ptr @Range, ptr %49, align 8
  %245 = load ptr, ptr %49, align 8
  %246 = getelementptr ptr, ptr %245, i32 6
  %247 = load ptr, ptr %246, align 8
  %248 = call { i64, i64 } @size_wrapper(ptr %247, ptr %49)
  %249 = extractvalue { i64, i64 } %248, 0
  %250 = call ptr @bump_malloc(i64 %249)
  store ptr @Range, ptr %53, align 8
  store ptr %250, ptr %52, align 8
  store i32 10, ptr %50, align 4
  store i32 1, ptr %54, align 4
  store i32 1, ptr %55, align 4
  %251 = load i32, ptr %11, align 4
  %252 = load i32, ptr %55, align 4
  %253 = sub i32 %251, %252
  store i32 %253, ptr %56, align 4
  %254 = load i32, ptr %54, align 4
  %255 = load i32, ptr %56, align 4
  %256 = load ptr, ptr %53, align 8
  %257 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %256, 0
  %258 = load ptr, ptr %52, align 8
  %259 = insertvalue { ptr, ptr, ptr, i32 } %257, ptr %258, 1
  %260 = load ptr, ptr %51, align 8
  %261 = insertvalue { ptr, ptr, ptr, i32 } %259, ptr %260, 2
  %262 = load i32, ptr %50, align 4
  %263 = insertvalue { ptr, ptr, ptr, i32 } %261, i32 %262, 3
  %264 = getelementptr [2 x ptr], ptr %57, i32 0, i32 0
  store ptr @_parameterization_i32, ptr %264, align 8
  %265 = getelementptr [2 x ptr], ptr %57, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %265, align 8
  %266 = call ptr @llvm.invariant.start.p0(i64 4, ptr %57)
  %267 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %256)
  %268 = getelementptr ptr, ptr %256, i32 %262
  %269 = getelementptr ptr, ptr %268, i32 5
  %270 = load ptr, ptr %269, align 8
  %271 = getelementptr { ptr, ptr }, ptr %58, i32 0, i32 0
  store ptr @i32_typ, ptr %271, align 8
  %272 = getelementptr { ptr, ptr }, ptr %58, i32 0, i32 1
  store ptr @i32_typ, ptr %272, align 8
  %273 = call ptr @behavior_wrapper(ptr %270, { ptr, ptr, ptr, i32 } %263, ptr %58)
  call void %273({ ptr, ptr, ptr, i32 } %263, { ptr, ptr, ptr, i32 } %263, ptr %57, i32 %254, i32 %255)
  %274 = load ptr, ptr %53, align 8
  %275 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %274, 0
  %276 = load ptr, ptr %52, align 8
  %277 = insertvalue { ptr, ptr, ptr, i32 } %275, ptr %276, 1
  %278 = load ptr, ptr %51, align 8
  %279 = insertvalue { ptr, ptr, ptr, i32 } %277, ptr %278, 2
  %280 = load i32, ptr %50, align 4
  %281 = insertvalue { ptr, ptr, ptr, i32 } %279, i32 %280, 3
  %282 = call ptr @llvm.invariant.start.p0(i64 0, ptr %59)
  %283 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %274)
  %284 = getelementptr ptr, ptr %274, i32 %280
  %285 = getelementptr ptr, ptr %284, i32 9
  %286 = load ptr, ptr %285, align 8
  %287 = call ptr @behavior_wrapper(ptr %286, { ptr, ptr, ptr, i32 } %281, ptr %60)
  %288 = call { ptr, ptr, ptr, i32 } %287({ ptr, ptr, ptr, i32 } %281, { ptr, ptr, ptr, i32 } %281, ptr %59)
  store { ptr, ptr, ptr, i32 } %288, ptr %61, align 8
  %289 = getelementptr { ptr, ptr, ptr, i32 }, ptr %61, i32 0, i32 0
  %290 = load ptr, ptr %289, align 8
  store ptr %290, ptr %65, align 8
  %291 = getelementptr { ptr, ptr, ptr, i32 }, ptr %61, i32 0, i32 1
  %292 = load ptr, ptr %291, align 8
  store ptr %292, ptr %64, align 8
  %293 = getelementptr { ptr, ptr, ptr, i32 }, ptr %61, i32 0, i32 2
  %294 = load ptr, ptr %293, align 8
  store ptr %294, ptr %63, align 8
  %295 = getelementptr { ptr, ptr, ptr, i32 }, ptr %61, i32 0, i32 3
  %296 = load i32, ptr %295, align 4
  store i32 %296, ptr %62, align 4
  %297 = load ptr, ptr %65, align 8
  %298 = call i32 @get_offset(ptr %297, ptr @RangeIterator)
  store i32 %298, ptr %62, align 4
  %299 = load ptr, ptr %65, align 8
  store ptr %299, ptr %69, align 8
  %300 = load ptr, ptr %64, align 8
  store ptr %300, ptr %68, align 8
  %301 = load ptr, ptr %63, align 8
  store ptr %301, ptr %67, align 8
  %302 = load i32, ptr %62, align 4
  store i32 %302, ptr %66, align 4
  %303 = getelementptr { ptr, i32 }, ptr %72, i32 0, i32 0
  %304 = getelementptr { ptr, i32 }, ptr %72, i32 0, i32 1
  br label %305

305:                                              ; preds = %384, %241
  %306 = load ptr, ptr %69, align 8
  %307 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %306, 0
  %308 = load ptr, ptr %68, align 8
  %309 = insertvalue { ptr, ptr, ptr, i32 } %307, ptr %308, 1
  %310 = load ptr, ptr %67, align 8
  %311 = insertvalue { ptr, ptr, ptr, i32 } %309, ptr %310, 2
  %312 = load i32, ptr %66, align 4
  %313 = insertvalue { ptr, ptr, ptr, i32 } %311, i32 %312, 3
  %314 = call ptr @llvm.invariant.start.p0(i64 0, ptr %70)
  %315 = call ptr @llvm.invariant.start.p0(i64 88, ptr %306)
  %316 = getelementptr ptr, ptr %306, i32 %312
  %317 = getelementptr ptr, ptr %316, i32 5
  %318 = load ptr, ptr %317, align 8
  %319 = call ptr @behavior_wrapper(ptr %318, { ptr, ptr, ptr, i32 } %313, ptr %71)
  %320 = call { ptr, i160 } %319({ ptr, ptr, ptr, i32 } %313, { ptr, ptr, ptr, i32 } %313, ptr %70)
  store { ptr, i160 } %320, ptr %72, align 8
  %321 = load ptr, ptr %303, align 8
  store ptr %321, ptr %74, align 8
  %322 = load i32, ptr %304, align 4
  store i32 %322, ptr %73, align 4
  store i8 0, ptr %75, align 1
  %323 = load ptr, ptr %74, align 8
  %324 = ptrtoint ptr %323 to i64
  %325 = icmp eq i64 %324, ptrtoint (ptr @nil_typ to i64)
  %326 = icmp eq i64 %324, 0
  %327 = or i1 %325, %326
  %328 = zext i1 %327 to i8
  store i8 %328, ptr %76, align 1
  %329 = load i8, ptr %75, align 1
  %330 = trunc i8 %329 to i1
  %331 = load i8, ptr %76, align 1
  %332 = trunc i8 %331 to i1
  %333 = icmp eq i1 %330, %332
  %334 = zext i1 %333 to i8
  store i8 %334, ptr %77, align 1
  %335 = load i8, ptr %77, align 1
  %336 = trunc i8 %335 to i1
  br i1 %336, label %337, label %378

337:                                              ; preds = %305
  %338 = load i32, ptr %73, align 4
  store i32 %338, ptr %78, align 4
  %339 = load i32, ptr %128, align 4
  %340 = load i32, ptr %78, align 4
  %341 = add i32 %339, %340
  store i32 %341, ptr %79, align 4
  %342 = load i32, ptr %79, align 4
  %343 = sext i32 %342 to i64
  store i64 %343, ptr %80, align 4
  %344 = load ptr, ptr %127, align 8
  %345 = load i64, ptr %80, align 4
  %346 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %345
  %347 = getelementptr i8, ptr %344, i64 %346
  %348 = load i8, ptr %347, align 1
  store i8 %348, ptr %81, align 1
  %349 = load i8, ptr %81, align 1
  %350 = sext i8 %349 to i32
  store i32 %350, ptr %82, align 4
  store i32 -64, ptr %83, align 4
  %351 = load i32, ptr %82, align 4
  %352 = load i32, ptr %83, align 4
  %353 = and i32 %351, %352
  store i32 %353, ptr %84, align 4
  store i32 -128, ptr %85, align 4
  %354 = load i32, ptr %84, align 4
  %355 = load i32, ptr %85, align 4
  %356 = icmp ne i32 %354, %355
  %357 = zext i1 %356 to i8
  store i8 %357, ptr %86, align 1
  %358 = load i8, ptr %86, align 1
  %359 = trunc i8 %358 to i1
  %360 = zext i1 %359 to i32
  %361 = xor i1 %359, true
  %362 = zext i1 %361 to i32
  br i1 %359, label %363, label %364

363:                                              ; preds = %337
  br label %378

364:                                              ; preds = %337
  store i32 6, ptr %89, align 4
  %365 = load i32, ptr %10, align 4
  %366 = load i32, ptr %89, align 4
  %367 = shl i32 %365, %366
  store i32 %367, ptr %90, align 4
  store i32 63, ptr %91, align 4
  %368 = load i32, ptr %82, align 4
  %369 = load i32, ptr %91, align 4
  %370 = and i32 %368, %369
  store i32 %370, ptr %92, align 4
  %371 = load i32, ptr %90, align 4
  %372 = load i32, ptr %92, align 4
  %373 = or i32 %371, %372
  store i32 %373, ptr %93, align 4
  %374 = load i32, ptr %78, align 4
  store i32 %374, ptr %94, align 4
  store ptr @i32_typ, ptr %95, align 8
  %375 = load ptr, ptr %95, align 8
  store ptr %375, ptr %74, align 8
  %376 = load i32, ptr %94, align 4
  store i32 %376, ptr %73, align 4
  %377 = load i32, ptr %93, align 4
  store i32 %377, ptr %10, align 4
  br label %378

378:                                              ; preds = %363, %364, %305
  %379 = phi i32 [ %360, %364 ], [ %360, %363 ], [ 2, %305 ]
  %380 = phi i32 [ %362, %364 ], [ %362, %363 ], [ 0, %305 ]
  br label %381

381:                                              ; preds = %378
  br label %382

382:                                              ; preds = %381
  %383 = trunc i32 %380 to i1
  br i1 %383, label %384, label %385

384:                                              ; preds = %382
  br label %305

385:                                              ; preds = %382
  %386 = zext i32 %379 to i64
  %387 = trunc i64 %386 to i32
  switch i32 %387, label %393 [
    i32 1, label %388
  ]

388:                                              ; preds = %513, %385
  %389 = phi ptr [ %123, %513 ], [ %88, %385 ]
  %390 = phi ptr [ %122, %513 ], [ %87, %385 ]
  %391 = phi { ptr, i64 } [ %514, %513 ], [ poison, %385 ]
  %392 = phi i32 [ %501, %513 ], [ 0, %385 ]
  br label %236

393:                                              ; preds = %385
  store i32 2, ptr %96, align 4
  %394 = load i32, ptr %11, align 4
  %395 = load i32, ptr %96, align 4
  %396 = icmp eq i32 %394, %395
  %397 = zext i1 %396 to i8
  store i8 %397, ptr %97, align 1
  %398 = load i8, ptr %97, align 1
  %399 = trunc i8 %398 to i1
  %400 = zext i1 %399 to i8
  store i8 %400, ptr %98, align 1
  br i1 %399, label %401, label %409

401:                                              ; preds = %393
  store i32 -128, ptr %99, align 4
  %402 = load i32, ptr %10, align 4
  %403 = load i32, ptr %99, align 4
  %404 = icmp slt i32 %402, %403
  %405 = zext i1 %404 to i8
  store i8 %405, ptr %100, align 1
  %406 = load i8, ptr %100, align 1
  %407 = trunc i8 %406 to i1
  %408 = zext i1 %407 to i8
  store i8 %408, ptr %98, align 1
  br label %409

409:                                              ; preds = %401, %393
  %410 = load i8, ptr %98, align 1
  %411 = trunc i8 %410 to i1
  %412 = zext i1 %411 to i8
  store i8 %412, ptr %101, align 1
  br i1 %411, label %413, label %414

413:                                              ; preds = %409
  br label %434

414:                                              ; preds = %409
  store i32 3, ptr %102, align 4
  %415 = load i32, ptr %11, align 4
  %416 = load i32, ptr %102, align 4
  %417 = icmp eq i32 %415, %416
  %418 = zext i1 %417 to i8
  store i8 %418, ptr %103, align 1
  %419 = load i8, ptr %103, align 1
  %420 = trunc i8 %419 to i1
  %421 = zext i1 %420 to i8
  store i8 %421, ptr %104, align 1
  br i1 %420, label %422, label %430

422:                                              ; preds = %414
  store i32 2048, ptr %105, align 4
  %423 = load i32, ptr %10, align 4
  %424 = load i32, ptr %105, align 4
  %425 = icmp slt i32 %423, %424
  %426 = zext i1 %425 to i8
  store i8 %426, ptr %106, align 1
  %427 = load i8, ptr %106, align 1
  %428 = trunc i8 %427 to i1
  %429 = zext i1 %428 to i8
  store i8 %429, ptr %104, align 1
  br label %430

430:                                              ; preds = %422, %414
  %431 = load i8, ptr %104, align 1
  %432 = trunc i8 %431 to i1
  %433 = zext i1 %432 to i8
  store i8 %433, ptr %101, align 1
  br label %434

434:                                              ; preds = %413, %430
  %435 = load i8, ptr %101, align 1
  %436 = trunc i8 %435 to i1
  %437 = zext i1 %436 to i8
  store i8 %437, ptr %107, align 1
  br i1 %436, label %438, label %439

438:                                              ; preds = %434
  br label %459

439:                                              ; preds = %434
  store i32 4, ptr %108, align 4
  %440 = load i32, ptr %11, align 4
  %441 = load i32, ptr %108, align 4
  %442 = icmp eq i32 %440, %441
  %443 = zext i1 %442 to i8
  store i8 %443, ptr %109, align 1
  %444 = load i8, ptr %109, align 1
  %445 = trunc i8 %444 to i1
  %446 = zext i1 %445 to i8
  store i8 %446, ptr %110, align 1
  br i1 %445, label %447, label %455

447:                                              ; preds = %439
  store i32 65536, ptr %111, align 4
  %448 = load i32, ptr %10, align 4
  %449 = load i32, ptr %111, align 4
  %450 = icmp slt i32 %448, %449
  %451 = zext i1 %450 to i8
  store i8 %451, ptr %112, align 1
  %452 = load i8, ptr %112, align 1
  %453 = trunc i8 %452 to i1
  %454 = zext i1 %453 to i8
  store i8 %454, ptr %110, align 1
  br label %455

455:                                              ; preds = %447, %439
  %456 = load i8, ptr %110, align 1
  %457 = trunc i8 %456 to i1
  %458 = zext i1 %457 to i8
  store i8 %458, ptr %107, align 1
  br label %459

459:                                              ; preds = %438, %455
  %460 = load i8, ptr %107, align 1
  %461 = trunc i8 %460 to i1
  %462 = zext i1 %461 to i8
  store i8 %462, ptr %113, align 1
  br i1 %461, label %463, label %464

463:                                              ; preds = %459
  br label %484

464:                                              ; preds = %459
  store i32 -10240, ptr %114, align 4
  %465 = load i32, ptr %10, align 4
  %466 = load i32, ptr %114, align 4
  %467 = icmp sge i32 %465, %466
  %468 = zext i1 %467 to i8
  store i8 %468, ptr %115, align 1
  %469 = load i8, ptr %115, align 1
  %470 = trunc i8 %469 to i1
  %471 = zext i1 %470 to i8
  store i8 %471, ptr %116, align 1
  br i1 %470, label %472, label %480

472:                                              ; preds = %464
  store i32 -8193, ptr %117, align 4
  %473 = load i32, ptr %10, align 4
  %474 = load i32, ptr %117, align 4
  %475 = icmp sle i32 %473, %474
  %476 = zext i1 %475 to i8
  store i8 %476, ptr %118, align 1
  %477 = load i8, ptr %118, align 1
  %478 = trunc i8 %477 to i1
  %479 = zext i1 %478 to i8
  store i8 %479, ptr %116, align 1
  br label %480

480:                                              ; preds = %472, %464
  %481 = load i8, ptr %116, align 1
  %482 = trunc i8 %481 to i1
  %483 = zext i1 %482 to i8
  store i8 %483, ptr %113, align 1
  br label %484

484:                                              ; preds = %463, %480
  %485 = load i8, ptr %113, align 1
  %486 = trunc i8 %485 to i1
  %487 = zext i1 %486 to i8
  store i8 %487, ptr %119, align 1
  br i1 %486, label %488, label %489

488:                                              ; preds = %484
  br label %497

489:                                              ; preds = %484
  store i32 1114111, ptr %120, align 4
  %490 = load i32, ptr %10, align 4
  %491 = load i32, ptr %120, align 4
  %492 = icmp sgt i32 %490, %491
  %493 = zext i1 %492 to i8
  store i8 %493, ptr %121, align 1
  %494 = load i8, ptr %121, align 1
  %495 = trunc i8 %494 to i1
  %496 = zext i1 %495 to i8
  store i8 %496, ptr %119, align 1
  br label %497

497:                                              ; preds = %488, %489
  %498 = load i8, ptr %119, align 1
  %499 = trunc i8 %498 to i1
  %500 = xor i1 %499, true
  %501 = zext i1 %500 to i32
  br i1 %499, label %502, label %503

502:                                              ; preds = %497
  br label %513

503:                                              ; preds = %497
  %504 = load i32, ptr %10, align 4
  %505 = load i32, ptr %11, align 4
  %506 = insertelement <2 x i32> undef, i32 %504, i64 0
  %507 = insertelement <2 x i32> %506, i32 %505, i64 1
  store <2 x i32> %507, ptr %124, align 8
  %508 = load <2 x i32>, ptr %124, align 8
  store <2 x i32> %508, ptr %125, align 8
  store ptr @tuple_typ, ptr %126, align 8
  %509 = load ptr, ptr %126, align 8
  %510 = insertvalue { ptr, i64 } undef, ptr %509, 0
  %511 = load i64, ptr %125, align 4
  %512 = insertvalue { ptr, i64 } %510, i64 %511, 1
  br label %513

513:                                              ; preds = %502, %503
  %514 = phi { ptr, i64 } [ %512, %503 ], [ poison, %502 ]
  br label %388

515:                                              ; preds = %236
  br label %137

516:                                              ; preds = %137
  br label %517

517:                                              ; preds = %516
  %518 = zext i32 %141 to i64
  %519 = trunc i64 %518 to i32
  switch i32 %519, label %528 [
    i32 0, label %520
  ]

520:                                              ; preds = %517
  %521 = getelementptr { ptr, i64 }, ptr %138, i32 0, i32 1
  %522 = load [0 x i8], ptr %139, align 1
  store [0 x i8] %522, ptr %521, align 1
  store ptr @nil_typ, ptr %138, align 8
  %523 = getelementptr { ptr, i64 }, ptr %138, i32 0, i32 0
  %524 = load ptr, ptr %523, align 8
  %525 = insertvalue { ptr, i64 } undef, ptr %524, 0
  %526 = load i64, ptr %521, align 4
  %527 = insertvalue { ptr, i64 } %525, i64 %526, 1
  br label %529

528:                                              ; preds = %517
  br label %529

529:                                              ; preds = %528, %520
  %530 = phi { ptr, i64 } [ %140, %528 ], [ %527, %520 ]
  ret { ptr, i64 } %530
}

define ptr @Unicode_B__Self_decode_one_bytesBufferi8_indexi32_leni32(ptr %0) {
  %2 = alloca i1, align 1
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 24, ptr %0)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %0, align 8
  %8 = ptrtoint ptr %7 to i64
  %9 = icmp eq i64 %8, ptrtoint (ptr @buffer_typ to i64)
  %10 = zext i1 %9 to i8
  store i8 %10, ptr %4, align 1
  %11 = getelementptr ptr, ptr %0, i32 1
  %12 = load ptr, ptr %11, align 8
  %13 = ptrtoint ptr %12 to i64
  %14 = icmp eq i64 %13, ptrtoint (ptr @i32_typ to i64)
  %15 = zext i1 %14 to i8
  store i8 %15, ptr %3, align 1
  %16 = getelementptr ptr, ptr %0, i32 2
  %17 = load ptr, ptr %16, align 8
  %18 = ptrtoint ptr %17 to i64
  %19 = icmp eq i64 %18, ptrtoint (ptr @i32_typ to i64)
  %20 = zext i1 %19 to i8
  store i8 %20, ptr %2, align 1
  store i32 8, ptr %6, align 4
  %21 = load i32, ptr %6, align 4
  %22 = getelementptr [10 x ptr], ptr @Unicode, i32 0, i32 %21
  %23 = getelementptr ptr, ptr %22, i32 10
  %24 = load ptr, ptr %23, align 8
  ret ptr %24
}

define { ptr, ptr, ptr, i32 } @Unicode__Self_encode_one_cpi32(ptr %0, i32 %1) {
  %3 = alloca i32, align 4
  %4 = alloca i8, align 1
  %5 = alloca i64, align 8
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca [1 x ptr], align 8
  %9 = alloca i32, align 4
  %10 = alloca ptr, align 8
  %11 = alloca ptr, align 8
  %12 = alloca ptr, align 8
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %15 = alloca [4 x ptr], align 8
  %16 = alloca { ptr, ptr, ptr, ptr }, align 8
  %17 = alloca i32, align 4
  %18 = alloca ptr, align 8
  %19 = alloca ptr, align 8
  %20 = alloca ptr, align 8
  %21 = alloca i32, align 4
  %22 = alloca i1, align 1
  %23 = alloca i32, align 4
  %24 = alloca i32, align 4
  %25 = alloca i32, align 4
  %26 = alloca i32, align 4
  %27 = alloca i32, align 4
  %28 = alloca i8, align 1
  %29 = alloca i64, align 8
  %30 = alloca i32, align 4
  %31 = alloca i32, align 4
  %32 = alloca i32, align 4
  %33 = alloca i32, align 4
  %34 = alloca i32, align 4
  %35 = alloca i8, align 1
  %36 = alloca i64, align 8
  %37 = alloca i32, align 4
  %38 = alloca i32, align 4
  %39 = alloca [1 x ptr], align 8
  %40 = alloca i32, align 4
  %41 = alloca ptr, align 8
  %42 = alloca ptr, align 8
  %43 = alloca ptr, align 8
  %44 = alloca i32, align 4
  %45 = alloca i32, align 4
  %46 = alloca [4 x ptr], align 8
  %47 = alloca { ptr, ptr, ptr, ptr }, align 8
  %48 = alloca i32, align 4
  %49 = alloca ptr, align 8
  %50 = alloca ptr, align 8
  %51 = alloca ptr, align 8
  %52 = alloca i32, align 4
  %53 = alloca i1, align 1
  %54 = alloca i32, align 4
  %55 = alloca i32, align 4
  %56 = alloca i32, align 4
  %57 = alloca i32, align 4
  %58 = alloca i32, align 4
  %59 = alloca i8, align 1
  %60 = alloca i64, align 8
  %61 = alloca i32, align 4
  %62 = alloca i32, align 4
  %63 = alloca i32, align 4
  %64 = alloca i32, align 4
  %65 = alloca i32, align 4
  %66 = alloca i32, align 4
  %67 = alloca i32, align 4
  %68 = alloca i8, align 1
  %69 = alloca i64, align 8
  %70 = alloca i32, align 4
  %71 = alloca i32, align 4
  %72 = alloca i32, align 4
  %73 = alloca i32, align 4
  %74 = alloca i32, align 4
  %75 = alloca i8, align 1
  %76 = alloca i64, align 8
  %77 = alloca i32, align 4
  %78 = alloca i32, align 4
  %79 = alloca [1 x ptr], align 8
  %80 = alloca i32, align 4
  %81 = alloca ptr, align 8
  %82 = alloca ptr, align 8
  %83 = alloca ptr, align 8
  %84 = alloca i32, align 4
  %85 = alloca i32, align 4
  %86 = alloca [4 x ptr], align 8
  %87 = alloca { ptr, ptr, ptr, ptr }, align 8
  %88 = alloca i32, align 4
  %89 = alloca ptr, align 8
  %90 = alloca ptr, align 8
  %91 = alloca ptr, align 8
  %92 = alloca i32, align 4
  %93 = alloca i1, align 1
  %94 = alloca i32, align 4
  %95 = alloca i32, align 4
  %96 = alloca i32, align 4
  %97 = alloca i32, align 4
  %98 = alloca i32, align 4
  %99 = alloca i8, align 1
  %100 = alloca i64, align 8
  %101 = alloca i32, align 4
  %102 = alloca i32, align 4
  %103 = alloca i32, align 4
  %104 = alloca i32, align 4
  %105 = alloca i32, align 4
  %106 = alloca i32, align 4
  %107 = alloca i32, align 4
  %108 = alloca i8, align 1
  %109 = alloca i64, align 8
  %110 = alloca i32, align 4
  %111 = alloca i32, align 4
  %112 = alloca i32, align 4
  %113 = alloca i32, align 4
  %114 = alloca i32, align 4
  %115 = alloca i32, align 4
  %116 = alloca i32, align 4
  %117 = alloca i8, align 1
  %118 = alloca i64, align 8
  %119 = alloca i32, align 4
  %120 = alloca i32, align 4
  %121 = alloca i32, align 4
  %122 = alloca i32, align 4
  %123 = alloca i32, align 4
  %124 = alloca i8, align 1
  %125 = alloca i64, align 8
  %126 = alloca i32, align 4
  %127 = alloca i32, align 4
  %128 = alloca [1 x ptr], align 8
  %129 = alloca i32, align 4
  %130 = alloca ptr, align 8
  %131 = alloca ptr, align 8
  %132 = alloca ptr, align 8
  %133 = alloca i32, align 4
  %134 = alloca i32, align 4
  %135 = alloca [4 x ptr], align 8
  %136 = alloca { ptr, ptr, ptr, ptr }, align 8
  %137 = alloca i32, align 4
  %138 = alloca ptr, align 8
  %139 = alloca ptr, align 8
  %140 = alloca ptr, align 8
  %141 = alloca [0 x ptr], align 8
  %142 = alloca {}, align 8
  %143 = alloca { ptr, ptr, ptr, i32 }, align 8
  %144 = alloca i32, align 4
  %145 = alloca ptr, align 8
  %146 = alloca ptr, align 8
  %147 = alloca ptr, align 8
  %148 = alloca i32, align 4
  %149 = alloca ptr, align 8
  %150 = alloca ptr, align 8
  %151 = alloca ptr, align 8
  %152 = alloca i32, align 4
  store i32 %1, ptr %152, align 4
  %153 = alloca i32, align 4
  store i32 4, ptr %153, align 4
  %154 = alloca i64, align 8
  %155 = load i32, ptr %153, align 4
  %156 = sext i32 %155 to i64
  store i64 %156, ptr %154, align 4
  %157 = load i64, ptr %154, align 4
  %158 = alloca ptr, align 8
  %159 = mul i64 %157, ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
  %160 = call ptr @bump_malloc(i64 %159)
  store ptr %160, ptr %158, align 8
  %161 = alloca ptr, align 8
  %162 = getelementptr { ptr }, ptr %158, i32 0, i32 0
  %163 = load ptr, ptr %162, align 8
  store ptr %163, ptr %161, align 8
  %164 = alloca i32, align 4
  store i32 127, ptr %164, align 4
  %165 = load i32, ptr %152, align 4
  %166 = load i32, ptr %164, align 4
  %167 = icmp sle i32 %165, %166
  %168 = alloca i1, align 1
  %169 = zext i1 %167 to i8
  store i8 %169, ptr %168, align 1
  %170 = load i8, ptr %168, align 1
  %171 = trunc i8 %170 to i1
  br i1 %171, label %172, label %229

172:                                              ; preds = %2
  store i32 0, ptr %3, align 4
  %173 = load i32, ptr %152, align 4
  %174 = trunc i32 %173 to i8
  store i8 %174, ptr %4, align 1
  %175 = load i32, ptr %3, align 4
  %176 = sext i32 %175 to i64
  store i64 %176, ptr %5, align 4
  %177 = load ptr, ptr %161, align 8
  %178 = load i64, ptr %5, align 4
  %179 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %178
  %180 = getelementptr i8, ptr %177, i64 %179
  %181 = load i8, ptr %4, align 1
  store i8 %181, ptr %180, align 1
  store i32 1, ptr %6, align 4
  store i32 1, ptr %7, align 4
  store ptr @String, ptr %8, align 8
  %182 = load ptr, ptr %8, align 8
  %183 = getelementptr ptr, ptr %182, i32 6
  %184 = load ptr, ptr %183, align 8
  %185 = call { i64, i64 } @size_wrapper(ptr %184, ptr %8)
  %186 = extractvalue { i64, i64 } %185, 0
  %187 = call ptr @bump_malloc(i64 %186)
  store ptr @String, ptr %12, align 8
  store ptr %187, ptr %11, align 8
  store i32 10, ptr %9, align 4
  store i32 1, ptr %13, align 4
  store i32 1, ptr %14, align 4
  %188 = load ptr, ptr %161, align 8
  %189 = insertvalue { ptr } undef, ptr %188, 0
  %190 = load i32, ptr %13, align 4
  %191 = load i32, ptr %14, align 4
  %192 = load i32, ptr %153, align 4
  %193 = load ptr, ptr %12, align 8
  %194 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %193, 0
  %195 = load ptr, ptr %11, align 8
  %196 = insertvalue { ptr, ptr, ptr, i32 } %194, ptr %195, 1
  %197 = load ptr, ptr %10, align 8
  %198 = insertvalue { ptr, ptr, ptr, i32 } %196, ptr %197, 2
  %199 = load i32, ptr %9, align 4
  %200 = insertvalue { ptr, ptr, ptr, i32 } %198, i32 %199, 3
  %201 = getelementptr [4 x ptr], ptr %15, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %201, align 8
  %202 = getelementptr [4 x ptr], ptr %15, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %202, align 8
  %203 = getelementptr [4 x ptr], ptr %15, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %203, align 8
  %204 = getelementptr [4 x ptr], ptr %15, i32 0, i32 3
  store ptr @_parameterization_i32, ptr %204, align 8
  %205 = call ptr @llvm.invariant.start.p0(i64 16, ptr %15)
  %206 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %193)
  %207 = getelementptr ptr, ptr %193, i32 %199
  %208 = getelementptr ptr, ptr %207, i32 12
  %209 = load ptr, ptr %208, align 8
  %210 = getelementptr { ptr, ptr, ptr, ptr }, ptr %16, i32 0, i32 0
  store ptr @buffer_typ, ptr %210, align 8
  %211 = getelementptr { ptr, ptr, ptr, ptr }, ptr %16, i32 0, i32 1
  store ptr @i32_typ, ptr %211, align 8
  %212 = getelementptr { ptr, ptr, ptr, ptr }, ptr %16, i32 0, i32 2
  store ptr @i32_typ, ptr %212, align 8
  %213 = getelementptr { ptr, ptr, ptr, ptr }, ptr %16, i32 0, i32 3
  store ptr @i32_typ, ptr %213, align 8
  %214 = call ptr @behavior_wrapper(ptr %209, { ptr, ptr, ptr, i32 } %200, ptr %16)
  call void %214({ ptr, ptr, ptr, i32 } %200, { ptr, ptr, ptr, i32 } %200, ptr %15, { ptr } %189, i32 %190, i32 %191, i32 %192)
  %215 = load ptr, ptr %12, align 8
  store ptr %215, ptr %20, align 8
  %216 = load ptr, ptr %11, align 8
  store ptr %216, ptr %19, align 8
  %217 = load ptr, ptr %10, align 8
  store ptr %217, ptr %18, align 8
  %218 = load i32, ptr %9, align 4
  store i32 %218, ptr %17, align 4
  %219 = load ptr, ptr %20, align 8
  %220 = call i32 @get_offset(ptr %219, ptr @String)
  store i32 %220, ptr %17, align 4
  %221 = load ptr, ptr %20, align 8
  %222 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %221, 0
  %223 = load ptr, ptr %19, align 8
  %224 = insertvalue { ptr, ptr, ptr, i32 } %222, ptr %223, 1
  %225 = load ptr, ptr %18, align 8
  %226 = insertvalue { ptr, ptr, ptr, i32 } %224, ptr %225, 2
  %227 = load i32, ptr %17, align 4
  %228 = insertvalue { ptr, ptr, ptr, i32 } %226, i32 %227, 3
  br label %577

229:                                              ; preds = %2
  store i32 2047, ptr %21, align 4
  %230 = load i32, ptr %152, align 4
  %231 = load i32, ptr %21, align 4
  %232 = icmp sle i32 %230, %231
  %233 = zext i1 %232 to i8
  store i8 %233, ptr %22, align 1
  %234 = load i8, ptr %22, align 1
  %235 = trunc i8 %234 to i1
  br i1 %235, label %236, label %314

236:                                              ; preds = %229
  store i32 0, ptr %23, align 4
  store i32 -64, ptr %24, align 4
  store i32 6, ptr %25, align 4
  %237 = load i32, ptr %152, align 4
  %238 = load i32, ptr %25, align 4
  %239 = ashr i32 %237, %238
  store i32 %239, ptr %26, align 4
  %240 = load i32, ptr %24, align 4
  %241 = load i32, ptr %26, align 4
  %242 = or i32 %240, %241
  store i32 %242, ptr %27, align 4
  %243 = load i32, ptr %27, align 4
  %244 = trunc i32 %243 to i8
  store i8 %244, ptr %28, align 1
  %245 = load i32, ptr %23, align 4
  %246 = sext i32 %245 to i64
  store i64 %246, ptr %29, align 4
  %247 = load ptr, ptr %161, align 8
  %248 = load i64, ptr %29, align 4
  %249 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %248
  %250 = getelementptr i8, ptr %247, i64 %249
  %251 = load i8, ptr %28, align 1
  store i8 %251, ptr %250, align 1
  store i32 1, ptr %30, align 4
  store i32 -128, ptr %31, align 4
  store i32 63, ptr %32, align 4
  %252 = load i32, ptr %152, align 4
  %253 = load i32, ptr %32, align 4
  %254 = and i32 %252, %253
  store i32 %254, ptr %33, align 4
  %255 = load i32, ptr %31, align 4
  %256 = load i32, ptr %33, align 4
  %257 = or i32 %255, %256
  store i32 %257, ptr %34, align 4
  %258 = load i32, ptr %34, align 4
  %259 = trunc i32 %258 to i8
  store i8 %259, ptr %35, align 1
  %260 = load i32, ptr %30, align 4
  %261 = sext i32 %260 to i64
  store i64 %261, ptr %36, align 4
  %262 = load ptr, ptr %161, align 8
  %263 = load i64, ptr %36, align 4
  %264 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %263
  %265 = getelementptr i8, ptr %262, i64 %264
  %266 = load i8, ptr %35, align 1
  store i8 %266, ptr %265, align 1
  store i32 2, ptr %37, align 4
  store i32 1, ptr %38, align 4
  store ptr @String, ptr %39, align 8
  %267 = load ptr, ptr %39, align 8
  %268 = getelementptr ptr, ptr %267, i32 6
  %269 = load ptr, ptr %268, align 8
  %270 = call { i64, i64 } @size_wrapper(ptr %269, ptr %39)
  %271 = extractvalue { i64, i64 } %270, 0
  %272 = call ptr @bump_malloc(i64 %271)
  store ptr @String, ptr %43, align 8
  store ptr %272, ptr %42, align 8
  store i32 10, ptr %40, align 4
  store i32 2, ptr %44, align 4
  store i32 1, ptr %45, align 4
  %273 = load ptr, ptr %161, align 8
  %274 = insertvalue { ptr } undef, ptr %273, 0
  %275 = load i32, ptr %44, align 4
  %276 = load i32, ptr %45, align 4
  %277 = load i32, ptr %153, align 4
  %278 = load ptr, ptr %43, align 8
  %279 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %278, 0
  %280 = load ptr, ptr %42, align 8
  %281 = insertvalue { ptr, ptr, ptr, i32 } %279, ptr %280, 1
  %282 = load ptr, ptr %41, align 8
  %283 = insertvalue { ptr, ptr, ptr, i32 } %281, ptr %282, 2
  %284 = load i32, ptr %40, align 4
  %285 = insertvalue { ptr, ptr, ptr, i32 } %283, i32 %284, 3
  %286 = getelementptr [4 x ptr], ptr %46, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %286, align 8
  %287 = getelementptr [4 x ptr], ptr %46, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %287, align 8
  %288 = getelementptr [4 x ptr], ptr %46, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %288, align 8
  %289 = getelementptr [4 x ptr], ptr %46, i32 0, i32 3
  store ptr @_parameterization_i32, ptr %289, align 8
  %290 = call ptr @llvm.invariant.start.p0(i64 16, ptr %46)
  %291 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %278)
  %292 = getelementptr ptr, ptr %278, i32 %284
  %293 = getelementptr ptr, ptr %292, i32 12
  %294 = load ptr, ptr %293, align 8
  %295 = getelementptr { ptr, ptr, ptr, ptr }, ptr %47, i32 0, i32 0
  store ptr @buffer_typ, ptr %295, align 8
  %296 = getelementptr { ptr, ptr, ptr, ptr }, ptr %47, i32 0, i32 1
  store ptr @i32_typ, ptr %296, align 8
  %297 = getelementptr { ptr, ptr, ptr, ptr }, ptr %47, i32 0, i32 2
  store ptr @i32_typ, ptr %297, align 8
  %298 = getelementptr { ptr, ptr, ptr, ptr }, ptr %47, i32 0, i32 3
  store ptr @i32_typ, ptr %298, align 8
  %299 = call ptr @behavior_wrapper(ptr %294, { ptr, ptr, ptr, i32 } %285, ptr %47)
  call void %299({ ptr, ptr, ptr, i32 } %285, { ptr, ptr, ptr, i32 } %285, ptr %46, { ptr } %274, i32 %275, i32 %276, i32 %277)
  %300 = load ptr, ptr %43, align 8
  store ptr %300, ptr %51, align 8
  %301 = load ptr, ptr %42, align 8
  store ptr %301, ptr %50, align 8
  %302 = load ptr, ptr %41, align 8
  store ptr %302, ptr %49, align 8
  %303 = load i32, ptr %40, align 4
  store i32 %303, ptr %48, align 4
  %304 = load ptr, ptr %51, align 8
  %305 = call i32 @get_offset(ptr %304, ptr @String)
  store i32 %305, ptr %48, align 4
  %306 = load ptr, ptr %51, align 8
  %307 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %306, 0
  %308 = load ptr, ptr %50, align 8
  %309 = insertvalue { ptr, ptr, ptr, i32 } %307, ptr %308, 1
  %310 = load ptr, ptr %49, align 8
  %311 = insertvalue { ptr, ptr, ptr, i32 } %309, ptr %310, 2
  %312 = load i32, ptr %48, align 4
  %313 = insertvalue { ptr, ptr, ptr, i32 } %311, i32 %312, 3
  br label %574

314:                                              ; preds = %229
  store i32 -1, ptr %52, align 4
  %315 = load i32, ptr %152, align 4
  %316 = load i32, ptr %52, align 4
  %317 = icmp sle i32 %315, %316
  %318 = zext i1 %317 to i8
  store i8 %318, ptr %53, align 1
  %319 = load i8, ptr %53, align 1
  %320 = trunc i8 %319 to i1
  br i1 %320, label %321, label %417

321:                                              ; preds = %314
  store i32 0, ptr %54, align 4
  store i32 -32, ptr %55, align 4
  store i32 12, ptr %56, align 4
  %322 = load i32, ptr %152, align 4
  %323 = load i32, ptr %56, align 4
  %324 = ashr i32 %322, %323
  store i32 %324, ptr %57, align 4
  %325 = load i32, ptr %55, align 4
  %326 = load i32, ptr %57, align 4
  %327 = or i32 %325, %326
  store i32 %327, ptr %58, align 4
  %328 = load i32, ptr %58, align 4
  %329 = trunc i32 %328 to i8
  store i8 %329, ptr %59, align 1
  %330 = load i32, ptr %54, align 4
  %331 = sext i32 %330 to i64
  store i64 %331, ptr %60, align 4
  %332 = load ptr, ptr %161, align 8
  %333 = load i64, ptr %60, align 4
  %334 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %333
  %335 = getelementptr i8, ptr %332, i64 %334
  %336 = load i8, ptr %59, align 1
  store i8 %336, ptr %335, align 1
  store i32 1, ptr %61, align 4
  store i32 -128, ptr %62, align 4
  store i32 6, ptr %63, align 4
  %337 = load i32, ptr %152, align 4
  %338 = load i32, ptr %63, align 4
  %339 = ashr i32 %337, %338
  store i32 %339, ptr %64, align 4
  store i32 63, ptr %65, align 4
  %340 = load i32, ptr %64, align 4
  %341 = load i32, ptr %65, align 4
  %342 = and i32 %340, %341
  store i32 %342, ptr %66, align 4
  %343 = load i32, ptr %62, align 4
  %344 = load i32, ptr %66, align 4
  %345 = or i32 %343, %344
  store i32 %345, ptr %67, align 4
  %346 = load i32, ptr %67, align 4
  %347 = trunc i32 %346 to i8
  store i8 %347, ptr %68, align 1
  %348 = load i32, ptr %61, align 4
  %349 = sext i32 %348 to i64
  store i64 %349, ptr %69, align 4
  %350 = load ptr, ptr %161, align 8
  %351 = load i64, ptr %69, align 4
  %352 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %351
  %353 = getelementptr i8, ptr %350, i64 %352
  %354 = load i8, ptr %68, align 1
  store i8 %354, ptr %353, align 1
  store i32 2, ptr %70, align 4
  store i32 -128, ptr %71, align 4
  store i32 63, ptr %72, align 4
  %355 = load i32, ptr %152, align 4
  %356 = load i32, ptr %72, align 4
  %357 = and i32 %355, %356
  store i32 %357, ptr %73, align 4
  %358 = load i32, ptr %71, align 4
  %359 = load i32, ptr %73, align 4
  %360 = or i32 %358, %359
  store i32 %360, ptr %74, align 4
  %361 = load i32, ptr %74, align 4
  %362 = trunc i32 %361 to i8
  store i8 %362, ptr %75, align 1
  %363 = load i32, ptr %70, align 4
  %364 = sext i32 %363 to i64
  store i64 %364, ptr %76, align 4
  %365 = load ptr, ptr %161, align 8
  %366 = load i64, ptr %76, align 4
  %367 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %366
  %368 = getelementptr i8, ptr %365, i64 %367
  %369 = load i8, ptr %75, align 1
  store i8 %369, ptr %368, align 1
  store i32 3, ptr %77, align 4
  store i32 1, ptr %78, align 4
  store ptr @String, ptr %79, align 8
  %370 = load ptr, ptr %79, align 8
  %371 = getelementptr ptr, ptr %370, i32 6
  %372 = load ptr, ptr %371, align 8
  %373 = call { i64, i64 } @size_wrapper(ptr %372, ptr %79)
  %374 = extractvalue { i64, i64 } %373, 0
  %375 = call ptr @bump_malloc(i64 %374)
  store ptr @String, ptr %83, align 8
  store ptr %375, ptr %82, align 8
  store i32 10, ptr %80, align 4
  store i32 3, ptr %84, align 4
  store i32 1, ptr %85, align 4
  %376 = load ptr, ptr %161, align 8
  %377 = insertvalue { ptr } undef, ptr %376, 0
  %378 = load i32, ptr %84, align 4
  %379 = load i32, ptr %85, align 4
  %380 = load i32, ptr %153, align 4
  %381 = load ptr, ptr %83, align 8
  %382 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %381, 0
  %383 = load ptr, ptr %82, align 8
  %384 = insertvalue { ptr, ptr, ptr, i32 } %382, ptr %383, 1
  %385 = load ptr, ptr %81, align 8
  %386 = insertvalue { ptr, ptr, ptr, i32 } %384, ptr %385, 2
  %387 = load i32, ptr %80, align 4
  %388 = insertvalue { ptr, ptr, ptr, i32 } %386, i32 %387, 3
  %389 = getelementptr [4 x ptr], ptr %86, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %389, align 8
  %390 = getelementptr [4 x ptr], ptr %86, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %390, align 8
  %391 = getelementptr [4 x ptr], ptr %86, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %391, align 8
  %392 = getelementptr [4 x ptr], ptr %86, i32 0, i32 3
  store ptr @_parameterization_i32, ptr %392, align 8
  %393 = call ptr @llvm.invariant.start.p0(i64 16, ptr %86)
  %394 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %381)
  %395 = getelementptr ptr, ptr %381, i32 %387
  %396 = getelementptr ptr, ptr %395, i32 12
  %397 = load ptr, ptr %396, align 8
  %398 = getelementptr { ptr, ptr, ptr, ptr }, ptr %87, i32 0, i32 0
  store ptr @buffer_typ, ptr %398, align 8
  %399 = getelementptr { ptr, ptr, ptr, ptr }, ptr %87, i32 0, i32 1
  store ptr @i32_typ, ptr %399, align 8
  %400 = getelementptr { ptr, ptr, ptr, ptr }, ptr %87, i32 0, i32 2
  store ptr @i32_typ, ptr %400, align 8
  %401 = getelementptr { ptr, ptr, ptr, ptr }, ptr %87, i32 0, i32 3
  store ptr @i32_typ, ptr %401, align 8
  %402 = call ptr @behavior_wrapper(ptr %397, { ptr, ptr, ptr, i32 } %388, ptr %87)
  call void %402({ ptr, ptr, ptr, i32 } %388, { ptr, ptr, ptr, i32 } %388, ptr %86, { ptr } %377, i32 %378, i32 %379, i32 %380)
  %403 = load ptr, ptr %83, align 8
  store ptr %403, ptr %91, align 8
  %404 = load ptr, ptr %82, align 8
  store ptr %404, ptr %90, align 8
  %405 = load ptr, ptr %81, align 8
  store ptr %405, ptr %89, align 8
  %406 = load i32, ptr %80, align 4
  store i32 %406, ptr %88, align 4
  %407 = load ptr, ptr %91, align 8
  %408 = call i32 @get_offset(ptr %407, ptr @String)
  store i32 %408, ptr %88, align 4
  %409 = load ptr, ptr %91, align 8
  %410 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %409, 0
  %411 = load ptr, ptr %90, align 8
  %412 = insertvalue { ptr, ptr, ptr, i32 } %410, ptr %411, 1
  %413 = load ptr, ptr %89, align 8
  %414 = insertvalue { ptr, ptr, ptr, i32 } %412, ptr %413, 2
  %415 = load i32, ptr %88, align 4
  %416 = insertvalue { ptr, ptr, ptr, i32 } %414, i32 %415, 3
  br label %571

417:                                              ; preds = %314
  store i32 1114111, ptr %92, align 4
  %418 = load i32, ptr %152, align 4
  %419 = load i32, ptr %92, align 4
  %420 = icmp sle i32 %418, %419
  %421 = zext i1 %420 to i8
  store i8 %421, ptr %93, align 1
  %422 = load i8, ptr %93, align 1
  %423 = trunc i8 %422 to i1
  br i1 %423, label %424, label %538

424:                                              ; preds = %417
  store i32 0, ptr %94, align 4
  store i32 -16, ptr %95, align 4
  store i32 18, ptr %96, align 4
  %425 = load i32, ptr %152, align 4
  %426 = load i32, ptr %96, align 4
  %427 = ashr i32 %425, %426
  store i32 %427, ptr %97, align 4
  %428 = load i32, ptr %95, align 4
  %429 = load i32, ptr %97, align 4
  %430 = or i32 %428, %429
  store i32 %430, ptr %98, align 4
  %431 = load i32, ptr %98, align 4
  %432 = trunc i32 %431 to i8
  store i8 %432, ptr %99, align 1
  %433 = load i32, ptr %94, align 4
  %434 = sext i32 %433 to i64
  store i64 %434, ptr %100, align 4
  %435 = load ptr, ptr %161, align 8
  %436 = load i64, ptr %100, align 4
  %437 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %436
  %438 = getelementptr i8, ptr %435, i64 %437
  %439 = load i8, ptr %99, align 1
  store i8 %439, ptr %438, align 1
  store i32 1, ptr %101, align 4
  store i32 -128, ptr %102, align 4
  store i32 12, ptr %103, align 4
  %440 = load i32, ptr %152, align 4
  %441 = load i32, ptr %103, align 4
  %442 = ashr i32 %440, %441
  store i32 %442, ptr %104, align 4
  store i32 63, ptr %105, align 4
  %443 = load i32, ptr %104, align 4
  %444 = load i32, ptr %105, align 4
  %445 = and i32 %443, %444
  store i32 %445, ptr %106, align 4
  %446 = load i32, ptr %102, align 4
  %447 = load i32, ptr %106, align 4
  %448 = or i32 %446, %447
  store i32 %448, ptr %107, align 4
  %449 = load i32, ptr %107, align 4
  %450 = trunc i32 %449 to i8
  store i8 %450, ptr %108, align 1
  %451 = load i32, ptr %101, align 4
  %452 = sext i32 %451 to i64
  store i64 %452, ptr %109, align 4
  %453 = load ptr, ptr %161, align 8
  %454 = load i64, ptr %109, align 4
  %455 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %454
  %456 = getelementptr i8, ptr %453, i64 %455
  %457 = load i8, ptr %108, align 1
  store i8 %457, ptr %456, align 1
  store i32 2, ptr %110, align 4
  store i32 -128, ptr %111, align 4
  store i32 6, ptr %112, align 4
  %458 = load i32, ptr %152, align 4
  %459 = load i32, ptr %112, align 4
  %460 = ashr i32 %458, %459
  store i32 %460, ptr %113, align 4
  store i32 63, ptr %114, align 4
  %461 = load i32, ptr %113, align 4
  %462 = load i32, ptr %114, align 4
  %463 = and i32 %461, %462
  store i32 %463, ptr %115, align 4
  %464 = load i32, ptr %111, align 4
  %465 = load i32, ptr %115, align 4
  %466 = or i32 %464, %465
  store i32 %466, ptr %116, align 4
  %467 = load i32, ptr %116, align 4
  %468 = trunc i32 %467 to i8
  store i8 %468, ptr %117, align 1
  %469 = load i32, ptr %110, align 4
  %470 = sext i32 %469 to i64
  store i64 %470, ptr %118, align 4
  %471 = load ptr, ptr %161, align 8
  %472 = load i64, ptr %118, align 4
  %473 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %472
  %474 = getelementptr i8, ptr %471, i64 %473
  %475 = load i8, ptr %117, align 1
  store i8 %475, ptr %474, align 1
  store i32 3, ptr %119, align 4
  store i32 -128, ptr %120, align 4
  store i32 63, ptr %121, align 4
  %476 = load i32, ptr %152, align 4
  %477 = load i32, ptr %121, align 4
  %478 = and i32 %476, %477
  store i32 %478, ptr %122, align 4
  %479 = load i32, ptr %120, align 4
  %480 = load i32, ptr %122, align 4
  %481 = or i32 %479, %480
  store i32 %481, ptr %123, align 4
  %482 = load i32, ptr %123, align 4
  %483 = trunc i32 %482 to i8
  store i8 %483, ptr %124, align 1
  %484 = load i32, ptr %119, align 4
  %485 = sext i32 %484 to i64
  store i64 %485, ptr %125, align 4
  %486 = load ptr, ptr %161, align 8
  %487 = load i64, ptr %125, align 4
  %488 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %487
  %489 = getelementptr i8, ptr %486, i64 %488
  %490 = load i8, ptr %124, align 1
  store i8 %490, ptr %489, align 1
  store i32 4, ptr %126, align 4
  store i32 1, ptr %127, align 4
  store ptr @String, ptr %128, align 8
  %491 = load ptr, ptr %128, align 8
  %492 = getelementptr ptr, ptr %491, i32 6
  %493 = load ptr, ptr %492, align 8
  %494 = call { i64, i64 } @size_wrapper(ptr %493, ptr %128)
  %495 = extractvalue { i64, i64 } %494, 0
  %496 = call ptr @bump_malloc(i64 %495)
  store ptr @String, ptr %132, align 8
  store ptr %496, ptr %131, align 8
  store i32 10, ptr %129, align 4
  store i32 4, ptr %133, align 4
  store i32 1, ptr %134, align 4
  %497 = load ptr, ptr %161, align 8
  %498 = insertvalue { ptr } undef, ptr %497, 0
  %499 = load i32, ptr %133, align 4
  %500 = load i32, ptr %134, align 4
  %501 = load i32, ptr %153, align 4
  %502 = load ptr, ptr %132, align 8
  %503 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %502, 0
  %504 = load ptr, ptr %131, align 8
  %505 = insertvalue { ptr, ptr, ptr, i32 } %503, ptr %504, 1
  %506 = load ptr, ptr %130, align 8
  %507 = insertvalue { ptr, ptr, ptr, i32 } %505, ptr %506, 2
  %508 = load i32, ptr %129, align 4
  %509 = insertvalue { ptr, ptr, ptr, i32 } %507, i32 %508, 3
  %510 = getelementptr [4 x ptr], ptr %135, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %510, align 8
  %511 = getelementptr [4 x ptr], ptr %135, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %511, align 8
  %512 = getelementptr [4 x ptr], ptr %135, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %512, align 8
  %513 = getelementptr [4 x ptr], ptr %135, i32 0, i32 3
  store ptr @_parameterization_i32, ptr %513, align 8
  %514 = call ptr @llvm.invariant.start.p0(i64 16, ptr %135)
  %515 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %502)
  %516 = getelementptr ptr, ptr %502, i32 %508
  %517 = getelementptr ptr, ptr %516, i32 12
  %518 = load ptr, ptr %517, align 8
  %519 = getelementptr { ptr, ptr, ptr, ptr }, ptr %136, i32 0, i32 0
  store ptr @buffer_typ, ptr %519, align 8
  %520 = getelementptr { ptr, ptr, ptr, ptr }, ptr %136, i32 0, i32 1
  store ptr @i32_typ, ptr %520, align 8
  %521 = getelementptr { ptr, ptr, ptr, ptr }, ptr %136, i32 0, i32 2
  store ptr @i32_typ, ptr %521, align 8
  %522 = getelementptr { ptr, ptr, ptr, ptr }, ptr %136, i32 0, i32 3
  store ptr @i32_typ, ptr %522, align 8
  %523 = call ptr @behavior_wrapper(ptr %518, { ptr, ptr, ptr, i32 } %509, ptr %136)
  call void %523({ ptr, ptr, ptr, i32 } %509, { ptr, ptr, ptr, i32 } %509, ptr %135, { ptr } %498, i32 %499, i32 %500, i32 %501)
  %524 = load ptr, ptr %132, align 8
  store ptr %524, ptr %140, align 8
  %525 = load ptr, ptr %131, align 8
  store ptr %525, ptr %139, align 8
  %526 = load ptr, ptr %130, align 8
  store ptr %526, ptr %138, align 8
  %527 = load i32, ptr %129, align 4
  store i32 %527, ptr %137, align 4
  %528 = load ptr, ptr %140, align 8
  %529 = call i32 @get_offset(ptr %528, ptr @String)
  store i32 %529, ptr %137, align 4
  %530 = load ptr, ptr %140, align 8
  %531 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %530, 0
  %532 = load ptr, ptr %139, align 8
  %533 = insertvalue { ptr, ptr, ptr, i32 } %531, ptr %532, 1
  %534 = load ptr, ptr %138, align 8
  %535 = insertvalue { ptr, ptr, ptr, i32 } %533, ptr %534, 2
  %536 = load i32, ptr %137, align 4
  %537 = insertvalue { ptr, ptr, ptr, i32 } %535, i32 %536, 3
  br label %568

538:                                              ; preds = %417
  %539 = call ptr @llvm.invariant.start.p0(i64 0, ptr %141)
  %540 = call ptr @llvm.invariant.start.p0(i64 80, ptr @Unicode)
  %541 = load ptr, ptr getelementptr (ptr, ptr getelementptr (ptr, ptr @Unicode, i32 10), i32 1), align 8
  %542 = call ptr @class_behavior_wrapper(ptr %541, ptr %142)
  %543 = call { ptr, ptr, ptr, i32 } %542(ptr %141)
  store { ptr, ptr, ptr, i32 } %543, ptr %143, align 8
  %544 = getelementptr { ptr, ptr, ptr, i32 }, ptr %143, i32 0, i32 0
  %545 = load ptr, ptr %544, align 8
  store ptr %545, ptr %147, align 8
  %546 = getelementptr { ptr, ptr, ptr, i32 }, ptr %143, i32 0, i32 1
  %547 = load ptr, ptr %546, align 8
  store ptr %547, ptr %146, align 8
  %548 = getelementptr { ptr, ptr, ptr, i32 }, ptr %143, i32 0, i32 2
  %549 = load ptr, ptr %548, align 8
  store ptr %549, ptr %145, align 8
  %550 = getelementptr { ptr, ptr, ptr, i32 }, ptr %143, i32 0, i32 3
  %551 = load i32, ptr %550, align 4
  store i32 %551, ptr %144, align 4
  %552 = load ptr, ptr %147, align 8
  %553 = call i32 @get_offset(ptr %552, ptr @String)
  store i32 %553, ptr %144, align 4
  %554 = load ptr, ptr %147, align 8
  store ptr %554, ptr %151, align 8
  %555 = load ptr, ptr %146, align 8
  store ptr %555, ptr %150, align 8
  %556 = load ptr, ptr %145, align 8
  store ptr %556, ptr %149, align 8
  %557 = load i32, ptr %144, align 4
  store i32 %557, ptr %148, align 4
  %558 = load ptr, ptr %151, align 8
  %559 = call i32 @get_offset(ptr %558, ptr @String)
  store i32 %559, ptr %148, align 4
  %560 = load ptr, ptr %151, align 8
  %561 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %560, 0
  %562 = load ptr, ptr %150, align 8
  %563 = insertvalue { ptr, ptr, ptr, i32 } %561, ptr %562, 1
  %564 = load ptr, ptr %149, align 8
  %565 = insertvalue { ptr, ptr, ptr, i32 } %563, ptr %564, 2
  %566 = load i32, ptr %148, align 4
  %567 = insertvalue { ptr, ptr, ptr, i32 } %565, i32 %566, 3
  br label %568

568:                                              ; preds = %424, %538
  %569 = phi { ptr, ptr, ptr, i32 } [ %567, %538 ], [ %537, %424 ]
  br label %570

570:                                              ; preds = %568
  br label %571

571:                                              ; preds = %321, %570
  %572 = phi { ptr, ptr, ptr, i32 } [ %569, %570 ], [ %416, %321 ]
  br label %573

573:                                              ; preds = %571
  br label %574

574:                                              ; preds = %236, %573
  %575 = phi { ptr, ptr, ptr, i32 } [ %572, %573 ], [ %313, %236 ]
  br label %576

576:                                              ; preds = %574
  br label %577

577:                                              ; preds = %172, %576
  %578 = phi { ptr, ptr, ptr, i32 } [ %575, %576 ], [ %228, %172 ]
  br label %579

579:                                              ; preds = %577
  ret { ptr, ptr, ptr, i32 } %578
}

define ptr @Unicode_B__Self_encode_one_cpi32(ptr %0) {
  %2 = alloca i1, align 1
  %3 = call ptr @llvm.invariant.start.p0(i64 8, ptr %0)
  %4 = alloca ptr, align 8
  %5 = load ptr, ptr %0, align 8
  %6 = ptrtoint ptr %5 to i64
  %7 = icmp eq i64 %6, ptrtoint (ptr @i32_typ to i64)
  %8 = zext i1 %7 to i8
  store i8 %8, ptr %2, align 1
  store i32 9, ptr %4, align 4
  %9 = load i32, ptr %4, align 4
  %10 = getelementptr [10 x ptr], ptr @Unicode, i32 0, i32 %9
  %11 = getelementptr ptr, ptr %10, i32 10
  %12 = load ptr, ptr %11, align 8
  ret ptr %12
}

define { i64, i64 } @_data_size_Representable(ptr %0) {
  ret { i64, i64 } { i64 0, i64 1 }
}

define { ptr, ptr, ptr, i32 } @Representable_repr_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %8, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %7, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @Representable)
  store i32 %18, ptr %5, align 4
  %19 = alloca i32, align 4
  store i32 7, ptr %19, align 4
  %20 = alloca i64, align 8
  %21 = load i32, ptr %19, align 4
  %22 = sext i32 %21 to i64
  store i64 %22, ptr %20, align 4
  %23 = load i64, ptr %20, align 4
  %24 = alloca ptr, align 8
  %25 = mul i64 %23, ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
  %26 = call ptr @bump_malloc(i64 %25)
  store ptr %26, ptr %24, align 8
  %27 = alloca ptr, align 8
  %28 = getelementptr { ptr }, ptr %24, i32 0, i32 0
  %29 = load ptr, ptr %28, align 8
  store ptr %29, ptr %27, align 8
  %30 = alloca [6 x i8], align 1
  store [6 x i8] c"Object", ptr %30, align 1
  %31 = alloca i32, align 4
  store i32 0, ptr %31, align 4
  %32 = load ptr, ptr %27, align 8
  %33 = load i64, ptr %31, align 4
  %34 = mul i64 ptrtoint (ptr getelementptr ([6 x i8], ptr null, i32 1) to i64), %33
  %35 = getelementptr i8, ptr %32, i64 %34
  %36 = load <6 x i8>, ptr %30, align 1
  store <6 x i8> %36, ptr %35, align 1
  %37 = alloca i32, align 4
  store i32 6, ptr %37, align 4
  %38 = alloca i32, align 4
  store i32 6, ptr %38, align 4
  %39 = alloca i32, align 4
  store i32 7, ptr %39, align 4
  %40 = alloca [1 x ptr], align 8
  store ptr @String, ptr %40, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = getelementptr ptr, ptr %41, i32 6
  %43 = load ptr, ptr %42, align 8
  %44 = call { i64, i64 } @size_wrapper(ptr %43, ptr %40)
  %45 = extractvalue { i64, i64 } %44, 0
  %46 = call ptr @bump_malloc(i64 %45)
  %47 = alloca i32, align 4
  %48 = alloca ptr, align 8
  %49 = alloca ptr, align 8
  %50 = alloca ptr, align 8
  store ptr @String, ptr %50, align 8
  store ptr %46, ptr %49, align 8
  store i32 10, ptr %47, align 4
  %51 = alloca i32, align 4
  store i32 6, ptr %51, align 4
  %52 = alloca i32, align 4
  store i32 6, ptr %52, align 4
  %53 = alloca i32, align 4
  store i32 7, ptr %53, align 4
  %54 = load ptr, ptr %27, align 8
  %55 = insertvalue { ptr } undef, ptr %54, 0
  %56 = load i32, ptr %51, align 4
  %57 = load i32, ptr %52, align 4
  %58 = load i32, ptr %53, align 4
  %59 = load ptr, ptr %50, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %59, 0
  %61 = load ptr, ptr %49, align 8
  %62 = insertvalue { ptr, ptr, ptr, i32 } %60, ptr %61, 1
  %63 = load ptr, ptr %48, align 8
  %64 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %63, 2
  %65 = load i32, ptr %47, align 4
  %66 = insertvalue { ptr, ptr, ptr, i32 } %64, i32 %65, 3
  %67 = alloca [4 x ptr], align 8
  %68 = getelementptr [4 x ptr], ptr %67, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %68, align 8
  %69 = getelementptr [4 x ptr], ptr %67, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %69, align 8
  %70 = getelementptr [4 x ptr], ptr %67, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %70, align 8
  %71 = getelementptr [4 x ptr], ptr %67, i32 0, i32 3
  store ptr @_parameterization_i32, ptr %71, align 8
  %72 = call ptr @llvm.invariant.start.p0(i64 16, ptr %67)
  %73 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %59)
  %74 = getelementptr ptr, ptr %59, i32 %65
  %75 = getelementptr ptr, ptr %74, i32 12
  %76 = load ptr, ptr %75, align 8
  %77 = alloca { ptr, ptr, ptr, ptr }, align 8
  %78 = getelementptr { ptr, ptr, ptr, ptr }, ptr %77, i32 0, i32 0
  store ptr @buffer_typ, ptr %78, align 8
  %79 = getelementptr { ptr, ptr, ptr, ptr }, ptr %77, i32 0, i32 1
  store ptr @i32_typ, ptr %79, align 8
  %80 = getelementptr { ptr, ptr, ptr, ptr }, ptr %77, i32 0, i32 2
  store ptr @i32_typ, ptr %80, align 8
  %81 = getelementptr { ptr, ptr, ptr, ptr }, ptr %77, i32 0, i32 3
  store ptr @i32_typ, ptr %81, align 8
  %82 = call ptr @behavior_wrapper(ptr %76, { ptr, ptr, ptr, i32 } %66, ptr %77)
  call void %82({ ptr, ptr, ptr, i32 } %66, { ptr, ptr, ptr, i32 } %66, ptr %67, { ptr } %55, i32 %56, i32 %57, i32 %58)
  %83 = alloca i32, align 4
  %84 = alloca ptr, align 8
  %85 = alloca ptr, align 8
  %86 = alloca ptr, align 8
  %87 = load ptr, ptr %50, align 8
  store ptr %87, ptr %86, align 8
  %88 = load ptr, ptr %49, align 8
  store ptr %88, ptr %85, align 8
  %89 = load ptr, ptr %48, align 8
  store ptr %89, ptr %84, align 8
  %90 = load i32, ptr %47, align 4
  store i32 %90, ptr %83, align 4
  %91 = load ptr, ptr %86, align 8
  %92 = call i32 @get_offset(ptr %91, ptr @String)
  store i32 %92, ptr %83, align 4
  %93 = load ptr, ptr %86, align 8
  %94 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %93, 0
  %95 = load ptr, ptr %85, align 8
  %96 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr %95, 1
  %97 = load ptr, ptr %84, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } %96, ptr %97, 2
  %99 = load i32, ptr %83, align 4
  %100 = insertvalue { ptr, ptr, ptr, i32 } %98, i32 %99, 3
  ret { ptr, ptr, ptr, i32 } %100
}

define ptr @Representable_B_repr_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 1, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [2 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { i64, i64 } @_data_size_String(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), %10
  %12 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %5
  %13 = select i1 %12, i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), i64 %5
  %14 = urem i64 %11, ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %17
  %19 = add i64 %11, %18
  %20 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %13
  %21 = select i1 %20, i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), i64 %13
  %22 = urem i64 %19, ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %23 = icmp eq i64 %22, 0
  %24 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %22
  %25 = select i1 %23, i64 0, i64 %24
  %26 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %25
  %27 = add i64 %19, %26
  %28 = urem i64 %27, %21
  %29 = icmp eq i64 %28, 0
  %30 = sub i64 %21, %28
  %31 = select i1 %29, i64 0, i64 %30
  %32 = add i64 %27, %31
  %33 = insertvalue { i64, i64 } undef, i64 %32, 0
  %34 = insertvalue { i64, i64 } %33, i64 %21, 1
  ret { i64, i64 } %34
}

define { ptr } @String_getter_bytes(ptr %0) {
  %2 = getelementptr i8, ptr %0, i64 0
  %3 = getelementptr { ptr }, ptr %2, i32 0, i32 0
  %4 = load ptr, ptr %3, align 8
  %5 = insertvalue { ptr } undef, ptr %4, 0
  ret { ptr } %5
}

define void @String_setter_bytes(ptr %0, { ptr } %1) {
  %3 = getelementptr i8, ptr %0, i64 0
  %4 = alloca ptr, align 8
  store { ptr } %1, ptr %4, align 8
  %5 = getelementptr { ptr }, ptr %3, i32 0, i32 0
  %6 = load ptr, ptr %4, align 8
  store ptr %6, ptr %5, align 8
  ret void
}

define i32 @String_getter_byte_length(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), %5
  %7 = getelementptr i8, ptr %0, i64 %6
  %8 = load i32, ptr %7, align 4
  ret i32 %8
}

define void @String_setter_byte_length(ptr %0, i32 %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), %6
  %8 = getelementptr i8, ptr %0, i64 %7
  %9 = alloca i32, align 4
  store i32 %1, ptr %9, align 4
  %10 = load i32, ptr %9, align 4
  store i32 %10, ptr %8, align 4
  ret void
}

define i32 @String_getter_char_length(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %7, %11
  %13 = getelementptr i8, ptr %0, i64 %12
  %14 = load i32, ptr %13, align 4
  ret i32 %14
}

define void @String_setter_char_length(ptr %0, i32 %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %8, %12
  %14 = getelementptr i8, ptr %0, i64 %13
  %15 = alloca i32, align 4
  store i32 %1, ptr %15, align 4
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %14, align 4
  ret void
}

define i32 @String_getter_capacity(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %11
  %13 = add i64 %7, %12
  %14 = urem i64 %13, ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 %13, %17
  %19 = getelementptr i8, ptr %0, i64 %18
  %20 = load i32, ptr %19, align 4
  ret i32 %20
}

define void @String_setter_capacity(ptr %0, i32 %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %12
  %14 = add i64 %8, %13
  %15 = urem i64 %14, ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %16 = icmp eq i64 %15, 0
  %17 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add i64 %14, %18
  %20 = getelementptr i8, ptr %0, i64 %19
  %21 = alloca i32, align 4
  store i32 %1, ptr %21, align 4
  %22 = load i32, ptr %21, align 4
  store i32 %22, ptr %20, align 4
  ret void
}

define ptr @String_field_String_0(ptr %0) {
  ret ptr @_parameterization_Character
}

define i32 @String_byte_length_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @String)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 1
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr { ptr, ptr }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = call i32 %27(ptr %19) #1
  %29 = alloca i32, align 4
  store i32 %28, ptr %29, align 4
  %30 = load i32, ptr %29, align 4
  ret i32 %30
}

define ptr @String_B_byte_length_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 45, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [314 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define i32 @String_capacity_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @String)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 3
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr { ptr, ptr }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = call i32 %27(ptr %19) #1
  %29 = alloca i32, align 4
  store i32 %28, ptr %29, align 4
  %30 = load i32, ptr %29, align 4
  ret i32 %30
}

define ptr @String_B_capacity_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 46, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [314 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { ptr, ptr, ptr, i32 } @String__Self_from_bytes_source_bytesBufferi8_source_leni32(ptr %0, { ptr } %1, i32 %2) {
  %4 = alloca i1, align 1
  %5 = alloca [3 x ptr], align 8
  %6 = alloca { ptr, ptr, ptr }, align 8
  %7 = alloca { ptr, i64 }, align 8
  %8 = alloca i1, align 1
  %9 = alloca [0 x i8], align 1
  %10 = alloca [1 x ptr], align 8
  %11 = alloca { ptr, ptr, ptr, i32 }, align 8
  %12 = alloca [0 x ptr], align 8
  %13 = alloca {}, align 8
  %14 = alloca i32, align 4
  %15 = alloca i32, align 4
  %16 = alloca i64, align 8
  %17 = alloca ptr, align 8
  %18 = alloca ptr, align 8
  %19 = alloca [55 x i8], align 1
  %20 = alloca i32, align 4
  %21 = alloca i32, align 4
  %22 = alloca i32, align 4
  %23 = alloca i32, align 4
  %24 = alloca [1 x ptr], align 8
  %25 = alloca i32, align 4
  %26 = alloca ptr, align 8
  %27 = alloca ptr, align 8
  %28 = alloca ptr, align 8
  %29 = alloca i32, align 4
  %30 = alloca i32, align 4
  %31 = alloca i32, align 4
  %32 = alloca [4 x ptr], align 8
  %33 = alloca { ptr, ptr, ptr, ptr }, align 8
  %34 = alloca i32, align 4
  %35 = alloca ptr, align 8
  %36 = alloca ptr, align 8
  %37 = alloca ptr, align 8
  %38 = alloca [2 x ptr], align 8
  %39 = alloca { ptr, ptr }, align 8
  %40 = alloca { ptr, i160 }, align 8
  %41 = alloca { ptr, i160 }, align 8
  %42 = alloca i64, align 8
  %43 = alloca ptr, align 8
  %44 = alloca i1, align 1
  %45 = alloca <2 x i32>, align 8
  %46 = alloca i32, align 4
  %47 = alloca [3 x ptr], align 8
  %48 = alloca { ptr, ptr, ptr }, align 8
  %49 = alloca { ptr, ptr, ptr, i32 }, align 8
  %50 = alloca i32, align 4
  %51 = alloca ptr, align 8
  %52 = alloca ptr, align 8
  %53 = alloca ptr, align 8
  %54 = alloca i32, align 4
  %55 = alloca i64, align 8
  %56 = alloca ptr, align 8
  %57 = alloca i32, align 4
  %58 = alloca ptr, align 8
  %59 = alloca ptr, align 8
  %60 = alloca ptr, align 8
  %61 = alloca ptr, align 8
  store { ptr } %1, ptr %61, align 8
  %62 = alloca i32, align 4
  store i32 %2, ptr %62, align 4
  %63 = alloca [1 x ptr], align 8
  store ptr @String, ptr %63, align 8
  %64 = load ptr, ptr %63, align 8
  %65 = getelementptr ptr, ptr %64, i32 6
  %66 = load ptr, ptr %65, align 8
  %67 = call { i64, i64 } @size_wrapper(ptr %66, ptr %63)
  %68 = extractvalue { i64, i64 } %67, 0
  %69 = call ptr @bump_malloc(i64 %68)
  %70 = alloca i32, align 4
  %71 = alloca ptr, align 8
  %72 = alloca ptr, align 8
  %73 = alloca ptr, align 8
  store ptr @String, ptr %73, align 8
  store ptr %69, ptr %72, align 8
  store i32 10, ptr %70, align 4
  %74 = load i32, ptr %62, align 4
  %75 = load ptr, ptr %73, align 8
  %76 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %75, 0
  %77 = load ptr, ptr %72, align 8
  %78 = insertvalue { ptr, ptr, ptr, i32 } %76, ptr %77, 1
  %79 = load ptr, ptr %71, align 8
  %80 = insertvalue { ptr, ptr, ptr, i32 } %78, ptr %79, 2
  %81 = load i32, ptr %70, align 4
  %82 = insertvalue { ptr, ptr, ptr, i32 } %80, i32 %81, 3
  %83 = alloca [1 x ptr], align 8
  %84 = getelementptr [1 x ptr], ptr %83, i32 0, i32 0
  store ptr @_parameterization_i32, ptr %84, align 8
  %85 = call ptr @llvm.invariant.start.p0(i64 1, ptr %83)
  %86 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %75)
  %87 = getelementptr ptr, ptr %75, i32 %81
  %88 = getelementptr ptr, ptr %87, i32 11
  %89 = load ptr, ptr %88, align 8
  %90 = alloca { ptr }, align 8
  %91 = getelementptr { ptr }, ptr %90, i32 0, i32 0
  store ptr @i32_typ, ptr %91, align 8
  %92 = call ptr @behavior_wrapper(ptr %89, { ptr, ptr, ptr, i32 } %82, ptr %90)
  call void %92({ ptr, ptr, ptr, i32 } %82, { ptr, ptr, ptr, i32 } %82, ptr %83, i32 %74)
  %93 = alloca i32, align 4
  %94 = alloca ptr, align 8
  %95 = alloca ptr, align 8
  %96 = alloca ptr, align 8
  %97 = load ptr, ptr %73, align 8
  store ptr %97, ptr %96, align 8
  %98 = load ptr, ptr %72, align 8
  store ptr %98, ptr %95, align 8
  %99 = load ptr, ptr %71, align 8
  store ptr %99, ptr %94, align 8
  %100 = load i32, ptr %70, align 4
  store i32 %100, ptr %93, align 4
  %101 = alloca i32, align 4
  store i32 0, ptr %101, align 4
  br label %102

102:                                              ; preds = %319, %3
  %103 = load i32, ptr %101, align 4
  %104 = load i32, ptr %62, align 4
  %105 = icmp slt i32 %103, %104
  %106 = zext i1 %105 to i8
  store i8 %106, ptr %4, align 1
  %107 = load i8, ptr %4, align 1
  %108 = trunc i8 %107 to i1
  br i1 %108, label %109, label %319

109:                                              ; preds = %102
  %110 = load ptr, ptr %61, align 8
  %111 = insertvalue { ptr } undef, ptr %110, 0
  %112 = load i32, ptr %101, align 4
  %113 = load i32, ptr %62, align 4
  %114 = getelementptr [3 x ptr], ptr %5, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %114, align 8
  %115 = getelementptr [3 x ptr], ptr %5, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %115, align 8
  %116 = getelementptr [3 x ptr], ptr %5, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %116, align 8
  %117 = call ptr @llvm.invariant.start.p0(i64 9, ptr %5)
  %118 = call ptr @llvm.invariant.start.p0(i64 80, ptr @Unicode)
  %119 = load ptr, ptr getelementptr (ptr, ptr getelementptr (ptr, ptr @Unicode, i32 10), i32 3), align 8
  %120 = getelementptr { ptr, ptr, ptr }, ptr %6, i32 0, i32 0
  store ptr @buffer_typ, ptr %120, align 8
  %121 = getelementptr { ptr, ptr, ptr }, ptr %6, i32 0, i32 1
  store ptr @i32_typ, ptr %121, align 8
  %122 = getelementptr { ptr, ptr, ptr }, ptr %6, i32 0, i32 2
  store ptr @i32_typ, ptr %122, align 8
  %123 = call ptr @class_behavior_wrapper(ptr %119, ptr %6)
  %124 = call { ptr, i64 } %123(ptr %5, { ptr } %111, i32 %112, i32 %113)
  store { ptr, i64 } %124, ptr %7, align 8
  %125 = load ptr, ptr %7, align 8
  %126 = ptrtoint ptr %125 to i64
  %127 = icmp eq i64 %126, ptrtoint (ptr @nil_typ to i64)
  %128 = icmp eq i64 %126, 0
  %129 = or i1 %127, %128
  %130 = zext i1 %129 to i8
  store i8 %130, ptr %8, align 1
  %131 = load i8, ptr %8, align 1
  %132 = trunc i8 %131 to i1
  br i1 %132, label %133, label %260

133:                                              ; preds = %109
  %134 = getelementptr { ptr, i64 }, ptr %7, i32 0, i32 1
  %135 = load [0 x i8], ptr %134, align 1
  store [0 x i8] %135, ptr %9, align 1
  store ptr @InvalidUTF8Error, ptr %10, align 8
  %136 = load ptr, ptr %10, align 8
  %137 = getelementptr ptr, ptr %136, i32 6
  %138 = load ptr, ptr %137, align 8
  %139 = call { i64, i64 } @size_wrapper(ptr %138, ptr %10)
  %140 = extractvalue { i64, i64 } %139, 0
  %141 = call ptr @bump_malloc(i64 %140)
  %142 = getelementptr { ptr, ptr, ptr, i32 }, ptr %11, i32 0, i32 1
  %143 = getelementptr { ptr, ptr, ptr, i32 }, ptr %11, i32 0, i32 3
  store ptr @InvalidUTF8Error, ptr %11, align 8
  store ptr %141, ptr %142, align 8
  store i32 10, ptr %143, align 4
  %144 = getelementptr { ptr, ptr, ptr, i32 }, ptr %11, i32 0, i32 0
  %145 = load ptr, ptr %144, align 8
  %146 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %145, 0
  %147 = load ptr, ptr %142, align 8
  %148 = insertvalue { ptr, ptr, ptr, i32 } %146, ptr %147, 1
  %149 = getelementptr { ptr, ptr, ptr, i32 }, ptr %11, i32 0, i32 2
  %150 = load ptr, ptr %149, align 8
  %151 = insertvalue { ptr, ptr, ptr, i32 } %148, ptr %150, 2
  %152 = load i32, ptr %143, align 4
  %153 = insertvalue { ptr, ptr, ptr, i32 } %151, i32 %152, 3
  %154 = call ptr @llvm.invariant.start.p0(i64 0, ptr %12)
  %155 = call ptr @llvm.invariant.start.p0(i64 224, ptr %145)
  %156 = getelementptr ptr, ptr %145, i32 %152
  %157 = getelementptr ptr, ptr %156, i32 5
  %158 = load ptr, ptr %157, align 8
  %159 = call ptr @behavior_wrapper(ptr %158, { ptr, ptr, ptr, i32 } %153, ptr %13)
  call void %159({ ptr, ptr, ptr, i32 } %153, { ptr, ptr, ptr, i32 } %153, ptr %12)
  store i32 141, ptr %14, align 4
  store i32 56, ptr %15, align 4
  %160 = load i32, ptr %15, align 4
  %161 = sext i32 %160 to i64
  store i64 %161, ptr %16, align 4
  %162 = load i64, ptr %16, align 4
  %163 = mul i64 %162, ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
  %164 = call ptr @bump_malloc(i64 %163)
  store ptr %164, ptr %17, align 8
  %165 = getelementptr { ptr }, ptr %17, i32 0, i32 0
  %166 = load ptr, ptr %165, align 8
  store ptr %166, ptr %18, align 8
  store [55 x i8] c"C:/Users/PaulK/OneDrive/Documents/PL/PyPL/lib/core.mini", ptr %19, align 1
  store i32 0, ptr %20, align 4
  %167 = load ptr, ptr %18, align 8
  %168 = load i64, ptr %20, align 4
  %169 = mul i64 ptrtoint (ptr getelementptr ([55 x i8], ptr null, i32 1) to i64), %168
  %170 = getelementptr i8, ptr %167, i64 %169
  %171 = load <55 x i8>, ptr %19, align 1
  store <55 x i8> %171, ptr %170, align 1
  store i32 55, ptr %21, align 4
  store i32 55, ptr %22, align 4
  store i32 56, ptr %23, align 4
  store ptr @String, ptr %24, align 8
  %172 = load ptr, ptr %24, align 8
  %173 = getelementptr ptr, ptr %172, i32 6
  %174 = load ptr, ptr %173, align 8
  %175 = call { i64, i64 } @size_wrapper(ptr %174, ptr %24)
  %176 = extractvalue { i64, i64 } %175, 0
  %177 = call ptr @bump_malloc(i64 %176)
  store ptr @String, ptr %28, align 8
  store ptr %177, ptr %27, align 8
  store i32 10, ptr %25, align 4
  store i32 55, ptr %29, align 4
  store i32 55, ptr %30, align 4
  store i32 56, ptr %31, align 4
  %178 = load ptr, ptr %18, align 8
  %179 = insertvalue { ptr } undef, ptr %178, 0
  %180 = load i32, ptr %29, align 4
  %181 = load i32, ptr %30, align 4
  %182 = load i32, ptr %31, align 4
  %183 = load ptr, ptr %28, align 8
  %184 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %183, 0
  %185 = load ptr, ptr %27, align 8
  %186 = insertvalue { ptr, ptr, ptr, i32 } %184, ptr %185, 1
  %187 = load ptr, ptr %26, align 8
  %188 = insertvalue { ptr, ptr, ptr, i32 } %186, ptr %187, 2
  %189 = load i32, ptr %25, align 4
  %190 = insertvalue { ptr, ptr, ptr, i32 } %188, i32 %189, 3
  %191 = getelementptr [4 x ptr], ptr %32, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %191, align 8
  %192 = getelementptr [4 x ptr], ptr %32, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %192, align 8
  %193 = getelementptr [4 x ptr], ptr %32, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %193, align 8
  %194 = getelementptr [4 x ptr], ptr %32, i32 0, i32 3
  store ptr @_parameterization_i32, ptr %194, align 8
  %195 = call ptr @llvm.invariant.start.p0(i64 16, ptr %32)
  %196 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %183)
  %197 = getelementptr ptr, ptr %183, i32 %189
  %198 = getelementptr ptr, ptr %197, i32 12
  %199 = load ptr, ptr %198, align 8
  %200 = getelementptr { ptr, ptr, ptr, ptr }, ptr %33, i32 0, i32 0
  store ptr @buffer_typ, ptr %200, align 8
  %201 = getelementptr { ptr, ptr, ptr, ptr }, ptr %33, i32 0, i32 1
  store ptr @i32_typ, ptr %201, align 8
  %202 = getelementptr { ptr, ptr, ptr, ptr }, ptr %33, i32 0, i32 2
  store ptr @i32_typ, ptr %202, align 8
  %203 = getelementptr { ptr, ptr, ptr, ptr }, ptr %33, i32 0, i32 3
  store ptr @i32_typ, ptr %203, align 8
  %204 = call ptr @behavior_wrapper(ptr %199, { ptr, ptr, ptr, i32 } %190, ptr %33)
  call void %204({ ptr, ptr, ptr, i32 } %190, { ptr, ptr, ptr, i32 } %190, ptr %32, { ptr } %179, i32 %180, i32 %181, i32 %182)
  %205 = load i32, ptr %14, align 4
  %206 = load ptr, ptr %28, align 8
  store ptr %206, ptr %37, align 8
  %207 = load ptr, ptr %27, align 8
  store ptr %207, ptr %36, align 8
  %208 = load ptr, ptr %26, align 8
  store ptr %208, ptr %35, align 8
  %209 = load i32, ptr %25, align 4
  store i32 %209, ptr %34, align 4
  %210 = load ptr, ptr %37, align 8
  %211 = call i32 @get_offset(ptr %210, ptr @String)
  store i32 %211, ptr %34, align 4
  %212 = load ptr, ptr %37, align 8
  %213 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %212, 0
  %214 = load ptr, ptr %36, align 8
  %215 = insertvalue { ptr, ptr, ptr, i32 } %213, ptr %214, 1
  %216 = load ptr, ptr %35, align 8
  %217 = insertvalue { ptr, ptr, ptr, i32 } %215, ptr %216, 2
  %218 = load i32, ptr %34, align 4
  %219 = insertvalue { ptr, ptr, ptr, i32 } %217, i32 %218, 3
  %220 = load ptr, ptr %144, align 8
  %221 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %220, 0
  %222 = load ptr, ptr %142, align 8
  %223 = insertvalue { ptr, ptr, ptr, i32 } %221, ptr %222, 1
  %224 = load ptr, ptr %149, align 8
  %225 = insertvalue { ptr, ptr, ptr, i32 } %223, ptr %224, 2
  %226 = load i32, ptr %143, align 4
  %227 = insertvalue { ptr, ptr, ptr, i32 } %225, i32 %226, 3
  %228 = getelementptr [2 x ptr], ptr %38, i32 0, i32 0
  store ptr @_parameterization_i32, ptr %228, align 8
  %229 = getelementptr [2 x ptr], ptr %38, i32 0, i32 1
  store ptr @_parameterization_String, ptr %229, align 8
  %230 = call ptr @llvm.invariant.start.p0(i64 4, ptr %38)
  %231 = call ptr @llvm.invariant.start.p0(i64 224, ptr %220)
  %232 = getelementptr ptr, ptr %220, i32 %226
  %233 = getelementptr ptr, ptr %232, i32 6
  %234 = load ptr, ptr %233, align 8
  %235 = getelementptr { ptr, ptr }, ptr %39, i32 0, i32 0
  store ptr @i32_typ, ptr %235, align 8
  %236 = getelementptr { ptr, ptr }, ptr %39, i32 0, i32 1
  store ptr %212, ptr %236, align 8
  %237 = call ptr @behavior_wrapper(ptr %234, { ptr, ptr, ptr, i32 } %227, ptr %39)
  call void %237({ ptr, ptr, ptr, i32 } %227, { ptr, ptr, ptr, i32 } %227, ptr %38, i32 %205, { ptr, ptr, ptr, i32 } %219)
  %238 = getelementptr { ptr, i160 }, ptr %11, i32 0, i32 0
  %239 = load ptr, ptr %238, align 8
  %240 = insertvalue { ptr, i160 } undef, ptr %239, 0
  %241 = getelementptr { ptr, i160 }, ptr %11, i32 0, i32 1
  %242 = load i160, ptr %241, align 4
  %243 = insertvalue { ptr, i160 } %240, i160 %242, 1
  %244 = call ptr @get_current_coroutine()
  %245 = getelementptr { ptr, [3 x ptr], ptr, i1, { ptr, i160 } }, ptr %244, i32 0, i32 4
  store { ptr, i160 } %243, ptr %40, align 8
  %246 = getelementptr { ptr, i160 }, ptr %40, i32 0, i32 0
  %247 = getelementptr { ptr, i160 }, ptr %245, i32 0, i32 0
  %248 = load ptr, ptr %246, align 8
  store ptr %248, ptr %247, align 8
  %249 = getelementptr { ptr, i160 }, ptr %40, i32 0, i32 1
  %250 = getelementptr { ptr, i160 }, ptr %245, i32 0, i32 1
  %251 = load i160, ptr %249, align 4
  store i160 %251, ptr %250, align 4
  call void @coroutine_yield_cold(ptr %244)
  %252 = load ptr, ptr %247, align 8
  %253 = insertvalue { ptr, i160 } undef, ptr %252, 0
  %254 = load i160, ptr %250, align 4
  %255 = insertvalue { ptr, i160 } %253, i160 %254, 1
  store { ptr, i160 } %255, ptr %41, align 8
  %256 = load [0 x i8], ptr %9, align 1
  store [0 x i8] %256, ptr %42, align 1
  store ptr @nil_typ, ptr %43, align 8
  %257 = getelementptr { ptr, i64 }, ptr %7, i32 0, i32 0
  %258 = load ptr, ptr %43, align 8
  store ptr %258, ptr %257, align 8
  %259 = load i64, ptr %42, align 4
  store i64 %259, ptr %134, align 4
  br label %260

260:                                              ; preds = %133, %109
  %261 = load ptr, ptr %7, align 8
  %262 = ptrtoint ptr %261 to i64
  %263 = icmp eq i64 %262, ptrtoint (ptr @nil_typ to i64)
  %264 = icmp eq i64 %262, 0
  %265 = or i1 %263, %264
  %266 = icmp eq i1 %265, false
  %267 = zext i1 %266 to i8
  store i8 %267, ptr %44, align 1
  %268 = load i8, ptr %44, align 1
  %269 = trunc i8 %268 to i1
  br i1 %269, label %270, label %318

270:                                              ; preds = %260
  %271 = getelementptr { ptr, i64 }, ptr %7, i32 0, i32 1
  %272 = load <2 x i32>, ptr %271, align 8
  store <2 x i32> %272, ptr %45, align 8
  %273 = getelementptr <2 x i32>, ptr %45, i32 0, i32 1
  %274 = load i32, ptr %273, align 4
  store i32 %274, ptr %46, align 4
  %275 = load ptr, ptr %61, align 8
  %276 = insertvalue { ptr } undef, ptr %275, 0
  %277 = load i32, ptr %101, align 4
  %278 = load i32, ptr %46, align 4
  %279 = load ptr, ptr %96, align 8
  %280 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %279, 0
  %281 = load ptr, ptr %95, align 8
  %282 = insertvalue { ptr, ptr, ptr, i32 } %280, ptr %281, 1
  %283 = load ptr, ptr %94, align 8
  %284 = insertvalue { ptr, ptr, ptr, i32 } %282, ptr %283, 2
  %285 = load i32, ptr %93, align 4
  %286 = insertvalue { ptr, ptr, ptr, i32 } %284, i32 %285, 3
  %287 = getelementptr [3 x ptr], ptr %47, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %287, align 8
  %288 = getelementptr [3 x ptr], ptr %47, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %288, align 8
  %289 = getelementptr [3 x ptr], ptr %47, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %289, align 8
  %290 = call ptr @llvm.invariant.start.p0(i64 9, ptr %47)
  %291 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %279)
  %292 = getelementptr ptr, ptr %279, i32 %285
  %293 = getelementptr ptr, ptr %292, i32 14
  %294 = load ptr, ptr %293, align 8
  %295 = getelementptr { ptr, ptr, ptr }, ptr %48, i32 0, i32 0
  store ptr @buffer_typ, ptr %295, align 8
  %296 = getelementptr { ptr, ptr, ptr }, ptr %48, i32 0, i32 1
  store ptr @i32_typ, ptr %296, align 8
  %297 = getelementptr { ptr, ptr, ptr }, ptr %48, i32 0, i32 2
  store ptr @i32_typ, ptr %297, align 8
  %298 = call ptr @behavior_wrapper(ptr %294, { ptr, ptr, ptr, i32 } %286, ptr %48)
  %299 = call { ptr, ptr, ptr, i32 } %298({ ptr, ptr, ptr, i32 } %286, { ptr, ptr, ptr, i32 } %286, ptr %47, { ptr } %276, i32 %277, i32 %278)
  store { ptr, ptr, ptr, i32 } %299, ptr %49, align 8
  %300 = getelementptr { ptr, ptr, ptr, i32 }, ptr %49, i32 0, i32 0
  %301 = load ptr, ptr %300, align 8
  store ptr %301, ptr %51, align 8
  %302 = getelementptr { ptr, ptr, ptr, i32 }, ptr %49, i32 0, i32 1
  %303 = load ptr, ptr %302, align 8
  store ptr %303, ptr %53, align 8
  %304 = getelementptr { ptr, ptr, ptr, i32 }, ptr %49, i32 0, i32 2
  %305 = load ptr, ptr %304, align 8
  store ptr %305, ptr %52, align 8
  %306 = getelementptr { ptr, ptr, ptr, i32 }, ptr %49, i32 0, i32 3
  %307 = load i32, ptr %306, align 4
  store i32 %307, ptr %50, align 4
  %308 = load ptr, ptr %51, align 8
  %309 = call i32 @get_offset(ptr %308, ptr @String)
  store i32 %309, ptr %50, align 4
  %310 = load i32, ptr %101, align 4
  %311 = load i32, ptr %46, align 4
  %312 = add i32 %310, %311
  store i32 %312, ptr %54, align 4
  %313 = load <2 x i32>, ptr %45, align 8
  store <2 x i32> %313, ptr %55, align 8
  store ptr @tuple_typ, ptr %56, align 8
  %314 = getelementptr { ptr, i64 }, ptr %7, i32 0, i32 0
  %315 = load ptr, ptr %56, align 8
  store ptr %315, ptr %314, align 8
  %316 = load i64, ptr %55, align 4
  store i64 %316, ptr %271, align 4
  %317 = load i32, ptr %54, align 4
  store i32 %317, ptr %101, align 4
  br label %318

318:                                              ; preds = %270, %260
  br label %319

319:                                              ; preds = %318, %102
  br i1 %108, label %102, label %320

320:                                              ; preds = %319
  %321 = load ptr, ptr %96, align 8
  store ptr %321, ptr %60, align 8
  %322 = load ptr, ptr %95, align 8
  store ptr %322, ptr %59, align 8
  %323 = load ptr, ptr %94, align 8
  store ptr %323, ptr %58, align 8
  %324 = load i32, ptr %93, align 4
  store i32 %324, ptr %57, align 4
  %325 = load ptr, ptr %60, align 8
  %326 = call i32 @get_offset(ptr %325, ptr @String)
  store i32 %326, ptr %57, align 4
  %327 = load ptr, ptr %60, align 8
  %328 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %327, 0
  %329 = load ptr, ptr %59, align 8
  %330 = insertvalue { ptr, ptr, ptr, i32 } %328, ptr %329, 1
  %331 = load ptr, ptr %58, align 8
  %332 = insertvalue { ptr, ptr, ptr, i32 } %330, ptr %331, 2
  %333 = load i32, ptr %57, align 4
  %334 = insertvalue { ptr, ptr, ptr, i32 } %332, i32 %333, 3
  ret { ptr, ptr, ptr, i32 } %334
}

define ptr @String_B__Self_from_bytes_source_bytesBufferi8_source_leni32(ptr %0) {
  %2 = alloca i1, align 1
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 16, ptr %0)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %0, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @buffer_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  %10 = getelementptr ptr, ptr %0, i32 1
  %11 = load ptr, ptr %10, align 8
  %12 = ptrtoint ptr %11 to i64
  %13 = icmp eq i64 %12, ptrtoint (ptr @i32_typ to i64)
  %14 = zext i1 %13 to i8
  store i8 %14, ptr %2, align 1
  store i32 47, ptr %5, align 4
  %15 = load i32, ptr %5, align 4
  %16 = getelementptr [314 x ptr], ptr @String, i32 0, i32 %15
  %17 = getelementptr ptr, ptr %16, i32 10
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

define { ptr, ptr, ptr, i32 } @String__Self_from_bytes_lossy_source_bytesBufferi8_source_leni32(ptr %0, { ptr } %1, i32 %2) {
  %4 = alloca i1, align 1
  %5 = alloca [3 x ptr], align 8
  %6 = alloca { ptr, ptr, ptr }, align 8
  %7 = alloca { ptr, i64 }, align 8
  %8 = alloca i1, align 1
  %9 = alloca <2 x i32>, align 8
  %10 = alloca i32, align 4
  %11 = alloca [3 x ptr], align 8
  %12 = alloca { ptr, ptr, ptr }, align 8
  %13 = alloca { ptr, ptr, ptr, i32 }, align 8
  %14 = alloca i32, align 4
  %15 = alloca ptr, align 8
  %16 = alloca ptr, align 8
  %17 = alloca ptr, align 8
  %18 = alloca i32, align 4
  %19 = alloca i64, align 8
  %20 = alloca ptr, align 8
  %21 = alloca [0 x i8], align 1
  %22 = alloca i32, align 4
  %23 = alloca i32, align 4
  %24 = alloca [3 x ptr], align 8
  %25 = alloca { ptr, ptr, ptr }, align 8
  %26 = alloca { ptr, ptr, ptr, i32 }, align 8
  %27 = alloca i32, align 4
  %28 = alloca ptr, align 8
  %29 = alloca ptr, align 8
  %30 = alloca ptr, align 8
  %31 = alloca i32, align 4
  %32 = alloca i32, align 4
  %33 = alloca i64, align 8
  %34 = alloca ptr, align 8
  %35 = alloca i32, align 4
  %36 = alloca ptr, align 8
  %37 = alloca ptr, align 8
  %38 = alloca ptr, align 8
  %39 = alloca ptr, align 8
  store { ptr } %1, ptr %39, align 8
  %40 = alloca i32, align 4
  store i32 %2, ptr %40, align 4
  %41 = alloca [1 x ptr], align 8
  store ptr @String, ptr %41, align 8
  %42 = load ptr, ptr %41, align 8
  %43 = getelementptr ptr, ptr %42, i32 6
  %44 = load ptr, ptr %43, align 8
  %45 = call { i64, i64 } @size_wrapper(ptr %44, ptr %41)
  %46 = extractvalue { i64, i64 } %45, 0
  %47 = call ptr @bump_malloc(i64 %46)
  %48 = alloca i32, align 4
  %49 = alloca ptr, align 8
  %50 = alloca ptr, align 8
  %51 = alloca ptr, align 8
  store ptr @String, ptr %51, align 8
  store ptr %47, ptr %50, align 8
  store i32 10, ptr %48, align 4
  %52 = load i32, ptr %40, align 4
  %53 = load ptr, ptr %51, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %53, 0
  %55 = load ptr, ptr %50, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %55, 1
  %57 = load ptr, ptr %49, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %57, 2
  %59 = load i32, ptr %48, align 4
  %60 = insertvalue { ptr, ptr, ptr, i32 } %58, i32 %59, 3
  %61 = alloca [1 x ptr], align 8
  %62 = getelementptr [1 x ptr], ptr %61, i32 0, i32 0
  store ptr @_parameterization_i32, ptr %62, align 8
  %63 = call ptr @llvm.invariant.start.p0(i64 1, ptr %61)
  %64 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %53)
  %65 = getelementptr ptr, ptr %53, i32 %59
  %66 = getelementptr ptr, ptr %65, i32 11
  %67 = load ptr, ptr %66, align 8
  %68 = alloca { ptr }, align 8
  %69 = getelementptr { ptr }, ptr %68, i32 0, i32 0
  store ptr @i32_typ, ptr %69, align 8
  %70 = call ptr @behavior_wrapper(ptr %67, { ptr, ptr, ptr, i32 } %60, ptr %68)
  call void %70({ ptr, ptr, ptr, i32 } %60, { ptr, ptr, ptr, i32 } %60, ptr %61, i32 %52)
  %71 = alloca i32, align 4
  %72 = alloca ptr, align 8
  %73 = alloca ptr, align 8
  %74 = alloca ptr, align 8
  %75 = load ptr, ptr %51, align 8
  store ptr %75, ptr %74, align 8
  %76 = load ptr, ptr %50, align 8
  store ptr %76, ptr %73, align 8
  %77 = load ptr, ptr %49, align 8
  store ptr %77, ptr %72, align 8
  %78 = load i32, ptr %48, align 4
  store i32 %78, ptr %71, align 4
  %79 = alloca [0 x ptr], align 8
  %80 = call ptr @llvm.invariant.start.p0(i64 0, ptr %79)
  %81 = call ptr @llvm.invariant.start.p0(i64 80, ptr @Unicode)
  %82 = load ptr, ptr getelementptr (ptr, ptr getelementptr (ptr, ptr @Unicode, i32 10), i32 2), align 8
  %83 = alloca {}, align 8
  %84 = call ptr @class_behavior_wrapper(ptr %82, ptr %83)
  %85 = call { ptr } %84(ptr %79)
  %86 = alloca ptr, align 8
  store { ptr } %85, ptr %86, align 8
  %87 = alloca ptr, align 8
  %88 = load ptr, ptr %86, align 8
  store ptr %88, ptr %87, align 8
  %89 = alloca i32, align 4
  store i32 0, ptr %89, align 4
  br label %90

90:                                               ; preds = %217, %3
  %91 = load i32, ptr %89, align 4
  %92 = load i32, ptr %40, align 4
  %93 = icmp slt i32 %91, %92
  %94 = zext i1 %93 to i8
  store i8 %94, ptr %4, align 1
  %95 = load i8, ptr %4, align 1
  %96 = trunc i8 %95 to i1
  br i1 %96, label %97, label %217

97:                                               ; preds = %90
  %98 = load ptr, ptr %39, align 8
  %99 = insertvalue { ptr } undef, ptr %98, 0
  %100 = load i32, ptr %89, align 4
  %101 = load i32, ptr %40, align 4
  %102 = getelementptr [3 x ptr], ptr %5, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %102, align 8
  %103 = getelementptr [3 x ptr], ptr %5, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %103, align 8
  %104 = getelementptr [3 x ptr], ptr %5, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %104, align 8
  %105 = call ptr @llvm.invariant.start.p0(i64 9, ptr %5)
  %106 = call ptr @llvm.invariant.start.p0(i64 80, ptr @Unicode)
  %107 = load ptr, ptr getelementptr (ptr, ptr getelementptr (ptr, ptr @Unicode, i32 10), i32 3), align 8
  %108 = getelementptr { ptr, ptr, ptr }, ptr %6, i32 0, i32 0
  store ptr @buffer_typ, ptr %108, align 8
  %109 = getelementptr { ptr, ptr, ptr }, ptr %6, i32 0, i32 1
  store ptr @i32_typ, ptr %109, align 8
  %110 = getelementptr { ptr, ptr, ptr }, ptr %6, i32 0, i32 2
  store ptr @i32_typ, ptr %110, align 8
  %111 = call ptr @class_behavior_wrapper(ptr %107, ptr %6)
  %112 = call { ptr, i64 } %111(ptr %5, { ptr } %99, i32 %100, i32 %101)
  store { ptr, i64 } %112, ptr %7, align 8
  %113 = load ptr, ptr %7, align 8
  %114 = ptrtoint ptr %113 to i64
  %115 = icmp eq i64 %114, ptrtoint (ptr @nil_typ to i64)
  %116 = icmp eq i64 %114, 0
  %117 = or i1 %115, %116
  %118 = icmp eq i1 %117, false
  %119 = zext i1 %118 to i8
  store i8 %119, ptr %8, align 1
  %120 = load i8, ptr %8, align 1
  %121 = trunc i8 %120 to i1
  br i1 %121, label %122, label %170

122:                                              ; preds = %97
  %123 = getelementptr { ptr, i64 }, ptr %7, i32 0, i32 1
  %124 = load <2 x i32>, ptr %123, align 8
  store <2 x i32> %124, ptr %9, align 8
  %125 = getelementptr <2 x i32>, ptr %9, i32 0, i32 1
  %126 = load i32, ptr %125, align 4
  store i32 %126, ptr %10, align 4
  %127 = load ptr, ptr %39, align 8
  %128 = insertvalue { ptr } undef, ptr %127, 0
  %129 = load i32, ptr %89, align 4
  %130 = load i32, ptr %10, align 4
  %131 = load ptr, ptr %74, align 8
  %132 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %131, 0
  %133 = load ptr, ptr %73, align 8
  %134 = insertvalue { ptr, ptr, ptr, i32 } %132, ptr %133, 1
  %135 = load ptr, ptr %72, align 8
  %136 = insertvalue { ptr, ptr, ptr, i32 } %134, ptr %135, 2
  %137 = load i32, ptr %71, align 4
  %138 = insertvalue { ptr, ptr, ptr, i32 } %136, i32 %137, 3
  %139 = getelementptr [3 x ptr], ptr %11, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %139, align 8
  %140 = getelementptr [3 x ptr], ptr %11, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %140, align 8
  %141 = getelementptr [3 x ptr], ptr %11, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %141, align 8
  %142 = call ptr @llvm.invariant.start.p0(i64 9, ptr %11)
  %143 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %131)
  %144 = getelementptr ptr, ptr %131, i32 %137
  %145 = getelementptr ptr, ptr %144, i32 14
  %146 = load ptr, ptr %145, align 8
  %147 = getelementptr { ptr, ptr, ptr }, ptr %12, i32 0, i32 0
  store ptr @buffer_typ, ptr %147, align 8
  %148 = getelementptr { ptr, ptr, ptr }, ptr %12, i32 0, i32 1
  store ptr @i32_typ, ptr %148, align 8
  %149 = getelementptr { ptr, ptr, ptr }, ptr %12, i32 0, i32 2
  store ptr @i32_typ, ptr %149, align 8
  %150 = call ptr @behavior_wrapper(ptr %146, { ptr, ptr, ptr, i32 } %138, ptr %12)
  %151 = call { ptr, ptr, ptr, i32 } %150({ ptr, ptr, ptr, i32 } %138, { ptr, ptr, ptr, i32 } %138, ptr %11, { ptr } %128, i32 %129, i32 %130)
  store { ptr, ptr, ptr, i32 } %151, ptr %13, align 8
  %152 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 0
  %153 = load ptr, ptr %152, align 8
  store ptr %153, ptr %15, align 8
  %154 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 1
  %155 = load ptr, ptr %154, align 8
  store ptr %155, ptr %17, align 8
  %156 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 2
  %157 = load ptr, ptr %156, align 8
  store ptr %157, ptr %16, align 8
  %158 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 3
  %159 = load i32, ptr %158, align 4
  store i32 %159, ptr %14, align 4
  %160 = load ptr, ptr %15, align 8
  %161 = call i32 @get_offset(ptr %160, ptr @String)
  store i32 %161, ptr %14, align 4
  %162 = load i32, ptr %89, align 4
  %163 = load i32, ptr %10, align 4
  %164 = add i32 %162, %163
  store i32 %164, ptr %18, align 4
  %165 = load <2 x i32>, ptr %9, align 8
  store <2 x i32> %165, ptr %19, align 8
  store ptr @tuple_typ, ptr %20, align 8
  %166 = getelementptr { ptr, i64 }, ptr %7, i32 0, i32 0
  %167 = load ptr, ptr %20, align 8
  store ptr %167, ptr %166, align 8
  %168 = load i64, ptr %19, align 4
  store i64 %168, ptr %123, align 4
  %169 = load i32, ptr %18, align 4
  store i32 %169, ptr %89, align 4
  br label %216

170:                                              ; preds = %97
  %171 = getelementptr { ptr, i64 }, ptr %7, i32 0, i32 1
  %172 = load [0 x i8], ptr %171, align 1
  store [0 x i8] %172, ptr %21, align 1
  store i32 0, ptr %22, align 4
  store i32 3, ptr %23, align 4
  %173 = load ptr, ptr %87, align 8
  %174 = insertvalue { ptr } undef, ptr %173, 0
  %175 = load i32, ptr %22, align 4
  %176 = load i32, ptr %23, align 4
  %177 = load ptr, ptr %74, align 8
  %178 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %177, 0
  %179 = load ptr, ptr %73, align 8
  %180 = insertvalue { ptr, ptr, ptr, i32 } %178, ptr %179, 1
  %181 = load ptr, ptr %72, align 8
  %182 = insertvalue { ptr, ptr, ptr, i32 } %180, ptr %181, 2
  %183 = load i32, ptr %71, align 4
  %184 = insertvalue { ptr, ptr, ptr, i32 } %182, i32 %183, 3
  %185 = getelementptr [3 x ptr], ptr %24, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %185, align 8
  %186 = getelementptr [3 x ptr], ptr %24, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %186, align 8
  %187 = getelementptr [3 x ptr], ptr %24, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %187, align 8
  %188 = call ptr @llvm.invariant.start.p0(i64 9, ptr %24)
  %189 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %177)
  %190 = getelementptr ptr, ptr %177, i32 %183
  %191 = getelementptr ptr, ptr %190, i32 14
  %192 = load ptr, ptr %191, align 8
  %193 = getelementptr { ptr, ptr, ptr }, ptr %25, i32 0, i32 0
  store ptr @buffer_typ, ptr %193, align 8
  %194 = getelementptr { ptr, ptr, ptr }, ptr %25, i32 0, i32 1
  store ptr @i32_typ, ptr %194, align 8
  %195 = getelementptr { ptr, ptr, ptr }, ptr %25, i32 0, i32 2
  store ptr @i32_typ, ptr %195, align 8
  %196 = call ptr @behavior_wrapper(ptr %192, { ptr, ptr, ptr, i32 } %184, ptr %25)
  %197 = call { ptr, ptr, ptr, i32 } %196({ ptr, ptr, ptr, i32 } %184, { ptr, ptr, ptr, i32 } %184, ptr %24, { ptr } %174, i32 %175, i32 %176)
  store { ptr, ptr, ptr, i32 } %197, ptr %26, align 8
  %198 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 0
  %199 = load ptr, ptr %198, align 8
  store ptr %199, ptr %28, align 8
  %200 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 1
  %201 = load ptr, ptr %200, align 8
  store ptr %201, ptr %30, align 8
  %202 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 2
  %203 = load ptr, ptr %202, align 8
  store ptr %203, ptr %29, align 8
  %204 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 3
  %205 = load i32, ptr %204, align 4
  store i32 %205, ptr %27, align 4
  %206 = load ptr, ptr %28, align 8
  %207 = call i32 @get_offset(ptr %206, ptr @String)
  store i32 %207, ptr %27, align 4
  store i32 1, ptr %31, align 4
  %208 = load i32, ptr %89, align 4
  %209 = load i32, ptr %31, align 4
  %210 = add i32 %208, %209
  store i32 %210, ptr %32, align 4
  %211 = load [0 x i8], ptr %21, align 1
  store [0 x i8] %211, ptr %33, align 1
  store ptr @nil_typ, ptr %34, align 8
  %212 = getelementptr { ptr, i64 }, ptr %7, i32 0, i32 0
  %213 = load ptr, ptr %34, align 8
  store ptr %213, ptr %212, align 8
  %214 = load i64, ptr %33, align 4
  store i64 %214, ptr %171, align 4
  %215 = load i32, ptr %32, align 4
  store i32 %215, ptr %89, align 4
  br label %216

216:                                              ; preds = %122, %170
  br label %217

217:                                              ; preds = %216, %90
  br i1 %96, label %90, label %218

218:                                              ; preds = %217
  %219 = load ptr, ptr %74, align 8
  store ptr %219, ptr %38, align 8
  %220 = load ptr, ptr %73, align 8
  store ptr %220, ptr %37, align 8
  %221 = load ptr, ptr %72, align 8
  store ptr %221, ptr %36, align 8
  %222 = load i32, ptr %71, align 4
  store i32 %222, ptr %35, align 4
  %223 = load ptr, ptr %38, align 8
  %224 = call i32 @get_offset(ptr %223, ptr @String)
  store i32 %224, ptr %35, align 4
  %225 = load ptr, ptr %38, align 8
  %226 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %225, 0
  %227 = load ptr, ptr %37, align 8
  %228 = insertvalue { ptr, ptr, ptr, i32 } %226, ptr %227, 1
  %229 = load ptr, ptr %36, align 8
  %230 = insertvalue { ptr, ptr, ptr, i32 } %228, ptr %229, 2
  %231 = load i32, ptr %35, align 4
  %232 = insertvalue { ptr, ptr, ptr, i32 } %230, i32 %231, 3
  ret { ptr, ptr, ptr, i32 } %232
}

define ptr @String_B__Self_from_bytes_lossy_source_bytesBufferi8_source_leni32(ptr %0) {
  %2 = alloca i1, align 1
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 16, ptr %0)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %0, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @buffer_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  %10 = getelementptr ptr, ptr %0, i32 1
  %11 = load ptr, ptr %10, align 8
  %12 = ptrtoint ptr %11 to i64
  %13 = icmp eq i64 %12, ptrtoint (ptr @i32_typ to i64)
  %14 = zext i1 %13 to i8
  store i8 %14, ptr %2, align 1
  store i32 48, ptr %5, align 4
  %15 = load i32, ptr %5, align 4
  %16 = getelementptr [314 x ptr], ptr @String, i32 0, i32 %15
  %17 = getelementptr ptr, ptr %16, i32 10
  %18 = load ptr, ptr %17, align 8
  ret ptr %18
}

define { ptr, ptr, ptr, i32 } @String__Self_from_c_string_c_stringBufferi8(ptr %0, { ptr } %1) {
  %3 = alloca i1, align 1
  %4 = alloca i64, align 8
  %5 = alloca i8, align 1
  %6 = alloca i1, align 1
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca [2 x ptr], align 8
  %10 = alloca { ptr, ptr }, align 8
  %11 = alloca { ptr, ptr, ptr, i32 }, align 8
  %12 = alloca i32, align 4
  %13 = alloca ptr, align 8
  %14 = alloca ptr, align 8
  %15 = alloca ptr, align 8
  %16 = alloca i32, align 4
  %17 = alloca ptr, align 8
  %18 = alloca ptr, align 8
  %19 = alloca ptr, align 8
  %20 = alloca ptr, align 8
  store { ptr } %1, ptr %20, align 8
  %21 = alloca i8, align 1
  store i8 0, ptr %21, align 1
  %22 = alloca i32, align 4
  store i32 0, ptr %22, align 4
  br label %23

23:                                               ; preds = %51, %2
  store i8 1, ptr %3, align 1
  %24 = load i8, ptr %3, align 1
  %25 = trunc i8 %24 to i1
  br i1 %25, label %26, label %48

26:                                               ; preds = %23
  %27 = load i32, ptr %22, align 4
  %28 = sext i32 %27 to i64
  store i64 %28, ptr %4, align 4
  %29 = load ptr, ptr %20, align 8
  %30 = load i64, ptr %4, align 4
  %31 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %30
  %32 = getelementptr i8, ptr %29, i64 %31
  %33 = load i8, ptr %32, align 1
  store i8 %33, ptr %5, align 1
  %34 = load i8, ptr %5, align 1
  %35 = load i8, ptr %21, align 1
  %36 = icmp eq i8 %34, %35
  %37 = zext i1 %36 to i8
  store i8 %37, ptr %6, align 1
  %38 = load i8, ptr %6, align 1
  %39 = trunc i8 %38 to i1
  %40 = xor i1 %39, true
  %41 = zext i1 %40 to i32
  br i1 %39, label %42, label %43

42:                                               ; preds = %26
  br label %48

43:                                               ; preds = %26
  store i32 1, ptr %7, align 4
  %44 = load i32, ptr %22, align 4
  %45 = load i32, ptr %7, align 4
  %46 = add i32 %44, %45
  store i32 %46, ptr %8, align 4
  %47 = load i32, ptr %8, align 4
  store i32 %47, ptr %22, align 4
  br label %48

48:                                               ; preds = %42, %43, %23
  %49 = phi i32 [ %41, %43 ], [ %41, %42 ], [ 0, %23 ]
  br label %50

50:                                               ; preds = %48
  br label %51

51:                                               ; preds = %50
  %52 = trunc i32 %49 to i1
  br i1 %52, label %23, label %53

53:                                               ; preds = %51
  %54 = load ptr, ptr %20, align 8
  %55 = insertvalue { ptr } undef, ptr %54, 0
  %56 = load i32, ptr %22, align 4
  %57 = getelementptr [2 x ptr], ptr %9, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %57, align 8
  %58 = getelementptr [2 x ptr], ptr %9, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %58, align 8
  %59 = call ptr @llvm.invariant.start.p0(i64 4, ptr %9)
  %60 = call ptr @llvm.invariant.start.p0(i64 2512, ptr @String)
  %61 = load ptr, ptr getelementptr (ptr, ptr getelementptr (ptr, ptr @String, i32 10), i32 8), align 8
  %62 = getelementptr { ptr, ptr }, ptr %10, i32 0, i32 0
  store ptr @buffer_typ, ptr %62, align 8
  %63 = getelementptr { ptr, ptr }, ptr %10, i32 0, i32 1
  store ptr @i32_typ, ptr %63, align 8
  %64 = call ptr @class_behavior_wrapper(ptr %61, ptr %10)
  %65 = call { ptr, ptr, ptr, i32 } %64(ptr %9, { ptr } %55, i32 %56)
  store { ptr, ptr, ptr, i32 } %65, ptr %11, align 8
  %66 = getelementptr { ptr, ptr, ptr, i32 }, ptr %11, i32 0, i32 0
  %67 = load ptr, ptr %66, align 8
  store ptr %67, ptr %15, align 8
  %68 = getelementptr { ptr, ptr, ptr, i32 }, ptr %11, i32 0, i32 1
  %69 = load ptr, ptr %68, align 8
  store ptr %69, ptr %14, align 8
  %70 = getelementptr { ptr, ptr, ptr, i32 }, ptr %11, i32 0, i32 2
  %71 = load ptr, ptr %70, align 8
  store ptr %71, ptr %13, align 8
  %72 = getelementptr { ptr, ptr, ptr, i32 }, ptr %11, i32 0, i32 3
  %73 = load i32, ptr %72, align 4
  store i32 %73, ptr %12, align 4
  %74 = load ptr, ptr %15, align 8
  %75 = call i32 @get_offset(ptr %74, ptr @String)
  store i32 %75, ptr %12, align 4
  %76 = load ptr, ptr %15, align 8
  store ptr %76, ptr %19, align 8
  %77 = load ptr, ptr %14, align 8
  store ptr %77, ptr %18, align 8
  %78 = load ptr, ptr %13, align 8
  store ptr %78, ptr %17, align 8
  %79 = load i32, ptr %12, align 4
  store i32 %79, ptr %16, align 4
  %80 = load ptr, ptr %19, align 8
  %81 = call i32 @get_offset(ptr %80, ptr @String)
  store i32 %81, ptr %16, align 4
  %82 = load ptr, ptr %19, align 8
  %83 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %82, 0
  %84 = load ptr, ptr %18, align 8
  %85 = insertvalue { ptr, ptr, ptr, i32 } %83, ptr %84, 1
  %86 = load ptr, ptr %17, align 8
  %87 = insertvalue { ptr, ptr, ptr, i32 } %85, ptr %86, 2
  %88 = load i32, ptr %16, align 4
  %89 = insertvalue { ptr, ptr, ptr, i32 } %87, i32 %88, 3
  ret { ptr, ptr, ptr, i32 } %89
}

define ptr @String_B__Self_from_c_string_c_stringBufferi8(ptr %0) {
  %2 = alloca i1, align 1
  %3 = call ptr @llvm.invariant.start.p0(i64 8, ptr %0)
  %4 = alloca ptr, align 8
  %5 = load ptr, ptr %0, align 8
  %6 = ptrtoint ptr %5 to i64
  %7 = icmp eq i64 %6, ptrtoint (ptr @buffer_typ to i64)
  %8 = zext i1 %7 to i8
  store i8 %8, ptr %2, align 1
  store i32 49, ptr %4, align 4
  %9 = load i32, ptr %4, align 4
  %10 = getelementptr [314 x ptr], ptr @String, i32 0, i32 %9
  %11 = getelementptr ptr, ptr %10, i32 10
  %12 = load ptr, ptr %11, align 8
  ret ptr %12
}

define void @String_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @String)
  store i32 %18, ptr %5, align 4
  %19 = alloca i32, align 4
  store i32 1, ptr %19, align 4
  %20 = alloca i64, align 8
  %21 = load i32, ptr %19, align 4
  %22 = sext i32 %21 to i64
  store i64 %22, ptr %20, align 4
  %23 = load i64, ptr %20, align 4
  %24 = alloca ptr, align 8
  %25 = mul i64 %23, ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
  %26 = call ptr @bump_malloc(i64 %25)
  store ptr %26, ptr %24, align 8
  %27 = load ptr, ptr %7, align 8
  %28 = load ptr, ptr %6, align 8
  %29 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %28)
  %30 = load i32, ptr %5, align 4
  %31 = getelementptr ptr, ptr %28, i32 %30
  %32 = load ptr, ptr %31, align 8
  %33 = getelementptr { ptr, ptr }, ptr %32, i32 0, i32 1
  %34 = load ptr, ptr %33, align 8
  %35 = getelementptr { ptr }, ptr %24, i32 0, i32 0
  %36 = load ptr, ptr %35, align 8
  %37 = insertvalue { ptr } undef, ptr %36, 0
  call void %34(ptr %27, { ptr } %37) #2
  %38 = alloca i32, align 4
  store i32 1, ptr %38, align 4
  %39 = load ptr, ptr %7, align 8
  %40 = load ptr, ptr %6, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %40)
  %42 = load i32, ptr %5, align 4
  %43 = getelementptr ptr, ptr %40, i32 %42
  %44 = getelementptr ptr, ptr %43, i32 3
  %45 = load ptr, ptr %44, align 8
  %46 = getelementptr { ptr, ptr }, ptr %45, i32 0, i32 1
  %47 = load ptr, ptr %46, align 8
  %48 = load i32, ptr %38, align 4
  call void %47(ptr %39, i32 %48) #2
  %49 = alloca i32, align 4
  store i32 0, ptr %49, align 4
  %50 = load ptr, ptr %7, align 8
  %51 = load ptr, ptr %6, align 8
  %52 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %51)
  %53 = load i32, ptr %5, align 4
  %54 = getelementptr ptr, ptr %51, i32 %53
  %55 = getelementptr ptr, ptr %54, i32 1
  %56 = load ptr, ptr %55, align 8
  %57 = getelementptr { ptr, ptr }, ptr %56, i32 0, i32 1
  %58 = load ptr, ptr %57, align 8
  %59 = load i32, ptr %49, align 4
  call void %58(ptr %50, i32 %59) #2
  %60 = alloca i32, align 4
  store i32 0, ptr %60, align 4
  %61 = load ptr, ptr %7, align 8
  %62 = load ptr, ptr %6, align 8
  %63 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %62)
  %64 = load i32, ptr %5, align 4
  %65 = getelementptr ptr, ptr %62, i32 %64
  %66 = getelementptr ptr, ptr %65, i32 2
  %67 = load ptr, ptr %66, align 8
  %68 = getelementptr { ptr, ptr }, ptr %67, i32 0, i32 1
  %69 = load ptr, ptr %68, align 8
  %70 = load i32, ptr %60, align 4
  call void %69(ptr %61, i32 %70) #2
  ret void
}

define ptr @String_B_init_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 50, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [314 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define void @String_init_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, i32 %3) {
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %5, align 8
  %6 = alloca i32, align 4
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %7, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %8, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %9, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = call i32 @get_offset(ptr %18, ptr @String)
  store i32 %19, ptr %6, align 4
  %20 = alloca i32, align 4
  store i32 %3, ptr %20, align 4
  %21 = load ptr, ptr %8, align 8
  %22 = load ptr, ptr %7, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %22)
  %24 = load i32, ptr %6, align 4
  %25 = getelementptr ptr, ptr %22, i32 %24
  %26 = getelementptr ptr, ptr %25, i32 3
  %27 = load ptr, ptr %26, align 8
  %28 = getelementptr { ptr, ptr }, ptr %27, i32 0, i32 1
  %29 = load ptr, ptr %28, align 8
  %30 = load i32, ptr %20, align 4
  call void %29(ptr %21, i32 %30) #2
  %31 = load ptr, ptr %8, align 8
  %32 = load ptr, ptr %7, align 8
  %33 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %32)
  %34 = load i32, ptr %6, align 4
  %35 = getelementptr ptr, ptr %32, i32 %34
  %36 = getelementptr ptr, ptr %35, i32 3
  %37 = load ptr, ptr %36, align 8
  %38 = getelementptr { ptr, ptr }, ptr %37, i32 0, i32 0
  %39 = load ptr, ptr %38, align 8
  %40 = call i32 %39(ptr %31) #1
  %41 = alloca i32, align 4
  store i32 %40, ptr %41, align 4
  %42 = alloca i64, align 8
  %43 = load i32, ptr %41, align 4
  %44 = sext i32 %43 to i64
  store i64 %44, ptr %42, align 4
  %45 = load i64, ptr %42, align 4
  %46 = alloca ptr, align 8
  %47 = mul i64 %45, ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
  %48 = call ptr @bump_malloc(i64 %47)
  store ptr %48, ptr %46, align 8
  %49 = load ptr, ptr %8, align 8
  %50 = load ptr, ptr %7, align 8
  %51 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %50)
  %52 = load i32, ptr %6, align 4
  %53 = getelementptr ptr, ptr %50, i32 %52
  %54 = load ptr, ptr %53, align 8
  %55 = getelementptr { ptr, ptr }, ptr %54, i32 0, i32 1
  %56 = load ptr, ptr %55, align 8
  %57 = getelementptr { ptr }, ptr %46, i32 0, i32 0
  %58 = load ptr, ptr %57, align 8
  %59 = insertvalue { ptr } undef, ptr %58, 0
  call void %56(ptr %49, { ptr } %59) #2
  %60 = alloca i32, align 4
  store i32 0, ptr %60, align 4
  %61 = load ptr, ptr %8, align 8
  %62 = load ptr, ptr %7, align 8
  %63 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %62)
  %64 = load i32, ptr %6, align 4
  %65 = getelementptr ptr, ptr %62, i32 %64
  %66 = getelementptr ptr, ptr %65, i32 1
  %67 = load ptr, ptr %66, align 8
  %68 = getelementptr { ptr, ptr }, ptr %67, i32 0, i32 1
  %69 = load ptr, ptr %68, align 8
  %70 = load i32, ptr %60, align 4
  call void %69(ptr %61, i32 %70) #2
  %71 = alloca i32, align 4
  store i32 0, ptr %71, align 4
  %72 = load ptr, ptr %8, align 8
  %73 = load ptr, ptr %7, align 8
  %74 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %73)
  %75 = load i32, ptr %6, align 4
  %76 = getelementptr ptr, ptr %73, i32 %75
  %77 = getelementptr ptr, ptr %76, i32 2
  %78 = load ptr, ptr %77, align 8
  %79 = getelementptr { ptr, ptr }, ptr %78, i32 0, i32 1
  %80 = load ptr, ptr %79, align 8
  %81 = load i32, ptr %71, align 4
  call void %80(ptr %72, i32 %81) #2
  ret void
}

define ptr @String_B_init_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @i32_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 51, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [314 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define void @String_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr } %3, i32 %4, i32 %5, i32 %6) {
  %8 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %8, align 8
  %9 = alloca i32, align 4
  %10 = alloca ptr, align 8
  %11 = alloca ptr, align 8
  %12 = alloca ptr, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 0
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %10, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 1
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %11, align 8
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 2
  %18 = load ptr, ptr %17, align 8
  store ptr %18, ptr %12, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 3
  %20 = load i32, ptr %19, align 4
  store i32 %20, ptr %9, align 4
  %21 = load ptr, ptr %10, align 8
  %22 = call i32 @get_offset(ptr %21, ptr @String)
  store i32 %22, ptr %9, align 4
  %23 = alloca ptr, align 8
  store { ptr } %3, ptr %23, align 8
  %24 = load ptr, ptr %11, align 8
  %25 = load ptr, ptr %10, align 8
  %26 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %25)
  %27 = load i32, ptr %9, align 4
  %28 = getelementptr ptr, ptr %25, i32 %27
  %29 = load ptr, ptr %28, align 8
  %30 = getelementptr { ptr, ptr }, ptr %29, i32 0, i32 1
  %31 = load ptr, ptr %30, align 8
  %32 = load ptr, ptr %23, align 8
  %33 = insertvalue { ptr } undef, ptr %32, 0
  call void %31(ptr %24, { ptr } %33) #2
  %34 = alloca i32, align 4
  store i32 %4, ptr %34, align 4
  %35 = load ptr, ptr %11, align 8
  %36 = load ptr, ptr %10, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %36)
  %38 = load i32, ptr %9, align 4
  %39 = getelementptr ptr, ptr %36, i32 %38
  %40 = getelementptr ptr, ptr %39, i32 1
  %41 = load ptr, ptr %40, align 8
  %42 = getelementptr { ptr, ptr }, ptr %41, i32 0, i32 1
  %43 = load ptr, ptr %42, align 8
  %44 = load i32, ptr %34, align 4
  call void %43(ptr %35, i32 %44) #2
  %45 = alloca i32, align 4
  store i32 %5, ptr %45, align 4
  %46 = load ptr, ptr %11, align 8
  %47 = load ptr, ptr %10, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %47)
  %49 = load i32, ptr %9, align 4
  %50 = getelementptr ptr, ptr %47, i32 %49
  %51 = getelementptr ptr, ptr %50, i32 2
  %52 = load ptr, ptr %51, align 8
  %53 = getelementptr { ptr, ptr }, ptr %52, i32 0, i32 1
  %54 = load ptr, ptr %53, align 8
  %55 = load i32, ptr %45, align 4
  call void %54(ptr %46, i32 %55) #2
  %56 = alloca i32, align 4
  store i32 %6, ptr %56, align 4
  %57 = load ptr, ptr %11, align 8
  %58 = load ptr, ptr %10, align 8
  %59 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %58)
  %60 = load i32, ptr %9, align 4
  %61 = getelementptr ptr, ptr %58, i32 %60
  %62 = getelementptr ptr, ptr %61, i32 3
  %63 = load ptr, ptr %62, align 8
  %64 = getelementptr { ptr, ptr }, ptr %63, i32 0, i32 1
  %65 = load ptr, ptr %64, align 8
  %66 = load i32, ptr %56, align 4
  call void %65(ptr %57, i32 %66) #2
  ret void
}

define ptr @String_B_init_bytesBufferi8_byte_lengthi32_char_lengthi32_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = alloca i1, align 1
  %7 = call ptr @llvm.invariant.start.p0(i64 32, ptr %1)
  %8 = alloca ptr, align 8
  %9 = load ptr, ptr %1, align 8
  %10 = ptrtoint ptr %9 to i64
  %11 = icmp eq i64 %10, ptrtoint (ptr @buffer_typ to i64)
  %12 = zext i1 %11 to i8
  store i8 %12, ptr %6, align 1
  %13 = getelementptr ptr, ptr %1, i32 1
  %14 = load ptr, ptr %13, align 8
  %15 = ptrtoint ptr %14 to i64
  %16 = icmp eq i64 %15, ptrtoint (ptr @i32_typ to i64)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %5, align 1
  %18 = getelementptr ptr, ptr %1, i32 2
  %19 = load ptr, ptr %18, align 8
  %20 = ptrtoint ptr %19 to i64
  %21 = icmp eq i64 %20, ptrtoint (ptr @i32_typ to i64)
  %22 = zext i1 %21 to i8
  store i8 %22, ptr %4, align 1
  %23 = getelementptr ptr, ptr %1, i32 3
  %24 = load ptr, ptr %23, align 8
  %25 = ptrtoint ptr %24 to i64
  %26 = icmp eq i64 %25, ptrtoint (ptr @i32_typ to i64)
  %27 = zext i1 %26 to i8
  store i8 %27, ptr %3, align 1
  store i32 52, ptr %8, align 4
  %28 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %29 = load i32, ptr %8, align 4
  %30 = getelementptr [314 x ptr], ptr %28, i32 0, i32 %29
  %31 = getelementptr ptr, ptr %30, i32 10
  %32 = load ptr, ptr %31, align 8
  ret ptr %32
}

define { ptr } @String_c_string_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca {}, align 8
  %6 = alloca { ptr, i160 }, align 8
  %7 = alloca i32, align 4
  %8 = alloca ptr, align 8
  %9 = alloca i1, align 1
  %10 = alloca i1, align 1
  %11 = alloca i1, align 1
  %12 = alloca i32, align 4
  %13 = alloca ptr, align 8
  %14 = alloca i64, align 8
  %15 = alloca i8, align 1
  %16 = alloca i64, align 8
  %17 = alloca i32, align 4
  %18 = alloca ptr, align 8
  %19 = alloca i8, align 1
  %20 = alloca i32, align 4
  %21 = alloca i64, align 8
  %22 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %22, align 8
  %23 = alloca i32, align 4
  %24 = alloca ptr, align 8
  %25 = alloca ptr, align 8
  %26 = alloca ptr, align 8
  %27 = getelementptr { ptr, ptr, ptr, i32 }, ptr %22, i32 0, i32 0
  %28 = load ptr, ptr %27, align 8
  store ptr %28, ptr %24, align 8
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %22, i32 0, i32 1
  %30 = load ptr, ptr %29, align 8
  store ptr %30, ptr %25, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %22, i32 0, i32 2
  %32 = load ptr, ptr %31, align 8
  store ptr %32, ptr %26, align 8
  %33 = getelementptr { ptr, ptr, ptr, i32 }, ptr %22, i32 0, i32 3
  %34 = load i32, ptr %33, align 4
  store i32 %34, ptr %23, align 4
  %35 = load ptr, ptr %24, align 8
  %36 = call i32 @get_offset(ptr %35, ptr @String)
  store i32 %36, ptr %23, align 4
  %37 = load ptr, ptr %25, align 8
  %38 = load ptr, ptr %24, align 8
  %39 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %38)
  %40 = load i32, ptr %23, align 4
  %41 = getelementptr ptr, ptr %38, i32 %40
  %42 = getelementptr ptr, ptr %41, i32 1
  %43 = load ptr, ptr %42, align 8
  %44 = getelementptr { ptr, ptr }, ptr %43, i32 0, i32 0
  %45 = load ptr, ptr %44, align 8
  %46 = call i32 %45(ptr %37) #1
  %47 = alloca i32, align 4
  store i32 %46, ptr %47, align 4
  %48 = alloca i32, align 4
  store i32 1, ptr %48, align 4
  %49 = load i32, ptr %47, align 4
  %50 = load i32, ptr %48, align 4
  %51 = add i32 %49, %50
  %52 = alloca i32, align 4
  store i32 %51, ptr %52, align 4
  %53 = alloca i64, align 8
  %54 = load i32, ptr %52, align 4
  %55 = sext i32 %54 to i64
  store i64 %55, ptr %53, align 4
  %56 = load i64, ptr %53, align 4
  %57 = alloca ptr, align 8
  %58 = mul i64 %56, ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
  %59 = call ptr @bump_malloc(i64 %58)
  store ptr %59, ptr %57, align 8
  %60 = alloca ptr, align 8
  %61 = getelementptr { ptr }, ptr %57, i32 0, i32 0
  %62 = load ptr, ptr %61, align 8
  store ptr %62, ptr %60, align 8
  %63 = alloca i32, align 4
  store i32 0, ptr %63, align 4
  %64 = load ptr, ptr %25, align 8
  %65 = load ptr, ptr %24, align 8
  %66 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %65)
  %67 = load i32, ptr %23, align 4
  %68 = getelementptr ptr, ptr %65, i32 %67
  %69 = getelementptr ptr, ptr %68, i32 1
  %70 = load ptr, ptr %69, align 8
  %71 = getelementptr { ptr, ptr }, ptr %70, i32 0, i32 0
  %72 = load ptr, ptr %71, align 8
  %73 = call i32 %72(ptr %64) #1
  %74 = alloca i32, align 4
  store i32 %73, ptr %74, align 4
  %75 = alloca i32, align 4
  store i32 1, ptr %75, align 4
  %76 = load i32, ptr %74, align 4
  %77 = load i32, ptr %75, align 4
  %78 = sub i32 %76, %77
  %79 = alloca i32, align 4
  store i32 %78, ptr %79, align 4
  %80 = alloca [1 x ptr], align 8
  store ptr @Range, ptr %80, align 8
  %81 = load ptr, ptr %80, align 8
  %82 = getelementptr ptr, ptr %81, i32 6
  %83 = load ptr, ptr %82, align 8
  %84 = call { i64, i64 } @size_wrapper(ptr %83, ptr %80)
  %85 = extractvalue { i64, i64 } %84, 0
  %86 = call ptr @bump_malloc(i64 %85)
  %87 = alloca i32, align 4
  %88 = alloca ptr, align 8
  %89 = alloca ptr, align 8
  %90 = alloca ptr, align 8
  store ptr @Range, ptr %90, align 8
  store ptr %86, ptr %89, align 8
  store i32 10, ptr %87, align 4
  %91 = alloca i32, align 4
  store i32 0, ptr %91, align 4
  %92 = load ptr, ptr %25, align 8
  %93 = load ptr, ptr %24, align 8
  %94 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %93)
  %95 = load i32, ptr %23, align 4
  %96 = getelementptr ptr, ptr %93, i32 %95
  %97 = getelementptr ptr, ptr %96, i32 1
  %98 = load ptr, ptr %97, align 8
  %99 = getelementptr { ptr, ptr }, ptr %98, i32 0, i32 0
  %100 = load ptr, ptr %99, align 8
  %101 = call i32 %100(ptr %92) #1
  %102 = alloca i32, align 4
  store i32 %101, ptr %102, align 4
  %103 = alloca i32, align 4
  store i32 1, ptr %103, align 4
  %104 = load i32, ptr %102, align 4
  %105 = load i32, ptr %103, align 4
  %106 = sub i32 %104, %105
  %107 = alloca i32, align 4
  store i32 %106, ptr %107, align 4
  %108 = load i32, ptr %91, align 4
  %109 = load i32, ptr %107, align 4
  %110 = load ptr, ptr %90, align 8
  %111 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %110, 0
  %112 = load ptr, ptr %89, align 8
  %113 = insertvalue { ptr, ptr, ptr, i32 } %111, ptr %112, 1
  %114 = load ptr, ptr %88, align 8
  %115 = insertvalue { ptr, ptr, ptr, i32 } %113, ptr %114, 2
  %116 = load i32, ptr %87, align 4
  %117 = insertvalue { ptr, ptr, ptr, i32 } %115, i32 %116, 3
  %118 = alloca [2 x ptr], align 8
  %119 = getelementptr [2 x ptr], ptr %118, i32 0, i32 0
  store ptr @_parameterization_i32, ptr %119, align 8
  %120 = getelementptr [2 x ptr], ptr %118, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %120, align 8
  %121 = call ptr @llvm.invariant.start.p0(i64 4, ptr %118)
  %122 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %110)
  %123 = getelementptr ptr, ptr %110, i32 %116
  %124 = getelementptr ptr, ptr %123, i32 5
  %125 = load ptr, ptr %124, align 8
  %126 = alloca { ptr, ptr }, align 8
  %127 = getelementptr { ptr, ptr }, ptr %126, i32 0, i32 0
  store ptr @i32_typ, ptr %127, align 8
  %128 = getelementptr { ptr, ptr }, ptr %126, i32 0, i32 1
  store ptr @i32_typ, ptr %128, align 8
  %129 = call ptr @behavior_wrapper(ptr %125, { ptr, ptr, ptr, i32 } %117, ptr %126)
  call void %129({ ptr, ptr, ptr, i32 } %117, { ptr, ptr, ptr, i32 } %117, ptr %118, i32 %108, i32 %109)
  %130 = load ptr, ptr %90, align 8
  %131 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %130, 0
  %132 = load ptr, ptr %89, align 8
  %133 = insertvalue { ptr, ptr, ptr, i32 } %131, ptr %132, 1
  %134 = load ptr, ptr %88, align 8
  %135 = insertvalue { ptr, ptr, ptr, i32 } %133, ptr %134, 2
  %136 = load i32, ptr %87, align 4
  %137 = insertvalue { ptr, ptr, ptr, i32 } %135, i32 %136, 3
  %138 = alloca [0 x ptr], align 8
  %139 = call ptr @llvm.invariant.start.p0(i64 0, ptr %138)
  %140 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %130)
  %141 = getelementptr ptr, ptr %130, i32 %136
  %142 = getelementptr ptr, ptr %141, i32 9
  %143 = load ptr, ptr %142, align 8
  %144 = alloca {}, align 8
  %145 = call ptr @behavior_wrapper(ptr %143, { ptr, ptr, ptr, i32 } %137, ptr %144)
  %146 = call { ptr, ptr, ptr, i32 } %145({ ptr, ptr, ptr, i32 } %137, { ptr, ptr, ptr, i32 } %137, ptr %138)
  %147 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %146, ptr %147, align 8
  %148 = alloca i32, align 4
  %149 = alloca ptr, align 8
  %150 = alloca ptr, align 8
  %151 = alloca ptr, align 8
  %152 = getelementptr { ptr, ptr, ptr, i32 }, ptr %147, i32 0, i32 0
  %153 = load ptr, ptr %152, align 8
  store ptr %153, ptr %151, align 8
  %154 = getelementptr { ptr, ptr, ptr, i32 }, ptr %147, i32 0, i32 1
  %155 = load ptr, ptr %154, align 8
  store ptr %155, ptr %150, align 8
  %156 = getelementptr { ptr, ptr, ptr, i32 }, ptr %147, i32 0, i32 2
  %157 = load ptr, ptr %156, align 8
  store ptr %157, ptr %149, align 8
  %158 = getelementptr { ptr, ptr, ptr, i32 }, ptr %147, i32 0, i32 3
  %159 = load i32, ptr %158, align 4
  store i32 %159, ptr %148, align 4
  %160 = load ptr, ptr %151, align 8
  %161 = call i32 @get_offset(ptr %160, ptr @RangeIterator)
  store i32 %161, ptr %148, align 4
  %162 = alloca i32, align 4
  %163 = alloca ptr, align 8
  %164 = alloca ptr, align 8
  %165 = alloca ptr, align 8
  %166 = load ptr, ptr %151, align 8
  store ptr %166, ptr %165, align 8
  %167 = load ptr, ptr %150, align 8
  store ptr %167, ptr %164, align 8
  %168 = load ptr, ptr %149, align 8
  store ptr %168, ptr %163, align 8
  %169 = load i32, ptr %148, align 4
  store i32 %169, ptr %162, align 4
  %170 = getelementptr { ptr, i32 }, ptr %6, i32 0, i32 0
  %171 = getelementptr { ptr, i32 }, ptr %6, i32 0, i32 1
  br label %172

172:                                              ; preds = %232, %3
  %173 = load ptr, ptr %165, align 8
  %174 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %173, 0
  %175 = load ptr, ptr %164, align 8
  %176 = insertvalue { ptr, ptr, ptr, i32 } %174, ptr %175, 1
  %177 = load ptr, ptr %163, align 8
  %178 = insertvalue { ptr, ptr, ptr, i32 } %176, ptr %177, 2
  %179 = load i32, ptr %162, align 4
  %180 = insertvalue { ptr, ptr, ptr, i32 } %178, i32 %179, 3
  %181 = call ptr @llvm.invariant.start.p0(i64 0, ptr %4)
  %182 = call ptr @llvm.invariant.start.p0(i64 88, ptr %173)
  %183 = getelementptr ptr, ptr %173, i32 %179
  %184 = getelementptr ptr, ptr %183, i32 5
  %185 = load ptr, ptr %184, align 8
  %186 = call ptr @behavior_wrapper(ptr %185, { ptr, ptr, ptr, i32 } %180, ptr %5)
  %187 = call { ptr, i160 } %186({ ptr, ptr, ptr, i32 } %180, { ptr, ptr, ptr, i32 } %180, ptr %4)
  store { ptr, i160 } %187, ptr %6, align 8
  %188 = load ptr, ptr %170, align 8
  store ptr %188, ptr %8, align 8
  %189 = load i32, ptr %171, align 4
  store i32 %189, ptr %7, align 4
  store i8 0, ptr %9, align 1
  %190 = load ptr, ptr %8, align 8
  %191 = ptrtoint ptr %190 to i64
  %192 = icmp eq i64 %191, ptrtoint (ptr @nil_typ to i64)
  %193 = icmp eq i64 %191, 0
  %194 = or i1 %192, %193
  %195 = zext i1 %194 to i8
  store i8 %195, ptr %10, align 1
  %196 = load i8, ptr %9, align 1
  %197 = trunc i8 %196 to i1
  %198 = load i8, ptr %10, align 1
  %199 = trunc i8 %198 to i1
  %200 = icmp eq i1 %197, %199
  %201 = zext i1 %200 to i8
  store i8 %201, ptr %11, align 1
  %202 = load i8, ptr %11, align 1
  %203 = trunc i8 %202 to i1
  br i1 %203, label %204, label %232

204:                                              ; preds = %172
  %205 = load i32, ptr %7, align 4
  store i32 %205, ptr %12, align 4
  %206 = load ptr, ptr %25, align 8
  %207 = load ptr, ptr %24, align 8
  %208 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %207)
  %209 = load i32, ptr %23, align 4
  %210 = getelementptr ptr, ptr %207, i32 %209
  %211 = load ptr, ptr %210, align 8
  %212 = getelementptr { ptr, ptr }, ptr %211, i32 0, i32 0
  %213 = load ptr, ptr %212, align 8
  %214 = call { ptr } %213(ptr %206) #1
  store { ptr } %214, ptr %13, align 8
  %215 = load i32, ptr %12, align 4
  %216 = sext i32 %215 to i64
  store i64 %216, ptr %14, align 4
  %217 = load ptr, ptr %13, align 8
  %218 = load i64, ptr %14, align 4
  %219 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %218
  %220 = getelementptr i8, ptr %217, i64 %219
  %221 = load i8, ptr %220, align 1
  store i8 %221, ptr %15, align 1
  %222 = load i32, ptr %12, align 4
  %223 = sext i32 %222 to i64
  store i64 %223, ptr %16, align 4
  %224 = load ptr, ptr %60, align 8
  %225 = load i64, ptr %16, align 4
  %226 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %225
  %227 = getelementptr i8, ptr %224, i64 %226
  %228 = load i8, ptr %15, align 1
  store i8 %228, ptr %227, align 1
  %229 = load i32, ptr %12, align 4
  store i32 %229, ptr %17, align 4
  store ptr @i32_typ, ptr %18, align 8
  %230 = load ptr, ptr %18, align 8
  store ptr %230, ptr %8, align 8
  %231 = load i32, ptr %17, align 4
  store i32 %231, ptr %7, align 4
  br label %232

232:                                              ; preds = %204, %172
  br i1 %203, label %172, label %233

233:                                              ; preds = %232
  store i8 0, ptr %19, align 1
  %234 = load ptr, ptr %25, align 8
  %235 = load ptr, ptr %24, align 8
  %236 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %235)
  %237 = load i32, ptr %23, align 4
  %238 = getelementptr ptr, ptr %235, i32 %237
  %239 = getelementptr ptr, ptr %238, i32 1
  %240 = load ptr, ptr %239, align 8
  %241 = getelementptr { ptr, ptr }, ptr %240, i32 0, i32 0
  %242 = load ptr, ptr %241, align 8
  %243 = call i32 %242(ptr %234) #1
  store i32 %243, ptr %20, align 4
  %244 = load i32, ptr %20, align 4
  %245 = sext i32 %244 to i64
  store i64 %245, ptr %21, align 4
  %246 = load ptr, ptr %60, align 8
  %247 = load i64, ptr %21, align 4
  %248 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %247
  %249 = getelementptr i8, ptr %246, i64 %248
  %250 = load i8, ptr %19, align 1
  store i8 %250, ptr %249, align 1
  %251 = load ptr, ptr %60, align 8
  %252 = insertvalue { ptr } undef, ptr %251, 0
  ret { ptr } %252
}

define ptr @String_B_c_string_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 53, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [314 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { ptr, ptr, ptr, i32 } @String_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr } %3, i32 %4, i32 %5) {
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca [1 x ptr], align 8
  %11 = alloca { ptr }, align 8
  %12 = alloca i32, align 4
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %15 = alloca [1 x ptr], align 8
  %16 = alloca i32, align 4
  %17 = alloca ptr, align 8
  %18 = alloca ptr, align 8
  %19 = alloca ptr, align 8
  %20 = alloca i32, align 4
  %21 = alloca i32, align 4
  %22 = alloca i32, align 4
  %23 = alloca [2 x ptr], align 8
  %24 = alloca { ptr, ptr }, align 8
  %25 = alloca [0 x ptr], align 8
  %26 = alloca {}, align 8
  %27 = alloca { ptr, ptr, ptr, i32 }, align 8
  %28 = alloca i32, align 4
  %29 = alloca ptr, align 8
  %30 = alloca ptr, align 8
  %31 = alloca ptr, align 8
  %32 = alloca i32, align 4
  %33 = alloca ptr, align 8
  %34 = alloca ptr, align 8
  %35 = alloca ptr, align 8
  %36 = alloca [0 x ptr], align 8
  %37 = alloca {}, align 8
  %38 = alloca { ptr, i160 }, align 8
  %39 = alloca i32, align 4
  %40 = alloca ptr, align 8
  %41 = alloca i1, align 1
  %42 = alloca i1, align 1
  %43 = alloca i1, align 1
  %44 = alloca i32, align 4
  %45 = alloca i32, align 4
  %46 = alloca i32, align 4
  %47 = alloca i32, align 4
  %48 = alloca i64, align 8
  %49 = alloca i8, align 1
  %50 = alloca ptr, align 8
  %51 = alloca i64, align 8
  %52 = alloca i32, align 4
  %53 = alloca ptr, align 8
  %54 = alloca i32, align 4
  %55 = alloca i32, align 4
  %56 = alloca i32, align 4
  %57 = alloca i32, align 4
  %58 = alloca i32, align 4
  %59 = alloca i32, align 4
  %60 = alloca ptr, align 8
  %61 = alloca ptr, align 8
  %62 = alloca ptr, align 8
  %63 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %63, align 8
  %64 = alloca i32, align 4
  %65 = alloca ptr, align 8
  %66 = alloca ptr, align 8
  %67 = alloca ptr, align 8
  %68 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 0
  %69 = load ptr, ptr %68, align 8
  store ptr %69, ptr %67, align 8
  %70 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 1
  %71 = load ptr, ptr %70, align 8
  store ptr %71, ptr %66, align 8
  %72 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 2
  %73 = load ptr, ptr %72, align 8
  store ptr %73, ptr %65, align 8
  %74 = getelementptr { ptr, ptr, ptr, i32 }, ptr %63, i32 0, i32 3
  %75 = load i32, ptr %74, align 4
  store i32 %75, ptr %64, align 4
  %76 = load ptr, ptr %67, align 8
  %77 = call i32 @get_offset(ptr %76, ptr @String)
  store i32 %77, ptr %64, align 4
  %78 = alloca ptr, align 8
  store { ptr } %3, ptr %78, align 8
  %79 = alloca i32, align 4
  store i32 %4, ptr %79, align 4
  %80 = alloca i32, align 4
  store i32 %5, ptr %80, align 4
  %81 = load ptr, ptr %66, align 8
  %82 = load ptr, ptr %67, align 8
  %83 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %82)
  %84 = load i32, ptr %64, align 4
  %85 = getelementptr ptr, ptr %82, i32 %84
  %86 = getelementptr ptr, ptr %85, i32 1
  %87 = load ptr, ptr %86, align 8
  %88 = getelementptr { ptr, ptr }, ptr %87, i32 0, i32 0
  %89 = load ptr, ptr %88, align 8
  %90 = call i32 %89(ptr %81) #1
  %91 = alloca i32, align 4
  store i32 %90, ptr %91, align 4
  %92 = load i32, ptr %91, align 4
  %93 = load i32, ptr %80, align 4
  %94 = add i32 %92, %93
  %95 = alloca i32, align 4
  store i32 %94, ptr %95, align 4
  %96 = load ptr, ptr %66, align 8
  %97 = load ptr, ptr %67, align 8
  %98 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %97)
  %99 = load i32, ptr %64, align 4
  %100 = getelementptr ptr, ptr %97, i32 %99
  %101 = getelementptr ptr, ptr %100, i32 3
  %102 = load ptr, ptr %101, align 8
  %103 = getelementptr { ptr, ptr }, ptr %102, i32 0, i32 0
  %104 = load ptr, ptr %103, align 8
  %105 = call i32 %104(ptr %96) #1
  %106 = alloca i32, align 4
  store i32 %105, ptr %106, align 4
  %107 = load i32, ptr %95, align 4
  %108 = load i32, ptr %106, align 4
  %109 = icmp sge i32 %107, %108
  %110 = alloca i1, align 1
  %111 = zext i1 %109 to i8
  store i8 %111, ptr %110, align 1
  %112 = load i8, ptr %110, align 1
  %113 = trunc i8 %112 to i1
  br i1 %113, label %114, label %145

114:                                              ; preds = %6
  %115 = load ptr, ptr %66, align 8
  %116 = load ptr, ptr %67, align 8
  %117 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %116)
  %118 = load i32, ptr %64, align 4
  %119 = getelementptr ptr, ptr %116, i32 %118
  %120 = getelementptr ptr, ptr %119, i32 3
  %121 = load ptr, ptr %120, align 8
  %122 = getelementptr { ptr, ptr }, ptr %121, i32 0, i32 0
  %123 = load ptr, ptr %122, align 8
  %124 = call i32 %123(ptr %115) #1
  store i32 %124, ptr %7, align 4
  store i32 2, ptr %8, align 4
  %125 = load i32, ptr %7, align 4
  %126 = load i32, ptr %8, align 4
  %127 = mul i32 %125, %126
  store i32 %127, ptr %9, align 4
  %128 = load i32, ptr %9, align 4
  %129 = load ptr, ptr %67, align 8
  %130 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %129, 0
  %131 = load ptr, ptr %66, align 8
  %132 = insertvalue { ptr, ptr, ptr, i32 } %130, ptr %131, 1
  %133 = load ptr, ptr %65, align 8
  %134 = insertvalue { ptr, ptr, ptr, i32 } %132, ptr %133, 2
  %135 = load i32, ptr %64, align 4
  %136 = insertvalue { ptr, ptr, ptr, i32 } %134, i32 %135, 3
  %137 = getelementptr [1 x ptr], ptr %10, i32 0, i32 0
  store ptr @_parameterization_i32, ptr %137, align 8
  %138 = call ptr @llvm.invariant.start.p0(i64 1, ptr %10)
  %139 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %129)
  %140 = getelementptr ptr, ptr %129, i32 %135
  %141 = getelementptr ptr, ptr %140, i32 15
  %142 = load ptr, ptr %141, align 8
  %143 = getelementptr { ptr }, ptr %11, i32 0, i32 0
  store ptr @i32_typ, ptr %143, align 8
  %144 = call ptr @behavior_wrapper(ptr %142, { ptr, ptr, ptr, i32 } %136, ptr %11)
  call void %144({ ptr, ptr, ptr, i32 } %136, { ptr, ptr, ptr, i32 } %136, ptr %10, i32 %128)
  br label %145

145:                                              ; preds = %114, %6
  store i32 0, ptr %12, align 4
  store i32 1, ptr %13, align 4
  %146 = load i32, ptr %80, align 4
  %147 = load i32, ptr %13, align 4
  %148 = sub i32 %146, %147
  store i32 %148, ptr %14, align 4
  store ptr @Range, ptr %15, align 8
  %149 = load ptr, ptr %15, align 8
  %150 = getelementptr ptr, ptr %149, i32 6
  %151 = load ptr, ptr %150, align 8
  %152 = call { i64, i64 } @size_wrapper(ptr %151, ptr %15)
  %153 = extractvalue { i64, i64 } %152, 0
  %154 = call ptr @bump_malloc(i64 %153)
  store ptr @Range, ptr %19, align 8
  store ptr %154, ptr %18, align 8
  store i32 10, ptr %16, align 4
  store i32 0, ptr %20, align 4
  store i32 1, ptr %21, align 4
  %155 = load i32, ptr %80, align 4
  %156 = load i32, ptr %21, align 4
  %157 = sub i32 %155, %156
  store i32 %157, ptr %22, align 4
  %158 = load i32, ptr %20, align 4
  %159 = load i32, ptr %22, align 4
  %160 = load ptr, ptr %19, align 8
  %161 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %160, 0
  %162 = load ptr, ptr %18, align 8
  %163 = insertvalue { ptr, ptr, ptr, i32 } %161, ptr %162, 1
  %164 = load ptr, ptr %17, align 8
  %165 = insertvalue { ptr, ptr, ptr, i32 } %163, ptr %164, 2
  %166 = load i32, ptr %16, align 4
  %167 = insertvalue { ptr, ptr, ptr, i32 } %165, i32 %166, 3
  %168 = getelementptr [2 x ptr], ptr %23, i32 0, i32 0
  store ptr @_parameterization_i32, ptr %168, align 8
  %169 = getelementptr [2 x ptr], ptr %23, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %169, align 8
  %170 = call ptr @llvm.invariant.start.p0(i64 4, ptr %23)
  %171 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %160)
  %172 = getelementptr ptr, ptr %160, i32 %166
  %173 = getelementptr ptr, ptr %172, i32 5
  %174 = load ptr, ptr %173, align 8
  %175 = getelementptr { ptr, ptr }, ptr %24, i32 0, i32 0
  store ptr @i32_typ, ptr %175, align 8
  %176 = getelementptr { ptr, ptr }, ptr %24, i32 0, i32 1
  store ptr @i32_typ, ptr %176, align 8
  %177 = call ptr @behavior_wrapper(ptr %174, { ptr, ptr, ptr, i32 } %167, ptr %24)
  call void %177({ ptr, ptr, ptr, i32 } %167, { ptr, ptr, ptr, i32 } %167, ptr %23, i32 %158, i32 %159)
  %178 = load ptr, ptr %19, align 8
  %179 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %178, 0
  %180 = load ptr, ptr %18, align 8
  %181 = insertvalue { ptr, ptr, ptr, i32 } %179, ptr %180, 1
  %182 = load ptr, ptr %17, align 8
  %183 = insertvalue { ptr, ptr, ptr, i32 } %181, ptr %182, 2
  %184 = load i32, ptr %16, align 4
  %185 = insertvalue { ptr, ptr, ptr, i32 } %183, i32 %184, 3
  %186 = call ptr @llvm.invariant.start.p0(i64 0, ptr %25)
  %187 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %178)
  %188 = getelementptr ptr, ptr %178, i32 %184
  %189 = getelementptr ptr, ptr %188, i32 9
  %190 = load ptr, ptr %189, align 8
  %191 = call ptr @behavior_wrapper(ptr %190, { ptr, ptr, ptr, i32 } %185, ptr %26)
  %192 = call { ptr, ptr, ptr, i32 } %191({ ptr, ptr, ptr, i32 } %185, { ptr, ptr, ptr, i32 } %185, ptr %25)
  store { ptr, ptr, ptr, i32 } %192, ptr %27, align 8
  %193 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 0
  %194 = load ptr, ptr %193, align 8
  store ptr %194, ptr %31, align 8
  %195 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 1
  %196 = load ptr, ptr %195, align 8
  store ptr %196, ptr %30, align 8
  %197 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 2
  %198 = load ptr, ptr %197, align 8
  store ptr %198, ptr %29, align 8
  %199 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 3
  %200 = load i32, ptr %199, align 4
  store i32 %200, ptr %28, align 4
  %201 = load ptr, ptr %31, align 8
  %202 = call i32 @get_offset(ptr %201, ptr @RangeIterator)
  store i32 %202, ptr %28, align 4
  %203 = load ptr, ptr %31, align 8
  store ptr %203, ptr %35, align 8
  %204 = load ptr, ptr %30, align 8
  store ptr %204, ptr %34, align 8
  %205 = load ptr, ptr %29, align 8
  store ptr %205, ptr %33, align 8
  %206 = load i32, ptr %28, align 4
  store i32 %206, ptr %32, align 4
  %207 = getelementptr { ptr, i32 }, ptr %38, i32 0, i32 0
  %208 = getelementptr { ptr, i32 }, ptr %38, i32 0, i32 1
  br label %209

209:                                              ; preds = %285, %145
  %210 = load ptr, ptr %35, align 8
  %211 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %210, 0
  %212 = load ptr, ptr %34, align 8
  %213 = insertvalue { ptr, ptr, ptr, i32 } %211, ptr %212, 1
  %214 = load ptr, ptr %33, align 8
  %215 = insertvalue { ptr, ptr, ptr, i32 } %213, ptr %214, 2
  %216 = load i32, ptr %32, align 4
  %217 = insertvalue { ptr, ptr, ptr, i32 } %215, i32 %216, 3
  %218 = call ptr @llvm.invariant.start.p0(i64 0, ptr %36)
  %219 = call ptr @llvm.invariant.start.p0(i64 88, ptr %210)
  %220 = getelementptr ptr, ptr %210, i32 %216
  %221 = getelementptr ptr, ptr %220, i32 5
  %222 = load ptr, ptr %221, align 8
  %223 = call ptr @behavior_wrapper(ptr %222, { ptr, ptr, ptr, i32 } %217, ptr %37)
  %224 = call { ptr, i160 } %223({ ptr, ptr, ptr, i32 } %217, { ptr, ptr, ptr, i32 } %217, ptr %36)
  store { ptr, i160 } %224, ptr %38, align 8
  %225 = load ptr, ptr %207, align 8
  store ptr %225, ptr %40, align 8
  %226 = load i32, ptr %208, align 4
  store i32 %226, ptr %39, align 4
  store i8 0, ptr %41, align 1
  %227 = load ptr, ptr %40, align 8
  %228 = ptrtoint ptr %227 to i64
  %229 = icmp eq i64 %228, ptrtoint (ptr @nil_typ to i64)
  %230 = icmp eq i64 %228, 0
  %231 = or i1 %229, %230
  %232 = zext i1 %231 to i8
  store i8 %232, ptr %42, align 1
  %233 = load i8, ptr %41, align 1
  %234 = trunc i8 %233 to i1
  %235 = load i8, ptr %42, align 1
  %236 = trunc i8 %235 to i1
  %237 = icmp eq i1 %234, %236
  %238 = zext i1 %237 to i8
  store i8 %238, ptr %43, align 1
  %239 = load i8, ptr %43, align 1
  %240 = trunc i8 %239 to i1
  br i1 %240, label %241, label %285

241:                                              ; preds = %209
  %242 = load i32, ptr %39, align 4
  store i32 %242, ptr %44, align 4
  %243 = load ptr, ptr %66, align 8
  %244 = load ptr, ptr %67, align 8
  %245 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %244)
  %246 = load i32, ptr %64, align 4
  %247 = getelementptr ptr, ptr %244, i32 %246
  %248 = getelementptr ptr, ptr %247, i32 1
  %249 = load ptr, ptr %248, align 8
  %250 = getelementptr { ptr, ptr }, ptr %249, i32 0, i32 0
  %251 = load ptr, ptr %250, align 8
  %252 = call i32 %251(ptr %243) #1
  store i32 %252, ptr %45, align 4
  %253 = load i32, ptr %45, align 4
  %254 = load i32, ptr %44, align 4
  %255 = add i32 %253, %254
  store i32 %255, ptr %46, align 4
  %256 = load i32, ptr %79, align 4
  %257 = load i32, ptr %44, align 4
  %258 = add i32 %256, %257
  store i32 %258, ptr %47, align 4
  %259 = load i32, ptr %47, align 4
  %260 = sext i32 %259 to i64
  store i64 %260, ptr %48, align 4
  %261 = load ptr, ptr %78, align 8
  %262 = load i64, ptr %48, align 4
  %263 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %262
  %264 = getelementptr i8, ptr %261, i64 %263
  %265 = load i8, ptr %264, align 1
  store i8 %265, ptr %49, align 1
  %266 = load ptr, ptr %66, align 8
  %267 = load ptr, ptr %67, align 8
  %268 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %267)
  %269 = load i32, ptr %64, align 4
  %270 = getelementptr ptr, ptr %267, i32 %269
  %271 = load ptr, ptr %270, align 8
  %272 = getelementptr { ptr, ptr }, ptr %271, i32 0, i32 0
  %273 = load ptr, ptr %272, align 8
  %274 = call { ptr } %273(ptr %266) #1
  store { ptr } %274, ptr %50, align 8
  %275 = load i32, ptr %46, align 4
  %276 = sext i32 %275 to i64
  store i64 %276, ptr %51, align 4
  %277 = load ptr, ptr %50, align 8
  %278 = load i64, ptr %51, align 4
  %279 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %278
  %280 = getelementptr i8, ptr %277, i64 %279
  %281 = load i8, ptr %49, align 1
  store i8 %281, ptr %280, align 1
  %282 = load i32, ptr %44, align 4
  store i32 %282, ptr %52, align 4
  store ptr @i32_typ, ptr %53, align 8
  %283 = load ptr, ptr %53, align 8
  store ptr %283, ptr %40, align 8
  %284 = load i32, ptr %52, align 4
  store i32 %284, ptr %39, align 4
  br label %285

285:                                              ; preds = %241, %209
  br i1 %240, label %209, label %286

286:                                              ; preds = %285
  %287 = load ptr, ptr %66, align 8
  %288 = load ptr, ptr %67, align 8
  %289 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %288)
  %290 = load i32, ptr %64, align 4
  %291 = getelementptr ptr, ptr %288, i32 %290
  %292 = getelementptr ptr, ptr %291, i32 2
  %293 = load ptr, ptr %292, align 8
  %294 = getelementptr { ptr, ptr }, ptr %293, i32 0, i32 0
  %295 = load ptr, ptr %294, align 8
  %296 = call i32 %295(ptr %287) #1
  store i32 %296, ptr %54, align 4
  store i32 1, ptr %55, align 4
  %297 = load i32, ptr %54, align 4
  %298 = load i32, ptr %55, align 4
  %299 = add i32 %297, %298
  store i32 %299, ptr %56, align 4
  %300 = load ptr, ptr %66, align 8
  %301 = load ptr, ptr %67, align 8
  %302 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %301)
  %303 = load i32, ptr %64, align 4
  %304 = getelementptr ptr, ptr %301, i32 %303
  %305 = getelementptr ptr, ptr %304, i32 2
  %306 = load ptr, ptr %305, align 8
  %307 = getelementptr { ptr, ptr }, ptr %306, i32 0, i32 1
  %308 = load ptr, ptr %307, align 8
  %309 = load i32, ptr %56, align 4
  call void %308(ptr %300, i32 %309) #2
  %310 = load ptr, ptr %66, align 8
  %311 = load ptr, ptr %67, align 8
  %312 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %311)
  %313 = load i32, ptr %64, align 4
  %314 = getelementptr ptr, ptr %311, i32 %313
  %315 = getelementptr ptr, ptr %314, i32 1
  %316 = load ptr, ptr %315, align 8
  %317 = getelementptr { ptr, ptr }, ptr %316, i32 0, i32 0
  %318 = load ptr, ptr %317, align 8
  %319 = call i32 %318(ptr %310) #1
  store i32 %319, ptr %57, align 4
  %320 = load i32, ptr %57, align 4
  %321 = load i32, ptr %80, align 4
  %322 = add i32 %320, %321
  store i32 %322, ptr %58, align 4
  %323 = load ptr, ptr %66, align 8
  %324 = load ptr, ptr %67, align 8
  %325 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %324)
  %326 = load i32, ptr %64, align 4
  %327 = getelementptr ptr, ptr %324, i32 %326
  %328 = getelementptr ptr, ptr %327, i32 1
  %329 = load ptr, ptr %328, align 8
  %330 = getelementptr { ptr, ptr }, ptr %329, i32 0, i32 1
  %331 = load ptr, ptr %330, align 8
  %332 = load i32, ptr %58, align 4
  call void %331(ptr %323, i32 %332) #2
  %333 = load ptr, ptr %67, align 8
  store ptr %333, ptr %62, align 8
  %334 = load ptr, ptr %66, align 8
  store ptr %334, ptr %61, align 8
  %335 = load ptr, ptr %65, align 8
  store ptr %335, ptr %60, align 8
  %336 = load i32, ptr %64, align 4
  store i32 %336, ptr %59, align 4
  %337 = load ptr, ptr %62, align 8
  %338 = call i32 @get_offset(ptr %337, ptr @String)
  store i32 %338, ptr %59, align 4
  %339 = load ptr, ptr %62, align 8
  %340 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %339, 0
  %341 = load ptr, ptr %61, align 8
  %342 = insertvalue { ptr, ptr, ptr, i32 } %340, ptr %341, 1
  %343 = load ptr, ptr %60, align 8
  %344 = insertvalue { ptr, ptr, ptr, i32 } %342, ptr %343, 2
  %345 = load i32, ptr %59, align 4
  %346 = insertvalue { ptr, ptr, ptr, i32 } %344, i32 %345, 3
  ret { ptr, ptr, ptr, i32 } %346
}

define ptr @String_B_append_char_from_bytes_source_bytesBufferi8_start_indexi32_n_bytesi32({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 24, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = ptrtoint ptr %8 to i64
  %10 = icmp eq i64 %9, ptrtoint (ptr @buffer_typ to i64)
  %11 = zext i1 %10 to i8
  store i8 %11, ptr %5, align 1
  %12 = getelementptr ptr, ptr %1, i32 1
  %13 = load ptr, ptr %12, align 8
  %14 = ptrtoint ptr %13 to i64
  %15 = icmp eq i64 %14, ptrtoint (ptr @i32_typ to i64)
  %16 = zext i1 %15 to i8
  store i8 %16, ptr %4, align 1
  %17 = getelementptr ptr, ptr %1, i32 2
  %18 = load ptr, ptr %17, align 8
  %19 = ptrtoint ptr %18 to i64
  %20 = icmp eq i64 %19, ptrtoint (ptr @i32_typ to i64)
  %21 = zext i1 %20 to i8
  store i8 %21, ptr %3, align 1
  store i32 54, ptr %7, align 4
  %22 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %23 = load i32, ptr %7, align 4
  %24 = getelementptr [314 x ptr], ptr %22, i32 0, i32 %23
  %25 = getelementptr ptr, ptr %24, i32 10
  %26 = load ptr, ptr %25, align 8
  ret ptr %26
}

define void @String_reserve_new_capacityi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, i32 %3) {
  %5 = alloca ptr, align 8
  %6 = alloca ptr, align 8
  %7 = alloca i32, align 4
  %8 = alloca i64, align 8
  %9 = alloca ptr, align 8
  %10 = alloca i32, align 4
  %11 = alloca i32, align 4
  %12 = alloca i32, align 4
  %13 = alloca i32, align 4
  %14 = alloca [1 x ptr], align 8
  %15 = alloca i32, align 4
  %16 = alloca ptr, align 8
  %17 = alloca ptr, align 8
  %18 = alloca ptr, align 8
  %19 = alloca i32, align 4
  %20 = alloca i32, align 4
  %21 = alloca i32, align 4
  %22 = alloca i32, align 4
  %23 = alloca [2 x ptr], align 8
  %24 = alloca { ptr, ptr }, align 8
  %25 = alloca [0 x ptr], align 8
  %26 = alloca {}, align 8
  %27 = alloca { ptr, ptr, ptr, i32 }, align 8
  %28 = alloca i32, align 4
  %29 = alloca ptr, align 8
  %30 = alloca ptr, align 8
  %31 = alloca ptr, align 8
  %32 = alloca i32, align 4
  %33 = alloca ptr, align 8
  %34 = alloca ptr, align 8
  %35 = alloca ptr, align 8
  %36 = alloca [0 x ptr], align 8
  %37 = alloca {}, align 8
  %38 = alloca { ptr, i160 }, align 8
  %39 = alloca i32, align 4
  %40 = alloca ptr, align 8
  %41 = alloca i1, align 1
  %42 = alloca i1, align 1
  %43 = alloca i1, align 1
  %44 = alloca i32, align 4
  %45 = alloca i64, align 8
  %46 = alloca i8, align 1
  %47 = alloca ptr, align 8
  %48 = alloca i64, align 8
  %49 = alloca i32, align 4
  %50 = alloca ptr, align 8
  %51 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %51, align 8
  %52 = alloca i32, align 4
  %53 = alloca ptr, align 8
  %54 = alloca ptr, align 8
  %55 = alloca ptr, align 8
  %56 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 0
  %57 = load ptr, ptr %56, align 8
  store ptr %57, ptr %53, align 8
  %58 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 1
  %59 = load ptr, ptr %58, align 8
  store ptr %59, ptr %54, align 8
  %60 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 2
  %61 = load ptr, ptr %60, align 8
  store ptr %61, ptr %55, align 8
  %62 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 3
  %63 = load i32, ptr %62, align 4
  store i32 %63, ptr %52, align 4
  %64 = load ptr, ptr %53, align 8
  %65 = call i32 @get_offset(ptr %64, ptr @String)
  store i32 %65, ptr %52, align 4
  %66 = alloca i32, align 4
  store i32 %3, ptr %66, align 4
  %67 = load ptr, ptr %54, align 8
  %68 = load ptr, ptr %53, align 8
  %69 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %68)
  %70 = load i32, ptr %52, align 4
  %71 = getelementptr ptr, ptr %68, i32 %70
  %72 = getelementptr ptr, ptr %71, i32 3
  %73 = load ptr, ptr %72, align 8
  %74 = getelementptr { ptr, ptr }, ptr %73, i32 0, i32 0
  %75 = load ptr, ptr %74, align 8
  %76 = call i32 %75(ptr %67) #1
  %77 = alloca i32, align 4
  store i32 %76, ptr %77, align 4
  %78 = load i32, ptr %66, align 4
  %79 = load i32, ptr %77, align 4
  %80 = icmp sle i32 %78, %79
  %81 = alloca i1, align 1
  %82 = zext i1 %80 to i8
  store i8 %82, ptr %81, align 1
  %83 = load i8, ptr %81, align 1
  %84 = trunc i8 %83 to i1
  br i1 %84, label %85, label %86

85:                                               ; preds = %276, %4
  br label %277

86:                                               ; preds = %4
  %87 = load ptr, ptr %54, align 8
  %88 = load ptr, ptr %53, align 8
  %89 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %88)
  %90 = load i32, ptr %52, align 4
  %91 = getelementptr ptr, ptr %88, i32 %90
  %92 = getelementptr ptr, ptr %91, i32 3
  %93 = load ptr, ptr %92, align 8
  %94 = getelementptr { ptr, ptr }, ptr %93, i32 0, i32 1
  %95 = load ptr, ptr %94, align 8
  %96 = load i32, ptr %66, align 4
  call void %95(ptr %87, i32 %96) #2
  %97 = load ptr, ptr %54, align 8
  %98 = load ptr, ptr %53, align 8
  %99 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %98)
  %100 = load i32, ptr %52, align 4
  %101 = getelementptr ptr, ptr %98, i32 %100
  %102 = load ptr, ptr %101, align 8
  %103 = getelementptr { ptr, ptr }, ptr %102, i32 0, i32 0
  %104 = load ptr, ptr %103, align 8
  %105 = call { ptr } %104(ptr %97) #1
  store { ptr } %105, ptr %5, align 8
  %106 = load ptr, ptr %5, align 8
  store ptr %106, ptr %6, align 8
  %107 = load ptr, ptr %54, align 8
  %108 = load ptr, ptr %53, align 8
  %109 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %108)
  %110 = load i32, ptr %52, align 4
  %111 = getelementptr ptr, ptr %108, i32 %110
  %112 = getelementptr ptr, ptr %111, i32 3
  %113 = load ptr, ptr %112, align 8
  %114 = getelementptr { ptr, ptr }, ptr %113, i32 0, i32 0
  %115 = load ptr, ptr %114, align 8
  %116 = call i32 %115(ptr %107) #1
  store i32 %116, ptr %7, align 4
  %117 = load i32, ptr %7, align 4
  %118 = sext i32 %117 to i64
  store i64 %118, ptr %8, align 4
  %119 = load i64, ptr %8, align 4
  %120 = mul i64 %119, ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
  %121 = call ptr @bump_malloc(i64 %120)
  store ptr %121, ptr %9, align 8
  %122 = load ptr, ptr %54, align 8
  %123 = load ptr, ptr %53, align 8
  %124 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %123)
  %125 = load i32, ptr %52, align 4
  %126 = getelementptr ptr, ptr %123, i32 %125
  %127 = load ptr, ptr %126, align 8
  %128 = getelementptr { ptr, ptr }, ptr %127, i32 0, i32 1
  %129 = load ptr, ptr %128, align 8
  %130 = getelementptr { ptr }, ptr %9, i32 0, i32 0
  %131 = load ptr, ptr %130, align 8
  %132 = insertvalue { ptr } undef, ptr %131, 0
  call void %129(ptr %122, { ptr } %132) #2
  store i32 0, ptr %10, align 4
  %133 = load ptr, ptr %54, align 8
  %134 = load ptr, ptr %53, align 8
  %135 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %134)
  %136 = load i32, ptr %52, align 4
  %137 = getelementptr ptr, ptr %134, i32 %136
  %138 = getelementptr ptr, ptr %137, i32 1
  %139 = load ptr, ptr %138, align 8
  %140 = getelementptr { ptr, ptr }, ptr %139, i32 0, i32 0
  %141 = load ptr, ptr %140, align 8
  %142 = call i32 %141(ptr %133) #1
  store i32 %142, ptr %11, align 4
  store i32 1, ptr %12, align 4
  %143 = load i32, ptr %11, align 4
  %144 = load i32, ptr %12, align 4
  %145 = sub i32 %143, %144
  store i32 %145, ptr %13, align 4
  store ptr @Range, ptr %14, align 8
  %146 = load ptr, ptr %14, align 8
  %147 = getelementptr ptr, ptr %146, i32 6
  %148 = load ptr, ptr %147, align 8
  %149 = call { i64, i64 } @size_wrapper(ptr %148, ptr %14)
  %150 = extractvalue { i64, i64 } %149, 0
  %151 = call ptr @bump_malloc(i64 %150)
  store ptr @Range, ptr %18, align 8
  store ptr %151, ptr %17, align 8
  store i32 10, ptr %15, align 4
  store i32 0, ptr %19, align 4
  %152 = load ptr, ptr %54, align 8
  %153 = load ptr, ptr %53, align 8
  %154 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %153)
  %155 = load i32, ptr %52, align 4
  %156 = getelementptr ptr, ptr %153, i32 %155
  %157 = getelementptr ptr, ptr %156, i32 1
  %158 = load ptr, ptr %157, align 8
  %159 = getelementptr { ptr, ptr }, ptr %158, i32 0, i32 0
  %160 = load ptr, ptr %159, align 8
  %161 = call i32 %160(ptr %152) #1
  store i32 %161, ptr %20, align 4
  store i32 1, ptr %21, align 4
  %162 = load i32, ptr %20, align 4
  %163 = load i32, ptr %21, align 4
  %164 = sub i32 %162, %163
  store i32 %164, ptr %22, align 4
  %165 = load i32, ptr %19, align 4
  %166 = load i32, ptr %22, align 4
  %167 = load ptr, ptr %18, align 8
  %168 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %167, 0
  %169 = load ptr, ptr %17, align 8
  %170 = insertvalue { ptr, ptr, ptr, i32 } %168, ptr %169, 1
  %171 = load ptr, ptr %16, align 8
  %172 = insertvalue { ptr, ptr, ptr, i32 } %170, ptr %171, 2
  %173 = load i32, ptr %15, align 4
  %174 = insertvalue { ptr, ptr, ptr, i32 } %172, i32 %173, 3
  %175 = getelementptr [2 x ptr], ptr %23, i32 0, i32 0
  store ptr @_parameterization_i32, ptr %175, align 8
  %176 = getelementptr [2 x ptr], ptr %23, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %176, align 8
  %177 = call ptr @llvm.invariant.start.p0(i64 4, ptr %23)
  %178 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %167)
  %179 = getelementptr ptr, ptr %167, i32 %173
  %180 = getelementptr ptr, ptr %179, i32 5
  %181 = load ptr, ptr %180, align 8
  %182 = getelementptr { ptr, ptr }, ptr %24, i32 0, i32 0
  store ptr @i32_typ, ptr %182, align 8
  %183 = getelementptr { ptr, ptr }, ptr %24, i32 0, i32 1
  store ptr @i32_typ, ptr %183, align 8
  %184 = call ptr @behavior_wrapper(ptr %181, { ptr, ptr, ptr, i32 } %174, ptr %24)
  call void %184({ ptr, ptr, ptr, i32 } %174, { ptr, ptr, ptr, i32 } %174, ptr %23, i32 %165, i32 %166)
  %185 = load ptr, ptr %18, align 8
  %186 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %185, 0
  %187 = load ptr, ptr %17, align 8
  %188 = insertvalue { ptr, ptr, ptr, i32 } %186, ptr %187, 1
  %189 = load ptr, ptr %16, align 8
  %190 = insertvalue { ptr, ptr, ptr, i32 } %188, ptr %189, 2
  %191 = load i32, ptr %15, align 4
  %192 = insertvalue { ptr, ptr, ptr, i32 } %190, i32 %191, 3
  %193 = call ptr @llvm.invariant.start.p0(i64 0, ptr %25)
  %194 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %185)
  %195 = getelementptr ptr, ptr %185, i32 %191
  %196 = getelementptr ptr, ptr %195, i32 9
  %197 = load ptr, ptr %196, align 8
  %198 = call ptr @behavior_wrapper(ptr %197, { ptr, ptr, ptr, i32 } %192, ptr %26)
  %199 = call { ptr, ptr, ptr, i32 } %198({ ptr, ptr, ptr, i32 } %192, { ptr, ptr, ptr, i32 } %192, ptr %25)
  store { ptr, ptr, ptr, i32 } %199, ptr %27, align 8
  %200 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 0
  %201 = load ptr, ptr %200, align 8
  store ptr %201, ptr %31, align 8
  %202 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 1
  %203 = load ptr, ptr %202, align 8
  store ptr %203, ptr %30, align 8
  %204 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 2
  %205 = load ptr, ptr %204, align 8
  store ptr %205, ptr %29, align 8
  %206 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 3
  %207 = load i32, ptr %206, align 4
  store i32 %207, ptr %28, align 4
  %208 = load ptr, ptr %31, align 8
  %209 = call i32 @get_offset(ptr %208, ptr @RangeIterator)
  store i32 %209, ptr %28, align 4
  %210 = load ptr, ptr %31, align 8
  store ptr %210, ptr %35, align 8
  %211 = load ptr, ptr %30, align 8
  store ptr %211, ptr %34, align 8
  %212 = load ptr, ptr %29, align 8
  store ptr %212, ptr %33, align 8
  %213 = load i32, ptr %28, align 4
  store i32 %213, ptr %32, align 4
  %214 = getelementptr { ptr, i32 }, ptr %38, i32 0, i32 0
  %215 = getelementptr { ptr, i32 }, ptr %38, i32 0, i32 1
  br label %216

216:                                              ; preds = %276, %86
  %217 = load ptr, ptr %35, align 8
  %218 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %217, 0
  %219 = load ptr, ptr %34, align 8
  %220 = insertvalue { ptr, ptr, ptr, i32 } %218, ptr %219, 1
  %221 = load ptr, ptr %33, align 8
  %222 = insertvalue { ptr, ptr, ptr, i32 } %220, ptr %221, 2
  %223 = load i32, ptr %32, align 4
  %224 = insertvalue { ptr, ptr, ptr, i32 } %222, i32 %223, 3
  %225 = call ptr @llvm.invariant.start.p0(i64 0, ptr %36)
  %226 = call ptr @llvm.invariant.start.p0(i64 88, ptr %217)
  %227 = getelementptr ptr, ptr %217, i32 %223
  %228 = getelementptr ptr, ptr %227, i32 5
  %229 = load ptr, ptr %228, align 8
  %230 = call ptr @behavior_wrapper(ptr %229, { ptr, ptr, ptr, i32 } %224, ptr %37)
  %231 = call { ptr, i160 } %230({ ptr, ptr, ptr, i32 } %224, { ptr, ptr, ptr, i32 } %224, ptr %36)
  store { ptr, i160 } %231, ptr %38, align 8
  %232 = load ptr, ptr %214, align 8
  store ptr %232, ptr %40, align 8
  %233 = load i32, ptr %215, align 4
  store i32 %233, ptr %39, align 4
  store i8 0, ptr %41, align 1
  %234 = load ptr, ptr %40, align 8
  %235 = ptrtoint ptr %234 to i64
  %236 = icmp eq i64 %235, ptrtoint (ptr @nil_typ to i64)
  %237 = icmp eq i64 %235, 0
  %238 = or i1 %236, %237
  %239 = zext i1 %238 to i8
  store i8 %239, ptr %42, align 1
  %240 = load i8, ptr %41, align 1
  %241 = trunc i8 %240 to i1
  %242 = load i8, ptr %42, align 1
  %243 = trunc i8 %242 to i1
  %244 = icmp eq i1 %241, %243
  %245 = zext i1 %244 to i8
  store i8 %245, ptr %43, align 1
  %246 = load i8, ptr %43, align 1
  %247 = trunc i8 %246 to i1
  br i1 %247, label %248, label %276

248:                                              ; preds = %216
  %249 = load i32, ptr %39, align 4
  store i32 %249, ptr %44, align 4
  %250 = load i32, ptr %44, align 4
  %251 = sext i32 %250 to i64
  store i64 %251, ptr %45, align 4
  %252 = load ptr, ptr %6, align 8
  %253 = load i64, ptr %45, align 4
  %254 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %253
  %255 = getelementptr i8, ptr %252, i64 %254
  %256 = load i8, ptr %255, align 1
  store i8 %256, ptr %46, align 1
  %257 = load ptr, ptr %54, align 8
  %258 = load ptr, ptr %53, align 8
  %259 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %258)
  %260 = load i32, ptr %52, align 4
  %261 = getelementptr ptr, ptr %258, i32 %260
  %262 = load ptr, ptr %261, align 8
  %263 = getelementptr { ptr, ptr }, ptr %262, i32 0, i32 0
  %264 = load ptr, ptr %263, align 8
  %265 = call { ptr } %264(ptr %257) #1
  store { ptr } %265, ptr %47, align 8
  %266 = load i32, ptr %44, align 4
  %267 = sext i32 %266 to i64
  store i64 %267, ptr %48, align 4
  %268 = load ptr, ptr %47, align 8
  %269 = load i64, ptr %48, align 4
  %270 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %269
  %271 = getelementptr i8, ptr %268, i64 %270
  %272 = load i8, ptr %46, align 1
  store i8 %272, ptr %271, align 1
  %273 = load i32, ptr %44, align 4
  store i32 %273, ptr %49, align 4
  store ptr @i32_typ, ptr %50, align 8
  %274 = load ptr, ptr %50, align 8
  store ptr %274, ptr %40, align 8
  %275 = load i32, ptr %49, align 4
  store i32 %275, ptr %39, align 4
  br label %276

276:                                              ; preds = %248, %216
  br i1 %247, label %216, label %85

277:                                              ; preds = %85
  ret void
}

define ptr @String_B_reserve_new_capacityi32({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @i32_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 55, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [314 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define i1 @String__EQ_otherString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3) {
  %5 = alloca i1, align 1
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca [1 x ptr], align 8
  %11 = alloca i32, align 4
  %12 = alloca ptr, align 8
  %13 = alloca ptr, align 8
  %14 = alloca ptr, align 8
  %15 = alloca i32, align 4
  %16 = alloca i32, align 4
  %17 = alloca i32, align 4
  %18 = alloca i32, align 4
  %19 = alloca [2 x ptr], align 8
  %20 = alloca { ptr, ptr }, align 8
  %21 = alloca [0 x ptr], align 8
  %22 = alloca {}, align 8
  %23 = alloca { ptr, ptr, ptr, i32 }, align 8
  %24 = alloca i32, align 4
  %25 = alloca ptr, align 8
  %26 = alloca ptr, align 8
  %27 = alloca ptr, align 8
  %28 = alloca i32, align 4
  %29 = alloca ptr, align 8
  %30 = alloca ptr, align 8
  %31 = alloca ptr, align 8
  %32 = alloca [0 x ptr], align 8
  %33 = alloca {}, align 8
  %34 = alloca { ptr, i160 }, align 8
  %35 = alloca i32, align 4
  %36 = alloca ptr, align 8
  %37 = alloca i1, align 1
  %38 = alloca i1, align 1
  %39 = alloca i1, align 1
  %40 = alloca i32, align 4
  %41 = alloca ptr, align 8
  %42 = alloca i64, align 8
  %43 = alloca i8, align 1
  %44 = alloca [1 x ptr], align 8
  %45 = alloca { ptr }, align 8
  %46 = alloca i8, align 1
  %47 = alloca i1, align 1
  %48 = alloca i1, align 1
  %49 = alloca i32, align 4
  %50 = alloca ptr, align 8
  %51 = alloca i1, align 1
  %52 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %52, align 8
  %53 = alloca i32, align 4
  %54 = alloca ptr, align 8
  %55 = alloca ptr, align 8
  %56 = alloca ptr, align 8
  %57 = getelementptr { ptr, ptr, ptr, i32 }, ptr %52, i32 0, i32 0
  %58 = load ptr, ptr %57, align 8
  store ptr %58, ptr %54, align 8
  %59 = getelementptr { ptr, ptr, ptr, i32 }, ptr %52, i32 0, i32 1
  %60 = load ptr, ptr %59, align 8
  store ptr %60, ptr %55, align 8
  %61 = getelementptr { ptr, ptr, ptr, i32 }, ptr %52, i32 0, i32 2
  %62 = load ptr, ptr %61, align 8
  store ptr %62, ptr %56, align 8
  %63 = getelementptr { ptr, ptr, ptr, i32 }, ptr %52, i32 0, i32 3
  %64 = load i32, ptr %63, align 4
  store i32 %64, ptr %53, align 4
  %65 = load ptr, ptr %54, align 8
  %66 = call i32 @get_offset(ptr %65, ptr @String)
  store i32 %66, ptr %53, align 4
  %67 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %67, align 8
  %68 = alloca i32, align 4
  %69 = alloca ptr, align 8
  %70 = alloca ptr, align 8
  %71 = alloca ptr, align 8
  %72 = getelementptr { ptr, ptr, ptr, i32 }, ptr %67, i32 0, i32 0
  %73 = load ptr, ptr %72, align 8
  store ptr %73, ptr %71, align 8
  %74 = getelementptr { ptr, ptr, ptr, i32 }, ptr %67, i32 0, i32 1
  %75 = load ptr, ptr %74, align 8
  store ptr %75, ptr %70, align 8
  %76 = getelementptr { ptr, ptr, ptr, i32 }, ptr %67, i32 0, i32 2
  %77 = load ptr, ptr %76, align 8
  store ptr %77, ptr %69, align 8
  %78 = getelementptr { ptr, ptr, ptr, i32 }, ptr %67, i32 0, i32 3
  %79 = load i32, ptr %78, align 4
  store i32 %79, ptr %68, align 4
  %80 = load ptr, ptr %71, align 8
  %81 = call i32 @get_offset(ptr %80, ptr @String)
  store i32 %81, ptr %68, align 4
  %82 = load ptr, ptr %55, align 8
  %83 = load ptr, ptr %54, align 8
  %84 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %83)
  %85 = load i32, ptr %53, align 4
  %86 = getelementptr ptr, ptr %83, i32 %85
  %87 = getelementptr ptr, ptr %86, i32 1
  %88 = load ptr, ptr %87, align 8
  %89 = getelementptr { ptr, ptr }, ptr %88, i32 0, i32 0
  %90 = load ptr, ptr %89, align 8
  %91 = call i32 %90(ptr %82) #1
  %92 = alloca i32, align 4
  store i32 %91, ptr %92, align 4
  %93 = load ptr, ptr %71, align 8
  %94 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %93, 0
  %95 = load ptr, ptr %70, align 8
  %96 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr %95, 1
  %97 = load ptr, ptr %69, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } %96, ptr %97, 2
  %99 = load i32, ptr %68, align 4
  %100 = insertvalue { ptr, ptr, ptr, i32 } %98, i32 %99, 3
  %101 = alloca [0 x ptr], align 8
  %102 = call ptr @llvm.invariant.start.p0(i64 0, ptr %101)
  %103 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %93)
  %104 = getelementptr ptr, ptr %93, i32 %99
  %105 = getelementptr ptr, ptr %104, i32 5
  %106 = load ptr, ptr %105, align 8
  %107 = alloca {}, align 8
  %108 = call ptr @behavior_wrapper(ptr %106, { ptr, ptr, ptr, i32 } %100, ptr %107)
  %109 = call i32 %108({ ptr, ptr, ptr, i32 } %100, { ptr, ptr, ptr, i32 } %100, ptr %101)
  %110 = alloca i32, align 4
  store i32 %109, ptr %110, align 4
  %111 = load i32, ptr %92, align 4
  %112 = load i32, ptr %110, align 4
  %113 = icmp ne i32 %111, %112
  %114 = alloca i1, align 1
  %115 = zext i1 %113 to i8
  store i8 %115, ptr %114, align 1
  %116 = load i8, ptr %114, align 1
  %117 = trunc i8 %116 to i1
  br i1 %117, label %118, label %121

118:                                              ; preds = %292, %4
  %119 = phi i8 [ %238, %292 ], [ 0, %4 ]
  %120 = phi ptr [ %239, %292 ], [ %5, %4 ]
  br label %295

121:                                              ; preds = %4
  store i32 0, ptr %6, align 4
  %122 = load ptr, ptr %55, align 8
  %123 = load ptr, ptr %54, align 8
  %124 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %123)
  %125 = load i32, ptr %53, align 4
  %126 = getelementptr ptr, ptr %123, i32 %125
  %127 = getelementptr ptr, ptr %126, i32 1
  %128 = load ptr, ptr %127, align 8
  %129 = getelementptr { ptr, ptr }, ptr %128, i32 0, i32 0
  %130 = load ptr, ptr %129, align 8
  %131 = call i32 %130(ptr %122) #1
  store i32 %131, ptr %7, align 4
  store i32 1, ptr %8, align 4
  %132 = load i32, ptr %7, align 4
  %133 = load i32, ptr %8, align 4
  %134 = sub i32 %132, %133
  store i32 %134, ptr %9, align 4
  store ptr @Range, ptr %10, align 8
  %135 = load ptr, ptr %10, align 8
  %136 = getelementptr ptr, ptr %135, i32 6
  %137 = load ptr, ptr %136, align 8
  %138 = call { i64, i64 } @size_wrapper(ptr %137, ptr %10)
  %139 = extractvalue { i64, i64 } %138, 0
  %140 = call ptr @bump_malloc(i64 %139)
  store ptr @Range, ptr %14, align 8
  store ptr %140, ptr %13, align 8
  store i32 10, ptr %11, align 4
  store i32 0, ptr %15, align 4
  %141 = load ptr, ptr %55, align 8
  %142 = load ptr, ptr %54, align 8
  %143 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %142)
  %144 = load i32, ptr %53, align 4
  %145 = getelementptr ptr, ptr %142, i32 %144
  %146 = getelementptr ptr, ptr %145, i32 1
  %147 = load ptr, ptr %146, align 8
  %148 = getelementptr { ptr, ptr }, ptr %147, i32 0, i32 0
  %149 = load ptr, ptr %148, align 8
  %150 = call i32 %149(ptr %141) #1
  store i32 %150, ptr %16, align 4
  store i32 1, ptr %17, align 4
  %151 = load i32, ptr %16, align 4
  %152 = load i32, ptr %17, align 4
  %153 = sub i32 %151, %152
  store i32 %153, ptr %18, align 4
  %154 = load i32, ptr %15, align 4
  %155 = load i32, ptr %18, align 4
  %156 = load ptr, ptr %14, align 8
  %157 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %156, 0
  %158 = load ptr, ptr %13, align 8
  %159 = insertvalue { ptr, ptr, ptr, i32 } %157, ptr %158, 1
  %160 = load ptr, ptr %12, align 8
  %161 = insertvalue { ptr, ptr, ptr, i32 } %159, ptr %160, 2
  %162 = load i32, ptr %11, align 4
  %163 = insertvalue { ptr, ptr, ptr, i32 } %161, i32 %162, 3
  %164 = getelementptr [2 x ptr], ptr %19, i32 0, i32 0
  store ptr @_parameterization_i32, ptr %164, align 8
  %165 = getelementptr [2 x ptr], ptr %19, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %165, align 8
  %166 = call ptr @llvm.invariant.start.p0(i64 4, ptr %19)
  %167 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %156)
  %168 = getelementptr ptr, ptr %156, i32 %162
  %169 = getelementptr ptr, ptr %168, i32 5
  %170 = load ptr, ptr %169, align 8
  %171 = getelementptr { ptr, ptr }, ptr %20, i32 0, i32 0
  store ptr @i32_typ, ptr %171, align 8
  %172 = getelementptr { ptr, ptr }, ptr %20, i32 0, i32 1
  store ptr @i32_typ, ptr %172, align 8
  %173 = call ptr @behavior_wrapper(ptr %170, { ptr, ptr, ptr, i32 } %163, ptr %20)
  call void %173({ ptr, ptr, ptr, i32 } %163, { ptr, ptr, ptr, i32 } %163, ptr %19, i32 %154, i32 %155)
  %174 = load ptr, ptr %14, align 8
  %175 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %174, 0
  %176 = load ptr, ptr %13, align 8
  %177 = insertvalue { ptr, ptr, ptr, i32 } %175, ptr %176, 1
  %178 = load ptr, ptr %12, align 8
  %179 = insertvalue { ptr, ptr, ptr, i32 } %177, ptr %178, 2
  %180 = load i32, ptr %11, align 4
  %181 = insertvalue { ptr, ptr, ptr, i32 } %179, i32 %180, 3
  %182 = call ptr @llvm.invariant.start.p0(i64 0, ptr %21)
  %183 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %174)
  %184 = getelementptr ptr, ptr %174, i32 %180
  %185 = getelementptr ptr, ptr %184, i32 9
  %186 = load ptr, ptr %185, align 8
  %187 = call ptr @behavior_wrapper(ptr %186, { ptr, ptr, ptr, i32 } %181, ptr %22)
  %188 = call { ptr, ptr, ptr, i32 } %187({ ptr, ptr, ptr, i32 } %181, { ptr, ptr, ptr, i32 } %181, ptr %21)
  store { ptr, ptr, ptr, i32 } %188, ptr %23, align 8
  %189 = getelementptr { ptr, ptr, ptr, i32 }, ptr %23, i32 0, i32 0
  %190 = load ptr, ptr %189, align 8
  store ptr %190, ptr %27, align 8
  %191 = getelementptr { ptr, ptr, ptr, i32 }, ptr %23, i32 0, i32 1
  %192 = load ptr, ptr %191, align 8
  store ptr %192, ptr %26, align 8
  %193 = getelementptr { ptr, ptr, ptr, i32 }, ptr %23, i32 0, i32 2
  %194 = load ptr, ptr %193, align 8
  store ptr %194, ptr %25, align 8
  %195 = getelementptr { ptr, ptr, ptr, i32 }, ptr %23, i32 0, i32 3
  %196 = load i32, ptr %195, align 4
  store i32 %196, ptr %24, align 4
  %197 = load ptr, ptr %27, align 8
  %198 = call i32 @get_offset(ptr %197, ptr @RangeIterator)
  store i32 %198, ptr %24, align 4
  %199 = load ptr, ptr %27, align 8
  store ptr %199, ptr %31, align 8
  %200 = load ptr, ptr %26, align 8
  store ptr %200, ptr %30, align 8
  %201 = load ptr, ptr %25, align 8
  store ptr %201, ptr %29, align 8
  %202 = load i32, ptr %24, align 4
  store i32 %202, ptr %28, align 4
  %203 = getelementptr { ptr, i32 }, ptr %34, i32 0, i32 0
  %204 = getelementptr { ptr, i32 }, ptr %34, i32 0, i32 1
  br label %205

205:                                              ; preds = %294, %121
  %206 = load ptr, ptr %31, align 8
  %207 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %206, 0
  %208 = load ptr, ptr %30, align 8
  %209 = insertvalue { ptr, ptr, ptr, i32 } %207, ptr %208, 1
  %210 = load ptr, ptr %29, align 8
  %211 = insertvalue { ptr, ptr, ptr, i32 } %209, ptr %210, 2
  %212 = load i32, ptr %28, align 4
  %213 = insertvalue { ptr, ptr, ptr, i32 } %211, i32 %212, 3
  %214 = call ptr @llvm.invariant.start.p0(i64 0, ptr %32)
  %215 = call ptr @llvm.invariant.start.p0(i64 88, ptr %206)
  %216 = getelementptr ptr, ptr %206, i32 %212
  %217 = getelementptr ptr, ptr %216, i32 5
  %218 = load ptr, ptr %217, align 8
  %219 = call ptr @behavior_wrapper(ptr %218, { ptr, ptr, ptr, i32 } %213, ptr %33)
  %220 = call { ptr, i160 } %219({ ptr, ptr, ptr, i32 } %213, { ptr, ptr, ptr, i32 } %213, ptr %32)
  store { ptr, i160 } %220, ptr %34, align 8
  %221 = load ptr, ptr %203, align 8
  store ptr %221, ptr %36, align 8
  %222 = load i32, ptr %204, align 4
  store i32 %222, ptr %35, align 4
  store i8 0, ptr %37, align 1
  %223 = load ptr, ptr %36, align 8
  %224 = ptrtoint ptr %223 to i64
  %225 = icmp eq i64 %224, ptrtoint (ptr @nil_typ to i64)
  %226 = icmp eq i64 %224, 0
  %227 = or i1 %225, %226
  %228 = zext i1 %227 to i8
  store i8 %228, ptr %38, align 1
  %229 = load i8, ptr %37, align 1
  %230 = trunc i8 %229 to i1
  %231 = load i8, ptr %38, align 1
  %232 = trunc i8 %231 to i1
  %233 = icmp eq i1 %230, %232
  %234 = zext i1 %233 to i8
  store i8 %234, ptr %39, align 1
  %235 = load i8, ptr %39, align 1
  %236 = trunc i8 %235 to i1
  %237 = xor i1 %236, true
  %238 = zext i1 %237 to i8
  %239 = select i1 %236, ptr %48, ptr %51
  br i1 %236, label %240, label %289

240:                                              ; preds = %205
  %241 = load i32, ptr %35, align 4
  store i32 %241, ptr %40, align 4
  %242 = load ptr, ptr %55, align 8
  %243 = load ptr, ptr %54, align 8
  %244 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %243)
  %245 = load i32, ptr %53, align 4
  %246 = getelementptr ptr, ptr %243, i32 %245
  %247 = load ptr, ptr %246, align 8
  %248 = getelementptr { ptr, ptr }, ptr %247, i32 0, i32 0
  %249 = load ptr, ptr %248, align 8
  %250 = call { ptr } %249(ptr %242) #1
  store { ptr } %250, ptr %41, align 8
  %251 = load i32, ptr %40, align 4
  %252 = sext i32 %251 to i64
  store i64 %252, ptr %42, align 4
  %253 = load ptr, ptr %41, align 8
  %254 = load i64, ptr %42, align 4
  %255 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %254
  %256 = getelementptr i8, ptr %253, i64 %255
  %257 = load i8, ptr %256, align 1
  store i8 %257, ptr %43, align 1
  %258 = load i32, ptr %40, align 4
  %259 = load ptr, ptr %71, align 8
  %260 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %259, 0
  %261 = load ptr, ptr %70, align 8
  %262 = insertvalue { ptr, ptr, ptr, i32 } %260, ptr %261, 1
  %263 = load ptr, ptr %69, align 8
  %264 = insertvalue { ptr, ptr, ptr, i32 } %262, ptr %263, 2
  %265 = load i32, ptr %68, align 4
  %266 = insertvalue { ptr, ptr, ptr, i32 } %264, i32 %265, 3
  %267 = getelementptr [1 x ptr], ptr %44, i32 0, i32 0
  store ptr @_parameterization_i32, ptr %267, align 8
  %268 = call ptr @llvm.invariant.start.p0(i64 1, ptr %44)
  %269 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %259)
  %270 = getelementptr ptr, ptr %259, i32 %265
  %271 = getelementptr ptr, ptr %270, i32 18
  %272 = load ptr, ptr %271, align 8
  %273 = getelementptr { ptr }, ptr %45, i32 0, i32 0
  store ptr @i32_typ, ptr %273, align 8
  %274 = call ptr @behavior_wrapper(ptr %272, { ptr, ptr, ptr, i32 } %266, ptr %45)
  %275 = call i8 %274({ ptr, ptr, ptr, i32 } %266, { ptr, ptr, ptr, i32 } %266, ptr %44, i32 %258)
  store i8 %275, ptr %46, align 1
  %276 = load i8, ptr %43, align 1
  %277 = load i8, ptr %46, align 1
  %278 = icmp ne i8 %276, %277
  %279 = zext i1 %278 to i8
  store i8 %279, ptr %47, align 1
  %280 = load i8, ptr %47, align 1
  %281 = trunc i8 %280 to i1
  %282 = xor i1 %281, true
  %283 = zext i1 %282 to i32
  br i1 %281, label %284, label %285

284:                                              ; preds = %240
  br label %289

285:                                              ; preds = %240
  %286 = load i32, ptr %40, align 4
  store i32 %286, ptr %49, align 4
  store ptr @i32_typ, ptr %50, align 8
  %287 = load ptr, ptr %50, align 8
  store ptr %287, ptr %36, align 8
  %288 = load i32, ptr %49, align 4
  store i32 %288, ptr %35, align 4
  br label %289

289:                                              ; preds = %284, %285, %205
  %290 = phi i32 [ %283, %285 ], [ %283, %284 ], [ 0, %205 ]
  br label %291

291:                                              ; preds = %289
  br label %292

292:                                              ; preds = %291
  %293 = trunc i32 %290 to i1
  br i1 %293, label %294, label %118

294:                                              ; preds = %292
  br label %205

295:                                              ; preds = %118
  br label %296

296:                                              ; preds = %295
  store i8 %119, ptr %120, align 1
  %297 = load i8, ptr %120, align 1
  %298 = trunc i8 %297 to i1
  ret i1 %298
}

define ptr @String_B__EQ_otherString({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @String, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @String to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 56, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [314 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define { ptr, i64 } @String_decode_at_byte_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, i32 %3) {
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %5, align 8
  %6 = alloca i32, align 4
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %7, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %8, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %9, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = call i32 @get_offset(ptr %18, ptr @String)
  store i32 %19, ptr %6, align 4
  %20 = alloca i32, align 4
  store i32 %3, ptr %20, align 4
  %21 = load ptr, ptr %8, align 8
  %22 = load ptr, ptr %7, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %22)
  %24 = load i32, ptr %6, align 4
  %25 = getelementptr ptr, ptr %22, i32 %24
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr { ptr, ptr }, ptr %26, i32 0, i32 0
  %28 = load ptr, ptr %27, align 8
  %29 = call { ptr } %28(ptr %21) #1
  %30 = alloca ptr, align 8
  store { ptr } %29, ptr %30, align 8
  %31 = load ptr, ptr %8, align 8
  %32 = load ptr, ptr %7, align 8
  %33 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %32)
  %34 = load i32, ptr %6, align 4
  %35 = getelementptr ptr, ptr %32, i32 %34
  %36 = getelementptr ptr, ptr %35, i32 1
  %37 = load ptr, ptr %36, align 8
  %38 = getelementptr { ptr, ptr }, ptr %37, i32 0, i32 0
  %39 = load ptr, ptr %38, align 8
  %40 = call i32 %39(ptr %31) #1
  %41 = alloca i32, align 4
  store i32 %40, ptr %41, align 4
  %42 = load ptr, ptr %30, align 8
  %43 = insertvalue { ptr } undef, ptr %42, 0
  %44 = load i32, ptr %20, align 4
  %45 = load i32, ptr %41, align 4
  %46 = alloca [3 x ptr], align 8
  %47 = getelementptr [3 x ptr], ptr %46, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %47, align 8
  %48 = getelementptr [3 x ptr], ptr %46, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %48, align 8
  %49 = getelementptr [3 x ptr], ptr %46, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %49, align 8
  %50 = call ptr @llvm.invariant.start.p0(i64 9, ptr %46)
  %51 = call ptr @llvm.invariant.start.p0(i64 80, ptr @Unicode)
  %52 = load ptr, ptr getelementptr (ptr, ptr getelementptr (ptr, ptr @Unicode, i32 10), i32 3), align 8
  %53 = alloca { ptr, ptr, ptr }, align 8
  %54 = getelementptr { ptr, ptr, ptr }, ptr %53, i32 0, i32 0
  store ptr @buffer_typ, ptr %54, align 8
  %55 = getelementptr { ptr, ptr, ptr }, ptr %53, i32 0, i32 1
  store ptr @i32_typ, ptr %55, align 8
  %56 = getelementptr { ptr, ptr, ptr }, ptr %53, i32 0, i32 2
  store ptr @i32_typ, ptr %56, align 8
  %57 = call ptr @class_behavior_wrapper(ptr %52, ptr %53)
  %58 = call { ptr, i64 } %57(ptr %46, { ptr } %43, i32 %44, i32 %45)
  %59 = alloca { ptr, i64 }, align 8
  store { ptr, i64 } %58, ptr %59, align 8
  %60 = getelementptr { ptr, i64 }, ptr %59, i32 0, i32 0
  %61 = load ptr, ptr %60, align 8
  %62 = insertvalue { ptr, i64 } undef, ptr %61, 0
  %63 = getelementptr { ptr, i64 }, ptr %59, i32 0, i32 1
  %64 = load i64, ptr %63, align 4
  %65 = insertvalue { ptr, i64 } %62, i64 %64, 1
  ret { ptr, i64 } %65
}

define ptr @String_B_decode_at_byte_indexi32({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @i32_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 57, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [314 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define i8 @String_unchecked_index_xi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, i32 %3) {
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %5, align 8
  %6 = alloca i32, align 4
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %7, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %8, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %9, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = call i32 @get_offset(ptr %18, ptr @String)
  store i32 %19, ptr %6, align 4
  %20 = alloca i32, align 4
  store i32 %3, ptr %20, align 4
  %21 = load ptr, ptr %8, align 8
  %22 = load ptr, ptr %7, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %22)
  %24 = load i32, ptr %6, align 4
  %25 = getelementptr ptr, ptr %22, i32 %24
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr { ptr, ptr }, ptr %26, i32 0, i32 0
  %28 = load ptr, ptr %27, align 8
  %29 = call { ptr } %28(ptr %21) #1
  %30 = alloca ptr, align 8
  store { ptr } %29, ptr %30, align 8
  %31 = alloca i64, align 8
  %32 = load i32, ptr %20, align 4
  %33 = sext i32 %32 to i64
  store i64 %33, ptr %31, align 4
  %34 = alloca i8, align 1
  %35 = load ptr, ptr %30, align 8
  %36 = load i64, ptr %31, align 4
  %37 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %36
  %38 = getelementptr i8, ptr %35, i64 %37
  %39 = load i8, ptr %38, align 1
  store i8 %39, ptr %34, align 1
  %40 = load i8, ptr %34, align 1
  ret i8 %40
}

define ptr @String_B_unchecked_index_xi32({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @i32_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 58, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [314 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define void @String_unchecked_insert_xi32_valuei8({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, i32 %3, i8 %4) {
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %6, align 8
  %7 = alloca i32, align 4
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = alloca ptr, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %8, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 1
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %9, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 2
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %10, align 8
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  store i32 %18, ptr %7, align 4
  %19 = load ptr, ptr %8, align 8
  %20 = call i32 @get_offset(ptr %19, ptr @String)
  store i32 %20, ptr %7, align 4
  %21 = alloca i32, align 4
  store i32 %3, ptr %21, align 4
  %22 = alloca i8, align 1
  store i8 %4, ptr %22, align 1
  %23 = load ptr, ptr %9, align 8
  %24 = load ptr, ptr %8, align 8
  %25 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %24)
  %26 = load i32, ptr %7, align 4
  %27 = getelementptr ptr, ptr %24, i32 %26
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr { ptr, ptr }, ptr %28, i32 0, i32 0
  %30 = load ptr, ptr %29, align 8
  %31 = call { ptr } %30(ptr %23) #1
  %32 = alloca ptr, align 8
  store { ptr } %31, ptr %32, align 8
  %33 = alloca i64, align 8
  %34 = load i32, ptr %21, align 4
  %35 = sext i32 %34 to i64
  store i64 %35, ptr %33, align 4
  %36 = load ptr, ptr %32, align 8
  %37 = load i64, ptr %33, align 4
  %38 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %37
  %39 = getelementptr i8, ptr %36, i64 %38
  %40 = load i8, ptr %22, align 1
  store i8 %40, ptr %39, align 1
  ret void
}

define ptr @String_B_unchecked_insert_xi32_valuei8({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = ptrtoint ptr %7 to i64
  %9 = icmp eq i64 %8, ptrtoint (ptr @i32_typ to i64)
  %10 = zext i1 %9 to i8
  store i8 %10, ptr %4, align 1
  %11 = getelementptr ptr, ptr %1, i32 1
  %12 = load ptr, ptr %11, align 8
  %13 = ptrtoint ptr %12 to i64
  %14 = icmp eq i64 %13, ptrtoint (ptr @i8_typ to i64)
  %15 = zext i1 %14 to i8
  store i8 %15, ptr %3, align 1
  store i32 59, ptr %6, align 4
  %16 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %17 = load i32, ptr %6, align 4
  %18 = getelementptr [314 x ptr], ptr %16, i32 0, i32 %17
  %19 = getelementptr ptr, ptr %18, i32 10
  %20 = load ptr, ptr %19, align 8
  ret ptr %20
}

define { ptr, ptr, ptr, i32 } @String_copy_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca [0 x ptr], align 8
  %5 = alloca {}, align 8
  %6 = alloca { ptr, i160 }, align 8
  %7 = alloca i32, align 4
  %8 = alloca ptr, align 8
  %9 = alloca i1, align 1
  %10 = alloca i1, align 1
  %11 = alloca i1, align 1
  %12 = alloca i32, align 4
  %13 = alloca ptr, align 8
  %14 = alloca i64, align 8
  %15 = alloca i8, align 1
  %16 = alloca i64, align 8
  %17 = alloca i32, align 4
  %18 = alloca ptr, align 8
  %19 = alloca i32, align 4
  %20 = alloca i32, align 4
  %21 = alloca i32, align 4
  %22 = alloca [1 x ptr], align 8
  %23 = alloca i32, align 4
  %24 = alloca ptr, align 8
  %25 = alloca ptr, align 8
  %26 = alloca ptr, align 8
  %27 = alloca i32, align 4
  %28 = alloca i32, align 4
  %29 = alloca i32, align 4
  %30 = alloca [4 x ptr], align 8
  %31 = alloca { ptr, ptr, ptr, ptr }, align 8
  %32 = alloca i32, align 4
  %33 = alloca ptr, align 8
  %34 = alloca ptr, align 8
  %35 = alloca ptr, align 8
  %36 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %36, align 8
  %37 = alloca i32, align 4
  %38 = alloca ptr, align 8
  %39 = alloca ptr, align 8
  %40 = alloca ptr, align 8
  %41 = getelementptr { ptr, ptr, ptr, i32 }, ptr %36, i32 0, i32 0
  %42 = load ptr, ptr %41, align 8
  store ptr %42, ptr %38, align 8
  %43 = getelementptr { ptr, ptr, ptr, i32 }, ptr %36, i32 0, i32 1
  %44 = load ptr, ptr %43, align 8
  store ptr %44, ptr %39, align 8
  %45 = getelementptr { ptr, ptr, ptr, i32 }, ptr %36, i32 0, i32 2
  %46 = load ptr, ptr %45, align 8
  store ptr %46, ptr %40, align 8
  %47 = getelementptr { ptr, ptr, ptr, i32 }, ptr %36, i32 0, i32 3
  %48 = load i32, ptr %47, align 4
  store i32 %48, ptr %37, align 4
  %49 = load ptr, ptr %38, align 8
  %50 = call i32 @get_offset(ptr %49, ptr @String)
  store i32 %50, ptr %37, align 4
  %51 = load ptr, ptr %39, align 8
  %52 = load ptr, ptr %38, align 8
  %53 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %52)
  %54 = load i32, ptr %37, align 4
  %55 = getelementptr ptr, ptr %52, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 1
  %57 = load ptr, ptr %56, align 8
  %58 = getelementptr { ptr, ptr }, ptr %57, i32 0, i32 0
  %59 = load ptr, ptr %58, align 8
  %60 = call i32 %59(ptr %51) #1
  %61 = alloca i32, align 4
  store i32 %60, ptr %61, align 4
  %62 = alloca i64, align 8
  %63 = load i32, ptr %61, align 4
  %64 = sext i32 %63 to i64
  store i64 %64, ptr %62, align 4
  %65 = load i64, ptr %62, align 4
  %66 = alloca ptr, align 8
  %67 = mul i64 %65, ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
  %68 = call ptr @bump_malloc(i64 %67)
  store ptr %68, ptr %66, align 8
  %69 = alloca ptr, align 8
  %70 = getelementptr { ptr }, ptr %66, i32 0, i32 0
  %71 = load ptr, ptr %70, align 8
  store ptr %71, ptr %69, align 8
  %72 = alloca i32, align 4
  store i32 0, ptr %72, align 4
  %73 = load ptr, ptr %39, align 8
  %74 = load ptr, ptr %38, align 8
  %75 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %74)
  %76 = load i32, ptr %37, align 4
  %77 = getelementptr ptr, ptr %74, i32 %76
  %78 = getelementptr ptr, ptr %77, i32 1
  %79 = load ptr, ptr %78, align 8
  %80 = getelementptr { ptr, ptr }, ptr %79, i32 0, i32 0
  %81 = load ptr, ptr %80, align 8
  %82 = call i32 %81(ptr %73) #1
  %83 = alloca i32, align 4
  store i32 %82, ptr %83, align 4
  %84 = alloca i32, align 4
  store i32 1, ptr %84, align 4
  %85 = load i32, ptr %83, align 4
  %86 = load i32, ptr %84, align 4
  %87 = sub i32 %85, %86
  %88 = alloca i32, align 4
  store i32 %87, ptr %88, align 4
  %89 = alloca [1 x ptr], align 8
  store ptr @Range, ptr %89, align 8
  %90 = load ptr, ptr %89, align 8
  %91 = getelementptr ptr, ptr %90, i32 6
  %92 = load ptr, ptr %91, align 8
  %93 = call { i64, i64 } @size_wrapper(ptr %92, ptr %89)
  %94 = extractvalue { i64, i64 } %93, 0
  %95 = call ptr @bump_malloc(i64 %94)
  %96 = alloca i32, align 4
  %97 = alloca ptr, align 8
  %98 = alloca ptr, align 8
  %99 = alloca ptr, align 8
  store ptr @Range, ptr %99, align 8
  store ptr %95, ptr %98, align 8
  store i32 10, ptr %96, align 4
  %100 = alloca i32, align 4
  store i32 0, ptr %100, align 4
  %101 = load ptr, ptr %39, align 8
  %102 = load ptr, ptr %38, align 8
  %103 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %102)
  %104 = load i32, ptr %37, align 4
  %105 = getelementptr ptr, ptr %102, i32 %104
  %106 = getelementptr ptr, ptr %105, i32 1
  %107 = load ptr, ptr %106, align 8
  %108 = getelementptr { ptr, ptr }, ptr %107, i32 0, i32 0
  %109 = load ptr, ptr %108, align 8
  %110 = call i32 %109(ptr %101) #1
  %111 = alloca i32, align 4
  store i32 %110, ptr %111, align 4
  %112 = alloca i32, align 4
  store i32 1, ptr %112, align 4
  %113 = load i32, ptr %111, align 4
  %114 = load i32, ptr %112, align 4
  %115 = sub i32 %113, %114
  %116 = alloca i32, align 4
  store i32 %115, ptr %116, align 4
  %117 = load i32, ptr %100, align 4
  %118 = load i32, ptr %116, align 4
  %119 = load ptr, ptr %99, align 8
  %120 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %119, 0
  %121 = load ptr, ptr %98, align 8
  %122 = insertvalue { ptr, ptr, ptr, i32 } %120, ptr %121, 1
  %123 = load ptr, ptr %97, align 8
  %124 = insertvalue { ptr, ptr, ptr, i32 } %122, ptr %123, 2
  %125 = load i32, ptr %96, align 4
  %126 = insertvalue { ptr, ptr, ptr, i32 } %124, i32 %125, 3
  %127 = alloca [2 x ptr], align 8
  %128 = getelementptr [2 x ptr], ptr %127, i32 0, i32 0
  store ptr @_parameterization_i32, ptr %128, align 8
  %129 = getelementptr [2 x ptr], ptr %127, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %129, align 8
  %130 = call ptr @llvm.invariant.start.p0(i64 4, ptr %127)
  %131 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %119)
  %132 = getelementptr ptr, ptr %119, i32 %125
  %133 = getelementptr ptr, ptr %132, i32 5
  %134 = load ptr, ptr %133, align 8
  %135 = alloca { ptr, ptr }, align 8
  %136 = getelementptr { ptr, ptr }, ptr %135, i32 0, i32 0
  store ptr @i32_typ, ptr %136, align 8
  %137 = getelementptr { ptr, ptr }, ptr %135, i32 0, i32 1
  store ptr @i32_typ, ptr %137, align 8
  %138 = call ptr @behavior_wrapper(ptr %134, { ptr, ptr, ptr, i32 } %126, ptr %135)
  call void %138({ ptr, ptr, ptr, i32 } %126, { ptr, ptr, ptr, i32 } %126, ptr %127, i32 %117, i32 %118)
  %139 = load ptr, ptr %99, align 8
  %140 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %139, 0
  %141 = load ptr, ptr %98, align 8
  %142 = insertvalue { ptr, ptr, ptr, i32 } %140, ptr %141, 1
  %143 = load ptr, ptr %97, align 8
  %144 = insertvalue { ptr, ptr, ptr, i32 } %142, ptr %143, 2
  %145 = load i32, ptr %96, align 4
  %146 = insertvalue { ptr, ptr, ptr, i32 } %144, i32 %145, 3
  %147 = alloca [0 x ptr], align 8
  %148 = call ptr @llvm.invariant.start.p0(i64 0, ptr %147)
  %149 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %139)
  %150 = getelementptr ptr, ptr %139, i32 %145
  %151 = getelementptr ptr, ptr %150, i32 9
  %152 = load ptr, ptr %151, align 8
  %153 = alloca {}, align 8
  %154 = call ptr @behavior_wrapper(ptr %152, { ptr, ptr, ptr, i32 } %146, ptr %153)
  %155 = call { ptr, ptr, ptr, i32 } %154({ ptr, ptr, ptr, i32 } %146, { ptr, ptr, ptr, i32 } %146, ptr %147)
  %156 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %155, ptr %156, align 8
  %157 = alloca i32, align 4
  %158 = alloca ptr, align 8
  %159 = alloca ptr, align 8
  %160 = alloca ptr, align 8
  %161 = getelementptr { ptr, ptr, ptr, i32 }, ptr %156, i32 0, i32 0
  %162 = load ptr, ptr %161, align 8
  store ptr %162, ptr %160, align 8
  %163 = getelementptr { ptr, ptr, ptr, i32 }, ptr %156, i32 0, i32 1
  %164 = load ptr, ptr %163, align 8
  store ptr %164, ptr %159, align 8
  %165 = getelementptr { ptr, ptr, ptr, i32 }, ptr %156, i32 0, i32 2
  %166 = load ptr, ptr %165, align 8
  store ptr %166, ptr %158, align 8
  %167 = getelementptr { ptr, ptr, ptr, i32 }, ptr %156, i32 0, i32 3
  %168 = load i32, ptr %167, align 4
  store i32 %168, ptr %157, align 4
  %169 = load ptr, ptr %160, align 8
  %170 = call i32 @get_offset(ptr %169, ptr @RangeIterator)
  store i32 %170, ptr %157, align 4
  %171 = alloca i32, align 4
  %172 = alloca ptr, align 8
  %173 = alloca ptr, align 8
  %174 = alloca ptr, align 8
  %175 = load ptr, ptr %160, align 8
  store ptr %175, ptr %174, align 8
  %176 = load ptr, ptr %159, align 8
  store ptr %176, ptr %173, align 8
  %177 = load ptr, ptr %158, align 8
  store ptr %177, ptr %172, align 8
  %178 = load i32, ptr %157, align 4
  store i32 %178, ptr %171, align 4
  %179 = getelementptr { ptr, i32 }, ptr %6, i32 0, i32 0
  %180 = getelementptr { ptr, i32 }, ptr %6, i32 0, i32 1
  br label %181

181:                                              ; preds = %241, %3
  %182 = load ptr, ptr %174, align 8
  %183 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %182, 0
  %184 = load ptr, ptr %173, align 8
  %185 = insertvalue { ptr, ptr, ptr, i32 } %183, ptr %184, 1
  %186 = load ptr, ptr %172, align 8
  %187 = insertvalue { ptr, ptr, ptr, i32 } %185, ptr %186, 2
  %188 = load i32, ptr %171, align 4
  %189 = insertvalue { ptr, ptr, ptr, i32 } %187, i32 %188, 3
  %190 = call ptr @llvm.invariant.start.p0(i64 0, ptr %4)
  %191 = call ptr @llvm.invariant.start.p0(i64 88, ptr %182)
  %192 = getelementptr ptr, ptr %182, i32 %188
  %193 = getelementptr ptr, ptr %192, i32 5
  %194 = load ptr, ptr %193, align 8
  %195 = call ptr @behavior_wrapper(ptr %194, { ptr, ptr, ptr, i32 } %189, ptr %5)
  %196 = call { ptr, i160 } %195({ ptr, ptr, ptr, i32 } %189, { ptr, ptr, ptr, i32 } %189, ptr %4)
  store { ptr, i160 } %196, ptr %6, align 8
  %197 = load ptr, ptr %179, align 8
  store ptr %197, ptr %8, align 8
  %198 = load i32, ptr %180, align 4
  store i32 %198, ptr %7, align 4
  store i8 0, ptr %9, align 1
  %199 = load ptr, ptr %8, align 8
  %200 = ptrtoint ptr %199 to i64
  %201 = icmp eq i64 %200, ptrtoint (ptr @nil_typ to i64)
  %202 = icmp eq i64 %200, 0
  %203 = or i1 %201, %202
  %204 = zext i1 %203 to i8
  store i8 %204, ptr %10, align 1
  %205 = load i8, ptr %9, align 1
  %206 = trunc i8 %205 to i1
  %207 = load i8, ptr %10, align 1
  %208 = trunc i8 %207 to i1
  %209 = icmp eq i1 %206, %208
  %210 = zext i1 %209 to i8
  store i8 %210, ptr %11, align 1
  %211 = load i8, ptr %11, align 1
  %212 = trunc i8 %211 to i1
  br i1 %212, label %213, label %241

213:                                              ; preds = %181
  %214 = load i32, ptr %7, align 4
  store i32 %214, ptr %12, align 4
  %215 = load ptr, ptr %39, align 8
  %216 = load ptr, ptr %38, align 8
  %217 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %216)
  %218 = load i32, ptr %37, align 4
  %219 = getelementptr ptr, ptr %216, i32 %218
  %220 = load ptr, ptr %219, align 8
  %221 = getelementptr { ptr, ptr }, ptr %220, i32 0, i32 0
  %222 = load ptr, ptr %221, align 8
  %223 = call { ptr } %222(ptr %215) #1
  store { ptr } %223, ptr %13, align 8
  %224 = load i32, ptr %12, align 4
  %225 = sext i32 %224 to i64
  store i64 %225, ptr %14, align 4
  %226 = load ptr, ptr %13, align 8
  %227 = load i64, ptr %14, align 4
  %228 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %227
  %229 = getelementptr i8, ptr %226, i64 %228
  %230 = load i8, ptr %229, align 1
  store i8 %230, ptr %15, align 1
  %231 = load i32, ptr %12, align 4
  %232 = sext i32 %231 to i64
  store i64 %232, ptr %16, align 4
  %233 = load ptr, ptr %69, align 8
  %234 = load i64, ptr %16, align 4
  %235 = mul i64 ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64), %234
  %236 = getelementptr i8, ptr %233, i64 %235
  %237 = load i8, ptr %15, align 1
  store i8 %237, ptr %236, align 1
  %238 = load i32, ptr %12, align 4
  store i32 %238, ptr %17, align 4
  store ptr @i32_typ, ptr %18, align 8
  %239 = load ptr, ptr %18, align 8
  store ptr %239, ptr %8, align 8
  %240 = load i32, ptr %17, align 4
  store i32 %240, ptr %7, align 4
  br label %241

241:                                              ; preds = %213, %181
  br i1 %212, label %181, label %242

242:                                              ; preds = %241
  %243 = load ptr, ptr %39, align 8
  %244 = load ptr, ptr %38, align 8
  %245 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %244)
  %246 = load i32, ptr %37, align 4
  %247 = getelementptr ptr, ptr %244, i32 %246
  %248 = getelementptr ptr, ptr %247, i32 1
  %249 = load ptr, ptr %248, align 8
  %250 = getelementptr { ptr, ptr }, ptr %249, i32 0, i32 0
  %251 = load ptr, ptr %250, align 8
  %252 = call i32 %251(ptr %243) #1
  store i32 %252, ptr %19, align 4
  %253 = load ptr, ptr %39, align 8
  %254 = load ptr, ptr %38, align 8
  %255 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %254)
  %256 = load i32, ptr %37, align 4
  %257 = getelementptr ptr, ptr %254, i32 %256
  %258 = getelementptr ptr, ptr %257, i32 2
  %259 = load ptr, ptr %258, align 8
  %260 = getelementptr { ptr, ptr }, ptr %259, i32 0, i32 0
  %261 = load ptr, ptr %260, align 8
  %262 = call i32 %261(ptr %253) #1
  store i32 %262, ptr %20, align 4
  %263 = load ptr, ptr %39, align 8
  %264 = load ptr, ptr %38, align 8
  %265 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %264)
  %266 = load i32, ptr %37, align 4
  %267 = getelementptr ptr, ptr %264, i32 %266
  %268 = getelementptr ptr, ptr %267, i32 1
  %269 = load ptr, ptr %268, align 8
  %270 = getelementptr { ptr, ptr }, ptr %269, i32 0, i32 0
  %271 = load ptr, ptr %270, align 8
  %272 = call i32 %271(ptr %263) #1
  store i32 %272, ptr %21, align 4
  store ptr @String, ptr %22, align 8
  %273 = load ptr, ptr %22, align 8
  %274 = getelementptr ptr, ptr %273, i32 6
  %275 = load ptr, ptr %274, align 8
  %276 = call { i64, i64 } @size_wrapper(ptr %275, ptr %22)
  %277 = extractvalue { i64, i64 } %276, 0
  %278 = call ptr @bump_malloc(i64 %277)
  store ptr @String, ptr %26, align 8
  store ptr %278, ptr %25, align 8
  store i32 10, ptr %23, align 4
  %279 = load ptr, ptr %39, align 8
  %280 = load ptr, ptr %38, align 8
  %281 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %280)
  %282 = load i32, ptr %37, align 4
  %283 = getelementptr ptr, ptr %280, i32 %282
  %284 = getelementptr ptr, ptr %283, i32 1
  %285 = load ptr, ptr %284, align 8
  %286 = getelementptr { ptr, ptr }, ptr %285, i32 0, i32 0
  %287 = load ptr, ptr %286, align 8
  %288 = call i32 %287(ptr %279) #1
  store i32 %288, ptr %27, align 4
  %289 = load ptr, ptr %39, align 8
  %290 = load ptr, ptr %38, align 8
  %291 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %290)
  %292 = load i32, ptr %37, align 4
  %293 = getelementptr ptr, ptr %290, i32 %292
  %294 = getelementptr ptr, ptr %293, i32 2
  %295 = load ptr, ptr %294, align 8
  %296 = getelementptr { ptr, ptr }, ptr %295, i32 0, i32 0
  %297 = load ptr, ptr %296, align 8
  %298 = call i32 %297(ptr %289) #1
  store i32 %298, ptr %28, align 4
  %299 = load ptr, ptr %39, align 8
  %300 = load ptr, ptr %38, align 8
  %301 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %300)
  %302 = load i32, ptr %37, align 4
  %303 = getelementptr ptr, ptr %300, i32 %302
  %304 = getelementptr ptr, ptr %303, i32 1
  %305 = load ptr, ptr %304, align 8
  %306 = getelementptr { ptr, ptr }, ptr %305, i32 0, i32 0
  %307 = load ptr, ptr %306, align 8
  %308 = call i32 %307(ptr %299) #1
  store i32 %308, ptr %29, align 4
  %309 = load ptr, ptr %69, align 8
  %310 = insertvalue { ptr } undef, ptr %309, 0
  %311 = load i32, ptr %27, align 4
  %312 = load i32, ptr %28, align 4
  %313 = load i32, ptr %29, align 4
  %314 = load ptr, ptr %26, align 8
  %315 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %314, 0
  %316 = load ptr, ptr %25, align 8
  %317 = insertvalue { ptr, ptr, ptr, i32 } %315, ptr %316, 1
  %318 = load ptr, ptr %24, align 8
  %319 = insertvalue { ptr, ptr, ptr, i32 } %317, ptr %318, 2
  %320 = load i32, ptr %23, align 4
  %321 = insertvalue { ptr, ptr, ptr, i32 } %319, i32 %320, 3
  %322 = getelementptr [4 x ptr], ptr %30, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %322, align 8
  %323 = getelementptr [4 x ptr], ptr %30, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %323, align 8
  %324 = getelementptr [4 x ptr], ptr %30, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %324, align 8
  %325 = getelementptr [4 x ptr], ptr %30, i32 0, i32 3
  store ptr @_parameterization_i32, ptr %325, align 8
  %326 = call ptr @llvm.invariant.start.p0(i64 16, ptr %30)
  %327 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %314)
  %328 = getelementptr ptr, ptr %314, i32 %320
  %329 = getelementptr ptr, ptr %328, i32 12
  %330 = load ptr, ptr %329, align 8
  %331 = getelementptr { ptr, ptr, ptr, ptr }, ptr %31, i32 0, i32 0
  store ptr @buffer_typ, ptr %331, align 8
  %332 = getelementptr { ptr, ptr, ptr, ptr }, ptr %31, i32 0, i32 1
  store ptr @i32_typ, ptr %332, align 8
  %333 = getelementptr { ptr, ptr, ptr, ptr }, ptr %31, i32 0, i32 2
  store ptr @i32_typ, ptr %333, align 8
  %334 = getelementptr { ptr, ptr, ptr, ptr }, ptr %31, i32 0, i32 3
  store ptr @i32_typ, ptr %334, align 8
  %335 = call ptr @behavior_wrapper(ptr %330, { ptr, ptr, ptr, i32 } %321, ptr %31)
  call void %335({ ptr, ptr, ptr, i32 } %321, { ptr, ptr, ptr, i32 } %321, ptr %30, { ptr } %310, i32 %311, i32 %312, i32 %313)
  %336 = load ptr, ptr %26, align 8
  store ptr %336, ptr %35, align 8
  %337 = load ptr, ptr %25, align 8
  store ptr %337, ptr %34, align 8
  %338 = load ptr, ptr %24, align 8
  store ptr %338, ptr %33, align 8
  %339 = load i32, ptr %23, align 4
  store i32 %339, ptr %32, align 4
  %340 = load ptr, ptr %35, align 8
  %341 = call i32 @get_offset(ptr %340, ptr @String)
  store i32 %341, ptr %32, align 4
  %342 = load ptr, ptr %35, align 8
  %343 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %342, 0
  %344 = load ptr, ptr %34, align 8
  %345 = insertvalue { ptr, ptr, ptr, i32 } %343, ptr %344, 1
  %346 = load ptr, ptr %33, align 8
  %347 = insertvalue { ptr, ptr, ptr, i32 } %345, ptr %346, 2
  %348 = load i32, ptr %32, align 4
  %349 = insertvalue { ptr, ptr, ptr, i32 } %347, i32 %348, 3
  ret { ptr, ptr, ptr, i32 } %349
}

define ptr @String_B_copy_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 60, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [314 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { ptr, ptr, ptr, i32 } @String__Self_empty_(ptr %0) {
  %2 = alloca [1 x ptr], align 8
  store ptr @String, ptr %2, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr ptr, ptr %3, i32 6
  %5 = load ptr, ptr %4, align 8
  %6 = call { i64, i64 } @size_wrapper(ptr %5, ptr %2)
  %7 = extractvalue { i64, i64 } %6, 0
  %8 = call ptr @bump_malloc(i64 %7)
  %9 = alloca i32, align 4
  %10 = alloca ptr, align 8
  %11 = alloca ptr, align 8
  %12 = alloca ptr, align 8
  store ptr @String, ptr %12, align 8
  store ptr %8, ptr %11, align 8
  store i32 10, ptr %9, align 4
  %13 = load ptr, ptr %12, align 8
  %14 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %13, 0
  %15 = load ptr, ptr %11, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } %14, ptr %15, 1
  %17 = load ptr, ptr %10, align 8
  %18 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %17, 2
  %19 = load i32, ptr %9, align 4
  %20 = insertvalue { ptr, ptr, ptr, i32 } %18, i32 %19, 3
  %21 = alloca [0 x ptr], align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 0, ptr %21)
  %23 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %13)
  %24 = getelementptr ptr, ptr %13, i32 %19
  %25 = getelementptr ptr, ptr %24, i32 10
  %26 = load ptr, ptr %25, align 8
  %27 = alloca {}, align 8
  %28 = call ptr @behavior_wrapper(ptr %26, { ptr, ptr, ptr, i32 } %20, ptr %27)
  call void %28({ ptr, ptr, ptr, i32 } %20, { ptr, ptr, ptr, i32 } %20, ptr %21)
  %29 = alloca i32, align 4
  %30 = alloca ptr, align 8
  %31 = alloca ptr, align 8
  %32 = alloca ptr, align 8
  %33 = load ptr, ptr %12, align 8
  store ptr %33, ptr %32, align 8
  %34 = load ptr, ptr %11, align 8
  store ptr %34, ptr %31, align 8
  %35 = load ptr, ptr %10, align 8
  store ptr %35, ptr %30, align 8
  %36 = load i32, ptr %9, align 4
  store i32 %36, ptr %29, align 4
  %37 = load ptr, ptr %32, align 8
  %38 = call i32 @get_offset(ptr %37, ptr @List)
  store i32 %38, ptr %29, align 4
  %39 = load ptr, ptr %32, align 8
  %40 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %39, 0
  %41 = load ptr, ptr %31, align 8
  %42 = insertvalue { ptr, ptr, ptr, i32 } %40, ptr %41, 1
  %43 = load ptr, ptr %30, align 8
  %44 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %43, 2
  %45 = load i32, ptr %29, align 4
  %46 = insertvalue { ptr, ptr, ptr, i32 } %44, i32 %45, 3
  ret { ptr, ptr, ptr, i32 } %46
}

define ptr @String_B__Self_empty_(ptr %0) {
  %2 = call ptr @llvm.invariant.start.p0(i64 0, ptr %0)
  %3 = alloca ptr, align 8
  store i32 61, ptr %3, align 4
  %4 = load i32, ptr %3, align 4
  %5 = getelementptr [314 x ptr], ptr @String, i32 0, i32 %4
  %6 = getelementptr ptr, ptr %5, i32 10
  %7 = load ptr, ptr %6, align 8
  ret ptr %7
}

define { ptr, ptr, ptr, i32 } @String__Self_from_iterable_iterableIterableCharacter(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %3, align 8
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  %5 = getelementptr { ptr, ptr, ptr, i32 }, ptr %3, i32 0, i32 0
  %6 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %7 = load ptr, ptr %5, align 8
  store ptr %7, ptr %6, align 8
  %8 = getelementptr { ptr, ptr, ptr, i32 }, ptr %3, i32 0, i32 1
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %10 = load ptr, ptr %8, align 8
  store ptr %10, ptr %9, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %3, i32 0, i32 2
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %13 = load ptr, ptr %11, align 8
  store ptr %13, ptr %12, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %3, i32 0, i32 3
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %14, align 4
  store i32 %16, ptr %15, align 4
  %17 = load ptr, ptr %4, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @Iterable)
  store i32 %18, ptr %15, align 4
  %19 = getelementptr { ptr, i160 }, ptr %4, i32 0, i32 0
  %20 = load ptr, ptr %19, align 8
  %21 = insertvalue { ptr, i160 } undef, ptr %20, 0
  %22 = getelementptr { ptr, i160 }, ptr %4, i32 0, i32 1
  %23 = load i160, ptr %22, align 4
  %24 = insertvalue { ptr, i160 } %21, i160 %23, 1
  %25 = alloca [0 x ptr], align 8
  %26 = call ptr @llvm.invariant.start.p0(i64 0, ptr %25)
  %27 = call ptr @llvm.invariant.start.p0(i64 2512, ptr @String)
  %28 = load ptr, ptr getelementptr (ptr, ptr getelementptr (ptr, ptr @String, i32 10), i32 21), align 8
  %29 = alloca {}, align 8
  %30 = call ptr @class_behavior_wrapper(ptr %28, ptr %29)
  %31 = call { ptr, ptr, ptr, i32 } %30(ptr %25)
  %32 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %31, ptr %32, align 8
  %33 = alloca i32, align 4
  %34 = alloca ptr, align 8
  %35 = alloca ptr, align 8
  %36 = alloca ptr, align 8
  %37 = getelementptr { ptr, ptr, ptr, i32 }, ptr %32, i32 0, i32 0
  %38 = load ptr, ptr %37, align 8
  store ptr %38, ptr %36, align 8
  %39 = getelementptr { ptr, ptr, ptr, i32 }, ptr %32, i32 0, i32 1
  %40 = load ptr, ptr %39, align 8
  store ptr %40, ptr %35, align 8
  %41 = getelementptr { ptr, ptr, ptr, i32 }, ptr %32, i32 0, i32 2
  %42 = load ptr, ptr %41, align 8
  store ptr %42, ptr %34, align 8
  %43 = getelementptr { ptr, ptr, ptr, i32 }, ptr %32, i32 0, i32 3
  %44 = load i32, ptr %43, align 4
  store i32 %44, ptr %33, align 4
  %45 = load ptr, ptr %36, align 8
  %46 = call i32 @get_offset(ptr %45, ptr @String)
  store i32 %46, ptr %33, align 4
  %47 = load ptr, ptr %36, align 8
  %48 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %47, 0
  %49 = load ptr, ptr %35, align 8
  %50 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %49, 1
  %51 = load ptr, ptr %34, align 8
  %52 = insertvalue { ptr, ptr, ptr, i32 } %50, ptr %51, 2
  %53 = load i32, ptr %33, align 4
  %54 = insertvalue { ptr, ptr, ptr, i32 } %52, i32 %53, 3
  %55 = alloca [1 x ptr], align 8
  %56 = getelementptr [1 x ptr], ptr %55, i32 0, i32 0
  store ptr @_parameterization_IterableCharacter, ptr %56, align 8
  %57 = call ptr @llvm.invariant.start.p0(i64 1, ptr %55)
  %58 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %47)
  %59 = getelementptr ptr, ptr %47, i32 %53
  %60 = getelementptr ptr, ptr %59, i32 27
  %61 = load ptr, ptr %60, align 8
  %62 = alloca { ptr }, align 8
  %63 = getelementptr { ptr }, ptr %62, i32 0, i32 0
  store ptr %20, ptr %63, align 8
  %64 = call ptr @behavior_wrapper(ptr %61, { ptr, ptr, ptr, i32 } %54, ptr %62)
  %65 = call { ptr, i160 } %64({ ptr, ptr, ptr, i32 } %54, { ptr, ptr, ptr, i32 } %54, ptr %55, { ptr, i160 } %24)
  %66 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %65, ptr %66, align 8
  %67 = alloca { ptr, ptr, ptr, i32 }, align 8
  %68 = getelementptr { ptr, i160 }, ptr %66, i32 0, i32 0
  %69 = getelementptr { ptr, i160 }, ptr %67, i32 0, i32 0
  %70 = load ptr, ptr %68, align 8
  store ptr %70, ptr %69, align 8
  %71 = getelementptr { ptr, i160 }, ptr %66, i32 0, i32 1
  %72 = getelementptr { ptr, i160 }, ptr %67, i32 0, i32 1
  %73 = load i160, ptr %71, align 4
  store i160 %73, ptr %72, align 4
  %74 = load ptr, ptr %67, align 8
  %75 = call i32 @get_offset(ptr %74, ptr @String)
  %76 = getelementptr { ptr, ptr, ptr, i32 }, ptr %67, i32 0, i32 3
  store i32 %75, ptr %76, align 4
  %77 = alloca i32, align 4
  %78 = alloca ptr, align 8
  %79 = alloca ptr, align 8
  %80 = alloca ptr, align 8
  %81 = getelementptr { ptr, ptr, ptr, i32 }, ptr %67, i32 0, i32 0
  %82 = load ptr, ptr %81, align 8
  store ptr %82, ptr %80, align 8
  %83 = getelementptr { ptr, ptr, ptr, i32 }, ptr %67, i32 0, i32 1
  %84 = load ptr, ptr %83, align 8
  store ptr %84, ptr %79, align 8
  %85 = getelementptr { ptr, ptr, ptr, i32 }, ptr %67, i32 0, i32 2
  %86 = load ptr, ptr %85, align 8
  store ptr %86, ptr %78, align 8
  %87 = load i32, ptr %76, align 4
  store i32 %87, ptr %77, align 4
  %88 = load ptr, ptr %80, align 8
  %89 = call i32 @get_offset(ptr %88, ptr @List)
  store i32 %89, ptr %77, align 4
  %90 = load ptr, ptr %80, align 8
  %91 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %90, 0
  %92 = load ptr, ptr %79, align 8
  %93 = insertvalue { ptr, ptr, ptr, i32 } %91, ptr %92, 1
  %94 = load ptr, ptr %78, align 8
  %95 = insertvalue { ptr, ptr, ptr, i32 } %93, ptr %94, 2
  %96 = load i32, ptr %77, align 4
  %97 = insertvalue { ptr, ptr, ptr, i32 } %95, i32 %96, 3
  ret { ptr, ptr, ptr, i32 } %97
}

define ptr @String_B__Self_from_iterable_iterableIterableCharacter(ptr %0) {
  %2 = alloca i1, align 1
  %3 = call ptr @llvm.invariant.start.p0(i64 8, ptr %0)
  %4 = alloca ptr, align 8
  %5 = load ptr, ptr %0, align 8
  %6 = getelementptr { [3 x i64], [3 x ptr] }, ptr %5, i32 0, i32 0, i32 1
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %5, i32 0, i32 0, i32 2
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %5, i32 0, i32 1, i32 0
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %5, i32 0, i32 1, i32 1
  %10 = load i64, ptr %6, align 4
  %11 = load i64, ptr %7, align 4
  %12 = load ptr, ptr %8, align 8
  %13 = load ptr, ptr %9, align 8
  %14 = load i64, ptr @Iterable, align 4
  %15 = call i1 @subtype_test_wrapper(ptr %12, i64 %11, i64 %10, i64 %14, i64 ptrtoint (ptr @Iterable to i64), ptr %13)
  %16 = zext i1 %15 to i8
  store i8 %16, ptr %2, align 1
  store i32 62, ptr %4, align 4
  %17 = load i32, ptr %4, align 4
  %18 = getelementptr [314 x ptr], ptr @String, i32 0, i32 %17
  %19 = getelementptr ptr, ptr %18, i32 10
  %20 = load ptr, ptr %19, align 8
  ret ptr %20
}

define { ptr, ptr, ptr, i32 } @String_append_charCharacter({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, i160 } %3) {
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %5, align 8
  %6 = alloca i32, align 4
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %9, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %8, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %7, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %6, align 4
  %18 = load ptr, ptr %9, align 8
  %19 = call i32 @get_offset(ptr %18, ptr @String)
  store i32 %19, ptr %6, align 4
  %20 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %3, ptr %20, align 8
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  %22 = getelementptr { ptr, i160 }, ptr %20, i32 0, i32 0
  %23 = getelementptr { ptr, i160 }, ptr %21, i32 0, i32 0
  %24 = load ptr, ptr %22, align 8
  store ptr %24, ptr %23, align 8
  %25 = getelementptr { ptr, i160 }, ptr %20, i32 0, i32 1
  %26 = getelementptr { ptr, i160 }, ptr %21, i32 0, i32 1
  %27 = load i160, ptr %25, align 4
  store i160 %27, ptr %26, align 4
  %28 = load ptr, ptr %21, align 8
  %29 = call i32 @get_offset(ptr %28, ptr @Character)
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 3
  store i32 %29, ptr %30, align 4
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 0
  %32 = load ptr, ptr %31, align 8
  %33 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %32, 0
  %34 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 1
  %35 = load ptr, ptr %34, align 8
  %36 = insertvalue { ptr, ptr, ptr, i32 } %33, ptr %35, 1
  %37 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 2
  %38 = load ptr, ptr %37, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %36, ptr %38, 2
  %40 = load i32, ptr %30, align 4
  %41 = insertvalue { ptr, ptr, ptr, i32 } %39, i32 %40, 3
  %42 = alloca [0 x ptr], align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 0, ptr %42)
  %44 = call ptr @llvm.invariant.start.p0(i64 88, ptr %32)
  %45 = getelementptr ptr, ptr %32, i32 %40
  %46 = getelementptr ptr, ptr %45, i32 3
  %47 = load ptr, ptr %46, align 8
  %48 = alloca {}, align 8
  %49 = call ptr @behavior_wrapper(ptr %47, { ptr, ptr, ptr, i32 } %41, ptr %48)
  %50 = call { ptr, ptr, ptr, i32 } %49({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr %42)
  %51 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %50, ptr %51, align 8
  %52 = alloca { ptr, ptr, ptr, i32 }, align 8
  %53 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 0
  %54 = getelementptr { ptr, ptr, ptr, i32 }, ptr %52, i32 0, i32 0
  %55 = load ptr, ptr %53, align 8
  store ptr %55, ptr %54, align 8
  %56 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 1
  %57 = getelementptr { ptr, ptr, ptr, i32 }, ptr %52, i32 0, i32 1
  %58 = load ptr, ptr %56, align 8
  store ptr %58, ptr %57, align 8
  %59 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 2
  %60 = getelementptr { ptr, ptr, ptr, i32 }, ptr %52, i32 0, i32 2
  %61 = load ptr, ptr %59, align 8
  store ptr %61, ptr %60, align 8
  %62 = getelementptr { ptr, ptr, ptr, i32 }, ptr %51, i32 0, i32 3
  %63 = getelementptr { ptr, ptr, ptr, i32 }, ptr %52, i32 0, i32 3
  %64 = load i32, ptr %62, align 4
  store i32 %64, ptr %63, align 4
  %65 = load ptr, ptr %52, align 8
  %66 = call i32 @get_offset(ptr %65, ptr @String)
  store i32 %66, ptr %63, align 4
  %67 = getelementptr { ptr, i160 }, ptr %52, i32 0, i32 0
  %68 = load ptr, ptr %67, align 8
  %69 = insertvalue { ptr, i160 } undef, ptr %68, 0
  %70 = getelementptr { ptr, i160 }, ptr %52, i32 0, i32 1
  %71 = load i160, ptr %70, align 4
  %72 = insertvalue { ptr, i160 } %69, i160 %71, 1
  %73 = load ptr, ptr %9, align 8
  %74 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %73, 0
  %75 = load ptr, ptr %8, align 8
  %76 = insertvalue { ptr, ptr, ptr, i32 } %74, ptr %75, 1
  %77 = load ptr, ptr %7, align 8
  %78 = insertvalue { ptr, ptr, ptr, i32 } %76, ptr %77, 2
  %79 = load i32, ptr %6, align 4
  %80 = insertvalue { ptr, ptr, ptr, i32 } %78, i32 %79, 3
  %81 = alloca [1 x ptr], align 8
  %82 = getelementptr [1 x ptr], ptr %81, i32 0, i32 0
  store ptr @_parameterization_String, ptr %82, align 8
  %83 = call ptr @llvm.invariant.start.p0(i64 1, ptr %81)
  %84 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %73)
  %85 = getelementptr ptr, ptr %73, i32 %79
  %86 = getelementptr ptr, ptr %85, i32 27
  %87 = load ptr, ptr %86, align 8
  %88 = alloca { ptr }, align 8
  %89 = getelementptr { ptr }, ptr %88, i32 0, i32 0
  store ptr %68, ptr %89, align 8
  %90 = call ptr @behavior_wrapper(ptr %87, { ptr, ptr, ptr, i32 } %80, ptr %88)
  %91 = call { ptr, i160 } %90({ ptr, ptr, ptr, i32 } %80, { ptr, ptr, ptr, i32 } %80, ptr %81, { ptr, i160 } %72)
  %92 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %91, ptr %92, align 8
  %93 = alloca { ptr, ptr, ptr, i32 }, align 8
  %94 = getelementptr { ptr, i160 }, ptr %92, i32 0, i32 0
  %95 = getelementptr { ptr, i160 }, ptr %93, i32 0, i32 0
  %96 = load ptr, ptr %94, align 8
  store ptr %96, ptr %95, align 8
  %97 = getelementptr { ptr, i160 }, ptr %92, i32 0, i32 1
  %98 = getelementptr { ptr, i160 }, ptr %93, i32 0, i32 1
  %99 = load i160, ptr %97, align 4
  store i160 %99, ptr %98, align 4
  %100 = load ptr, ptr %93, align 8
  %101 = call i32 @get_offset(ptr %100, ptr @String)
  %102 = getelementptr { ptr, ptr, ptr, i32 }, ptr %93, i32 0, i32 3
  store i32 %101, ptr %102, align 4
  %103 = alloca i32, align 4
  %104 = alloca ptr, align 8
  %105 = alloca ptr, align 8
  %106 = alloca ptr, align 8
  %107 = getelementptr { ptr, ptr, ptr, i32 }, ptr %93, i32 0, i32 0
  %108 = load ptr, ptr %107, align 8
  store ptr %108, ptr %106, align 8
  %109 = getelementptr { ptr, ptr, ptr, i32 }, ptr %93, i32 0, i32 1
  %110 = load ptr, ptr %109, align 8
  store ptr %110, ptr %105, align 8
  %111 = getelementptr { ptr, ptr, ptr, i32 }, ptr %93, i32 0, i32 2
  %112 = load ptr, ptr %111, align 8
  store ptr %112, ptr %104, align 8
  %113 = load i32, ptr %102, align 4
  store i32 %113, ptr %103, align 4
  %114 = load ptr, ptr %106, align 8
  %115 = call i32 @get_offset(ptr %114, ptr @List)
  store i32 %115, ptr %103, align 4
  %116 = load ptr, ptr %106, align 8
  %117 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %116, 0
  %118 = load ptr, ptr %105, align 8
  %119 = insertvalue { ptr, ptr, ptr, i32 } %117, ptr %118, 1
  %120 = load ptr, ptr %104, align 8
  %121 = insertvalue { ptr, ptr, ptr, i32 } %119, ptr %120, 2
  %122 = load i32, ptr %103, align 4
  %123 = insertvalue { ptr, ptr, ptr, i32 } %121, i32 %122, 3
  ret { ptr, ptr, ptr, i32 } %123
}

define ptr @String_B_append_charCharacter({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Character, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Character to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 63, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [314 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

declare i32 @List_length_()

define ptr @String_B_length_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 64, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [314 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

declare { ptr, i160 } @List_first_()

define ptr @String_B_first_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 65, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [314 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

declare { ptr, i160 } @List_last_()

define ptr @String_B_last_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 66, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [314 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { ptr, i160 } @String_extend_otherCollectionCharacter({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, i160 } %3) {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca {}, align 8
  %7 = alloca { ptr, i160 }, align 8
  %8 = alloca i1, align 1
  %9 = alloca i1, align 1
  %10 = alloca i1, align 1
  %11 = alloca { ptr, ptr, ptr, i32 }, align 8
  %12 = alloca [0 x ptr], align 8
  %13 = alloca {}, align 8
  %14 = alloca i32, align 4
  %15 = alloca i32, align 4
  %16 = alloca i32, align 4
  %17 = alloca i32, align 4
  %18 = alloca [1 x ptr], align 8
  %19 = alloca { ptr }, align 8
  %20 = alloca [0 x ptr], align 8
  %21 = alloca {}, align 8
  %22 = alloca { ptr, ptr, ptr, i32 }, align 8
  %23 = alloca i32, align 4
  %24 = alloca ptr, align 8
  %25 = alloca ptr, align 8
  %26 = alloca ptr, align 8
  %27 = alloca i32, align 4
  %28 = alloca ptr, align 8
  %29 = alloca ptr, align 8
  %30 = alloca ptr, align 8
  %31 = alloca [0 x ptr], align 8
  %32 = alloca {}, align 8
  %33 = alloca { ptr, i160 }, align 8
  %34 = alloca i1, align 1
  %35 = alloca i1, align 1
  %36 = alloca i1, align 1
  %37 = alloca { ptr, ptr, ptr, i32 }, align 8
  %38 = alloca i160, align 8
  %39 = alloca ptr, align 8
  %40 = alloca [1 x ptr], align 8
  %41 = alloca { ptr }, align 8
  %42 = alloca { ptr, ptr, ptr, i32 }, align 8
  %43 = alloca i32, align 4
  %44 = alloca ptr, align 8
  %45 = alloca ptr, align 8
  %46 = alloca ptr, align 8
  %47 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %47, align 8
  %48 = alloca { ptr, ptr, ptr, i32 }, align 8
  %49 = getelementptr { ptr, ptr, ptr, i32 }, ptr %47, i32 0, i32 0
  %50 = getelementptr { ptr, ptr, ptr, i32 }, ptr %48, i32 0, i32 0
  %51 = load ptr, ptr %49, align 8
  store ptr %51, ptr %50, align 8
  %52 = getelementptr { ptr, ptr, ptr, i32 }, ptr %47, i32 0, i32 1
  %53 = getelementptr { ptr, ptr, ptr, i32 }, ptr %48, i32 0, i32 1
  %54 = load ptr, ptr %52, align 8
  store ptr %54, ptr %53, align 8
  %55 = getelementptr { ptr, ptr, ptr, i32 }, ptr %47, i32 0, i32 2
  %56 = getelementptr { ptr, ptr, ptr, i32 }, ptr %48, i32 0, i32 2
  %57 = load ptr, ptr %55, align 8
  store ptr %57, ptr %56, align 8
  %58 = getelementptr { ptr, ptr, ptr, i32 }, ptr %47, i32 0, i32 3
  %59 = getelementptr { ptr, ptr, ptr, i32 }, ptr %48, i32 0, i32 3
  %60 = load i32, ptr %58, align 4
  store i32 %60, ptr %59, align 4
  %61 = load ptr, ptr %48, align 8
  %62 = call i32 @get_offset(ptr %61, ptr @String)
  store i32 %62, ptr %59, align 4
  %63 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %3, ptr %63, align 8
  %64 = alloca { ptr, ptr, ptr, i32 }, align 8
  %65 = getelementptr { ptr, i160 }, ptr %63, i32 0, i32 0
  %66 = getelementptr { ptr, i160 }, ptr %64, i32 0, i32 0
  %67 = load ptr, ptr %65, align 8
  store ptr %67, ptr %66, align 8
  %68 = getelementptr { ptr, i160 }, ptr %63, i32 0, i32 1
  %69 = getelementptr { ptr, i160 }, ptr %64, i32 0, i32 1
  %70 = load i160, ptr %68, align 4
  store i160 %70, ptr %69, align 4
  %71 = load ptr, ptr %64, align 8
  %72 = call i32 @get_offset(ptr %71, ptr @Collection)
  %73 = getelementptr { ptr, ptr, ptr, i32 }, ptr %64, i32 0, i32 3
  store i32 %72, ptr %73, align 4
  %74 = alloca i32, align 4
  store i32 0, ptr %74, align 4
  %75 = getelementptr { ptr, ptr, ptr, i32 }, ptr %64, i32 0, i32 0
  %76 = load ptr, ptr %75, align 8
  %77 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %76, 0
  %78 = getelementptr { ptr, ptr, ptr, i32 }, ptr %64, i32 0, i32 1
  %79 = load ptr, ptr %78, align 8
  %80 = insertvalue { ptr, ptr, ptr, i32 } %77, ptr %79, 1
  %81 = getelementptr { ptr, ptr, ptr, i32 }, ptr %64, i32 0, i32 2
  %82 = load ptr, ptr %81, align 8
  %83 = insertvalue { ptr, ptr, ptr, i32 } %80, ptr %82, 2
  %84 = load i32, ptr %73, align 4
  %85 = insertvalue { ptr, ptr, ptr, i32 } %83, i32 %84, 3
  %86 = alloca [0 x ptr], align 8
  %87 = call ptr @llvm.invariant.start.p0(i64 0, ptr %86)
  %88 = call ptr @llvm.invariant.start.p0(i64 472, ptr %76)
  %89 = getelementptr ptr, ptr %76, i32 %84
  %90 = getelementptr ptr, ptr %89, i32 3
  %91 = load ptr, ptr %90, align 8
  %92 = alloca {}, align 8
  %93 = call ptr @behavior_wrapper(ptr %91, { ptr, ptr, ptr, i32 } %85, ptr %92)
  %94 = call { ptr, ptr, ptr, i32 } %93({ ptr, ptr, ptr, i32 } %85, { ptr, ptr, ptr, i32 } %85, ptr %86)
  %95 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %94, ptr %95, align 8
  %96 = alloca i32, align 4
  %97 = alloca ptr, align 8
  %98 = alloca ptr, align 8
  %99 = alloca ptr, align 8
  %100 = getelementptr { ptr, ptr, ptr, i32 }, ptr %95, i32 0, i32 0
  %101 = load ptr, ptr %100, align 8
  store ptr %101, ptr %99, align 8
  %102 = getelementptr { ptr, ptr, ptr, i32 }, ptr %95, i32 0, i32 1
  %103 = load ptr, ptr %102, align 8
  store ptr %103, ptr %98, align 8
  %104 = getelementptr { ptr, ptr, ptr, i32 }, ptr %95, i32 0, i32 2
  %105 = load ptr, ptr %104, align 8
  store ptr %105, ptr %97, align 8
  %106 = getelementptr { ptr, ptr, ptr, i32 }, ptr %95, i32 0, i32 3
  %107 = load i32, ptr %106, align 4
  store i32 %107, ptr %96, align 4
  %108 = load ptr, ptr %99, align 8
  %109 = call i32 @get_offset(ptr %108, ptr @Iterator)
  store i32 %109, ptr %96, align 4
  %110 = alloca i32, align 4
  %111 = alloca ptr, align 8
  %112 = alloca ptr, align 8
  %113 = alloca ptr, align 8
  %114 = load ptr, ptr %99, align 8
  store ptr %114, ptr %113, align 8
  %115 = load ptr, ptr %98, align 8
  store ptr %115, ptr %112, align 8
  %116 = load ptr, ptr %97, align 8
  store ptr %116, ptr %111, align 8
  %117 = load i32, ptr %96, align 4
  store i32 %117, ptr %110, align 4
  br label %118

118:                                              ; preds = %182, %4
  %119 = load ptr, ptr %113, align 8
  %120 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %119, 0
  %121 = load ptr, ptr %112, align 8
  %122 = insertvalue { ptr, ptr, ptr, i32 } %120, ptr %121, 1
  %123 = load ptr, ptr %111, align 8
  %124 = insertvalue { ptr, ptr, ptr, i32 } %122, ptr %123, 2
  %125 = load i32, ptr %110, align 4
  %126 = insertvalue { ptr, ptr, ptr, i32 } %124, i32 %125, 3
  %127 = call ptr @llvm.invariant.start.p0(i64 0, ptr %5)
  %128 = call ptr @llvm.invariant.start.p0(i64 24, ptr %119)
  %129 = getelementptr ptr, ptr %119, i32 %125
  %130 = getelementptr ptr, ptr %129, i32 1
  %131 = load ptr, ptr %130, align 8
  %132 = call ptr @behavior_wrapper(ptr %131, { ptr, ptr, ptr, i32 } %126, ptr %6)
  %133 = call { ptr, i160 } %132({ ptr, ptr, ptr, i32 } %126, { ptr, ptr, ptr, i32 } %126, ptr %5)
  store { ptr, i160 } %133, ptr %7, align 8
  store i8 0, ptr %8, align 1
  %134 = load ptr, ptr %7, align 8
  %135 = ptrtoint ptr %134 to i64
  %136 = icmp eq i64 %135, ptrtoint (ptr @nil_typ to i64)
  %137 = icmp eq i64 %135, 0
  %138 = or i1 %136, %137
  %139 = zext i1 %138 to i8
  store i8 %139, ptr %9, align 1
  %140 = load i8, ptr %8, align 1
  %141 = trunc i8 %140 to i1
  %142 = load i8, ptr %9, align 1
  %143 = trunc i8 %142 to i1
  %144 = icmp eq i1 %141, %143
  %145 = zext i1 %144 to i8
  store i8 %145, ptr %10, align 1
  %146 = load i8, ptr %10, align 1
  %147 = trunc i8 %146 to i1
  br i1 %147, label %148, label %182

148:                                              ; preds = %118
  %149 = getelementptr { ptr, i160 }, ptr %7, i32 0, i32 0
  %150 = getelementptr { ptr, i160 }, ptr %11, i32 0, i32 0
  %151 = load ptr, ptr %149, align 8
  store ptr %151, ptr %150, align 8
  %152 = getelementptr { ptr, i160 }, ptr %7, i32 0, i32 1
  %153 = getelementptr { ptr, i160 }, ptr %11, i32 0, i32 1
  %154 = load i160, ptr %152, align 4
  store i160 %154, ptr %153, align 4
  %155 = load ptr, ptr %11, align 8
  %156 = call i32 @get_offset(ptr %155, ptr @Character)
  %157 = getelementptr { ptr, ptr, ptr, i32 }, ptr %11, i32 0, i32 3
  store i32 %156, ptr %157, align 4
  %158 = getelementptr { ptr, ptr, ptr, i32 }, ptr %11, i32 0, i32 0
  %159 = load ptr, ptr %158, align 8
  %160 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %159, 0
  %161 = getelementptr { ptr, ptr, ptr, i32 }, ptr %11, i32 0, i32 1
  %162 = load ptr, ptr %161, align 8
  %163 = insertvalue { ptr, ptr, ptr, i32 } %160, ptr %162, 1
  %164 = getelementptr { ptr, ptr, ptr, i32 }, ptr %11, i32 0, i32 2
  %165 = load ptr, ptr %164, align 8
  %166 = insertvalue { ptr, ptr, ptr, i32 } %163, ptr %165, 2
  %167 = load i32, ptr %157, align 4
  %168 = insertvalue { ptr, ptr, ptr, i32 } %166, i32 %167, 3
  %169 = call ptr @llvm.invariant.start.p0(i64 0, ptr %12)
  %170 = call ptr @llvm.invariant.start.p0(i64 88, ptr %159)
  %171 = getelementptr ptr, ptr %159, i32 %167
  %172 = getelementptr ptr, ptr %171, i32 5
  %173 = load ptr, ptr %172, align 8
  %174 = call ptr @behavior_wrapper(ptr %173, { ptr, ptr, ptr, i32 } %168, ptr %13)
  %175 = call i32 %174({ ptr, ptr, ptr, i32 } %168, { ptr, ptr, ptr, i32 } %168, ptr %12)
  store i32 %175, ptr %14, align 4
  %176 = load i32, ptr %74, align 4
  %177 = load i32, ptr %14, align 4
  %178 = add i32 %176, %177
  store i32 %178, ptr %15, align 4
  %179 = load ptr, ptr %150, align 8
  store ptr %179, ptr %149, align 8
  %180 = load i160, ptr %153, align 4
  store i160 %180, ptr %152, align 4
  %181 = load i32, ptr %15, align 4
  store i32 %181, ptr %74, align 4
  br label %182

182:                                              ; preds = %148, %118
  br i1 %147, label %118, label %183

183:                                              ; preds = %182
  %184 = load ptr, ptr %53, align 8
  %185 = load ptr, ptr %48, align 8
  %186 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %185)
  %187 = load i32, ptr %59, align 4
  %188 = getelementptr ptr, ptr %185, i32 %187
  %189 = getelementptr ptr, ptr %188, i32 1
  %190 = load ptr, ptr %189, align 8
  %191 = getelementptr { ptr, ptr }, ptr %190, i32 0, i32 0
  %192 = load ptr, ptr %191, align 8
  %193 = call i32 %192(ptr %184) #1
  store i32 %193, ptr %16, align 4
  %194 = load i32, ptr %16, align 4
  %195 = load i32, ptr %74, align 4
  %196 = add i32 %194, %195
  store i32 %196, ptr %17, align 4
  %197 = load i32, ptr %17, align 4
  %198 = load ptr, ptr %50, align 8
  %199 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %198, 0
  %200 = load ptr, ptr %53, align 8
  %201 = insertvalue { ptr, ptr, ptr, i32 } %199, ptr %200, 1
  %202 = load ptr, ptr %56, align 8
  %203 = insertvalue { ptr, ptr, ptr, i32 } %201, ptr %202, 2
  %204 = load i32, ptr %59, align 4
  %205 = insertvalue { ptr, ptr, ptr, i32 } %203, i32 %204, 3
  %206 = getelementptr [1 x ptr], ptr %18, i32 0, i32 0
  store ptr @_parameterization_i32, ptr %206, align 8
  %207 = call ptr @llvm.invariant.start.p0(i64 1, ptr %18)
  %208 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %198)
  %209 = getelementptr ptr, ptr %198, i32 %204
  %210 = getelementptr ptr, ptr %209, i32 15
  %211 = load ptr, ptr %210, align 8
  %212 = getelementptr { ptr }, ptr %19, i32 0, i32 0
  store ptr @i32_typ, ptr %212, align 8
  %213 = call ptr @behavior_wrapper(ptr %211, { ptr, ptr, ptr, i32 } %205, ptr %19)
  call void %213({ ptr, ptr, ptr, i32 } %205, { ptr, ptr, ptr, i32 } %205, ptr %18, i32 %197)
  %214 = load ptr, ptr %75, align 8
  %215 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %214, 0
  %216 = load ptr, ptr %78, align 8
  %217 = insertvalue { ptr, ptr, ptr, i32 } %215, ptr %216, 1
  %218 = load ptr, ptr %81, align 8
  %219 = insertvalue { ptr, ptr, ptr, i32 } %217, ptr %218, 2
  %220 = load i32, ptr %73, align 4
  %221 = insertvalue { ptr, ptr, ptr, i32 } %219, i32 %220, 3
  %222 = call ptr @llvm.invariant.start.p0(i64 0, ptr %20)
  %223 = call ptr @llvm.invariant.start.p0(i64 472, ptr %214)
  %224 = getelementptr ptr, ptr %214, i32 %220
  %225 = getelementptr ptr, ptr %224, i32 3
  %226 = load ptr, ptr %225, align 8
  %227 = call ptr @behavior_wrapper(ptr %226, { ptr, ptr, ptr, i32 } %221, ptr %21)
  %228 = call { ptr, ptr, ptr, i32 } %227({ ptr, ptr, ptr, i32 } %221, { ptr, ptr, ptr, i32 } %221, ptr %20)
  store { ptr, ptr, ptr, i32 } %228, ptr %22, align 8
  %229 = getelementptr { ptr, ptr, ptr, i32 }, ptr %22, i32 0, i32 0
  %230 = load ptr, ptr %229, align 8
  store ptr %230, ptr %26, align 8
  %231 = getelementptr { ptr, ptr, ptr, i32 }, ptr %22, i32 0, i32 1
  %232 = load ptr, ptr %231, align 8
  store ptr %232, ptr %25, align 8
  %233 = getelementptr { ptr, ptr, ptr, i32 }, ptr %22, i32 0, i32 2
  %234 = load ptr, ptr %233, align 8
  store ptr %234, ptr %24, align 8
  %235 = getelementptr { ptr, ptr, ptr, i32 }, ptr %22, i32 0, i32 3
  %236 = load i32, ptr %235, align 4
  store i32 %236, ptr %23, align 4
  %237 = load ptr, ptr %26, align 8
  %238 = call i32 @get_offset(ptr %237, ptr @Iterator)
  store i32 %238, ptr %23, align 4
  %239 = load ptr, ptr %26, align 8
  store ptr %239, ptr %30, align 8
  %240 = load ptr, ptr %25, align 8
  store ptr %240, ptr %29, align 8
  %241 = load ptr, ptr %24, align 8
  store ptr %241, ptr %28, align 8
  %242 = load i32, ptr %23, align 4
  store i32 %242, ptr %27, align 4
  br label %243

243:                                              ; preds = %325, %183
  %244 = load ptr, ptr %30, align 8
  %245 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %244, 0
  %246 = load ptr, ptr %29, align 8
  %247 = insertvalue { ptr, ptr, ptr, i32 } %245, ptr %246, 1
  %248 = load ptr, ptr %28, align 8
  %249 = insertvalue { ptr, ptr, ptr, i32 } %247, ptr %248, 2
  %250 = load i32, ptr %27, align 4
  %251 = insertvalue { ptr, ptr, ptr, i32 } %249, i32 %250, 3
  %252 = call ptr @llvm.invariant.start.p0(i64 0, ptr %31)
  %253 = call ptr @llvm.invariant.start.p0(i64 24, ptr %244)
  %254 = getelementptr ptr, ptr %244, i32 %250
  %255 = getelementptr ptr, ptr %254, i32 1
  %256 = load ptr, ptr %255, align 8
  %257 = call ptr @behavior_wrapper(ptr %256, { ptr, ptr, ptr, i32 } %251, ptr %32)
  %258 = call { ptr, i160 } %257({ ptr, ptr, ptr, i32 } %251, { ptr, ptr, ptr, i32 } %251, ptr %31)
  store { ptr, i160 } %258, ptr %33, align 8
  store i8 0, ptr %34, align 1
  %259 = load ptr, ptr %33, align 8
  %260 = ptrtoint ptr %259 to i64
  %261 = icmp eq i64 %260, ptrtoint (ptr @nil_typ to i64)
  %262 = icmp eq i64 %260, 0
  %263 = or i1 %261, %262
  %264 = zext i1 %263 to i8
  store i8 %264, ptr %35, align 1
  %265 = load i8, ptr %34, align 1
  %266 = trunc i8 %265 to i1
  %267 = load i8, ptr %35, align 1
  %268 = trunc i8 %267 to i1
  %269 = icmp eq i1 %266, %268
  %270 = zext i1 %269 to i8
  store i8 %270, ptr %36, align 1
  %271 = load i8, ptr %36, align 1
  %272 = trunc i8 %271 to i1
  br i1 %272, label %273, label %325

273:                                              ; preds = %243
  %274 = getelementptr { ptr, i160 }, ptr %33, i32 0, i32 0
  %275 = getelementptr { ptr, i160 }, ptr %37, i32 0, i32 0
  %276 = load ptr, ptr %274, align 8
  store ptr %276, ptr %275, align 8
  %277 = getelementptr { ptr, i160 }, ptr %33, i32 0, i32 1
  %278 = getelementptr { ptr, i160 }, ptr %37, i32 0, i32 1
  %279 = load i160, ptr %277, align 4
  store i160 %279, ptr %278, align 4
  %280 = load ptr, ptr %37, align 8
  %281 = call i32 @get_offset(ptr %280, ptr @Character)
  %282 = getelementptr { ptr, ptr, ptr, i32 }, ptr %37, i32 0, i32 3
  store i32 %281, ptr %282, align 4
  %283 = getelementptr { ptr, ptr, ptr, i32 }, ptr %37, i32 0, i32 0
  %284 = load ptr, ptr %283, align 8
  store ptr %284, ptr %39, align 8
  %285 = getelementptr { ptr, ptr, ptr, i32 }, ptr %37, i32 0, i32 1
  %286 = load ptr, ptr %285, align 8
  store ptr %286, ptr %38, align 8
  %287 = getelementptr { ptr, ptr, ptr, i32 }, ptr %37, i32 0, i32 2
  %288 = getelementptr i8, ptr %38, i32 8
  %289 = load ptr, ptr %287, align 8
  store ptr %289, ptr %288, align 8
  %290 = getelementptr i8, ptr %38, i32 16
  %291 = load i32, ptr %282, align 4
  store i32 %291, ptr %290, align 4
  %292 = load ptr, ptr %39, align 8
  %293 = insertvalue { ptr, i160 } undef, ptr %292, 0
  %294 = load i160, ptr %38, align 4
  %295 = insertvalue { ptr, i160 } %293, i160 %294, 1
  %296 = load ptr, ptr %50, align 8
  %297 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %296, 0
  %298 = load ptr, ptr %53, align 8
  %299 = insertvalue { ptr, ptr, ptr, i32 } %297, ptr %298, 1
  %300 = load ptr, ptr %56, align 8
  %301 = insertvalue { ptr, ptr, ptr, i32 } %299, ptr %300, 2
  %302 = load i32, ptr %59, align 4
  %303 = insertvalue { ptr, ptr, ptr, i32 } %301, i32 %302, 3
  %304 = getelementptr [1 x ptr], ptr %40, i32 0, i32 0
  store ptr @_parameterization_Character, ptr %304, align 8
  %305 = call ptr @llvm.invariant.start.p0(i64 1, ptr %40)
  %306 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %296)
  %307 = getelementptr ptr, ptr %296, i32 %302
  %308 = getelementptr ptr, ptr %307, i32 23
  %309 = load ptr, ptr %308, align 8
  %310 = getelementptr { ptr }, ptr %41, i32 0, i32 0
  store ptr %292, ptr %310, align 8
  %311 = call ptr @behavior_wrapper(ptr %309, { ptr, ptr, ptr, i32 } %303, ptr %41)
  %312 = call { ptr, ptr, ptr, i32 } %311({ ptr, ptr, ptr, i32 } %303, { ptr, ptr, ptr, i32 } %303, ptr %40, { ptr, i160 } %295)
  store { ptr, ptr, ptr, i32 } %312, ptr %42, align 8
  %313 = getelementptr { ptr, ptr, ptr, i32 }, ptr %42, i32 0, i32 0
  %314 = load ptr, ptr %313, align 8
  store ptr %314, ptr %44, align 8
  %315 = getelementptr { ptr, ptr, ptr, i32 }, ptr %42, i32 0, i32 1
  %316 = load ptr, ptr %315, align 8
  store ptr %316, ptr %46, align 8
  %317 = getelementptr { ptr, ptr, ptr, i32 }, ptr %42, i32 0, i32 2
  %318 = load ptr, ptr %317, align 8
  store ptr %318, ptr %45, align 8
  %319 = getelementptr { ptr, ptr, ptr, i32 }, ptr %42, i32 0, i32 3
  %320 = load i32, ptr %319, align 4
  store i32 %320, ptr %43, align 4
  %321 = load ptr, ptr %44, align 8
  %322 = call i32 @get_offset(ptr %321, ptr @String)
  store i32 %322, ptr %43, align 4
  %323 = load ptr, ptr %275, align 8
  store ptr %323, ptr %274, align 8
  %324 = load i160, ptr %278, align 4
  store i160 %324, ptr %277, align 4
  br label %325

325:                                              ; preds = %273, %243
  br i1 %272, label %243, label %326

326:                                              ; preds = %325
  %327 = getelementptr { ptr, i160 }, ptr %48, i32 0, i32 0
  %328 = load ptr, ptr %327, align 8
  %329 = insertvalue { ptr, i160 } undef, ptr %328, 0
  %330 = getelementptr { ptr, i160 }, ptr %48, i32 0, i32 1
  %331 = load i160, ptr %330, align 4
  %332 = insertvalue { ptr, i160 } %329, i160 %331, 1
  ret { ptr, i160 } %332
}

declare { ptr, i160 } @List_extend_otherIterableT({ ptr, i160 })

define { ptr, i160 } @String_extend_otherString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, i160 } %3) {
  %5 = alloca [0 x ptr], align 8
  %6 = alloca {}, align 8
  %7 = alloca { ptr, i160 }, align 8
  %8 = alloca i32, align 4
  %9 = alloca ptr, align 8
  %10 = alloca i1, align 1
  %11 = alloca i1, align 1
  %12 = alloca i1, align 1
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %15 = alloca [1 x ptr], align 8
  %16 = alloca { ptr }, align 8
  %17 = alloca i8, align 1
  %18 = alloca [2 x ptr], align 8
  %19 = alloca { ptr, ptr }, align 8
  %20 = alloca i32, align 4
  %21 = alloca ptr, align 8
  %22 = alloca i32, align 4
  %23 = alloca [0 x ptr], align 8
  %24 = alloca {}, align 8
  %25 = alloca i32, align 4
  %26 = alloca i32, align 4
  %27 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %27, align 8
  %28 = alloca { ptr, ptr, ptr, i32 }, align 8
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 0
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %28, i32 0, i32 0
  %31 = load ptr, ptr %29, align 8
  store ptr %31, ptr %30, align 8
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 1
  %33 = getelementptr { ptr, ptr, ptr, i32 }, ptr %28, i32 0, i32 1
  %34 = load ptr, ptr %32, align 8
  store ptr %34, ptr %33, align 8
  %35 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 2
  %36 = getelementptr { ptr, ptr, ptr, i32 }, ptr %28, i32 0, i32 2
  %37 = load ptr, ptr %35, align 8
  store ptr %37, ptr %36, align 8
  %38 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 3
  %39 = getelementptr { ptr, ptr, ptr, i32 }, ptr %28, i32 0, i32 3
  %40 = load i32, ptr %38, align 4
  store i32 %40, ptr %39, align 4
  %41 = load ptr, ptr %28, align 8
  %42 = call i32 @get_offset(ptr %41, ptr @String)
  store i32 %42, ptr %39, align 4
  %43 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %3, ptr %43, align 8
  %44 = alloca { ptr, ptr, ptr, i32 }, align 8
  %45 = getelementptr { ptr, i160 }, ptr %43, i32 0, i32 0
  %46 = getelementptr { ptr, i160 }, ptr %44, i32 0, i32 0
  %47 = load ptr, ptr %45, align 8
  store ptr %47, ptr %46, align 8
  %48 = getelementptr { ptr, i160 }, ptr %43, i32 0, i32 1
  %49 = getelementptr { ptr, i160 }, ptr %44, i32 0, i32 1
  %50 = load i160, ptr %48, align 4
  store i160 %50, ptr %49, align 4
  %51 = load ptr, ptr %44, align 8
  %52 = call i32 @get_offset(ptr %51, ptr @String)
  %53 = getelementptr { ptr, ptr, ptr, i32 }, ptr %44, i32 0, i32 3
  store i32 %52, ptr %53, align 4
  %54 = getelementptr { ptr, ptr, ptr, i32 }, ptr %44, i32 0, i32 0
  %55 = load ptr, ptr %54, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %55, 0
  %57 = getelementptr { ptr, ptr, ptr, i32 }, ptr %44, i32 0, i32 1
  %58 = load ptr, ptr %57, align 8
  %59 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %58, 1
  %60 = getelementptr { ptr, ptr, ptr, i32 }, ptr %44, i32 0, i32 2
  %61 = load ptr, ptr %60, align 8
  %62 = insertvalue { ptr, ptr, ptr, i32 } %59, ptr %61, 2
  %63 = load i32, ptr %53, align 4
  %64 = insertvalue { ptr, ptr, ptr, i32 } %62, i32 %63, 3
  %65 = alloca [0 x ptr], align 8
  %66 = call ptr @llvm.invariant.start.p0(i64 0, ptr %65)
  %67 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %55)
  %68 = getelementptr ptr, ptr %55, i32 %63
  %69 = getelementptr ptr, ptr %68, i32 5
  %70 = load ptr, ptr %69, align 8
  %71 = alloca {}, align 8
  %72 = call ptr @behavior_wrapper(ptr %70, { ptr, ptr, ptr, i32 } %64, ptr %71)
  %73 = call i32 %72({ ptr, ptr, ptr, i32 } %64, { ptr, ptr, ptr, i32 } %64, ptr %65)
  %74 = alloca i32, align 4
  store i32 %73, ptr %74, align 4
  %75 = load ptr, ptr %33, align 8
  %76 = load ptr, ptr %28, align 8
  %77 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %76)
  %78 = load i32, ptr %39, align 4
  %79 = getelementptr ptr, ptr %76, i32 %78
  %80 = getelementptr ptr, ptr %79, i32 1
  %81 = load ptr, ptr %80, align 8
  %82 = getelementptr { ptr, ptr }, ptr %81, i32 0, i32 0
  %83 = load ptr, ptr %82, align 8
  %84 = call i32 %83(ptr %75) #1
  %85 = alloca i32, align 4
  store i32 %84, ptr %85, align 4
  %86 = alloca i32, align 4
  %87 = load i32, ptr %85, align 4
  store i32 %87, ptr %86, align 4
  %88 = load i32, ptr %86, align 4
  %89 = load i32, ptr %74, align 4
  %90 = add i32 %88, %89
  %91 = alloca i32, align 4
  store i32 %90, ptr %91, align 4
  %92 = load i32, ptr %91, align 4
  %93 = load ptr, ptr %30, align 8
  %94 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %93, 0
  %95 = load ptr, ptr %33, align 8
  %96 = insertvalue { ptr, ptr, ptr, i32 } %94, ptr %95, 1
  %97 = load ptr, ptr %36, align 8
  %98 = insertvalue { ptr, ptr, ptr, i32 } %96, ptr %97, 2
  %99 = load i32, ptr %39, align 4
  %100 = insertvalue { ptr, ptr, ptr, i32 } %98, i32 %99, 3
  %101 = alloca [1 x ptr], align 8
  %102 = getelementptr [1 x ptr], ptr %101, i32 0, i32 0
  store ptr @_parameterization_i32, ptr %102, align 8
  %103 = call ptr @llvm.invariant.start.p0(i64 1, ptr %101)
  %104 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %93)
  %105 = getelementptr ptr, ptr %93, i32 %99
  %106 = getelementptr ptr, ptr %105, i32 15
  %107 = load ptr, ptr %106, align 8
  %108 = alloca { ptr }, align 8
  %109 = getelementptr { ptr }, ptr %108, i32 0, i32 0
  store ptr @i32_typ, ptr %109, align 8
  %110 = call ptr @behavior_wrapper(ptr %107, { ptr, ptr, ptr, i32 } %100, ptr %108)
  call void %110({ ptr, ptr, ptr, i32 } %100, { ptr, ptr, ptr, i32 } %100, ptr %101, i32 %92)
  %111 = alloca i32, align 4
  store i32 0, ptr %111, align 4
  %112 = alloca i32, align 4
  store i32 1, ptr %112, align 4
  %113 = load i32, ptr %74, align 4
  %114 = load i32, ptr %112, align 4
  %115 = sub i32 %113, %114
  %116 = alloca i32, align 4
  store i32 %115, ptr %116, align 4
  %117 = alloca [1 x ptr], align 8
  store ptr @Range, ptr %117, align 8
  %118 = load ptr, ptr %117, align 8
  %119 = getelementptr ptr, ptr %118, i32 6
  %120 = load ptr, ptr %119, align 8
  %121 = call { i64, i64 } @size_wrapper(ptr %120, ptr %117)
  %122 = extractvalue { i64, i64 } %121, 0
  %123 = call ptr @bump_malloc(i64 %122)
  %124 = alloca i32, align 4
  %125 = alloca ptr, align 8
  %126 = alloca ptr, align 8
  %127 = alloca ptr, align 8
  store ptr @Range, ptr %127, align 8
  store ptr %123, ptr %126, align 8
  store i32 10, ptr %124, align 4
  %128 = alloca i32, align 4
  store i32 0, ptr %128, align 4
  %129 = alloca i32, align 4
  store i32 1, ptr %129, align 4
  %130 = load i32, ptr %74, align 4
  %131 = load i32, ptr %129, align 4
  %132 = sub i32 %130, %131
  %133 = alloca i32, align 4
  store i32 %132, ptr %133, align 4
  %134 = load i32, ptr %128, align 4
  %135 = load i32, ptr %133, align 4
  %136 = load ptr, ptr %127, align 8
  %137 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %136, 0
  %138 = load ptr, ptr %126, align 8
  %139 = insertvalue { ptr, ptr, ptr, i32 } %137, ptr %138, 1
  %140 = load ptr, ptr %125, align 8
  %141 = insertvalue { ptr, ptr, ptr, i32 } %139, ptr %140, 2
  %142 = load i32, ptr %124, align 4
  %143 = insertvalue { ptr, ptr, ptr, i32 } %141, i32 %142, 3
  %144 = alloca [2 x ptr], align 8
  %145 = getelementptr [2 x ptr], ptr %144, i32 0, i32 0
  store ptr @_parameterization_i32, ptr %145, align 8
  %146 = getelementptr [2 x ptr], ptr %144, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %146, align 8
  %147 = call ptr @llvm.invariant.start.p0(i64 4, ptr %144)
  %148 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %136)
  %149 = getelementptr ptr, ptr %136, i32 %142
  %150 = getelementptr ptr, ptr %149, i32 5
  %151 = load ptr, ptr %150, align 8
  %152 = alloca { ptr, ptr }, align 8
  %153 = getelementptr { ptr, ptr }, ptr %152, i32 0, i32 0
  store ptr @i32_typ, ptr %153, align 8
  %154 = getelementptr { ptr, ptr }, ptr %152, i32 0, i32 1
  store ptr @i32_typ, ptr %154, align 8
  %155 = call ptr @behavior_wrapper(ptr %151, { ptr, ptr, ptr, i32 } %143, ptr %152)
  call void %155({ ptr, ptr, ptr, i32 } %143, { ptr, ptr, ptr, i32 } %143, ptr %144, i32 %134, i32 %135)
  %156 = load ptr, ptr %127, align 8
  %157 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %156, 0
  %158 = load ptr, ptr %126, align 8
  %159 = insertvalue { ptr, ptr, ptr, i32 } %157, ptr %158, 1
  %160 = load ptr, ptr %125, align 8
  %161 = insertvalue { ptr, ptr, ptr, i32 } %159, ptr %160, 2
  %162 = load i32, ptr %124, align 4
  %163 = insertvalue { ptr, ptr, ptr, i32 } %161, i32 %162, 3
  %164 = alloca [0 x ptr], align 8
  %165 = call ptr @llvm.invariant.start.p0(i64 0, ptr %164)
  %166 = call ptr @llvm.invariant.start.p0(i64 1016, ptr %156)
  %167 = getelementptr ptr, ptr %156, i32 %162
  %168 = getelementptr ptr, ptr %167, i32 9
  %169 = load ptr, ptr %168, align 8
  %170 = alloca {}, align 8
  %171 = call ptr @behavior_wrapper(ptr %169, { ptr, ptr, ptr, i32 } %163, ptr %170)
  %172 = call { ptr, ptr, ptr, i32 } %171({ ptr, ptr, ptr, i32 } %163, { ptr, ptr, ptr, i32 } %163, ptr %164)
  %173 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %172, ptr %173, align 8
  %174 = alloca i32, align 4
  %175 = alloca ptr, align 8
  %176 = alloca ptr, align 8
  %177 = alloca ptr, align 8
  %178 = getelementptr { ptr, ptr, ptr, i32 }, ptr %173, i32 0, i32 0
  %179 = load ptr, ptr %178, align 8
  store ptr %179, ptr %177, align 8
  %180 = getelementptr { ptr, ptr, ptr, i32 }, ptr %173, i32 0, i32 1
  %181 = load ptr, ptr %180, align 8
  store ptr %181, ptr %176, align 8
  %182 = getelementptr { ptr, ptr, ptr, i32 }, ptr %173, i32 0, i32 2
  %183 = load ptr, ptr %182, align 8
  store ptr %183, ptr %175, align 8
  %184 = getelementptr { ptr, ptr, ptr, i32 }, ptr %173, i32 0, i32 3
  %185 = load i32, ptr %184, align 4
  store i32 %185, ptr %174, align 4
  %186 = load ptr, ptr %177, align 8
  %187 = call i32 @get_offset(ptr %186, ptr @RangeIterator)
  store i32 %187, ptr %174, align 4
  %188 = alloca i32, align 4
  %189 = alloca ptr, align 8
  %190 = alloca ptr, align 8
  %191 = alloca ptr, align 8
  %192 = load ptr, ptr %177, align 8
  store ptr %192, ptr %191, align 8
  %193 = load ptr, ptr %176, align 8
  store ptr %193, ptr %190, align 8
  %194 = load ptr, ptr %175, align 8
  store ptr %194, ptr %189, align 8
  %195 = load i32, ptr %174, align 4
  store i32 %195, ptr %188, align 4
  %196 = getelementptr { ptr, i32 }, ptr %7, i32 0, i32 0
  %197 = getelementptr { ptr, i32 }, ptr %7, i32 0, i32 1
  br label %198

198:                                              ; preds = %276, %4
  %199 = load ptr, ptr %191, align 8
  %200 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %199, 0
  %201 = load ptr, ptr %190, align 8
  %202 = insertvalue { ptr, ptr, ptr, i32 } %200, ptr %201, 1
  %203 = load ptr, ptr %189, align 8
  %204 = insertvalue { ptr, ptr, ptr, i32 } %202, ptr %203, 2
  %205 = load i32, ptr %188, align 4
  %206 = insertvalue { ptr, ptr, ptr, i32 } %204, i32 %205, 3
  %207 = call ptr @llvm.invariant.start.p0(i64 0, ptr %5)
  %208 = call ptr @llvm.invariant.start.p0(i64 88, ptr %199)
  %209 = getelementptr ptr, ptr %199, i32 %205
  %210 = getelementptr ptr, ptr %209, i32 5
  %211 = load ptr, ptr %210, align 8
  %212 = call ptr @behavior_wrapper(ptr %211, { ptr, ptr, ptr, i32 } %206, ptr %6)
  %213 = call { ptr, i160 } %212({ ptr, ptr, ptr, i32 } %206, { ptr, ptr, ptr, i32 } %206, ptr %5)
  store { ptr, i160 } %213, ptr %7, align 8
  %214 = load ptr, ptr %196, align 8
  store ptr %214, ptr %9, align 8
  %215 = load i32, ptr %197, align 4
  store i32 %215, ptr %8, align 4
  store i8 0, ptr %10, align 1
  %216 = load ptr, ptr %9, align 8
  %217 = ptrtoint ptr %216 to i64
  %218 = icmp eq i64 %217, ptrtoint (ptr @nil_typ to i64)
  %219 = icmp eq i64 %217, 0
  %220 = or i1 %218, %219
  %221 = zext i1 %220 to i8
  store i8 %221, ptr %11, align 1
  %222 = load i8, ptr %10, align 1
  %223 = trunc i8 %222 to i1
  %224 = load i8, ptr %11, align 1
  %225 = trunc i8 %224 to i1
  %226 = icmp eq i1 %223, %225
  %227 = zext i1 %226 to i8
  store i8 %227, ptr %12, align 1
  %228 = load i8, ptr %12, align 1
  %229 = trunc i8 %228 to i1
  br i1 %229, label %230, label %276

230:                                              ; preds = %198
  %231 = load i32, ptr %8, align 4
  store i32 %231, ptr %13, align 4
  %232 = load i32, ptr %13, align 4
  %233 = load i32, ptr %86, align 4
  %234 = add i32 %232, %233
  store i32 %234, ptr %14, align 4
  %235 = load i32, ptr %13, align 4
  %236 = load ptr, ptr %54, align 8
  %237 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %236, 0
  %238 = load ptr, ptr %57, align 8
  %239 = insertvalue { ptr, ptr, ptr, i32 } %237, ptr %238, 1
  %240 = load ptr, ptr %60, align 8
  %241 = insertvalue { ptr, ptr, ptr, i32 } %239, ptr %240, 2
  %242 = load i32, ptr %53, align 4
  %243 = insertvalue { ptr, ptr, ptr, i32 } %241, i32 %242, 3
  %244 = getelementptr [1 x ptr], ptr %15, i32 0, i32 0
  store ptr @_parameterization_i32, ptr %244, align 8
  %245 = call ptr @llvm.invariant.start.p0(i64 1, ptr %15)
  %246 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %236)
  %247 = getelementptr ptr, ptr %236, i32 %242
  %248 = getelementptr ptr, ptr %247, i32 18
  %249 = load ptr, ptr %248, align 8
  %250 = getelementptr { ptr }, ptr %16, i32 0, i32 0
  store ptr @i32_typ, ptr %250, align 8
  %251 = call ptr @behavior_wrapper(ptr %249, { ptr, ptr, ptr, i32 } %243, ptr %16)
  %252 = call i8 %251({ ptr, ptr, ptr, i32 } %243, { ptr, ptr, ptr, i32 } %243, ptr %15, i32 %235)
  store i8 %252, ptr %17, align 1
  %253 = load i32, ptr %14, align 4
  %254 = load i8, ptr %17, align 1
  %255 = load ptr, ptr %30, align 8
  %256 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %255, 0
  %257 = load ptr, ptr %33, align 8
  %258 = insertvalue { ptr, ptr, ptr, i32 } %256, ptr %257, 1
  %259 = load ptr, ptr %36, align 8
  %260 = insertvalue { ptr, ptr, ptr, i32 } %258, ptr %259, 2
  %261 = load i32, ptr %39, align 4
  %262 = insertvalue { ptr, ptr, ptr, i32 } %260, i32 %261, 3
  %263 = getelementptr [2 x ptr], ptr %18, i32 0, i32 0
  store ptr @_parameterization_i32, ptr %263, align 8
  %264 = getelementptr [2 x ptr], ptr %18, i32 0, i32 1
  store ptr @_parameterization_i8, ptr %264, align 8
  %265 = call ptr @llvm.invariant.start.p0(i64 4, ptr %18)
  %266 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %255)
  %267 = getelementptr ptr, ptr %255, i32 %261
  %268 = getelementptr ptr, ptr %267, i32 19
  %269 = load ptr, ptr %268, align 8
  %270 = getelementptr { ptr, ptr }, ptr %19, i32 0, i32 0
  store ptr @i32_typ, ptr %270, align 8
  %271 = getelementptr { ptr, ptr }, ptr %19, i32 0, i32 1
  store ptr @i8_typ, ptr %271, align 8
  %272 = call ptr @behavior_wrapper(ptr %269, { ptr, ptr, ptr, i32 } %262, ptr %19)
  call void %272({ ptr, ptr, ptr, i32 } %262, { ptr, ptr, ptr, i32 } %262, ptr %18, i32 %253, i8 %254)
  %273 = load i32, ptr %13, align 4
  store i32 %273, ptr %20, align 4
  store ptr @i32_typ, ptr %21, align 8
  %274 = load ptr, ptr %21, align 8
  store ptr %274, ptr %9, align 8
  %275 = load i32, ptr %20, align 4
  store i32 %275, ptr %8, align 4
  br label %276

276:                                              ; preds = %230, %198
  br i1 %229, label %198, label %277

277:                                              ; preds = %276
  %278 = load ptr, ptr %33, align 8
  %279 = load ptr, ptr %28, align 8
  %280 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %279)
  %281 = load i32, ptr %39, align 4
  %282 = getelementptr ptr, ptr %279, i32 %281
  %283 = getelementptr ptr, ptr %282, i32 1
  %284 = load ptr, ptr %283, align 8
  %285 = getelementptr { ptr, ptr }, ptr %284, i32 0, i32 1
  %286 = load ptr, ptr %285, align 8
  %287 = load i32, ptr %91, align 4
  call void %286(ptr %278, i32 %287) #2
  %288 = load ptr, ptr %33, align 8
  %289 = load ptr, ptr %28, align 8
  %290 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %289)
  %291 = load i32, ptr %39, align 4
  %292 = getelementptr ptr, ptr %289, i32 %291
  %293 = getelementptr ptr, ptr %292, i32 2
  %294 = load ptr, ptr %293, align 8
  %295 = getelementptr { ptr, ptr }, ptr %294, i32 0, i32 0
  %296 = load ptr, ptr %295, align 8
  %297 = call i32 %296(ptr %288) #1
  store i32 %297, ptr %22, align 4
  %298 = load ptr, ptr %54, align 8
  %299 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %298, 0
  %300 = load ptr, ptr %57, align 8
  %301 = insertvalue { ptr, ptr, ptr, i32 } %299, ptr %300, 1
  %302 = load ptr, ptr %60, align 8
  %303 = insertvalue { ptr, ptr, ptr, i32 } %301, ptr %302, 2
  %304 = load i32, ptr %53, align 4
  %305 = insertvalue { ptr, ptr, ptr, i32 } %303, i32 %304, 3
  %306 = call ptr @llvm.invariant.start.p0(i64 0, ptr %23)
  %307 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %298)
  %308 = getelementptr ptr, ptr %298, i32 %304
  %309 = getelementptr ptr, ptr %308, i32 30
  %310 = load ptr, ptr %309, align 8
  %311 = call ptr @behavior_wrapper(ptr %310, { ptr, ptr, ptr, i32 } %305, ptr %24)
  %312 = call i32 %311({ ptr, ptr, ptr, i32 } %305, { ptr, ptr, ptr, i32 } %305, ptr %23)
  store i32 %312, ptr %25, align 4
  %313 = load i32, ptr %22, align 4
  %314 = load i32, ptr %25, align 4
  %315 = add i32 %313, %314
  store i32 %315, ptr %26, align 4
  %316 = load ptr, ptr %33, align 8
  %317 = load ptr, ptr %28, align 8
  %318 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %317)
  %319 = load i32, ptr %39, align 4
  %320 = getelementptr ptr, ptr %317, i32 %319
  %321 = getelementptr ptr, ptr %320, i32 2
  %322 = load ptr, ptr %321, align 8
  %323 = getelementptr { ptr, ptr }, ptr %322, i32 0, i32 1
  %324 = load ptr, ptr %323, align 8
  %325 = load i32, ptr %26, align 4
  call void %324(ptr %316, i32 %325) #2
  %326 = getelementptr { ptr, i160 }, ptr %28, i32 0, i32 0
  %327 = load ptr, ptr %326, align 8
  %328 = insertvalue { ptr, i160 } undef, ptr %327, 0
  %329 = getelementptr { ptr, i160 }, ptr %28, i32 0, i32 1
  %330 = load i160, ptr %329, align 4
  %331 = insertvalue { ptr, i160 } %328, i160 %330, 1
  ret { ptr, i160 } %331
}

define ptr @String_B_extend_otherCollectionCharacter_extend_otherIterableT_extend_otherString({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = alloca i1, align 1
  %7 = alloca i1, align 1
  %8 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %9 = alloca ptr, align 8
  %10 = load ptr, ptr %1, align 8
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %10, i32 0, i32 0, i32 1
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %10, i32 0, i32 0, i32 2
  %13 = getelementptr { [3 x i64], [3 x ptr] }, ptr %10, i32 0, i32 1, i32 0
  %14 = getelementptr { [3 x i64], [3 x ptr] }, ptr %10, i32 0, i32 1, i32 1
  %15 = load i64, ptr %11, align 4
  %16 = load i64, ptr %12, align 4
  %17 = load ptr, ptr %13, align 8
  %18 = load ptr, ptr %14, align 8
  %19 = load i64, ptr @String, align 4
  %20 = call i1 @subtype_test_wrapper(ptr %17, i64 %16, i64 %15, i64 %19, i64 ptrtoint (ptr @String to i64), ptr %18)
  %21 = zext i1 %20 to i8
  store i8 %21, ptr %3, align 1
  %22 = load i8, ptr %3, align 1
  %23 = trunc i8 %22 to i1
  br i1 %23, label %24, label %26

24:                                               ; preds = %92, %2
  %25 = phi i32 [ %93, %92 ], [ 69, %2 ]
  br label %94

26:                                               ; preds = %2
  %27 = load ptr, ptr %1, align 8
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %27, i32 0, i32 0, i32 1
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %27, i32 0, i32 0, i32 2
  %30 = getelementptr { [3 x i64], [3 x ptr] }, ptr %27, i32 0, i32 1, i32 0
  %31 = getelementptr { [3 x i64], [3 x ptr] }, ptr %27, i32 0, i32 1, i32 1
  %32 = load i64, ptr %28, align 4
  %33 = load i64, ptr %29, align 4
  %34 = load ptr, ptr %30, align 8
  %35 = load ptr, ptr %31, align 8
  %36 = load i64, ptr @Collection, align 4
  %37 = call i1 @subtype_test_wrapper(ptr %34, i64 %33, i64 %32, i64 %36, i64 ptrtoint (ptr @Collection to i64), ptr %35)
  %38 = zext i1 %37 to i8
  store i8 %38, ptr %4, align 1
  %39 = load i8, ptr %4, align 1
  %40 = trunc i8 %39 to i1
  br i1 %40, label %41, label %58

41:                                               ; preds = %26
  %42 = load ptr, ptr %1, align 8
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %42, i32 0, i32 0, i32 1
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %42, i32 0, i32 0, i32 2
  %45 = getelementptr { [3 x i64], [3 x ptr] }, ptr %42, i32 0, i32 1, i32 0
  %46 = getelementptr { [3 x i64], [3 x ptr] }, ptr %42, i32 0, i32 1, i32 1
  %47 = load i64, ptr %43, align 4
  %48 = load i64, ptr %44, align 4
  %49 = load ptr, ptr %45, align 8
  %50 = load ptr, ptr %46, align 8
  %51 = load i64, ptr @String, align 4
  %52 = call i1 @subtype_test_wrapper(ptr %49, i64 %48, i64 %47, i64 %51, i64 ptrtoint (ptr @String to i64), ptr %50)
  %53 = zext i1 %52 to i8
  store i8 %53, ptr %5, align 1
  %54 = load i8, ptr %5, align 1
  %55 = trunc i8 %54 to i1
  %56 = xor i1 %55, true
  %57 = zext i1 %56 to i32
  br label %59

58:                                               ; preds = %26
  br label %59

59:                                               ; preds = %41, %58
  %60 = phi i32 [ 0, %58 ], [ %57, %41 ]
  br label %61

61:                                               ; preds = %59
  %62 = zext i32 %60 to i64
  %63 = trunc i64 %62 to i32
  switch i32 %63, label %92 [
    i32 0, label %64
  ]

64:                                               ; preds = %61
  %65 = load ptr, ptr %1, align 8
  %66 = getelementptr { [3 x i64], [3 x ptr] }, ptr %65, i32 0, i32 0, i32 1
  %67 = getelementptr { [3 x i64], [3 x ptr] }, ptr %65, i32 0, i32 0, i32 2
  %68 = getelementptr { [3 x i64], [3 x ptr] }, ptr %65, i32 0, i32 1, i32 0
  %69 = getelementptr { [3 x i64], [3 x ptr] }, ptr %65, i32 0, i32 1, i32 1
  %70 = load i64, ptr %66, align 4
  %71 = load i64, ptr %67, align 4
  %72 = load ptr, ptr %68, align 8
  %73 = load ptr, ptr %69, align 8
  %74 = load i64, ptr @Iterable, align 4
  %75 = call i1 @subtype_test_wrapper(ptr %72, i64 %71, i64 %70, i64 %74, i64 ptrtoint (ptr @Iterable to i64), ptr %73)
  %76 = zext i1 %75 to i8
  store i8 %76, ptr %6, align 1
  %77 = load i8, ptr %6, align 1
  %78 = trunc i8 %77 to i1
  br i1 %78, label %79, label %92

79:                                               ; preds = %64
  %80 = load ptr, ptr %1, align 8
  %81 = getelementptr { [3 x i64], [3 x ptr] }, ptr %80, i32 0, i32 0, i32 1
  %82 = getelementptr { [3 x i64], [3 x ptr] }, ptr %80, i32 0, i32 0, i32 2
  %83 = getelementptr { [3 x i64], [3 x ptr] }, ptr %80, i32 0, i32 1, i32 0
  %84 = getelementptr { [3 x i64], [3 x ptr] }, ptr %80, i32 0, i32 1, i32 1
  %85 = load i64, ptr %81, align 4
  %86 = load i64, ptr %82, align 4
  %87 = load ptr, ptr %83, align 8
  %88 = load ptr, ptr %84, align 8
  %89 = load i64, ptr @String, align 4
  %90 = call i1 @subtype_test_wrapper(ptr %87, i64 %86, i64 %85, i64 %89, i64 ptrtoint (ptr @String to i64), ptr %88)
  %91 = zext i1 %90 to i8
  store i8 %91, ptr %7, align 1
  br label %92

92:                                               ; preds = %79, %64, %61
  %93 = phi i32 [ 68, %79 ], [ 68, %64 ], [ 67, %61 ]
  br label %24

94:                                               ; preds = %24
  br label %95

95:                                               ; preds = %94
  store i32 %25, ptr %9, align 4
  %96 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %97 = load i32, ptr %9, align 4
  %98 = getelementptr [314 x ptr], ptr %96, i32 0, i32 %97
  %99 = getelementptr ptr, ptr %98, i32 10
  %100 = load ptr, ptr %99, align 8
  ret ptr %100
}

declare { ptr, i160 } @List_get_indexi32(i32)

define ptr @String_B_get_indexi32({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @i32_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 70, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [314 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

declare { ptr, i32 } @List_index_of_targetT_eqFunctionT._T_to_Bool({ ptr, i160 }, { ptr })

define ptr @String_B_index_of_targetT_eqFunctionT._T_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @Character, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @Character to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = ptrtoint ptr %20 to i64
  %22 = icmp eq i64 %21, ptrtoint (ptr @function_typ to i64)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 71, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [314 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define i32 @String_size_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @String)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 2
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr { ptr, ptr }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = call i32 %27(ptr %19) #1
  %29 = alloca i32, align 4
  store i32 %28, ptr %29, align 4
  %30 = load i32, ptr %29, align 4
  ret i32 %30
}

define ptr @String_B_size_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 72, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [314 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

declare i1 @Collection_is_empty_()

define ptr @String_B_is_empty_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 73, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [314 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { ptr, ptr, ptr, i32 } @String_iterator_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %8, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %6, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %8, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @String)
  store i32 %18, ptr %5, align 4
  %19 = alloca [1 x ptr], align 8
  store ptr @StringIterator, ptr %19, align 8
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr ptr, ptr %20, i32 6
  %22 = load ptr, ptr %21, align 8
  %23 = call { i64, i64 } @size_wrapper(ptr %22, ptr %19)
  %24 = extractvalue { i64, i64 } %23, 0
  %25 = call ptr @bump_malloc(i64 %24)
  %26 = alloca i32, align 4
  %27 = alloca ptr, align 8
  %28 = alloca ptr, align 8
  %29 = alloca ptr, align 8
  store ptr @StringIterator, ptr %29, align 8
  store ptr %25, ptr %28, align 8
  store i32 10, ptr %26, align 4
  %30 = alloca i32, align 4
  %31 = alloca ptr, align 8
  %32 = alloca ptr, align 8
  %33 = alloca ptr, align 8
  %34 = load ptr, ptr %8, align 8
  store ptr %34, ptr %33, align 8
  %35 = load ptr, ptr %7, align 8
  store ptr %35, ptr %32, align 8
  %36 = load ptr, ptr %6, align 8
  store ptr %36, ptr %31, align 8
  %37 = load i32, ptr %5, align 4
  store i32 %37, ptr %30, align 4
  %38 = load ptr, ptr %33, align 8
  %39 = call i32 @get_offset(ptr %38, ptr @String)
  store i32 %39, ptr %30, align 4
  %40 = load ptr, ptr %33, align 8
  %41 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %40, 0
  %42 = load ptr, ptr %32, align 8
  %43 = insertvalue { ptr, ptr, ptr, i32 } %41, ptr %42, 1
  %44 = load ptr, ptr %31, align 8
  %45 = insertvalue { ptr, ptr, ptr, i32 } %43, ptr %44, 2
  %46 = load i32, ptr %30, align 4
  %47 = insertvalue { ptr, ptr, ptr, i32 } %45, i32 %46, 3
  %48 = load ptr, ptr %29, align 8
  %49 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %48, 0
  %50 = load ptr, ptr %28, align 8
  %51 = insertvalue { ptr, ptr, ptr, i32 } %49, ptr %50, 1
  %52 = load ptr, ptr %27, align 8
  %53 = insertvalue { ptr, ptr, ptr, i32 } %51, ptr %52, 2
  %54 = load i32, ptr %26, align 4
  %55 = insertvalue { ptr, ptr, ptr, i32 } %53, i32 %54, 3
  %56 = alloca [1 x ptr], align 8
  %57 = getelementptr [1 x ptr], ptr %56, i32 0, i32 0
  store ptr @_parameterization_String, ptr %57, align 8
  %58 = call ptr @llvm.invariant.start.p0(i64 1, ptr %56)
  %59 = call ptr @llvm.invariant.start.p0(i64 128, ptr %48)
  %60 = getelementptr ptr, ptr %48, i32 %54
  %61 = getelementptr ptr, ptr %60, i32 3
  %62 = load ptr, ptr %61, align 8
  %63 = alloca { ptr }, align 8
  %64 = getelementptr { ptr }, ptr %63, i32 0, i32 0
  store ptr %40, ptr %64, align 8
  %65 = call ptr @behavior_wrapper(ptr %62, { ptr, ptr, ptr, i32 } %55, ptr %63)
  call void %65({ ptr, ptr, ptr, i32 } %55, { ptr, ptr, ptr, i32 } %55, ptr %56, { ptr, ptr, ptr, i32 } %47)
  %66 = alloca i32, align 4
  %67 = alloca ptr, align 8
  %68 = alloca ptr, align 8
  %69 = alloca ptr, align 8
  %70 = load ptr, ptr %29, align 8
  store ptr %70, ptr %69, align 8
  %71 = load ptr, ptr %28, align 8
  store ptr %71, ptr %68, align 8
  %72 = load ptr, ptr %27, align 8
  store ptr %72, ptr %67, align 8
  %73 = load i32, ptr %26, align 4
  store i32 %73, ptr %66, align 4
  %74 = load ptr, ptr %69, align 8
  %75 = call i32 @get_offset(ptr %74, ptr @Iterator)
  store i32 %75, ptr %66, align 4
  %76 = load ptr, ptr %69, align 8
  %77 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %76, 0
  %78 = load ptr, ptr %68, align 8
  %79 = insertvalue { ptr, ptr, ptr, i32 } %77, ptr %78, 1
  %80 = load ptr, ptr %67, align 8
  %81 = insertvalue { ptr, ptr, ptr, i32 } %79, ptr %80, 2
  %82 = load i32, ptr %66, align 4
  %83 = insertvalue { ptr, ptr, ptr, i32 } %81, i32 %82, 3
  ret { ptr, ptr, ptr, i32 } %83
}

define ptr @String_B_iterator_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 74, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [314 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

declare void @Iterable_each_fFunctionT_to_Nothing({ ptr })

define ptr @String_B_each_fFunctionT_to_Nothing({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 75, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [314 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

declare { ptr, i160 } @Iterable_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, i160 }, { ptr })

define ptr @String_B_reduce_accumulatorT_fFunctionT._T_to_T({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 1
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 0, i32 2
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 0
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %7, i32 0, i32 1, i32 1
  %12 = load i64, ptr %8, align 4
  %13 = load i64, ptr %9, align 4
  %14 = load ptr, ptr %10, align 8
  %15 = load ptr, ptr %11, align 8
  %16 = load i64, ptr @Character, align 4
  %17 = call i1 @subtype_test_wrapper(ptr %14, i64 %13, i64 %12, i64 %16, i64 ptrtoint (ptr @Character to i64), ptr %15)
  %18 = zext i1 %17 to i8
  store i8 %18, ptr %4, align 1
  %19 = getelementptr ptr, ptr %1, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = ptrtoint ptr %20 to i64
  %22 = icmp eq i64 %21, ptrtoint (ptr @function_typ to i64)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 76, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [314 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

declare i1 @Iterable_all_fFunctionT_to_Bool({ ptr })

define ptr @String_B_all_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 77, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [314 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

declare i1 @Iterable_any_fFunctionT_to_Bool({ ptr })

define ptr @String_B_any_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 78, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [314 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

declare { ptr, ptr, ptr, i32 } @Collection_enumerate_()

define ptr @String_B_enumerate_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 79, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [314 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

declare { ptr, ptr, ptr, i32 } @Iterable_map_fFunctionT_to_U({ ptr })

declare { ptr, ptr, ptr, i32 } @Collection_map_fFunctionT_to_U({ ptr })

define ptr @String_B_map_fFunctionT_to_U_map_fFunctionT_to_U({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = ptrtoint ptr %7 to i64
  %9 = icmp eq i64 %8, ptrtoint (ptr @function_typ to i64)
  %10 = zext i1 %9 to i8
  store i8 %10, ptr %3, align 1
  %11 = load i8, ptr %3, align 1
  %12 = trunc i8 %11 to i1
  %13 = select i1 %12, i32 80, i32 81
  br i1 %12, label %14, label %15

14:                                               ; preds = %2
  br label %20

15:                                               ; preds = %2
  %16 = load ptr, ptr %1, align 8
  %17 = ptrtoint ptr %16 to i64
  %18 = icmp eq i64 %17, ptrtoint (ptr @function_typ to i64)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %4, align 1
  br label %20

20:                                               ; preds = %14, %15
  store i32 %13, ptr %6, align 4
  %21 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %22 = load i32, ptr %6, align 4
  %23 = getelementptr [314 x ptr], ptr %21, i32 0, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 10
  %25 = load ptr, ptr %24, align 8
  ret ptr %25
}

declare { ptr, ptr, ptr, i32 } @Iterable_filter_fFunctionT_to_Bool({ ptr })

define ptr @String_B_filter_fFunctionT_to_Bool({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @function_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 82, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [314 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

declare { ptr, ptr, ptr, i32 } @Collection_chain_otherCollectionT({ ptr, ptr, ptr, i32 })

declare { ptr, ptr, ptr, i32 } @Iterable_chain_otherIterableT({ ptr, ptr, ptr, i32 })

define ptr @String_B_chain_otherCollectionT_chain_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 83, i32 84
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [314 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

declare { ptr, ptr, ptr, i32 } @Collection_interleave_otherCollectionT({ ptr, ptr, ptr, i32 })

declare { ptr, ptr, ptr, i32 } @Iterable_interleave_otherIterableT({ ptr, ptr, ptr, i32 })

define ptr @String_B_interleave_otherCollectionT_interleave_otherIterableT({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 85, i32 86
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [314 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

declare { ptr, ptr, ptr, i32 } @Iterable_zip_otherIterableU({ ptr, ptr, ptr, i32 })

declare { ptr, ptr, ptr, i32 } @Collection_zip_otherCollectionU({ ptr, ptr, ptr, i32 })

define ptr @String_B_zip_otherIterableU_zip_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 88, i32 87
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [314 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

declare { ptr, ptr, ptr, i32 } @Iterable_product_otherIterableU({ ptr, ptr, ptr, i32 })

declare { ptr, ptr, ptr, i32 } @Collection_product_otherCollectionU({ ptr, ptr, ptr, i32 })

define ptr @String_B_product_otherIterableU_product_otherCollectionU({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = alloca i1, align 1
  %6 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %7 = alloca ptr, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 1
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 0, i32 2
  %11 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 0
  %12 = getelementptr { [3 x i64], [3 x ptr] }, ptr %8, i32 0, i32 1, i32 1
  %13 = load i64, ptr %9, align 4
  %14 = load i64, ptr %10, align 4
  %15 = load ptr, ptr %11, align 8
  %16 = load ptr, ptr %12, align 8
  %17 = load i64, ptr @Collection, align 4
  %18 = call i1 @subtype_test_wrapper(ptr %15, i64 %14, i64 %13, i64 %17, i64 ptrtoint (ptr @Collection to i64), ptr %16)
  %19 = zext i1 %18 to i8
  store i8 %19, ptr %3, align 1
  %20 = load i8, ptr %3, align 1
  %21 = trunc i8 %20 to i1
  %22 = select i1 %21, i32 90, i32 89
  br i1 %21, label %23, label %24

23:                                               ; preds = %39, %24, %2
  br label %52

24:                                               ; preds = %2
  %25 = load ptr, ptr %1, align 8
  %26 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 1
  %27 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 0, i32 2
  %28 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 0
  %29 = getelementptr { [3 x i64], [3 x ptr] }, ptr %25, i32 0, i32 1, i32 1
  %30 = load i64, ptr %26, align 4
  %31 = load i64, ptr %27, align 4
  %32 = load ptr, ptr %28, align 8
  %33 = load ptr, ptr %29, align 8
  %34 = load i64, ptr @Iterable, align 4
  %35 = call i1 @subtype_test_wrapper(ptr %32, i64 %31, i64 %30, i64 %34, i64 ptrtoint (ptr @Iterable to i64), ptr %33)
  %36 = zext i1 %35 to i8
  store i8 %36, ptr %4, align 1
  %37 = load i8, ptr %4, align 1
  %38 = trunc i8 %37 to i1
  br i1 %38, label %39, label %23

39:                                               ; preds = %24
  %40 = load ptr, ptr %1, align 8
  %41 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 1
  %42 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 0, i32 2
  %43 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 0
  %44 = getelementptr { [3 x i64], [3 x ptr] }, ptr %40, i32 0, i32 1, i32 1
  %45 = load i64, ptr %41, align 4
  %46 = load i64, ptr %42, align 4
  %47 = load ptr, ptr %43, align 8
  %48 = load ptr, ptr %44, align 8
  %49 = load i64, ptr @Collection, align 4
  %50 = call i1 @subtype_test_wrapper(ptr %47, i64 %46, i64 %45, i64 %49, i64 ptrtoint (ptr @Collection to i64), ptr %48)
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %5, align 1
  br label %23

52:                                               ; preds = %23
  store i32 %22, ptr %7, align 4
  %53 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %54 = load i32, ptr %7, align 4
  %55 = getelementptr [314 x ptr], ptr %53, i32 0, i32 %54
  %56 = getelementptr ptr, ptr %55, i32 10
  %57 = load ptr, ptr %56, align 8
  ret ptr %57
}

define { ptr, ptr, ptr, i32 } @String_repr_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %8, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %6, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %8, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @String)
  store i32 %18, ptr %5, align 4
  %19 = alloca i32, align 4
  %20 = alloca ptr, align 8
  %21 = alloca ptr, align 8
  %22 = alloca ptr, align 8
  %23 = load ptr, ptr %8, align 8
  store ptr %23, ptr %22, align 8
  %24 = load ptr, ptr %7, align 8
  store ptr %24, ptr %21, align 8
  %25 = load ptr, ptr %6, align 8
  store ptr %25, ptr %20, align 8
  %26 = load i32, ptr %5, align 4
  store i32 %26, ptr %19, align 4
  %27 = load ptr, ptr %22, align 8
  %28 = call i32 @get_offset(ptr %27, ptr @String)
  store i32 %28, ptr %19, align 4
  %29 = load ptr, ptr %22, align 8
  %30 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %29, 0
  %31 = load ptr, ptr %21, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } %30, ptr %31, 1
  %33 = load ptr, ptr %20, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %33, 2
  %35 = load i32, ptr %19, align 4
  %36 = insertvalue { ptr, ptr, ptr, i32 } %34, i32 %35, 3
  ret { ptr, ptr, ptr, i32 } %36
}

define ptr @String_B_repr_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 91, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [314 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { i64, i64 } @_data_size_Character(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %3
  %5 = icmp eq i64 %4, 0
  %6 = sub i64 %3, %4
  %7 = select i1 %5, i64 0, i64 %6
  %8 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %7
  %9 = insertvalue { i64, i64 } undef, i64 %8, 0
  %10 = insertvalue { i64, i64 } %9, i64 %3, 1
  ret { i64, i64 } %10
}

define i32 @Character_getter_codepoint(ptr %0) {
  %2 = getelementptr i8, ptr %0, i64 0
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

define void @Character_setter_codepoint(ptr %0, i32 %1) {
  %3 = getelementptr i8, ptr %0, i64 0
  %4 = alloca i32, align 4
  store i32 %1, ptr %4, align 4
  %5 = load i32, ptr %4, align 4
  store i32 %5, ptr %3, align 4
  ret void
}

define i32 @Character_codepoint_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @Character)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 88, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = load ptr, ptr %23, align 8
  %25 = getelementptr { ptr, ptr }, ptr %24, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  %27 = call i32 %26(ptr %19) #1
  %28 = alloca i32, align 4
  store i32 %27, ptr %28, align 4
  %29 = load i32, ptr %28, align 4
  ret i32 %29
}

define ptr @Character_B_codepoint_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 6, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [11 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define void @Character_init_codepointi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, i32 %3) {
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %5, align 8
  %6 = alloca i32, align 4
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %7, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %8, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %9, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = call i32 @get_offset(ptr %18, ptr @Character)
  store i32 %19, ptr %6, align 4
  %20 = alloca i32, align 4
  store i32 %3, ptr %20, align 4
  %21 = load ptr, ptr %8, align 8
  %22 = load ptr, ptr %7, align 8
  %23 = call ptr @llvm.invariant.start.p0(i64 88, ptr %22)
  %24 = load i32, ptr %6, align 4
  %25 = getelementptr ptr, ptr %22, i32 %24
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr { ptr, ptr }, ptr %26, i32 0, i32 1
  %28 = load ptr, ptr %27, align 8
  %29 = load i32, ptr %20, align 4
  call void %28(ptr %21, i32 %29) #2
  ret void
}

define ptr @Character_B_init_codepointi32({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = ptrtoint ptr %6 to i64
  %8 = icmp eq i64 %7, ptrtoint (ptr @i32_typ to i64)
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %3, align 1
  store i32 7, ptr %5, align 4
  %10 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %11 = load i32, ptr %5, align 4
  %12 = getelementptr [11 x ptr], ptr %10, i32 0, i32 %11
  %13 = getelementptr ptr, ptr %12, i32 10
  %14 = load ptr, ptr %13, align 8
  ret ptr %14
}

define { ptr, ptr, ptr, i32 } @Character_to_string_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @Character)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 88, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = load ptr, ptr %23, align 8
  %25 = getelementptr { ptr, ptr }, ptr %24, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  %27 = call i32 %26(ptr %19) #1
  %28 = alloca i32, align 4
  store i32 %27, ptr %28, align 4
  %29 = load i32, ptr %28, align 4
  %30 = alloca [1 x ptr], align 8
  %31 = getelementptr [1 x ptr], ptr %30, i32 0, i32 0
  store ptr @_parameterization_i32, ptr %31, align 8
  %32 = call ptr @llvm.invariant.start.p0(i64 1, ptr %30)
  %33 = call ptr @llvm.invariant.start.p0(i64 80, ptr @Unicode)
  %34 = load ptr, ptr getelementptr (ptr, ptr getelementptr (ptr, ptr @Unicode, i32 10), i32 4), align 8
  %35 = alloca { ptr }, align 8
  %36 = getelementptr { ptr }, ptr %35, i32 0, i32 0
  store ptr @i32_typ, ptr %36, align 8
  %37 = call ptr @class_behavior_wrapper(ptr %34, ptr %35)
  %38 = call { ptr, ptr, ptr, i32 } %37(ptr %30, i32 %29)
  %39 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %38, ptr %39, align 8
  %40 = alloca i32, align 4
  %41 = alloca ptr, align 8
  %42 = alloca ptr, align 8
  %43 = alloca ptr, align 8
  %44 = getelementptr { ptr, ptr, ptr, i32 }, ptr %39, i32 0, i32 0
  %45 = load ptr, ptr %44, align 8
  store ptr %45, ptr %43, align 8
  %46 = getelementptr { ptr, ptr, ptr, i32 }, ptr %39, i32 0, i32 1
  %47 = load ptr, ptr %46, align 8
  store ptr %47, ptr %42, align 8
  %48 = getelementptr { ptr, ptr, ptr, i32 }, ptr %39, i32 0, i32 2
  %49 = load ptr, ptr %48, align 8
  store ptr %49, ptr %41, align 8
  %50 = getelementptr { ptr, ptr, ptr, i32 }, ptr %39, i32 0, i32 3
  %51 = load i32, ptr %50, align 4
  store i32 %51, ptr %40, align 4
  %52 = load ptr, ptr %43, align 8
  %53 = call i32 @get_offset(ptr %52, ptr @String)
  store i32 %53, ptr %40, align 4
  %54 = alloca i32, align 4
  %55 = alloca ptr, align 8
  %56 = alloca ptr, align 8
  %57 = alloca ptr, align 8
  %58 = load ptr, ptr %43, align 8
  store ptr %58, ptr %57, align 8
  %59 = load ptr, ptr %42, align 8
  store ptr %59, ptr %56, align 8
  %60 = load ptr, ptr %41, align 8
  store ptr %60, ptr %55, align 8
  %61 = load i32, ptr %40, align 4
  store i32 %61, ptr %54, align 4
  %62 = load ptr, ptr %57, align 8
  %63 = call i32 @get_offset(ptr %62, ptr @String)
  store i32 %63, ptr %54, align 4
  %64 = load ptr, ptr %57, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %64, 0
  %66 = load ptr, ptr %56, align 8
  %67 = insertvalue { ptr, ptr, ptr, i32 } %65, ptr %66, 1
  %68 = load ptr, ptr %55, align 8
  %69 = insertvalue { ptr, ptr, ptr, i32 } %67, ptr %68, 2
  %70 = load i32, ptr %54, align 4
  %71 = insertvalue { ptr, ptr, ptr, i32 } %69, i32 %70, 3
  ret { ptr, ptr, ptr, i32 } %71
}

define ptr @Character_B_to_string_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 8, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [11 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define i1 @Character__EQ_otherCharacter({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3) {
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %5, align 8
  %6 = alloca i32, align 4
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %7, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %8, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %9, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = call i32 @get_offset(ptr %18, ptr @Character)
  store i32 %19, ptr %6, align 4
  %20 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %20, align 8
  %21 = alloca i32, align 4
  %22 = alloca ptr, align 8
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  store ptr %26, ptr %24, align 8
  %27 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 1
  %28 = load ptr, ptr %27, align 8
  store ptr %28, ptr %23, align 8
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 2
  %30 = load ptr, ptr %29, align 8
  store ptr %30, ptr %22, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 3
  %32 = load i32, ptr %31, align 4
  store i32 %32, ptr %21, align 4
  %33 = load ptr, ptr %24, align 8
  %34 = call i32 @get_offset(ptr %33, ptr @Character)
  store i32 %34, ptr %21, align 4
  %35 = load ptr, ptr %8, align 8
  %36 = load ptr, ptr %7, align 8
  %37 = call ptr @llvm.invariant.start.p0(i64 88, ptr %36)
  %38 = load i32, ptr %6, align 4
  %39 = getelementptr ptr, ptr %36, i32 %38
  %40 = load ptr, ptr %39, align 8
  %41 = getelementptr { ptr, ptr }, ptr %40, i32 0, i32 0
  %42 = load ptr, ptr %41, align 8
  %43 = call i32 %42(ptr %35) #1
  %44 = alloca i32, align 4
  store i32 %43, ptr %44, align 4
  %45 = load ptr, ptr %24, align 8
  %46 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %45, 0
  %47 = load ptr, ptr %23, align 8
  %48 = insertvalue { ptr, ptr, ptr, i32 } %46, ptr %47, 1
  %49 = load ptr, ptr %22, align 8
  %50 = insertvalue { ptr, ptr, ptr, i32 } %48, ptr %49, 2
  %51 = load i32, ptr %21, align 4
  %52 = insertvalue { ptr, ptr, ptr, i32 } %50, i32 %51, 3
  %53 = alloca [0 x ptr], align 8
  %54 = call ptr @llvm.invariant.start.p0(i64 0, ptr %53)
  %55 = call ptr @llvm.invariant.start.p0(i64 88, ptr %45)
  %56 = getelementptr ptr, ptr %45, i32 %51
  %57 = getelementptr ptr, ptr %56, i32 1
  %58 = load ptr, ptr %57, align 8
  %59 = alloca {}, align 8
  %60 = call ptr @behavior_wrapper(ptr %58, { ptr, ptr, ptr, i32 } %52, ptr %59)
  %61 = call i32 %60({ ptr, ptr, ptr, i32 } %52, { ptr, ptr, ptr, i32 } %52, ptr %53)
  %62 = alloca i32, align 4
  store i32 %61, ptr %62, align 4
  %63 = load i32, ptr %44, align 4
  %64 = load i32, ptr %62, align 4
  %65 = icmp eq i32 %63, %64
  %66 = alloca i1, align 1
  %67 = zext i1 %65 to i8
  store i8 %67, ptr %66, align 1
  %68 = load i8, ptr %66, align 1
  %69 = trunc i8 %68 to i1
  ret i1 %69
}

define ptr @Character_B__EQ_otherCharacter({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @Character, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @Character to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 9, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [11 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define i32 @Character_n_bytes_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = alloca i1, align 1
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i1, align 1
  %10 = alloca i32, align 4
  %11 = alloca i32, align 4
  %12 = alloca i1, align 1
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %15 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %15, align 8
  %16 = alloca i32, align 4
  %17 = alloca ptr, align 8
  %18 = alloca ptr, align 8
  %19 = alloca ptr, align 8
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 0
  %21 = load ptr, ptr %20, align 8
  store ptr %21, ptr %17, align 8
  %22 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 1
  %23 = load ptr, ptr %22, align 8
  store ptr %23, ptr %18, align 8
  %24 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 2
  %25 = load ptr, ptr %24, align 8
  store ptr %25, ptr %19, align 8
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 3
  %27 = load i32, ptr %26, align 4
  store i32 %27, ptr %16, align 4
  %28 = load ptr, ptr %17, align 8
  %29 = call i32 @get_offset(ptr %28, ptr @Character)
  store i32 %29, ptr %16, align 4
  %30 = load ptr, ptr %18, align 8
  %31 = load ptr, ptr %17, align 8
  %32 = call ptr @llvm.invariant.start.p0(i64 88, ptr %31)
  %33 = load i32, ptr %16, align 4
  %34 = getelementptr ptr, ptr %31, i32 %33
  %35 = load ptr, ptr %34, align 8
  %36 = getelementptr { ptr, ptr }, ptr %35, i32 0, i32 0
  %37 = load ptr, ptr %36, align 8
  %38 = call i32 %37(ptr %30) #1
  %39 = alloca i32, align 4
  store i32 %38, ptr %39, align 4
  %40 = alloca i32, align 4
  %41 = load i32, ptr %39, align 4
  store i32 %41, ptr %40, align 4
  %42 = alloca i32, align 4
  store i32 127, ptr %42, align 4
  %43 = load i32, ptr %40, align 4
  %44 = load i32, ptr %42, align 4
  %45 = icmp sle i32 %43, %44
  %46 = alloca i1, align 1
  %47 = zext i1 %45 to i8
  store i8 %47, ptr %46, align 1
  %48 = load i8, ptr %46, align 1
  %49 = trunc i8 %48 to i1
  br i1 %49, label %50, label %53

50:                                               ; preds = %83, %3
  %51 = phi i32 [ %61, %83 ], [ 1, %3 ]
  %52 = phi ptr [ %62, %83 ], [ %4, %3 ]
  br label %84

53:                                               ; preds = %3
  store i32 2047, ptr %5, align 4
  %54 = load i32, ptr %40, align 4
  %55 = load i32, ptr %5, align 4
  %56 = icmp sle i32 %54, %55
  %57 = zext i1 %56 to i8
  store i8 %57, ptr %6, align 1
  %58 = load i8, ptr %6, align 1
  %59 = trunc i8 %58 to i1
  br i1 %59, label %60, label %63

60:                                               ; preds = %80, %53
  %61 = phi i32 [ %81, %80 ], [ 2, %53 ]
  %62 = phi ptr [ %82, %80 ], [ %7, %53 ]
  br label %83

63:                                               ; preds = %53
  store i32 -1, ptr %8, align 4
  %64 = load i32, ptr %40, align 4
  %65 = load i32, ptr %8, align 4
  %66 = icmp sle i32 %64, %65
  %67 = zext i1 %66 to i8
  store i8 %67, ptr %9, align 1
  %68 = load i8, ptr %9, align 1
  %69 = trunc i8 %68 to i1
  br i1 %69, label %70, label %71

70:                                               ; preds = %63
  br label %80

71:                                               ; preds = %63
  store i32 1114111, ptr %11, align 4
  %72 = load i32, ptr %40, align 4
  %73 = load i32, ptr %11, align 4
  %74 = icmp sle i32 %72, %73
  %75 = zext i1 %74 to i8
  store i8 %75, ptr %12, align 1
  %76 = load i8, ptr %12, align 1
  %77 = trunc i8 %76 to i1
  %78 = select i1 %77, i32 4, i32 3
  %79 = select i1 %77, ptr %13, ptr %14
  br label %80

80:                                               ; preds = %70, %71
  %81 = phi i32 [ %78, %71 ], [ 3, %70 ]
  %82 = phi ptr [ %79, %71 ], [ %10, %70 ]
  br label %60

83:                                               ; preds = %60
  br label %50

84:                                               ; preds = %50
  br label %85

85:                                               ; preds = %84
  store i32 %51, ptr %52, align 4
  %86 = load i32, ptr %52, align 4
  ret i32 %86
}

define ptr @Character_B_n_bytes_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 10, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [11 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { i64, i64 } @_data_size_StringIterator(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %10
  %12 = urem i64 %11, %5
  %13 = icmp eq i64 %12, 0
  %14 = sub i64 %5, %12
  %15 = select i1 %13, i64 0, i64 %14
  %16 = add i64 %11, %15
  %17 = insertvalue { i64, i64 } undef, i64 %16, 0
  %18 = insertvalue { i64, i64 } %17, i64 %5, 1
  ret { i64, i64 } %18
}

define { ptr, ptr, ptr, i32 } @StringIterator_getter_str(ptr %0) {
  %2 = getelementptr i8, ptr %0, i64 0
  %3 = getelementptr { ptr, ptr, ptr, i32 }, ptr %2, i32 0, i32 0
  %4 = load ptr, ptr %3, align 8
  %5 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %4, 0
  %6 = getelementptr { ptr, ptr, ptr, i32 }, ptr %2, i32 0, i32 1
  %7 = load ptr, ptr %6, align 8
  %8 = insertvalue { ptr, ptr, ptr, i32 } %5, ptr %7, 1
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %2, i32 0, i32 2
  %10 = load ptr, ptr %9, align 8
  %11 = insertvalue { ptr, ptr, ptr, i32 } %8, ptr %10, 2
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %2, i32 0, i32 3
  %13 = load i32, ptr %12, align 4
  %14 = insertvalue { ptr, ptr, ptr, i32 } %11, i32 %13, 3
  ret { ptr, ptr, ptr, i32 } %14
}

define void @StringIterator_setter_str(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = getelementptr i8, ptr %0, i64 0
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %4, align 8
  %5 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %6 = getelementptr { ptr, ptr, ptr, i32 }, ptr %3, i32 0, i32 0
  %7 = load ptr, ptr %5, align 8
  store ptr %7, ptr %6, align 8
  %8 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %3, i32 0, i32 1
  %10 = load ptr, ptr %8, align 8
  store ptr %10, ptr %9, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %3, i32 0, i32 2
  %13 = load ptr, ptr %11, align 8
  store ptr %13, ptr %12, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %3, i32 0, i32 3
  %16 = load i32, ptr %14, align 4
  store i32 %16, ptr %15, align 4
  ret void
}

define i32 @StringIterator_getter_byte_index(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %5
  %7 = getelementptr i8, ptr %0, i64 %6
  %8 = load i32, ptr %7, align 4
  ret i32 %8
}

define void @StringIterator_setter_byte_index(ptr %0, i32 %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %6
  %8 = getelementptr i8, ptr %0, i64 %7
  %9 = alloca i32, align 4
  store i32 %1, ptr %9, align 4
  %10 = load i32, ptr %9, align 4
  store i32 %10, ptr %8, align 4
  ret void
}

define ptr @StringIterator_field_StringIterator_0(ptr %0) {
  ret ptr @_parameterization_Character
}

define void @StringIterator_init_strString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3) {
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %5, align 8
  %6 = alloca i32, align 4
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %7, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %8, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %9, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = call i32 @get_offset(ptr %18, ptr @StringIterator)
  store i32 %19, ptr %6, align 4
  %20 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %20, align 8
  %21 = alloca i32, align 4
  %22 = alloca ptr, align 8
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  store ptr %26, ptr %24, align 8
  %27 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 1
  %28 = load ptr, ptr %27, align 8
  store ptr %28, ptr %23, align 8
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 2
  %30 = load ptr, ptr %29, align 8
  store ptr %30, ptr %22, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 3
  %32 = load i32, ptr %31, align 4
  store i32 %32, ptr %21, align 4
  %33 = load ptr, ptr %24, align 8
  %34 = call i32 @get_offset(ptr %33, ptr @String)
  store i32 %34, ptr %21, align 4
  %35 = alloca i32, align 4
  %36 = alloca ptr, align 8
  %37 = alloca ptr, align 8
  %38 = alloca ptr, align 8
  %39 = load ptr, ptr %24, align 8
  store ptr %39, ptr %38, align 8
  %40 = load ptr, ptr %23, align 8
  store ptr %40, ptr %37, align 8
  %41 = load ptr, ptr %22, align 8
  store ptr %41, ptr %36, align 8
  %42 = load i32, ptr %21, align 4
  store i32 %42, ptr %35, align 4
  %43 = load ptr, ptr %38, align 8
  %44 = call i32 @get_offset(ptr %43, ptr @String)
  store i32 %44, ptr %35, align 4
  %45 = load ptr, ptr %8, align 8
  %46 = load ptr, ptr %7, align 8
  %47 = call ptr @llvm.invariant.start.p0(i64 128, ptr %46)
  %48 = load i32, ptr %6, align 4
  %49 = getelementptr ptr, ptr %46, i32 %48
  %50 = load ptr, ptr %49, align 8
  %51 = getelementptr { ptr, ptr }, ptr %50, i32 0, i32 1
  %52 = load ptr, ptr %51, align 8
  %53 = load ptr, ptr %38, align 8
  %54 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %53, 0
  %55 = load ptr, ptr %37, align 8
  %56 = insertvalue { ptr, ptr, ptr, i32 } %54, ptr %55, 1
  %57 = load ptr, ptr %36, align 8
  %58 = insertvalue { ptr, ptr, ptr, i32 } %56, ptr %57, 2
  %59 = load i32, ptr %35, align 4
  %60 = insertvalue { ptr, ptr, ptr, i32 } %58, i32 %59, 3
  call void %52(ptr %45, { ptr, ptr, ptr, i32 } %60) #2
  %61 = alloca i32, align 4
  store i32 0, ptr %61, align 4
  %62 = load ptr, ptr %8, align 8
  %63 = load ptr, ptr %7, align 8
  %64 = call ptr @llvm.invariant.start.p0(i64 128, ptr %63)
  %65 = load i32, ptr %6, align 4
  %66 = getelementptr ptr, ptr %63, i32 %65
  %67 = getelementptr ptr, ptr %66, i32 1
  %68 = load ptr, ptr %67, align 8
  %69 = getelementptr { ptr, ptr }, ptr %68, i32 0, i32 1
  %70 = load ptr, ptr %69, align 8
  %71 = load i32, ptr %61, align 4
  call void %70(ptr %62, i32 %71) #2
  ret void
}

define ptr @StringIterator_B_init_strString({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @String, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @String to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 5, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [16 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define { ptr, i160 } @StringIterator_next_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca [0 x i8], align 1
  %5 = alloca i160, align 8
  %6 = alloca ptr, align 8
  %7 = alloca i32, align 4
  %8 = alloca { ptr, ptr, ptr, i32 }, align 8
  %9 = alloca [1 x ptr], align 8
  %10 = alloca { ptr }, align 8
  %11 = alloca { ptr, i64 }, align 8
  %12 = alloca i1, align 1
  %13 = alloca <2 x i32>, align 8
  %14 = alloca <2 x i32>, align 8
  %15 = alloca i32, align 4
  %16 = alloca i32, align 4
  %17 = alloca i32, align 4
  %18 = alloca i32, align 4
  %19 = alloca [1 x ptr], align 8
  %20 = alloca { ptr, ptr, ptr, i32 }, align 8
  %21 = alloca [1 x ptr], align 8
  %22 = alloca { ptr }, align 8
  %23 = alloca [0 x i8], align 1
  %24 = alloca [0 x i8], align 1
  %25 = alloca i160, align 8
  %26 = alloca ptr, align 8
  %27 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %27, align 8
  %28 = alloca i32, align 4
  %29 = alloca ptr, align 8
  %30 = alloca ptr, align 8
  %31 = alloca ptr, align 8
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 0
  %33 = load ptr, ptr %32, align 8
  store ptr %33, ptr %29, align 8
  %34 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 1
  %35 = load ptr, ptr %34, align 8
  store ptr %35, ptr %30, align 8
  %36 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 2
  %37 = load ptr, ptr %36, align 8
  store ptr %37, ptr %31, align 8
  %38 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 3
  %39 = load i32, ptr %38, align 4
  store i32 %39, ptr %28, align 4
  %40 = load ptr, ptr %29, align 8
  %41 = call i32 @get_offset(ptr %40, ptr @StringIterator)
  store i32 %41, ptr %28, align 4
  %42 = load ptr, ptr %30, align 8
  %43 = load ptr, ptr %29, align 8
  %44 = call ptr @llvm.invariant.start.p0(i64 128, ptr %43)
  %45 = load i32, ptr %28, align 4
  %46 = getelementptr ptr, ptr %43, i32 %45
  %47 = getelementptr ptr, ptr %46, i32 1
  %48 = load ptr, ptr %47, align 8
  %49 = getelementptr { ptr, ptr }, ptr %48, i32 0, i32 0
  %50 = load ptr, ptr %49, align 8
  %51 = call i32 %50(ptr %42) #1
  %52 = alloca i32, align 4
  store i32 %51, ptr %52, align 4
  %53 = load ptr, ptr %30, align 8
  %54 = load ptr, ptr %29, align 8
  %55 = call ptr @llvm.invariant.start.p0(i64 128, ptr %54)
  %56 = load i32, ptr %28, align 4
  %57 = getelementptr ptr, ptr %54, i32 %56
  %58 = load ptr, ptr %57, align 8
  %59 = getelementptr { ptr, ptr }, ptr %58, i32 0, i32 0
  %60 = load ptr, ptr %59, align 8
  %61 = call { ptr, ptr, ptr, i32 } %60(ptr %53) #1
  %62 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %61, ptr %62, align 8
  call void @assume_offset(ptr %62, ptr @String)
  %63 = getelementptr { ptr, ptr, ptr, i32 }, ptr %62, i32 0, i32 0
  %64 = load ptr, ptr %63, align 8
  %65 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %64, 0
  %66 = getelementptr { ptr, ptr, ptr, i32 }, ptr %62, i32 0, i32 1
  %67 = load ptr, ptr %66, align 8
  %68 = insertvalue { ptr, ptr, ptr, i32 } %65, ptr %67, 1
  %69 = getelementptr { ptr, ptr, ptr, i32 }, ptr %62, i32 0, i32 2
  %70 = load ptr, ptr %69, align 8
  %71 = insertvalue { ptr, ptr, ptr, i32 } %68, ptr %70, 2
  %72 = getelementptr { ptr, ptr, ptr, i32 }, ptr %62, i32 0, i32 3
  %73 = load i32, ptr %72, align 4
  %74 = insertvalue { ptr, ptr, ptr, i32 } %71, i32 %73, 3
  %75 = alloca [0 x ptr], align 8
  %76 = call ptr @llvm.invariant.start.p0(i64 0, ptr %75)
  %77 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %64)
  %78 = getelementptr ptr, ptr %64, i32 %73
  %79 = getelementptr ptr, ptr %78, i32 5
  %80 = load ptr, ptr %79, align 8
  %81 = alloca {}, align 8
  %82 = call ptr @behavior_wrapper(ptr %80, { ptr, ptr, ptr, i32 } %74, ptr %81)
  %83 = call i32 %82({ ptr, ptr, ptr, i32 } %74, { ptr, ptr, ptr, i32 } %74, ptr %75)
  %84 = alloca i32, align 4
  store i32 %83, ptr %84, align 4
  %85 = load i32, ptr %52, align 4
  %86 = load i32, ptr %84, align 4
  %87 = icmp sge i32 %85, %86
  %88 = alloca i1, align 1
  %89 = zext i1 %87 to i8
  store i8 %89, ptr %88, align 1
  %90 = load i8, ptr %88, align 1
  %91 = trunc i8 %90 to i1
  br i1 %91, label %92, label %98

92:                                               ; preds = %3
  %93 = load [0 x i8], ptr %4, align 1
  store [0 x i8] %93, ptr %5, align 1
  store ptr @nil_typ, ptr %6, align 8
  %94 = load ptr, ptr %6, align 8
  %95 = insertvalue { ptr, i160 } undef, ptr %94, 0
  %96 = load i160, ptr %5, align 4
  %97 = insertvalue { ptr, i160 } %95, i160 %96, 1
  br label %224

98:                                               ; preds = %3
  %99 = load ptr, ptr %30, align 8
  %100 = load ptr, ptr %29, align 8
  %101 = call ptr @llvm.invariant.start.p0(i64 128, ptr %100)
  %102 = load i32, ptr %28, align 4
  %103 = getelementptr ptr, ptr %100, i32 %102
  %104 = getelementptr ptr, ptr %103, i32 1
  %105 = load ptr, ptr %104, align 8
  %106 = getelementptr { ptr, ptr }, ptr %105, i32 0, i32 0
  %107 = load ptr, ptr %106, align 8
  %108 = call i32 %107(ptr %99) #1
  store i32 %108, ptr %7, align 4
  %109 = load i32, ptr %7, align 4
  %110 = load ptr, ptr %30, align 8
  %111 = load ptr, ptr %29, align 8
  %112 = call ptr @llvm.invariant.start.p0(i64 128, ptr %111)
  %113 = load i32, ptr %28, align 4
  %114 = getelementptr ptr, ptr %111, i32 %113
  %115 = load ptr, ptr %114, align 8
  %116 = getelementptr { ptr, ptr }, ptr %115, i32 0, i32 0
  %117 = load ptr, ptr %116, align 8
  %118 = call { ptr, ptr, ptr, i32 } %117(ptr %110) #1
  store { ptr, ptr, ptr, i32 } %118, ptr %8, align 8
  call void @assume_offset(ptr %8, ptr @String)
  %119 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 0
  %120 = load ptr, ptr %119, align 8
  %121 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %120, 0
  %122 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 1
  %123 = load ptr, ptr %122, align 8
  %124 = insertvalue { ptr, ptr, ptr, i32 } %121, ptr %123, 1
  %125 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 2
  %126 = load ptr, ptr %125, align 8
  %127 = insertvalue { ptr, ptr, ptr, i32 } %124, ptr %126, 2
  %128 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 3
  %129 = load i32, ptr %128, align 4
  %130 = insertvalue { ptr, ptr, ptr, i32 } %127, i32 %129, 3
  %131 = getelementptr [1 x ptr], ptr %9, i32 0, i32 0
  store ptr @_parameterization_i32, ptr %131, align 8
  %132 = call ptr @llvm.invariant.start.p0(i64 1, ptr %9)
  %133 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %120)
  %134 = getelementptr ptr, ptr %120, i32 %129
  %135 = getelementptr ptr, ptr %134, i32 17
  %136 = load ptr, ptr %135, align 8
  %137 = getelementptr { ptr }, ptr %10, i32 0, i32 0
  store ptr @i32_typ, ptr %137, align 8
  %138 = call ptr @behavior_wrapper(ptr %136, { ptr, ptr, ptr, i32 } %130, ptr %10)
  %139 = call { ptr, i64 } %138({ ptr, ptr, ptr, i32 } %130, { ptr, ptr, ptr, i32 } %130, ptr %9, i32 %109)
  store { ptr, i64 } %139, ptr %11, align 8
  %140 = load ptr, ptr %11, align 8
  %141 = ptrtoint ptr %140 to i64
  %142 = icmp eq i64 %141, ptrtoint (ptr @nil_typ to i64)
  %143 = icmp eq i64 %141, 0
  %144 = or i1 %142, %143
  %145 = icmp eq i1 %144, false
  %146 = zext i1 %145 to i8
  store i8 %146, ptr %12, align 1
  %147 = load i8, ptr %12, align 1
  %148 = trunc i8 %147 to i1
  br i1 %148, label %149, label %213

149:                                              ; preds = %98
  %150 = getelementptr { ptr, i64 }, ptr %11, i32 0, i32 1
  %151 = load <2 x i32>, ptr %150, align 8
  store <2 x i32> %151, ptr %13, align 8
  %152 = load <2 x i32>, ptr %13, align 8
  store <2 x i32> %152, ptr %14, align 8
  %153 = getelementptr <2 x i32>, ptr %14, i32 0, i32 0
  %154 = load i32, ptr %153, align 4
  store i32 %154, ptr %15, align 4
  %155 = getelementptr <2 x i32>, ptr %14, i32 0, i32 1
  %156 = load i32, ptr %155, align 4
  store i32 %156, ptr %16, align 4
  %157 = load ptr, ptr %30, align 8
  %158 = load ptr, ptr %29, align 8
  %159 = call ptr @llvm.invariant.start.p0(i64 128, ptr %158)
  %160 = load i32, ptr %28, align 4
  %161 = getelementptr ptr, ptr %158, i32 %160
  %162 = getelementptr ptr, ptr %161, i32 1
  %163 = load ptr, ptr %162, align 8
  %164 = getelementptr { ptr, ptr }, ptr %163, i32 0, i32 0
  %165 = load ptr, ptr %164, align 8
  %166 = call i32 %165(ptr %157) #1
  store i32 %166, ptr %17, align 4
  %167 = load i32, ptr %17, align 4
  %168 = load i32, ptr %16, align 4
  %169 = add i32 %167, %168
  store i32 %169, ptr %18, align 4
  %170 = load ptr, ptr %30, align 8
  %171 = load ptr, ptr %29, align 8
  %172 = call ptr @llvm.invariant.start.p0(i64 128, ptr %171)
  %173 = load i32, ptr %28, align 4
  %174 = getelementptr ptr, ptr %171, i32 %173
  %175 = getelementptr ptr, ptr %174, i32 1
  %176 = load ptr, ptr %175, align 8
  %177 = getelementptr { ptr, ptr }, ptr %176, i32 0, i32 1
  %178 = load ptr, ptr %177, align 8
  %179 = load i32, ptr %18, align 4
  call void %178(ptr %170, i32 %179) #2
  store ptr @Character, ptr %19, align 8
  %180 = load ptr, ptr %19, align 8
  %181 = getelementptr ptr, ptr %180, i32 6
  %182 = load ptr, ptr %181, align 8
  %183 = call { i64, i64 } @size_wrapper(ptr %182, ptr %19)
  %184 = extractvalue { i64, i64 } %183, 0
  %185 = call ptr @bump_malloc(i64 %184)
  %186 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 1
  %187 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 3
  store ptr @Character, ptr %20, align 8
  store ptr %185, ptr %186, align 8
  store i32 10, ptr %187, align 4
  %188 = load i32, ptr %15, align 4
  %189 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 0
  %190 = load ptr, ptr %189, align 8
  %191 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %190, 0
  %192 = load ptr, ptr %186, align 8
  %193 = insertvalue { ptr, ptr, ptr, i32 } %191, ptr %192, 1
  %194 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 2
  %195 = load ptr, ptr %194, align 8
  %196 = insertvalue { ptr, ptr, ptr, i32 } %193, ptr %195, 2
  %197 = load i32, ptr %187, align 4
  %198 = insertvalue { ptr, ptr, ptr, i32 } %196, i32 %197, 3
  %199 = getelementptr [1 x ptr], ptr %21, i32 0, i32 0
  store ptr @_parameterization_i32, ptr %199, align 8
  %200 = call ptr @llvm.invariant.start.p0(i64 1, ptr %21)
  %201 = call ptr @llvm.invariant.start.p0(i64 88, ptr %190)
  %202 = getelementptr ptr, ptr %190, i32 %197
  %203 = getelementptr ptr, ptr %202, i32 2
  %204 = load ptr, ptr %203, align 8
  %205 = getelementptr { ptr }, ptr %22, i32 0, i32 0
  store ptr @i32_typ, ptr %205, align 8
  %206 = call ptr @behavior_wrapper(ptr %204, { ptr, ptr, ptr, i32 } %198, ptr %22)
  call void %206({ ptr, ptr, ptr, i32 } %198, { ptr, ptr, ptr, i32 } %198, ptr %21, i32 %188)
  %207 = getelementptr { ptr, i160 }, ptr %20, i32 0, i32 0
  %208 = load ptr, ptr %207, align 8
  %209 = insertvalue { ptr, i160 } undef, ptr %208, 0
  %210 = getelementptr { ptr, i160 }, ptr %20, i32 0, i32 1
  %211 = load i160, ptr %210, align 4
  %212 = insertvalue { ptr, i160 } %209, i160 %211, 1
  br label %221

213:                                              ; preds = %98
  %214 = getelementptr { ptr, i64 }, ptr %11, i32 0, i32 1
  %215 = load [0 x i8], ptr %214, align 1
  store [0 x i8] %215, ptr %23, align 1
  %216 = load [0 x i8], ptr %24, align 1
  store [0 x i8] %216, ptr %25, align 1
  store ptr @nil_typ, ptr %26, align 8
  %217 = load ptr, ptr %26, align 8
  %218 = insertvalue { ptr, i160 } undef, ptr %217, 0
  %219 = load i160, ptr %25, align 4
  %220 = insertvalue { ptr, i160 } %218, i160 %219, 1
  br label %221

221:                                              ; preds = %149, %213
  %222 = phi { ptr, i160 } [ %220, %213 ], [ %212, %149 ]
  br label %223

223:                                              ; preds = %221
  br label %224

224:                                              ; preds = %92, %223
  %225 = phi { ptr, i160 } [ %222, %223 ], [ %97, %92 ]
  br label %226

226:                                              ; preds = %224
  ret { ptr, i160 } %225
}

define ptr @StringIterator_B_next_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 6, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [16 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { i64, i64 } @_data_size_Stacktrace(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, { ptr } }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, i64 }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, i64 }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i64 }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, i64 }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr (i64, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), %10
  %12 = urem i64 %11, %5
  %13 = icmp eq i64 %12, 0
  %14 = sub i64 %5, %12
  %15 = select i1 %13, i64 0, i64 %14
  %16 = add i64 %11, %15
  %17 = insertvalue { i64, i64 } undef, i64 %16, 0
  %18 = insertvalue { i64, i64 } %17, i64 %5, 1
  ret { i64, i64 } %18
}

define { ptr } @Stacktrace_getter_stacktrace(ptr %0) {
  %2 = getelementptr i8, ptr %0, i64 0
  %3 = getelementptr { ptr }, ptr %2, i32 0, i32 0
  %4 = load ptr, ptr %3, align 8
  %5 = insertvalue { ptr } undef, ptr %4, 0
  ret { ptr } %5
}

define void @Stacktrace_setter_stacktrace(ptr %0, { ptr } %1) {
  %3 = getelementptr i8, ptr %0, i64 0
  %4 = alloca ptr, align 8
  store { ptr } %1, ptr %4, align 8
  %5 = getelementptr { ptr }, ptr %3, i32 0, i32 0
  %6 = load ptr, ptr %4, align 8
  store ptr %6, ptr %5, align 8
  ret void
}

define i64 @Stacktrace_getter_n_frames(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i64 }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, i64 }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), %5
  %7 = getelementptr i8, ptr %0, i64 %6
  %8 = load i64, ptr %7, align 4
  ret i64 %8
}

define void @Stacktrace_setter_n_frames(ptr %0, i64 %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i64 }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, i64 }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr ({ ptr }, ptr null, i32 1) to i64), %6
  %8 = getelementptr i8, ptr %0, i64 %7
  %9 = alloca i64, align 8
  store i64 %1, ptr %9, align 4
  %10 = load i64, ptr %9, align 4
  store i64 %10, ptr %8, align 4
  ret void
}

define void @Stacktrace_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @Stacktrace)
  store i32 %18, ptr %5, align 4
  %19 = alloca i32, align 4
  store i32 100, ptr %19, align 4
  %20 = alloca i64, align 8
  %21 = load i32, ptr %19, align 4
  %22 = sext i32 %21 to i64
  store i64 %22, ptr %20, align 4
  %23 = load i64, ptr %20, align 4
  %24 = alloca ptr, align 8
  %25 = mul i64 %23, ptrtoint (ptr getelementptr (i64, ptr null, i32 1) to i64)
  %26 = call ptr @bump_malloc(i64 %25)
  store ptr %26, ptr %24, align 8
  %27 = load ptr, ptr %7, align 8
  %28 = load ptr, ptr %6, align 8
  %29 = call ptr @llvm.invariant.start.p0(i64 48, ptr %28)
  %30 = load i32, ptr %5, align 4
  %31 = getelementptr ptr, ptr %28, i32 %30
  %32 = load ptr, ptr %31, align 8
  %33 = getelementptr { ptr, ptr }, ptr %32, i32 0, i32 1
  %34 = load ptr, ptr %33, align 8
  %35 = getelementptr { ptr }, ptr %24, i32 0, i32 0
  %36 = load ptr, ptr %35, align 8
  %37 = insertvalue { ptr } undef, ptr %36, 0
  call void %34(ptr %27, { ptr } %37) #2
  %38 = alloca i64, align 8
  store i64 100, ptr %38, align 4
  %39 = load ptr, ptr %7, align 8
  %40 = load ptr, ptr %6, align 8
  %41 = call ptr @llvm.invariant.start.p0(i64 48, ptr %40)
  %42 = load i32, ptr %5, align 4
  %43 = getelementptr ptr, ptr %40, i32 %42
  %44 = load ptr, ptr %43, align 8
  %45 = getelementptr { ptr, ptr }, ptr %44, i32 0, i32 0
  %46 = load ptr, ptr %45, align 8
  %47 = call { ptr } %46(ptr %39) #1
  %48 = alloca ptr, align 8
  store { ptr } %47, ptr %48, align 8
  %49 = load i64, ptr %38, align 4
  %50 = load ptr, ptr %48, align 8
  %51 = insertvalue { ptr } undef, ptr %50, 0
  %52 = call i64 @capture_backtrace(i64 %49, { ptr } %51)
  %53 = alloca i64, align 8
  store i64 %52, ptr %53, align 4
  %54 = load ptr, ptr %7, align 8
  %55 = load ptr, ptr %6, align 8
  %56 = call ptr @llvm.invariant.start.p0(i64 48, ptr %55)
  %57 = load i32, ptr %5, align 4
  %58 = getelementptr ptr, ptr %55, i32 %57
  %59 = getelementptr ptr, ptr %58, i32 1
  %60 = load ptr, ptr %59, align 8
  %61 = getelementptr { ptr, ptr }, ptr %60, i32 0, i32 1
  %62 = load ptr, ptr %61, align 8
  %63 = load i64, ptr %53, align 4
  call void %62(ptr %54, i64 %63) #2
  ret void
}

define ptr @Stacktrace_B_init_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 4, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [6 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define void @Stacktrace_print_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @Stacktrace)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 48, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = load ptr, ptr %23, align 8
  %25 = getelementptr { ptr, ptr }, ptr %24, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  %27 = call { ptr } %26(ptr %19) #1
  %28 = alloca ptr, align 8
  store { ptr } %27, ptr %28, align 8
  %29 = load ptr, ptr %7, align 8
  %30 = load ptr, ptr %6, align 8
  %31 = call ptr @llvm.invariant.start.p0(i64 48, ptr %30)
  %32 = load i32, ptr %5, align 4
  %33 = getelementptr ptr, ptr %30, i32 %32
  %34 = getelementptr ptr, ptr %33, i32 1
  %35 = load ptr, ptr %34, align 8
  %36 = getelementptr { ptr, ptr }, ptr %35, i32 0, i32 0
  %37 = load ptr, ptr %36, align 8
  %38 = call i64 %37(ptr %29) #1
  %39 = alloca i64, align 8
  store i64 %38, ptr %39, align 4
  %40 = load ptr, ptr %28, align 8
  %41 = insertvalue { ptr } undef, ptr %40, 0
  %42 = load i64, ptr %39, align 4
  call void @print_backtrace({ ptr } %41, i64 %42)
  ret void
}

define ptr @Stacktrace_B_print_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 5, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [6 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { i64, i64 } @_data_size_Exception(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %10
  %12 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %5
  %13 = select i1 %12, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %5
  %14 = urem i64 %11, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %17
  %19 = add i64 %11, %18
  %20 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %13
  %21 = select i1 %20, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %13
  %22 = urem i64 %19, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %23 = icmp eq i64 %22, 0
  %24 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %22
  %25 = select i1 %23, i64 0, i64 %24
  %26 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %25
  %27 = add i64 %19, %26
  %28 = urem i64 %27, %21
  %29 = icmp eq i64 %28, 0
  %30 = sub i64 %21, %28
  %31 = select i1 %29, i64 0, i64 %30
  %32 = add i64 %27, %31
  %33 = insertvalue { i64, i64 } undef, i64 %32, 0
  %34 = insertvalue { i64, i64 } %33, i64 %21, 1
  ret { i64, i64 } %34
}

define i32 @Exception_getter_line_number(ptr %0) {
  %2 = getelementptr i8, ptr %0, i64 0
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

define void @Exception_setter_line_number(ptr %0, i32 %1) {
  %3 = getelementptr i8, ptr %0, i64 0
  %4 = alloca i32, align 4
  store i32 %1, ptr %4, align 4
  %5 = load i32, ptr %4, align 4
  store i32 %5, ptr %3, align 4
  ret void
}

define { ptr, ptr, ptr, i32 } @Exception_getter_file_name(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %5
  %7 = getelementptr i8, ptr %0, i64 %6
  %8 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %9, 0
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %12, 1
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %15, 2
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  %19 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %18, 3
  ret { ptr, ptr, ptr, i32 } %19
}

define void @Exception_setter_file_name(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %6
  %8 = getelementptr i8, ptr %0, i64 %7
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %9, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 0
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 0
  %12 = load ptr, ptr %10, align 8
  store ptr %12, ptr %11, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 1
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 1
  %15 = load ptr, ptr %13, align 8
  store ptr %15, ptr %14, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 2
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 2
  %18 = load ptr, ptr %16, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 3
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 3
  %21 = load i32, ptr %19, align 4
  store i32 %21, ptr %20, align 4
  ret void
}

define { ptr, ptr, ptr, i32 } @Exception_getter_message(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %7, %11
  %13 = getelementptr i8, ptr %0, i64 %12
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %15, 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 1
  %18 = load ptr, ptr %17, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %18, 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 2
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %21, 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 3
  %24 = load i32, ptr %23, align 4
  %25 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %24, 3
  ret { ptr, ptr, ptr, i32 } %25
}

define void @Exception_setter_message(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %8, %12
  %14 = getelementptr i8, ptr %0, i64 %13
  %15 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %15, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 0
  %18 = load ptr, ptr %16, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 1
  %21 = load ptr, ptr %19, align 8
  store ptr %21, ptr %20, align 8
  %22 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 2
  %24 = load ptr, ptr %22, align 8
  store ptr %24, ptr %23, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 3
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 3
  %27 = load i32, ptr %25, align 4
  store i32 %27, ptr %26, align 4
  ret void
}

define { ptr, ptr, ptr, i32 } @Exception_getter_stacktrace(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %11
  %13 = add i64 %7, %12
  %14 = urem i64 %13, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 %13, %17
  %19 = getelementptr i8, ptr %0, i64 %18
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 0
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %21, 0
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 1
  %24 = load ptr, ptr %23, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %24, 1
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 2
  %27 = load ptr, ptr %26, align 8
  %28 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %27, 2
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 3
  %30 = load i32, ptr %29, align 4
  %31 = insertvalue { ptr, ptr, ptr, i32 } %28, i32 %30, 3
  ret { ptr, ptr, ptr, i32 } %31
}

define void @Exception_setter_stacktrace(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %12
  %14 = add i64 %8, %13
  %15 = urem i64 %14, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %16 = icmp eq i64 %15, 0
  %17 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add i64 %14, %18
  %20 = getelementptr i8, ptr %0, i64 %19
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %21, align 8
  %22 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 0
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 0
  %24 = load ptr, ptr %22, align 8
  store ptr %24, ptr %23, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 1
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 1
  %27 = load ptr, ptr %25, align 8
  store ptr %27, ptr %26, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 2
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 2
  %30 = load ptr, ptr %28, align 8
  store ptr %30, ptr %29, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 3
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 3
  %33 = load i32, ptr %31, align 4
  store i32 %33, ptr %32, align 4
  ret void
}

define void @Exception_init_messageString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, { ptr, ptr, ptr, i32 } %3) {
  %5 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %5, align 8
  %6 = alloca i32, align 4
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %7, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %8, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %9, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %5, i32 0, i32 3
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %6, align 4
  %18 = load ptr, ptr %7, align 8
  %19 = call i32 @get_offset(ptr %18, ptr @Exception)
  store i32 %19, ptr %6, align 4
  %20 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %3, ptr %20, align 8
  %21 = alloca i32, align 4
  %22 = alloca ptr, align 8
  %23 = alloca ptr, align 8
  %24 = alloca ptr, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  store ptr %26, ptr %24, align 8
  %27 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 1
  %28 = load ptr, ptr %27, align 8
  store ptr %28, ptr %23, align 8
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 2
  %30 = load ptr, ptr %29, align 8
  store ptr %30, ptr %22, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 3
  %32 = load i32, ptr %31, align 4
  store i32 %32, ptr %21, align 4
  %33 = load ptr, ptr %24, align 8
  %34 = call i32 @get_offset(ptr %33, ptr @String)
  store i32 %34, ptr %21, align 4
  %35 = alloca i32, align 4
  %36 = alloca ptr, align 8
  %37 = alloca ptr, align 8
  %38 = alloca ptr, align 8
  %39 = load ptr, ptr %24, align 8
  store ptr %39, ptr %38, align 8
  %40 = load ptr, ptr %23, align 8
  store ptr %40, ptr %37, align 8
  %41 = load ptr, ptr %22, align 8
  store ptr %41, ptr %36, align 8
  %42 = load i32, ptr %21, align 4
  store i32 %42, ptr %35, align 4
  %43 = load ptr, ptr %38, align 8
  %44 = call i32 @get_offset(ptr %43, ptr @String)
  store i32 %44, ptr %35, align 4
  %45 = load ptr, ptr %8, align 8
  %46 = load ptr, ptr %7, align 8
  %47 = call ptr @llvm.invariant.start.p0(i64 112, ptr %46)
  %48 = load i32, ptr %6, align 4
  %49 = getelementptr ptr, ptr %46, i32 %48
  %50 = getelementptr ptr, ptr %49, i32 2
  %51 = load ptr, ptr %50, align 8
  %52 = getelementptr { ptr, ptr }, ptr %51, i32 0, i32 1
  %53 = load ptr, ptr %52, align 8
  %54 = load ptr, ptr %38, align 8
  %55 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %54, 0
  %56 = load ptr, ptr %37, align 8
  %57 = insertvalue { ptr, ptr, ptr, i32 } %55, ptr %56, 1
  %58 = load ptr, ptr %36, align 8
  %59 = insertvalue { ptr, ptr, ptr, i32 } %57, ptr %58, 2
  %60 = load i32, ptr %35, align 4
  %61 = insertvalue { ptr, ptr, ptr, i32 } %59, i32 %60, 3
  call void %53(ptr %45, { ptr, ptr, ptr, i32 } %61) #2
  %62 = alloca i32, align 4
  store i32 0, ptr %62, align 4
  %63 = load ptr, ptr %8, align 8
  %64 = load ptr, ptr %7, align 8
  %65 = call ptr @llvm.invariant.start.p0(i64 112, ptr %64)
  %66 = load i32, ptr %6, align 4
  %67 = getelementptr ptr, ptr %64, i32 %66
  %68 = load ptr, ptr %67, align 8
  %69 = getelementptr { ptr, ptr }, ptr %68, i32 0, i32 1
  %70 = load ptr, ptr %69, align 8
  %71 = load i32, ptr %62, align 4
  call void %70(ptr %63, i32 %71) #2
  %72 = alloca i32, align 4
  store i32 1, ptr %72, align 4
  %73 = alloca i64, align 8
  %74 = load i32, ptr %72, align 4
  %75 = sext i32 %74 to i64
  store i64 %75, ptr %73, align 4
  %76 = load i64, ptr %73, align 4
  %77 = alloca ptr, align 8
  %78 = mul i64 %76, ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
  %79 = call ptr @bump_malloc(i64 %78)
  store ptr %79, ptr %77, align 8
  %80 = alloca ptr, align 8
  %81 = getelementptr { ptr }, ptr %77, i32 0, i32 0
  %82 = load ptr, ptr %81, align 8
  store ptr %82, ptr %80, align 8
  %83 = alloca [0 x i8], align 1
  store [0 x i8] zeroinitializer, ptr %83, align 1
  %84 = alloca i32, align 4
  store i32 0, ptr %84, align 4
  %85 = alloca i32, align 4
  store i32 0, ptr %85, align 4
  %86 = alloca i32, align 4
  store i32 0, ptr %86, align 4
  %87 = alloca i32, align 4
  store i32 1, ptr %87, align 4
  %88 = alloca [1 x ptr], align 8
  store ptr @String, ptr %88, align 8
  %89 = load ptr, ptr %88, align 8
  %90 = getelementptr ptr, ptr %89, i32 6
  %91 = load ptr, ptr %90, align 8
  %92 = call { i64, i64 } @size_wrapper(ptr %91, ptr %88)
  %93 = extractvalue { i64, i64 } %92, 0
  %94 = call ptr @bump_malloc(i64 %93)
  %95 = alloca i32, align 4
  %96 = alloca ptr, align 8
  %97 = alloca ptr, align 8
  %98 = alloca ptr, align 8
  store ptr @String, ptr %98, align 8
  store ptr %94, ptr %97, align 8
  store i32 10, ptr %95, align 4
  %99 = alloca i32, align 4
  store i32 0, ptr %99, align 4
  %100 = alloca i32, align 4
  store i32 0, ptr %100, align 4
  %101 = alloca i32, align 4
  store i32 1, ptr %101, align 4
  %102 = load ptr, ptr %80, align 8
  %103 = insertvalue { ptr } undef, ptr %102, 0
  %104 = load i32, ptr %99, align 4
  %105 = load i32, ptr %100, align 4
  %106 = load i32, ptr %101, align 4
  %107 = load ptr, ptr %98, align 8
  %108 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %107, 0
  %109 = load ptr, ptr %97, align 8
  %110 = insertvalue { ptr, ptr, ptr, i32 } %108, ptr %109, 1
  %111 = load ptr, ptr %96, align 8
  %112 = insertvalue { ptr, ptr, ptr, i32 } %110, ptr %111, 2
  %113 = load i32, ptr %95, align 4
  %114 = insertvalue { ptr, ptr, ptr, i32 } %112, i32 %113, 3
  %115 = alloca [4 x ptr], align 8
  %116 = getelementptr [4 x ptr], ptr %115, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %116, align 8
  %117 = getelementptr [4 x ptr], ptr %115, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %117, align 8
  %118 = getelementptr [4 x ptr], ptr %115, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %118, align 8
  %119 = getelementptr [4 x ptr], ptr %115, i32 0, i32 3
  store ptr @_parameterization_i32, ptr %119, align 8
  %120 = call ptr @llvm.invariant.start.p0(i64 16, ptr %115)
  %121 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %107)
  %122 = getelementptr ptr, ptr %107, i32 %113
  %123 = getelementptr ptr, ptr %122, i32 12
  %124 = load ptr, ptr %123, align 8
  %125 = alloca { ptr, ptr, ptr, ptr }, align 8
  %126 = getelementptr { ptr, ptr, ptr, ptr }, ptr %125, i32 0, i32 0
  store ptr @buffer_typ, ptr %126, align 8
  %127 = getelementptr { ptr, ptr, ptr, ptr }, ptr %125, i32 0, i32 1
  store ptr @i32_typ, ptr %127, align 8
  %128 = getelementptr { ptr, ptr, ptr, ptr }, ptr %125, i32 0, i32 2
  store ptr @i32_typ, ptr %128, align 8
  %129 = getelementptr { ptr, ptr, ptr, ptr }, ptr %125, i32 0, i32 3
  store ptr @i32_typ, ptr %129, align 8
  %130 = call ptr @behavior_wrapper(ptr %124, { ptr, ptr, ptr, i32 } %114, ptr %125)
  call void %130({ ptr, ptr, ptr, i32 } %114, { ptr, ptr, ptr, i32 } %114, ptr %115, { ptr } %103, i32 %104, i32 %105, i32 %106)
  %131 = alloca i32, align 4
  %132 = alloca ptr, align 8
  %133 = alloca ptr, align 8
  %134 = alloca ptr, align 8
  %135 = load ptr, ptr %98, align 8
  store ptr %135, ptr %134, align 8
  %136 = load ptr, ptr %97, align 8
  store ptr %136, ptr %133, align 8
  %137 = load ptr, ptr %96, align 8
  store ptr %137, ptr %132, align 8
  %138 = load i32, ptr %95, align 4
  store i32 %138, ptr %131, align 4
  %139 = load ptr, ptr %134, align 8
  %140 = call i32 @get_offset(ptr %139, ptr @String)
  store i32 %140, ptr %131, align 4
  %141 = load ptr, ptr %8, align 8
  %142 = load ptr, ptr %7, align 8
  %143 = call ptr @llvm.invariant.start.p0(i64 112, ptr %142)
  %144 = load i32, ptr %6, align 4
  %145 = getelementptr ptr, ptr %142, i32 %144
  %146 = getelementptr ptr, ptr %145, i32 1
  %147 = load ptr, ptr %146, align 8
  %148 = getelementptr { ptr, ptr }, ptr %147, i32 0, i32 1
  %149 = load ptr, ptr %148, align 8
  %150 = load ptr, ptr %134, align 8
  %151 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %150, 0
  %152 = load ptr, ptr %133, align 8
  %153 = insertvalue { ptr, ptr, ptr, i32 } %151, ptr %152, 1
  %154 = load ptr, ptr %132, align 8
  %155 = insertvalue { ptr, ptr, ptr, i32 } %153, ptr %154, 2
  %156 = load i32, ptr %131, align 4
  %157 = insertvalue { ptr, ptr, ptr, i32 } %155, i32 %156, 3
  call void %149(ptr %141, { ptr, ptr, ptr, i32 } %157) #2
  %158 = alloca [1 x ptr], align 8
  store ptr @Stacktrace, ptr %158, align 8
  %159 = load ptr, ptr %158, align 8
  %160 = getelementptr ptr, ptr %159, i32 6
  %161 = load ptr, ptr %160, align 8
  %162 = call { i64, i64 } @size_wrapper(ptr %161, ptr %158)
  %163 = extractvalue { i64, i64 } %162, 0
  %164 = call ptr @bump_malloc(i64 %163)
  %165 = alloca i32, align 4
  %166 = alloca ptr, align 8
  %167 = alloca ptr, align 8
  %168 = alloca ptr, align 8
  store ptr @Stacktrace, ptr %168, align 8
  store ptr %164, ptr %167, align 8
  store i32 10, ptr %165, align 4
  %169 = load ptr, ptr %168, align 8
  %170 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %169, 0
  %171 = load ptr, ptr %167, align 8
  %172 = insertvalue { ptr, ptr, ptr, i32 } %170, ptr %171, 1
  %173 = load ptr, ptr %166, align 8
  %174 = insertvalue { ptr, ptr, ptr, i32 } %172, ptr %173, 2
  %175 = load i32, ptr %165, align 4
  %176 = insertvalue { ptr, ptr, ptr, i32 } %174, i32 %175, 3
  %177 = alloca [0 x ptr], align 8
  %178 = call ptr @llvm.invariant.start.p0(i64 0, ptr %177)
  %179 = call ptr @llvm.invariant.start.p0(i64 48, ptr %169)
  %180 = getelementptr ptr, ptr %169, i32 %175
  %181 = getelementptr ptr, ptr %180, i32 2
  %182 = load ptr, ptr %181, align 8
  %183 = alloca {}, align 8
  %184 = call ptr @behavior_wrapper(ptr %182, { ptr, ptr, ptr, i32 } %176, ptr %183)
  call void %184({ ptr, ptr, ptr, i32 } %176, { ptr, ptr, ptr, i32 } %176, ptr %177)
  %185 = alloca i32, align 4
  %186 = alloca ptr, align 8
  %187 = alloca ptr, align 8
  %188 = alloca ptr, align 8
  %189 = load ptr, ptr %168, align 8
  store ptr %189, ptr %188, align 8
  %190 = load ptr, ptr %167, align 8
  store ptr %190, ptr %187, align 8
  %191 = load ptr, ptr %166, align 8
  store ptr %191, ptr %186, align 8
  %192 = load i32, ptr %165, align 4
  store i32 %192, ptr %185, align 4
  %193 = load ptr, ptr %188, align 8
  %194 = call i32 @get_offset(ptr %193, ptr @Stacktrace)
  store i32 %194, ptr %185, align 4
  %195 = load ptr, ptr %8, align 8
  %196 = load ptr, ptr %7, align 8
  %197 = call ptr @llvm.invariant.start.p0(i64 112, ptr %196)
  %198 = load i32, ptr %6, align 4
  %199 = getelementptr ptr, ptr %196, i32 %198
  %200 = getelementptr ptr, ptr %199, i32 3
  %201 = load ptr, ptr %200, align 8
  %202 = getelementptr { ptr, ptr }, ptr %201, i32 0, i32 1
  %203 = load ptr, ptr %202, align 8
  %204 = load ptr, ptr %188, align 8
  %205 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %204, 0
  %206 = load ptr, ptr %187, align 8
  %207 = insertvalue { ptr, ptr, ptr, i32 } %205, ptr %206, 1
  %208 = load ptr, ptr %186, align 8
  %209 = insertvalue { ptr, ptr, ptr, i32 } %207, ptr %208, 2
  %210 = load i32, ptr %185, align 4
  %211 = insertvalue { ptr, ptr, ptr, i32 } %209, i32 %210, 3
  call void %203(ptr %195, { ptr, ptr, ptr, i32 } %211) #2
  ret void
}

define ptr @Exception_B_init_messageString({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @String, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @String to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 9, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [14 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define void @Exception_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @Exception)
  store i32 %18, ptr %5, align 4
  %19 = alloca i32, align 4
  store i32 0, ptr %19, align 4
  %20 = load ptr, ptr %7, align 8
  %21 = load ptr, ptr %6, align 8
  %22 = call ptr @llvm.invariant.start.p0(i64 112, ptr %21)
  %23 = load i32, ptr %5, align 4
  %24 = getelementptr ptr, ptr %21, i32 %23
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr { ptr, ptr }, ptr %25, i32 0, i32 1
  %27 = load ptr, ptr %26, align 8
  %28 = load i32, ptr %19, align 4
  call void %27(ptr %20, i32 %28) #2
  %29 = alloca i32, align 4
  store i32 7, ptr %29, align 4
  %30 = alloca i64, align 8
  %31 = load i32, ptr %29, align 4
  %32 = sext i32 %31 to i64
  store i64 %32, ptr %30, align 4
  %33 = load i64, ptr %30, align 4
  %34 = alloca ptr, align 8
  %35 = mul i64 %33, ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
  %36 = call ptr @bump_malloc(i64 %35)
  store ptr %36, ptr %34, align 8
  %37 = alloca ptr, align 8
  %38 = getelementptr { ptr }, ptr %34, i32 0, i32 0
  %39 = load ptr, ptr %38, align 8
  store ptr %39, ptr %37, align 8
  %40 = alloca [6 x i8], align 1
  store [6 x i8] c"<None>", ptr %40, align 1
  %41 = alloca i32, align 4
  store i32 0, ptr %41, align 4
  %42 = load ptr, ptr %37, align 8
  %43 = load i64, ptr %41, align 4
  %44 = mul i64 ptrtoint (ptr getelementptr ([6 x i8], ptr null, i32 1) to i64), %43
  %45 = getelementptr i8, ptr %42, i64 %44
  %46 = load <6 x i8>, ptr %40, align 1
  store <6 x i8> %46, ptr %45, align 1
  %47 = alloca i32, align 4
  store i32 6, ptr %47, align 4
  %48 = alloca i32, align 4
  store i32 6, ptr %48, align 4
  %49 = alloca i32, align 4
  store i32 7, ptr %49, align 4
  %50 = alloca [1 x ptr], align 8
  store ptr @String, ptr %50, align 8
  %51 = load ptr, ptr %50, align 8
  %52 = getelementptr ptr, ptr %51, i32 6
  %53 = load ptr, ptr %52, align 8
  %54 = call { i64, i64 } @size_wrapper(ptr %53, ptr %50)
  %55 = extractvalue { i64, i64 } %54, 0
  %56 = call ptr @bump_malloc(i64 %55)
  %57 = alloca i32, align 4
  %58 = alloca ptr, align 8
  %59 = alloca ptr, align 8
  %60 = alloca ptr, align 8
  store ptr @String, ptr %60, align 8
  store ptr %56, ptr %59, align 8
  store i32 10, ptr %57, align 4
  %61 = alloca i32, align 4
  store i32 6, ptr %61, align 4
  %62 = alloca i32, align 4
  store i32 6, ptr %62, align 4
  %63 = alloca i32, align 4
  store i32 7, ptr %63, align 4
  %64 = load ptr, ptr %37, align 8
  %65 = insertvalue { ptr } undef, ptr %64, 0
  %66 = load i32, ptr %61, align 4
  %67 = load i32, ptr %62, align 4
  %68 = load i32, ptr %63, align 4
  %69 = load ptr, ptr %60, align 8
  %70 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %69, 0
  %71 = load ptr, ptr %59, align 8
  %72 = insertvalue { ptr, ptr, ptr, i32 } %70, ptr %71, 1
  %73 = load ptr, ptr %58, align 8
  %74 = insertvalue { ptr, ptr, ptr, i32 } %72, ptr %73, 2
  %75 = load i32, ptr %57, align 4
  %76 = insertvalue { ptr, ptr, ptr, i32 } %74, i32 %75, 3
  %77 = alloca [4 x ptr], align 8
  %78 = getelementptr [4 x ptr], ptr %77, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %78, align 8
  %79 = getelementptr [4 x ptr], ptr %77, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %79, align 8
  %80 = getelementptr [4 x ptr], ptr %77, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %80, align 8
  %81 = getelementptr [4 x ptr], ptr %77, i32 0, i32 3
  store ptr @_parameterization_i32, ptr %81, align 8
  %82 = call ptr @llvm.invariant.start.p0(i64 16, ptr %77)
  %83 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %69)
  %84 = getelementptr ptr, ptr %69, i32 %75
  %85 = getelementptr ptr, ptr %84, i32 12
  %86 = load ptr, ptr %85, align 8
  %87 = alloca { ptr, ptr, ptr, ptr }, align 8
  %88 = getelementptr { ptr, ptr, ptr, ptr }, ptr %87, i32 0, i32 0
  store ptr @buffer_typ, ptr %88, align 8
  %89 = getelementptr { ptr, ptr, ptr, ptr }, ptr %87, i32 0, i32 1
  store ptr @i32_typ, ptr %89, align 8
  %90 = getelementptr { ptr, ptr, ptr, ptr }, ptr %87, i32 0, i32 2
  store ptr @i32_typ, ptr %90, align 8
  %91 = getelementptr { ptr, ptr, ptr, ptr }, ptr %87, i32 0, i32 3
  store ptr @i32_typ, ptr %91, align 8
  %92 = call ptr @behavior_wrapper(ptr %86, { ptr, ptr, ptr, i32 } %76, ptr %87)
  call void %92({ ptr, ptr, ptr, i32 } %76, { ptr, ptr, ptr, i32 } %76, ptr %77, { ptr } %65, i32 %66, i32 %67, i32 %68)
  %93 = alloca i32, align 4
  %94 = alloca ptr, align 8
  %95 = alloca ptr, align 8
  %96 = alloca ptr, align 8
  %97 = load ptr, ptr %60, align 8
  store ptr %97, ptr %96, align 8
  %98 = load ptr, ptr %59, align 8
  store ptr %98, ptr %95, align 8
  %99 = load ptr, ptr %58, align 8
  store ptr %99, ptr %94, align 8
  %100 = load i32, ptr %57, align 4
  store i32 %100, ptr %93, align 4
  %101 = load ptr, ptr %96, align 8
  %102 = call i32 @get_offset(ptr %101, ptr @String)
  store i32 %102, ptr %93, align 4
  %103 = load ptr, ptr %7, align 8
  %104 = load ptr, ptr %6, align 8
  %105 = call ptr @llvm.invariant.start.p0(i64 112, ptr %104)
  %106 = load i32, ptr %5, align 4
  %107 = getelementptr ptr, ptr %104, i32 %106
  %108 = getelementptr ptr, ptr %107, i32 2
  %109 = load ptr, ptr %108, align 8
  %110 = getelementptr { ptr, ptr }, ptr %109, i32 0, i32 1
  %111 = load ptr, ptr %110, align 8
  %112 = load ptr, ptr %96, align 8
  %113 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %112, 0
  %114 = load ptr, ptr %95, align 8
  %115 = insertvalue { ptr, ptr, ptr, i32 } %113, ptr %114, 1
  %116 = load ptr, ptr %94, align 8
  %117 = insertvalue { ptr, ptr, ptr, i32 } %115, ptr %116, 2
  %118 = load i32, ptr %93, align 4
  %119 = insertvalue { ptr, ptr, ptr, i32 } %117, i32 %118, 3
  call void %111(ptr %103, { ptr, ptr, ptr, i32 } %119) #2
  %120 = alloca i32, align 4
  store i32 1, ptr %120, align 4
  %121 = alloca i64, align 8
  %122 = load i32, ptr %120, align 4
  %123 = sext i32 %122 to i64
  store i64 %123, ptr %121, align 4
  %124 = load i64, ptr %121, align 4
  %125 = alloca ptr, align 8
  %126 = mul i64 %124, ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
  %127 = call ptr @bump_malloc(i64 %126)
  store ptr %127, ptr %125, align 8
  %128 = alloca ptr, align 8
  %129 = getelementptr { ptr }, ptr %125, i32 0, i32 0
  %130 = load ptr, ptr %129, align 8
  store ptr %130, ptr %128, align 8
  %131 = alloca [0 x i8], align 1
  store [0 x i8] zeroinitializer, ptr %131, align 1
  %132 = alloca i32, align 4
  store i32 0, ptr %132, align 4
  %133 = alloca i32, align 4
  store i32 0, ptr %133, align 4
  %134 = alloca i32, align 4
  store i32 0, ptr %134, align 4
  %135 = alloca i32, align 4
  store i32 1, ptr %135, align 4
  %136 = alloca [1 x ptr], align 8
  store ptr @String, ptr %136, align 8
  %137 = load ptr, ptr %136, align 8
  %138 = getelementptr ptr, ptr %137, i32 6
  %139 = load ptr, ptr %138, align 8
  %140 = call { i64, i64 } @size_wrapper(ptr %139, ptr %136)
  %141 = extractvalue { i64, i64 } %140, 0
  %142 = call ptr @bump_malloc(i64 %141)
  %143 = alloca i32, align 4
  %144 = alloca ptr, align 8
  %145 = alloca ptr, align 8
  %146 = alloca ptr, align 8
  store ptr @String, ptr %146, align 8
  store ptr %142, ptr %145, align 8
  store i32 10, ptr %143, align 4
  %147 = alloca i32, align 4
  store i32 0, ptr %147, align 4
  %148 = alloca i32, align 4
  store i32 0, ptr %148, align 4
  %149 = alloca i32, align 4
  store i32 1, ptr %149, align 4
  %150 = load ptr, ptr %128, align 8
  %151 = insertvalue { ptr } undef, ptr %150, 0
  %152 = load i32, ptr %147, align 4
  %153 = load i32, ptr %148, align 4
  %154 = load i32, ptr %149, align 4
  %155 = load ptr, ptr %146, align 8
  %156 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %155, 0
  %157 = load ptr, ptr %145, align 8
  %158 = insertvalue { ptr, ptr, ptr, i32 } %156, ptr %157, 1
  %159 = load ptr, ptr %144, align 8
  %160 = insertvalue { ptr, ptr, ptr, i32 } %158, ptr %159, 2
  %161 = load i32, ptr %143, align 4
  %162 = insertvalue { ptr, ptr, ptr, i32 } %160, i32 %161, 3
  %163 = alloca [4 x ptr], align 8
  %164 = getelementptr [4 x ptr], ptr %163, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %164, align 8
  %165 = getelementptr [4 x ptr], ptr %163, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %165, align 8
  %166 = getelementptr [4 x ptr], ptr %163, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %166, align 8
  %167 = getelementptr [4 x ptr], ptr %163, i32 0, i32 3
  store ptr @_parameterization_i32, ptr %167, align 8
  %168 = call ptr @llvm.invariant.start.p0(i64 16, ptr %163)
  %169 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %155)
  %170 = getelementptr ptr, ptr %155, i32 %161
  %171 = getelementptr ptr, ptr %170, i32 12
  %172 = load ptr, ptr %171, align 8
  %173 = alloca { ptr, ptr, ptr, ptr }, align 8
  %174 = getelementptr { ptr, ptr, ptr, ptr }, ptr %173, i32 0, i32 0
  store ptr @buffer_typ, ptr %174, align 8
  %175 = getelementptr { ptr, ptr, ptr, ptr }, ptr %173, i32 0, i32 1
  store ptr @i32_typ, ptr %175, align 8
  %176 = getelementptr { ptr, ptr, ptr, ptr }, ptr %173, i32 0, i32 2
  store ptr @i32_typ, ptr %176, align 8
  %177 = getelementptr { ptr, ptr, ptr, ptr }, ptr %173, i32 0, i32 3
  store ptr @i32_typ, ptr %177, align 8
  %178 = call ptr @behavior_wrapper(ptr %172, { ptr, ptr, ptr, i32 } %162, ptr %173)
  call void %178({ ptr, ptr, ptr, i32 } %162, { ptr, ptr, ptr, i32 } %162, ptr %163, { ptr } %151, i32 %152, i32 %153, i32 %154)
  %179 = alloca i32, align 4
  %180 = alloca ptr, align 8
  %181 = alloca ptr, align 8
  %182 = alloca ptr, align 8
  %183 = load ptr, ptr %146, align 8
  store ptr %183, ptr %182, align 8
  %184 = load ptr, ptr %145, align 8
  store ptr %184, ptr %181, align 8
  %185 = load ptr, ptr %144, align 8
  store ptr %185, ptr %180, align 8
  %186 = load i32, ptr %143, align 4
  store i32 %186, ptr %179, align 4
  %187 = load ptr, ptr %182, align 8
  %188 = call i32 @get_offset(ptr %187, ptr @String)
  store i32 %188, ptr %179, align 4
  %189 = load ptr, ptr %7, align 8
  %190 = load ptr, ptr %6, align 8
  %191 = call ptr @llvm.invariant.start.p0(i64 112, ptr %190)
  %192 = load i32, ptr %5, align 4
  %193 = getelementptr ptr, ptr %190, i32 %192
  %194 = getelementptr ptr, ptr %193, i32 1
  %195 = load ptr, ptr %194, align 8
  %196 = getelementptr { ptr, ptr }, ptr %195, i32 0, i32 1
  %197 = load ptr, ptr %196, align 8
  %198 = load ptr, ptr %182, align 8
  %199 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %198, 0
  %200 = load ptr, ptr %181, align 8
  %201 = insertvalue { ptr, ptr, ptr, i32 } %199, ptr %200, 1
  %202 = load ptr, ptr %180, align 8
  %203 = insertvalue { ptr, ptr, ptr, i32 } %201, ptr %202, 2
  %204 = load i32, ptr %179, align 4
  %205 = insertvalue { ptr, ptr, ptr, i32 } %203, i32 %204, 3
  call void %197(ptr %189, { ptr, ptr, ptr, i32 } %205) #2
  %206 = alloca [1 x ptr], align 8
  store ptr @Stacktrace, ptr %206, align 8
  %207 = load ptr, ptr %206, align 8
  %208 = getelementptr ptr, ptr %207, i32 6
  %209 = load ptr, ptr %208, align 8
  %210 = call { i64, i64 } @size_wrapper(ptr %209, ptr %206)
  %211 = extractvalue { i64, i64 } %210, 0
  %212 = call ptr @bump_malloc(i64 %211)
  %213 = alloca i32, align 4
  %214 = alloca ptr, align 8
  %215 = alloca ptr, align 8
  %216 = alloca ptr, align 8
  store ptr @Stacktrace, ptr %216, align 8
  store ptr %212, ptr %215, align 8
  store i32 10, ptr %213, align 4
  %217 = load ptr, ptr %216, align 8
  %218 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %217, 0
  %219 = load ptr, ptr %215, align 8
  %220 = insertvalue { ptr, ptr, ptr, i32 } %218, ptr %219, 1
  %221 = load ptr, ptr %214, align 8
  %222 = insertvalue { ptr, ptr, ptr, i32 } %220, ptr %221, 2
  %223 = load i32, ptr %213, align 4
  %224 = insertvalue { ptr, ptr, ptr, i32 } %222, i32 %223, 3
  %225 = alloca [0 x ptr], align 8
  %226 = call ptr @llvm.invariant.start.p0(i64 0, ptr %225)
  %227 = call ptr @llvm.invariant.start.p0(i64 48, ptr %217)
  %228 = getelementptr ptr, ptr %217, i32 %223
  %229 = getelementptr ptr, ptr %228, i32 2
  %230 = load ptr, ptr %229, align 8
  %231 = alloca {}, align 8
  %232 = call ptr @behavior_wrapper(ptr %230, { ptr, ptr, ptr, i32 } %224, ptr %231)
  call void %232({ ptr, ptr, ptr, i32 } %224, { ptr, ptr, ptr, i32 } %224, ptr %225)
  %233 = alloca i32, align 4
  %234 = alloca ptr, align 8
  %235 = alloca ptr, align 8
  %236 = alloca ptr, align 8
  %237 = load ptr, ptr %216, align 8
  store ptr %237, ptr %236, align 8
  %238 = load ptr, ptr %215, align 8
  store ptr %238, ptr %235, align 8
  %239 = load ptr, ptr %214, align 8
  store ptr %239, ptr %234, align 8
  %240 = load i32, ptr %213, align 4
  store i32 %240, ptr %233, align 4
  %241 = load ptr, ptr %236, align 8
  %242 = call i32 @get_offset(ptr %241, ptr @Stacktrace)
  store i32 %242, ptr %233, align 4
  %243 = load ptr, ptr %7, align 8
  %244 = load ptr, ptr %6, align 8
  %245 = call ptr @llvm.invariant.start.p0(i64 112, ptr %244)
  %246 = load i32, ptr %5, align 4
  %247 = getelementptr ptr, ptr %244, i32 %246
  %248 = getelementptr ptr, ptr %247, i32 3
  %249 = load ptr, ptr %248, align 8
  %250 = getelementptr { ptr, ptr }, ptr %249, i32 0, i32 1
  %251 = load ptr, ptr %250, align 8
  %252 = load ptr, ptr %236, align 8
  %253 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %252, 0
  %254 = load ptr, ptr %235, align 8
  %255 = insertvalue { ptr, ptr, ptr, i32 } %253, ptr %254, 1
  %256 = load ptr, ptr %234, align 8
  %257 = insertvalue { ptr, ptr, ptr, i32 } %255, ptr %256, 2
  %258 = load i32, ptr %233, align 4
  %259 = insertvalue { ptr, ptr, ptr, i32 } %257, i32 %258, 3
  call void %251(ptr %243, { ptr, ptr, ptr, i32 } %259) #2
  ret void
}

define ptr @Exception_B_init_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 10, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [14 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define void @Exception_set_info_line_numberi32_file_nameString({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, i32 %3, { ptr, ptr, ptr, i32 } %4) {
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %6, align 8
  %7 = alloca i32, align 4
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = alloca ptr, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %8, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 1
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %9, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 2
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %10, align 8
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  store i32 %18, ptr %7, align 4
  %19 = load ptr, ptr %8, align 8
  %20 = call i32 @get_offset(ptr %19, ptr @Exception)
  store i32 %20, ptr %7, align 4
  %21 = alloca i32, align 4
  store i32 %3, ptr %21, align 4
  %22 = load ptr, ptr %9, align 8
  %23 = load ptr, ptr %8, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 112, ptr %23)
  %25 = load i32, ptr %7, align 4
  %26 = getelementptr ptr, ptr %23, i32 %25
  %27 = load ptr, ptr %26, align 8
  %28 = getelementptr { ptr, ptr }, ptr %27, i32 0, i32 1
  %29 = load ptr, ptr %28, align 8
  %30 = load i32, ptr %21, align 4
  call void %29(ptr %22, i32 %30) #2
  %31 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %4, ptr %31, align 8
  %32 = alloca i32, align 4
  %33 = alloca ptr, align 8
  %34 = alloca ptr, align 8
  %35 = alloca ptr, align 8
  %36 = getelementptr { ptr, ptr, ptr, i32 }, ptr %31, i32 0, i32 0
  %37 = load ptr, ptr %36, align 8
  store ptr %37, ptr %35, align 8
  %38 = getelementptr { ptr, ptr, ptr, i32 }, ptr %31, i32 0, i32 1
  %39 = load ptr, ptr %38, align 8
  store ptr %39, ptr %34, align 8
  %40 = getelementptr { ptr, ptr, ptr, i32 }, ptr %31, i32 0, i32 2
  %41 = load ptr, ptr %40, align 8
  store ptr %41, ptr %33, align 8
  %42 = getelementptr { ptr, ptr, ptr, i32 }, ptr %31, i32 0, i32 3
  %43 = load i32, ptr %42, align 4
  store i32 %43, ptr %32, align 4
  %44 = load ptr, ptr %35, align 8
  %45 = call i32 @get_offset(ptr %44, ptr @String)
  store i32 %45, ptr %32, align 4
  %46 = alloca i32, align 4
  %47 = alloca ptr, align 8
  %48 = alloca ptr, align 8
  %49 = alloca ptr, align 8
  %50 = load ptr, ptr %35, align 8
  store ptr %50, ptr %49, align 8
  %51 = load ptr, ptr %34, align 8
  store ptr %51, ptr %48, align 8
  %52 = load ptr, ptr %33, align 8
  store ptr %52, ptr %47, align 8
  %53 = load i32, ptr %32, align 4
  store i32 %53, ptr %46, align 4
  %54 = load ptr, ptr %49, align 8
  %55 = call i32 @get_offset(ptr %54, ptr @String)
  store i32 %55, ptr %46, align 4
  %56 = load ptr, ptr %9, align 8
  %57 = load ptr, ptr %8, align 8
  %58 = call ptr @llvm.invariant.start.p0(i64 112, ptr %57)
  %59 = load i32, ptr %7, align 4
  %60 = getelementptr ptr, ptr %57, i32 %59
  %61 = getelementptr ptr, ptr %60, i32 1
  %62 = load ptr, ptr %61, align 8
  %63 = getelementptr { ptr, ptr }, ptr %62, i32 0, i32 1
  %64 = load ptr, ptr %63, align 8
  %65 = load ptr, ptr %49, align 8
  %66 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %65, 0
  %67 = load ptr, ptr %48, align 8
  %68 = insertvalue { ptr, ptr, ptr, i32 } %66, ptr %67, 1
  %69 = load ptr, ptr %47, align 8
  %70 = insertvalue { ptr, ptr, ptr, i32 } %68, ptr %69, 2
  %71 = load i32, ptr %46, align 4
  %72 = insertvalue { ptr, ptr, ptr, i32 } %70, i32 %71, 3
  call void %64(ptr %56, { ptr, ptr, ptr, i32 } %72) #2
  ret void
}

define ptr @Exception_B_set_info_line_numberi32_file_nameString({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = ptrtoint ptr %7 to i64
  %9 = icmp eq i64 %8, ptrtoint (ptr @i32_typ to i64)
  %10 = zext i1 %9 to i8
  store i8 %10, ptr %4, align 1
  %11 = getelementptr ptr, ptr %1, i32 1
  %12 = load ptr, ptr %11, align 8
  %13 = getelementptr { [3 x i64], [3 x ptr] }, ptr %12, i32 0, i32 0, i32 1
  %14 = getelementptr { [3 x i64], [3 x ptr] }, ptr %12, i32 0, i32 0, i32 2
  %15 = getelementptr { [3 x i64], [3 x ptr] }, ptr %12, i32 0, i32 1, i32 0
  %16 = getelementptr { [3 x i64], [3 x ptr] }, ptr %12, i32 0, i32 1, i32 1
  %17 = load i64, ptr %13, align 4
  %18 = load i64, ptr %14, align 4
  %19 = load ptr, ptr %15, align 8
  %20 = load ptr, ptr %16, align 8
  %21 = load i64, ptr @String, align 4
  %22 = call i1 @subtype_test_wrapper(ptr %19, i64 %18, i64 %17, i64 %21, i64 ptrtoint (ptr @String to i64), ptr %20)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 11, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [14 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define void @Exception_report_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @Exception)
  store i32 %18, ptr %5, align 4
  %19 = alloca i32, align 4
  store i32 10, ptr %19, align 4
  %20 = alloca i64, align 8
  %21 = load i32, ptr %19, align 4
  %22 = sext i32 %21 to i64
  store i64 %22, ptr %20, align 4
  %23 = load i64, ptr %20, align 4
  %24 = alloca ptr, align 8
  %25 = mul i64 %23, ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
  %26 = call ptr @bump_malloc(i64 %25)
  store ptr %26, ptr %24, align 8
  %27 = alloca ptr, align 8
  %28 = getelementptr { ptr }, ptr %24, i32 0, i32 0
  %29 = load ptr, ptr %28, align 8
  store ptr %29, ptr %27, align 8
  %30 = alloca [9 x i8], align 1
  store [9 x i8] c"---------", ptr %30, align 1
  %31 = alloca i32, align 4
  store i32 0, ptr %31, align 4
  %32 = load ptr, ptr %27, align 8
  %33 = load i64, ptr %31, align 4
  %34 = mul i64 ptrtoint (ptr getelementptr ([9 x i8], ptr null, i32 1) to i64), %33
  %35 = getelementptr i8, ptr %32, i64 %34
  %36 = load <9 x i8>, ptr %30, align 1
  store <9 x i8> %36, ptr %35, align 1
  %37 = alloca i32, align 4
  store i32 9, ptr %37, align 4
  %38 = alloca i32, align 4
  store i32 9, ptr %38, align 4
  %39 = alloca i32, align 4
  store i32 10, ptr %39, align 4
  %40 = alloca [1 x ptr], align 8
  store ptr @String, ptr %40, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = getelementptr ptr, ptr %41, i32 6
  %43 = load ptr, ptr %42, align 8
  %44 = call { i64, i64 } @size_wrapper(ptr %43, ptr %40)
  %45 = extractvalue { i64, i64 } %44, 0
  %46 = call ptr @bump_malloc(i64 %45)
  %47 = alloca i32, align 4
  %48 = alloca ptr, align 8
  %49 = alloca ptr, align 8
  %50 = alloca ptr, align 8
  store ptr @String, ptr %50, align 8
  store ptr %46, ptr %49, align 8
  store i32 10, ptr %47, align 4
  %51 = alloca i32, align 4
  store i32 9, ptr %51, align 4
  %52 = alloca i32, align 4
  store i32 9, ptr %52, align 4
  %53 = alloca i32, align 4
  store i32 10, ptr %53, align 4
  %54 = load ptr, ptr %27, align 8
  %55 = insertvalue { ptr } undef, ptr %54, 0
  %56 = load i32, ptr %51, align 4
  %57 = load i32, ptr %52, align 4
  %58 = load i32, ptr %53, align 4
  %59 = load ptr, ptr %50, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %59, 0
  %61 = load ptr, ptr %49, align 8
  %62 = insertvalue { ptr, ptr, ptr, i32 } %60, ptr %61, 1
  %63 = load ptr, ptr %48, align 8
  %64 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %63, 2
  %65 = load i32, ptr %47, align 4
  %66 = insertvalue { ptr, ptr, ptr, i32 } %64, i32 %65, 3
  %67 = alloca [4 x ptr], align 8
  %68 = getelementptr [4 x ptr], ptr %67, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %68, align 8
  %69 = getelementptr [4 x ptr], ptr %67, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %69, align 8
  %70 = getelementptr [4 x ptr], ptr %67, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %70, align 8
  %71 = getelementptr [4 x ptr], ptr %67, i32 0, i32 3
  store ptr @_parameterization_i32, ptr %71, align 8
  %72 = call ptr @llvm.invariant.start.p0(i64 16, ptr %67)
  %73 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %59)
  %74 = getelementptr ptr, ptr %59, i32 %65
  %75 = getelementptr ptr, ptr %74, i32 12
  %76 = load ptr, ptr %75, align 8
  %77 = alloca { ptr, ptr, ptr, ptr }, align 8
  %78 = getelementptr { ptr, ptr, ptr, ptr }, ptr %77, i32 0, i32 0
  store ptr @buffer_typ, ptr %78, align 8
  %79 = getelementptr { ptr, ptr, ptr, ptr }, ptr %77, i32 0, i32 1
  store ptr @i32_typ, ptr %79, align 8
  %80 = getelementptr { ptr, ptr, ptr, ptr }, ptr %77, i32 0, i32 2
  store ptr @i32_typ, ptr %80, align 8
  %81 = getelementptr { ptr, ptr, ptr, ptr }, ptr %77, i32 0, i32 3
  store ptr @i32_typ, ptr %81, align 8
  %82 = call ptr @behavior_wrapper(ptr %76, { ptr, ptr, ptr, i32 } %66, ptr %77)
  call void %82({ ptr, ptr, ptr, i32 } %66, { ptr, ptr, ptr, i32 } %66, ptr %67, { ptr } %55, i32 %56, i32 %57, i32 %58)
  %83 = load ptr, ptr %50, align 8
  %84 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %83, 0
  %85 = load ptr, ptr %49, align 8
  %86 = insertvalue { ptr, ptr, ptr, i32 } %84, ptr %85, 1
  %87 = load ptr, ptr %48, align 8
  %88 = insertvalue { ptr, ptr, ptr, i32 } %86, ptr %87, 2
  %89 = load i32, ptr %47, align 4
  %90 = insertvalue { ptr, ptr, ptr, i32 } %88, i32 %89, 3
  %91 = alloca [0 x ptr], align 8
  %92 = call ptr @llvm.invariant.start.p0(i64 0, ptr %91)
  %93 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %83)
  %94 = getelementptr ptr, ptr %83, i32 %89
  %95 = getelementptr ptr, ptr %94, i32 13
  %96 = load ptr, ptr %95, align 8
  %97 = alloca {}, align 8
  %98 = call ptr @behavior_wrapper(ptr %96, { ptr, ptr, ptr, i32 } %90, ptr %97)
  %99 = call { ptr } %98({ ptr, ptr, ptr, i32 } %90, { ptr, ptr, ptr, i32 } %90, ptr %91)
  %100 = alloca ptr, align 8
  store { ptr } %99, ptr %100, align 8
  %101 = load ptr, ptr %100, align 8
  %102 = call i32 (ptr, ...) @printf(ptr @string_string, ptr %101)
  %103 = alloca i32, align 4
  store i32 27, ptr %103, align 4
  %104 = alloca i64, align 8
  %105 = load i32, ptr %103, align 4
  %106 = sext i32 %105 to i64
  store i64 %106, ptr %104, align 4
  %107 = load i64, ptr %104, align 4
  %108 = alloca ptr, align 8
  %109 = mul i64 %107, ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
  %110 = call ptr @bump_malloc(i64 %109)
  store ptr %110, ptr %108, align 8
  %111 = alloca ptr, align 8
  %112 = getelementptr { ptr }, ptr %108, i32 0, i32 0
  %113 = load ptr, ptr %112, align 8
  store ptr %113, ptr %111, align 8
  %114 = alloca [26 x i8], align 1
  store [26 x i8] c"Exception thrown from file", ptr %114, align 1
  %115 = alloca i32, align 4
  store i32 0, ptr %115, align 4
  %116 = load ptr, ptr %111, align 8
  %117 = load i64, ptr %115, align 4
  %118 = mul i64 ptrtoint (ptr getelementptr ([26 x i8], ptr null, i32 1) to i64), %117
  %119 = getelementptr i8, ptr %116, i64 %118
  %120 = load <26 x i8>, ptr %114, align 1
  store <26 x i8> %120, ptr %119, align 1
  %121 = alloca i32, align 4
  store i32 26, ptr %121, align 4
  %122 = alloca i32, align 4
  store i32 26, ptr %122, align 4
  %123 = alloca i32, align 4
  store i32 27, ptr %123, align 4
  %124 = alloca [1 x ptr], align 8
  store ptr @String, ptr %124, align 8
  %125 = load ptr, ptr %124, align 8
  %126 = getelementptr ptr, ptr %125, i32 6
  %127 = load ptr, ptr %126, align 8
  %128 = call { i64, i64 } @size_wrapper(ptr %127, ptr %124)
  %129 = extractvalue { i64, i64 } %128, 0
  %130 = call ptr @bump_malloc(i64 %129)
  %131 = alloca i32, align 4
  %132 = alloca ptr, align 8
  %133 = alloca ptr, align 8
  %134 = alloca ptr, align 8
  store ptr @String, ptr %134, align 8
  store ptr %130, ptr %133, align 8
  store i32 10, ptr %131, align 4
  %135 = alloca i32, align 4
  store i32 26, ptr %135, align 4
  %136 = alloca i32, align 4
  store i32 26, ptr %136, align 4
  %137 = alloca i32, align 4
  store i32 27, ptr %137, align 4
  %138 = load ptr, ptr %111, align 8
  %139 = insertvalue { ptr } undef, ptr %138, 0
  %140 = load i32, ptr %135, align 4
  %141 = load i32, ptr %136, align 4
  %142 = load i32, ptr %137, align 4
  %143 = load ptr, ptr %134, align 8
  %144 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %143, 0
  %145 = load ptr, ptr %133, align 8
  %146 = insertvalue { ptr, ptr, ptr, i32 } %144, ptr %145, 1
  %147 = load ptr, ptr %132, align 8
  %148 = insertvalue { ptr, ptr, ptr, i32 } %146, ptr %147, 2
  %149 = load i32, ptr %131, align 4
  %150 = insertvalue { ptr, ptr, ptr, i32 } %148, i32 %149, 3
  %151 = alloca [4 x ptr], align 8
  %152 = getelementptr [4 x ptr], ptr %151, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %152, align 8
  %153 = getelementptr [4 x ptr], ptr %151, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %153, align 8
  %154 = getelementptr [4 x ptr], ptr %151, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %154, align 8
  %155 = getelementptr [4 x ptr], ptr %151, i32 0, i32 3
  store ptr @_parameterization_i32, ptr %155, align 8
  %156 = call ptr @llvm.invariant.start.p0(i64 16, ptr %151)
  %157 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %143)
  %158 = getelementptr ptr, ptr %143, i32 %149
  %159 = getelementptr ptr, ptr %158, i32 12
  %160 = load ptr, ptr %159, align 8
  %161 = alloca { ptr, ptr, ptr, ptr }, align 8
  %162 = getelementptr { ptr, ptr, ptr, ptr }, ptr %161, i32 0, i32 0
  store ptr @buffer_typ, ptr %162, align 8
  %163 = getelementptr { ptr, ptr, ptr, ptr }, ptr %161, i32 0, i32 1
  store ptr @i32_typ, ptr %163, align 8
  %164 = getelementptr { ptr, ptr, ptr, ptr }, ptr %161, i32 0, i32 2
  store ptr @i32_typ, ptr %164, align 8
  %165 = getelementptr { ptr, ptr, ptr, ptr }, ptr %161, i32 0, i32 3
  store ptr @i32_typ, ptr %165, align 8
  %166 = call ptr @behavior_wrapper(ptr %160, { ptr, ptr, ptr, i32 } %150, ptr %161)
  call void %166({ ptr, ptr, ptr, i32 } %150, { ptr, ptr, ptr, i32 } %150, ptr %151, { ptr } %139, i32 %140, i32 %141, i32 %142)
  %167 = load ptr, ptr %134, align 8
  %168 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %167, 0
  %169 = load ptr, ptr %133, align 8
  %170 = insertvalue { ptr, ptr, ptr, i32 } %168, ptr %169, 1
  %171 = load ptr, ptr %132, align 8
  %172 = insertvalue { ptr, ptr, ptr, i32 } %170, ptr %171, 2
  %173 = load i32, ptr %131, align 4
  %174 = insertvalue { ptr, ptr, ptr, i32 } %172, i32 %173, 3
  %175 = alloca [0 x ptr], align 8
  %176 = call ptr @llvm.invariant.start.p0(i64 0, ptr %175)
  %177 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %167)
  %178 = getelementptr ptr, ptr %167, i32 %173
  %179 = getelementptr ptr, ptr %178, i32 13
  %180 = load ptr, ptr %179, align 8
  %181 = alloca {}, align 8
  %182 = call ptr @behavior_wrapper(ptr %180, { ptr, ptr, ptr, i32 } %174, ptr %181)
  %183 = call { ptr } %182({ ptr, ptr, ptr, i32 } %174, { ptr, ptr, ptr, i32 } %174, ptr %175)
  %184 = alloca ptr, align 8
  store { ptr } %183, ptr %184, align 8
  %185 = load ptr, ptr %184, align 8
  %186 = call i32 (ptr, ...) @printf(ptr @string_string, ptr %185)
  %187 = load ptr, ptr %7, align 8
  %188 = load ptr, ptr %6, align 8
  %189 = call ptr @llvm.invariant.start.p0(i64 112, ptr %188)
  %190 = load i32, ptr %5, align 4
  %191 = getelementptr ptr, ptr %188, i32 %190
  %192 = getelementptr ptr, ptr %191, i32 1
  %193 = load ptr, ptr %192, align 8
  %194 = getelementptr { ptr, ptr }, ptr %193, i32 0, i32 0
  %195 = load ptr, ptr %194, align 8
  %196 = call { ptr, ptr, ptr, i32 } %195(ptr %187) #1
  %197 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %196, ptr %197, align 8
  call void @assume_offset(ptr %197, ptr @String)
  %198 = getelementptr { ptr, ptr, ptr, i32 }, ptr %197, i32 0, i32 0
  %199 = load ptr, ptr %198, align 8
  %200 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %199, 0
  %201 = getelementptr { ptr, ptr, ptr, i32 }, ptr %197, i32 0, i32 1
  %202 = load ptr, ptr %201, align 8
  %203 = insertvalue { ptr, ptr, ptr, i32 } %200, ptr %202, 1
  %204 = getelementptr { ptr, ptr, ptr, i32 }, ptr %197, i32 0, i32 2
  %205 = load ptr, ptr %204, align 8
  %206 = insertvalue { ptr, ptr, ptr, i32 } %203, ptr %205, 2
  %207 = getelementptr { ptr, ptr, ptr, i32 }, ptr %197, i32 0, i32 3
  %208 = load i32, ptr %207, align 4
  %209 = insertvalue { ptr, ptr, ptr, i32 } %206, i32 %208, 3
  %210 = alloca [0 x ptr], align 8
  %211 = call ptr @llvm.invariant.start.p0(i64 0, ptr %210)
  %212 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %199)
  %213 = getelementptr ptr, ptr %199, i32 %208
  %214 = getelementptr ptr, ptr %213, i32 13
  %215 = load ptr, ptr %214, align 8
  %216 = alloca {}, align 8
  %217 = call ptr @behavior_wrapper(ptr %215, { ptr, ptr, ptr, i32 } %209, ptr %216)
  %218 = call { ptr } %217({ ptr, ptr, ptr, i32 } %209, { ptr, ptr, ptr, i32 } %209, ptr %210)
  %219 = alloca ptr, align 8
  store { ptr } %218, ptr %219, align 8
  %220 = load ptr, ptr %219, align 8
  %221 = call i32 (ptr, ...) @printf(ptr @string_string, ptr %220)
  %222 = alloca i32, align 4
  store i32 8, ptr %222, align 4
  %223 = alloca i64, align 8
  %224 = load i32, ptr %222, align 4
  %225 = sext i32 %224 to i64
  store i64 %225, ptr %223, align 4
  %226 = load i64, ptr %223, align 4
  %227 = alloca ptr, align 8
  %228 = mul i64 %226, ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
  %229 = call ptr @bump_malloc(i64 %228)
  store ptr %229, ptr %227, align 8
  %230 = alloca ptr, align 8
  %231 = getelementptr { ptr }, ptr %227, i32 0, i32 0
  %232 = load ptr, ptr %231, align 8
  store ptr %232, ptr %230, align 8
  %233 = alloca [7 x i8], align 1
  store [7 x i8] c"At line", ptr %233, align 1
  %234 = alloca i32, align 4
  store i32 0, ptr %234, align 4
  %235 = load ptr, ptr %230, align 8
  %236 = load i64, ptr %234, align 4
  %237 = mul i64 ptrtoint (ptr getelementptr ([7 x i8], ptr null, i32 1) to i64), %236
  %238 = getelementptr i8, ptr %235, i64 %237
  %239 = load <7 x i8>, ptr %233, align 1
  store <7 x i8> %239, ptr %238, align 1
  %240 = alloca i32, align 4
  store i32 7, ptr %240, align 4
  %241 = alloca i32, align 4
  store i32 7, ptr %241, align 4
  %242 = alloca i32, align 4
  store i32 8, ptr %242, align 4
  %243 = alloca [1 x ptr], align 8
  store ptr @String, ptr %243, align 8
  %244 = load ptr, ptr %243, align 8
  %245 = getelementptr ptr, ptr %244, i32 6
  %246 = load ptr, ptr %245, align 8
  %247 = call { i64, i64 } @size_wrapper(ptr %246, ptr %243)
  %248 = extractvalue { i64, i64 } %247, 0
  %249 = call ptr @bump_malloc(i64 %248)
  %250 = alloca i32, align 4
  %251 = alloca ptr, align 8
  %252 = alloca ptr, align 8
  %253 = alloca ptr, align 8
  store ptr @String, ptr %253, align 8
  store ptr %249, ptr %252, align 8
  store i32 10, ptr %250, align 4
  %254 = alloca i32, align 4
  store i32 7, ptr %254, align 4
  %255 = alloca i32, align 4
  store i32 7, ptr %255, align 4
  %256 = alloca i32, align 4
  store i32 8, ptr %256, align 4
  %257 = load ptr, ptr %230, align 8
  %258 = insertvalue { ptr } undef, ptr %257, 0
  %259 = load i32, ptr %254, align 4
  %260 = load i32, ptr %255, align 4
  %261 = load i32, ptr %256, align 4
  %262 = load ptr, ptr %253, align 8
  %263 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %262, 0
  %264 = load ptr, ptr %252, align 8
  %265 = insertvalue { ptr, ptr, ptr, i32 } %263, ptr %264, 1
  %266 = load ptr, ptr %251, align 8
  %267 = insertvalue { ptr, ptr, ptr, i32 } %265, ptr %266, 2
  %268 = load i32, ptr %250, align 4
  %269 = insertvalue { ptr, ptr, ptr, i32 } %267, i32 %268, 3
  %270 = alloca [4 x ptr], align 8
  %271 = getelementptr [4 x ptr], ptr %270, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %271, align 8
  %272 = getelementptr [4 x ptr], ptr %270, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %272, align 8
  %273 = getelementptr [4 x ptr], ptr %270, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %273, align 8
  %274 = getelementptr [4 x ptr], ptr %270, i32 0, i32 3
  store ptr @_parameterization_i32, ptr %274, align 8
  %275 = call ptr @llvm.invariant.start.p0(i64 16, ptr %270)
  %276 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %262)
  %277 = getelementptr ptr, ptr %262, i32 %268
  %278 = getelementptr ptr, ptr %277, i32 12
  %279 = load ptr, ptr %278, align 8
  %280 = alloca { ptr, ptr, ptr, ptr }, align 8
  %281 = getelementptr { ptr, ptr, ptr, ptr }, ptr %280, i32 0, i32 0
  store ptr @buffer_typ, ptr %281, align 8
  %282 = getelementptr { ptr, ptr, ptr, ptr }, ptr %280, i32 0, i32 1
  store ptr @i32_typ, ptr %282, align 8
  %283 = getelementptr { ptr, ptr, ptr, ptr }, ptr %280, i32 0, i32 2
  store ptr @i32_typ, ptr %283, align 8
  %284 = getelementptr { ptr, ptr, ptr, ptr }, ptr %280, i32 0, i32 3
  store ptr @i32_typ, ptr %284, align 8
  %285 = call ptr @behavior_wrapper(ptr %279, { ptr, ptr, ptr, i32 } %269, ptr %280)
  call void %285({ ptr, ptr, ptr, i32 } %269, { ptr, ptr, ptr, i32 } %269, ptr %270, { ptr } %258, i32 %259, i32 %260, i32 %261)
  %286 = load ptr, ptr %253, align 8
  %287 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %286, 0
  %288 = load ptr, ptr %252, align 8
  %289 = insertvalue { ptr, ptr, ptr, i32 } %287, ptr %288, 1
  %290 = load ptr, ptr %251, align 8
  %291 = insertvalue { ptr, ptr, ptr, i32 } %289, ptr %290, 2
  %292 = load i32, ptr %250, align 4
  %293 = insertvalue { ptr, ptr, ptr, i32 } %291, i32 %292, 3
  %294 = alloca [0 x ptr], align 8
  %295 = call ptr @llvm.invariant.start.p0(i64 0, ptr %294)
  %296 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %286)
  %297 = getelementptr ptr, ptr %286, i32 %292
  %298 = getelementptr ptr, ptr %297, i32 13
  %299 = load ptr, ptr %298, align 8
  %300 = alloca {}, align 8
  %301 = call ptr @behavior_wrapper(ptr %299, { ptr, ptr, ptr, i32 } %293, ptr %300)
  %302 = call { ptr } %301({ ptr, ptr, ptr, i32 } %293, { ptr, ptr, ptr, i32 } %293, ptr %294)
  %303 = alloca ptr, align 8
  store { ptr } %302, ptr %303, align 8
  %304 = load ptr, ptr %303, align 8
  %305 = call i32 (ptr, ...) @printf(ptr @string_string, ptr %304)
  %306 = load ptr, ptr %7, align 8
  %307 = load ptr, ptr %6, align 8
  %308 = call ptr @llvm.invariant.start.p0(i64 112, ptr %307)
  %309 = load i32, ptr %5, align 4
  %310 = getelementptr ptr, ptr %307, i32 %309
  %311 = load ptr, ptr %310, align 8
  %312 = getelementptr { ptr, ptr }, ptr %311, i32 0, i32 0
  %313 = load ptr, ptr %312, align 8
  %314 = call i32 %313(ptr %306) #1
  %315 = alloca i32, align 4
  store i32 %314, ptr %315, align 4
  %316 = load i32, ptr %315, align 4
  %317 = call i32 (ptr, ...) @printf(ptr @i32_string, i32 %316)
  %318 = alloca i32, align 4
  store i32 13, ptr %318, align 4
  %319 = alloca i64, align 8
  %320 = load i32, ptr %318, align 4
  %321 = sext i32 %320 to i64
  store i64 %321, ptr %319, align 4
  %322 = load i64, ptr %319, align 4
  %323 = alloca ptr, align 8
  %324 = mul i64 %322, ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
  %325 = call ptr @bump_malloc(i64 %324)
  store ptr %325, ptr %323, align 8
  %326 = alloca ptr, align 8
  %327 = getelementptr { ptr }, ptr %323, i32 0, i32 0
  %328 = load ptr, ptr %327, align 8
  store ptr %328, ptr %326, align 8
  %329 = alloca [12 x i8], align 1
  store [12 x i8] c"With message", ptr %329, align 1
  %330 = alloca i32, align 4
  store i32 0, ptr %330, align 4
  %331 = load ptr, ptr %326, align 8
  %332 = load i64, ptr %330, align 4
  %333 = mul i64 ptrtoint (ptr getelementptr ([12 x i8], ptr null, i32 1) to i64), %332
  %334 = getelementptr i8, ptr %331, i64 %333
  %335 = load <12 x i8>, ptr %329, align 1
  store <12 x i8> %335, ptr %334, align 1
  %336 = alloca i32, align 4
  store i32 12, ptr %336, align 4
  %337 = alloca i32, align 4
  store i32 12, ptr %337, align 4
  %338 = alloca i32, align 4
  store i32 13, ptr %338, align 4
  %339 = alloca [1 x ptr], align 8
  store ptr @String, ptr %339, align 8
  %340 = load ptr, ptr %339, align 8
  %341 = getelementptr ptr, ptr %340, i32 6
  %342 = load ptr, ptr %341, align 8
  %343 = call { i64, i64 } @size_wrapper(ptr %342, ptr %339)
  %344 = extractvalue { i64, i64 } %343, 0
  %345 = call ptr @bump_malloc(i64 %344)
  %346 = alloca i32, align 4
  %347 = alloca ptr, align 8
  %348 = alloca ptr, align 8
  %349 = alloca ptr, align 8
  store ptr @String, ptr %349, align 8
  store ptr %345, ptr %348, align 8
  store i32 10, ptr %346, align 4
  %350 = alloca i32, align 4
  store i32 12, ptr %350, align 4
  %351 = alloca i32, align 4
  store i32 12, ptr %351, align 4
  %352 = alloca i32, align 4
  store i32 13, ptr %352, align 4
  %353 = load ptr, ptr %326, align 8
  %354 = insertvalue { ptr } undef, ptr %353, 0
  %355 = load i32, ptr %350, align 4
  %356 = load i32, ptr %351, align 4
  %357 = load i32, ptr %352, align 4
  %358 = load ptr, ptr %349, align 8
  %359 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %358, 0
  %360 = load ptr, ptr %348, align 8
  %361 = insertvalue { ptr, ptr, ptr, i32 } %359, ptr %360, 1
  %362 = load ptr, ptr %347, align 8
  %363 = insertvalue { ptr, ptr, ptr, i32 } %361, ptr %362, 2
  %364 = load i32, ptr %346, align 4
  %365 = insertvalue { ptr, ptr, ptr, i32 } %363, i32 %364, 3
  %366 = alloca [4 x ptr], align 8
  %367 = getelementptr [4 x ptr], ptr %366, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %367, align 8
  %368 = getelementptr [4 x ptr], ptr %366, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %368, align 8
  %369 = getelementptr [4 x ptr], ptr %366, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %369, align 8
  %370 = getelementptr [4 x ptr], ptr %366, i32 0, i32 3
  store ptr @_parameterization_i32, ptr %370, align 8
  %371 = call ptr @llvm.invariant.start.p0(i64 16, ptr %366)
  %372 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %358)
  %373 = getelementptr ptr, ptr %358, i32 %364
  %374 = getelementptr ptr, ptr %373, i32 12
  %375 = load ptr, ptr %374, align 8
  %376 = alloca { ptr, ptr, ptr, ptr }, align 8
  %377 = getelementptr { ptr, ptr, ptr, ptr }, ptr %376, i32 0, i32 0
  store ptr @buffer_typ, ptr %377, align 8
  %378 = getelementptr { ptr, ptr, ptr, ptr }, ptr %376, i32 0, i32 1
  store ptr @i32_typ, ptr %378, align 8
  %379 = getelementptr { ptr, ptr, ptr, ptr }, ptr %376, i32 0, i32 2
  store ptr @i32_typ, ptr %379, align 8
  %380 = getelementptr { ptr, ptr, ptr, ptr }, ptr %376, i32 0, i32 3
  store ptr @i32_typ, ptr %380, align 8
  %381 = call ptr @behavior_wrapper(ptr %375, { ptr, ptr, ptr, i32 } %365, ptr %376)
  call void %381({ ptr, ptr, ptr, i32 } %365, { ptr, ptr, ptr, i32 } %365, ptr %366, { ptr } %354, i32 %355, i32 %356, i32 %357)
  %382 = load ptr, ptr %349, align 8
  %383 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %382, 0
  %384 = load ptr, ptr %348, align 8
  %385 = insertvalue { ptr, ptr, ptr, i32 } %383, ptr %384, 1
  %386 = load ptr, ptr %347, align 8
  %387 = insertvalue { ptr, ptr, ptr, i32 } %385, ptr %386, 2
  %388 = load i32, ptr %346, align 4
  %389 = insertvalue { ptr, ptr, ptr, i32 } %387, i32 %388, 3
  %390 = alloca [0 x ptr], align 8
  %391 = call ptr @llvm.invariant.start.p0(i64 0, ptr %390)
  %392 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %382)
  %393 = getelementptr ptr, ptr %382, i32 %388
  %394 = getelementptr ptr, ptr %393, i32 13
  %395 = load ptr, ptr %394, align 8
  %396 = alloca {}, align 8
  %397 = call ptr @behavior_wrapper(ptr %395, { ptr, ptr, ptr, i32 } %389, ptr %396)
  %398 = call { ptr } %397({ ptr, ptr, ptr, i32 } %389, { ptr, ptr, ptr, i32 } %389, ptr %390)
  %399 = alloca ptr, align 8
  store { ptr } %398, ptr %399, align 8
  %400 = load ptr, ptr %399, align 8
  %401 = call i32 (ptr, ...) @printf(ptr @string_string, ptr %400)
  %402 = load ptr, ptr %6, align 8
  %403 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %402, 0
  %404 = load ptr, ptr %7, align 8
  %405 = insertvalue { ptr, ptr, ptr, i32 } %403, ptr %404, 1
  %406 = load ptr, ptr %8, align 8
  %407 = insertvalue { ptr, ptr, ptr, i32 } %405, ptr %406, 2
  %408 = load i32, ptr %5, align 4
  %409 = insertvalue { ptr, ptr, ptr, i32 } %407, i32 %408, 3
  %410 = alloca [0 x ptr], align 8
  %411 = call ptr @llvm.invariant.start.p0(i64 0, ptr %410)
  %412 = call ptr @llvm.invariant.start.p0(i64 112, ptr %402)
  %413 = getelementptr ptr, ptr %402, i32 %408
  %414 = getelementptr ptr, ptr %413, i32 8
  %415 = load ptr, ptr %414, align 8
  %416 = alloca {}, align 8
  %417 = call ptr @behavior_wrapper(ptr %415, { ptr, ptr, ptr, i32 } %409, ptr %416)
  call void %417({ ptr, ptr, ptr, i32 } %409, { ptr, ptr, ptr, i32 } %409, ptr %410)
  %418 = alloca i32, align 4
  store i32 13, ptr %418, align 4
  %419 = alloca i64, align 8
  %420 = load i32, ptr %418, align 4
  %421 = sext i32 %420 to i64
  store i64 %421, ptr %419, align 4
  %422 = load i64, ptr %419, align 4
  %423 = alloca ptr, align 8
  %424 = mul i64 %422, ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
  %425 = call ptr @bump_malloc(i64 %424)
  store ptr %425, ptr %423, align 8
  %426 = alloca ptr, align 8
  %427 = getelementptr { ptr }, ptr %423, i32 0, i32 0
  %428 = load ptr, ptr %427, align 8
  store ptr %428, ptr %426, align 8
  %429 = alloca [12 x i8], align 1
  store [12 x i8] c"Stack trace:", ptr %429, align 1
  %430 = alloca i32, align 4
  store i32 0, ptr %430, align 4
  %431 = load ptr, ptr %426, align 8
  %432 = load i64, ptr %430, align 4
  %433 = mul i64 ptrtoint (ptr getelementptr ([12 x i8], ptr null, i32 1) to i64), %432
  %434 = getelementptr i8, ptr %431, i64 %433
  %435 = load <12 x i8>, ptr %429, align 1
  store <12 x i8> %435, ptr %434, align 1
  %436 = alloca i32, align 4
  store i32 12, ptr %436, align 4
  %437 = alloca i32, align 4
  store i32 12, ptr %437, align 4
  %438 = alloca i32, align 4
  store i32 13, ptr %438, align 4
  %439 = alloca [1 x ptr], align 8
  store ptr @String, ptr %439, align 8
  %440 = load ptr, ptr %439, align 8
  %441 = getelementptr ptr, ptr %440, i32 6
  %442 = load ptr, ptr %441, align 8
  %443 = call { i64, i64 } @size_wrapper(ptr %442, ptr %439)
  %444 = extractvalue { i64, i64 } %443, 0
  %445 = call ptr @bump_malloc(i64 %444)
  %446 = alloca i32, align 4
  %447 = alloca ptr, align 8
  %448 = alloca ptr, align 8
  %449 = alloca ptr, align 8
  store ptr @String, ptr %449, align 8
  store ptr %445, ptr %448, align 8
  store i32 10, ptr %446, align 4
  %450 = alloca i32, align 4
  store i32 12, ptr %450, align 4
  %451 = alloca i32, align 4
  store i32 12, ptr %451, align 4
  %452 = alloca i32, align 4
  store i32 13, ptr %452, align 4
  %453 = load ptr, ptr %426, align 8
  %454 = insertvalue { ptr } undef, ptr %453, 0
  %455 = load i32, ptr %450, align 4
  %456 = load i32, ptr %451, align 4
  %457 = load i32, ptr %452, align 4
  %458 = load ptr, ptr %449, align 8
  %459 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %458, 0
  %460 = load ptr, ptr %448, align 8
  %461 = insertvalue { ptr, ptr, ptr, i32 } %459, ptr %460, 1
  %462 = load ptr, ptr %447, align 8
  %463 = insertvalue { ptr, ptr, ptr, i32 } %461, ptr %462, 2
  %464 = load i32, ptr %446, align 4
  %465 = insertvalue { ptr, ptr, ptr, i32 } %463, i32 %464, 3
  %466 = alloca [4 x ptr], align 8
  %467 = getelementptr [4 x ptr], ptr %466, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %467, align 8
  %468 = getelementptr [4 x ptr], ptr %466, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %468, align 8
  %469 = getelementptr [4 x ptr], ptr %466, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %469, align 8
  %470 = getelementptr [4 x ptr], ptr %466, i32 0, i32 3
  store ptr @_parameterization_i32, ptr %470, align 8
  %471 = call ptr @llvm.invariant.start.p0(i64 16, ptr %466)
  %472 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %458)
  %473 = getelementptr ptr, ptr %458, i32 %464
  %474 = getelementptr ptr, ptr %473, i32 12
  %475 = load ptr, ptr %474, align 8
  %476 = alloca { ptr, ptr, ptr, ptr }, align 8
  %477 = getelementptr { ptr, ptr, ptr, ptr }, ptr %476, i32 0, i32 0
  store ptr @buffer_typ, ptr %477, align 8
  %478 = getelementptr { ptr, ptr, ptr, ptr }, ptr %476, i32 0, i32 1
  store ptr @i32_typ, ptr %478, align 8
  %479 = getelementptr { ptr, ptr, ptr, ptr }, ptr %476, i32 0, i32 2
  store ptr @i32_typ, ptr %479, align 8
  %480 = getelementptr { ptr, ptr, ptr, ptr }, ptr %476, i32 0, i32 3
  store ptr @i32_typ, ptr %480, align 8
  %481 = call ptr @behavior_wrapper(ptr %475, { ptr, ptr, ptr, i32 } %465, ptr %476)
  call void %481({ ptr, ptr, ptr, i32 } %465, { ptr, ptr, ptr, i32 } %465, ptr %466, { ptr } %454, i32 %455, i32 %456, i32 %457)
  %482 = load ptr, ptr %449, align 8
  %483 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %482, 0
  %484 = load ptr, ptr %448, align 8
  %485 = insertvalue { ptr, ptr, ptr, i32 } %483, ptr %484, 1
  %486 = load ptr, ptr %447, align 8
  %487 = insertvalue { ptr, ptr, ptr, i32 } %485, ptr %486, 2
  %488 = load i32, ptr %446, align 4
  %489 = insertvalue { ptr, ptr, ptr, i32 } %487, i32 %488, 3
  %490 = alloca [0 x ptr], align 8
  %491 = call ptr @llvm.invariant.start.p0(i64 0, ptr %490)
  %492 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %482)
  %493 = getelementptr ptr, ptr %482, i32 %488
  %494 = getelementptr ptr, ptr %493, i32 13
  %495 = load ptr, ptr %494, align 8
  %496 = alloca {}, align 8
  %497 = call ptr @behavior_wrapper(ptr %495, { ptr, ptr, ptr, i32 } %489, ptr %496)
  %498 = call { ptr } %497({ ptr, ptr, ptr, i32 } %489, { ptr, ptr, ptr, i32 } %489, ptr %490)
  %499 = alloca ptr, align 8
  store { ptr } %498, ptr %499, align 8
  %500 = load ptr, ptr %499, align 8
  %501 = call i32 (ptr, ...) @printf(ptr @string_string, ptr %500)
  %502 = load ptr, ptr %7, align 8
  %503 = load ptr, ptr %6, align 8
  %504 = call ptr @llvm.invariant.start.p0(i64 112, ptr %503)
  %505 = load i32, ptr %5, align 4
  %506 = getelementptr ptr, ptr %503, i32 %505
  %507 = getelementptr ptr, ptr %506, i32 3
  %508 = load ptr, ptr %507, align 8
  %509 = getelementptr { ptr, ptr }, ptr %508, i32 0, i32 0
  %510 = load ptr, ptr %509, align 8
  %511 = call { ptr, ptr, ptr, i32 } %510(ptr %502) #1
  %512 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %511, ptr %512, align 8
  call void @assume_offset(ptr %512, ptr @Stacktrace)
  %513 = getelementptr { ptr, ptr, ptr, i32 }, ptr %512, i32 0, i32 0
  %514 = load ptr, ptr %513, align 8
  %515 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %514, 0
  %516 = getelementptr { ptr, ptr, ptr, i32 }, ptr %512, i32 0, i32 1
  %517 = load ptr, ptr %516, align 8
  %518 = insertvalue { ptr, ptr, ptr, i32 } %515, ptr %517, 1
  %519 = getelementptr { ptr, ptr, ptr, i32 }, ptr %512, i32 0, i32 2
  %520 = load ptr, ptr %519, align 8
  %521 = insertvalue { ptr, ptr, ptr, i32 } %518, ptr %520, 2
  %522 = getelementptr { ptr, ptr, ptr, i32 }, ptr %512, i32 0, i32 3
  %523 = load i32, ptr %522, align 4
  %524 = insertvalue { ptr, ptr, ptr, i32 } %521, i32 %523, 3
  %525 = alloca [0 x ptr], align 8
  %526 = call ptr @llvm.invariant.start.p0(i64 0, ptr %525)
  %527 = call ptr @llvm.invariant.start.p0(i64 48, ptr %514)
  %528 = getelementptr ptr, ptr %514, i32 %523
  %529 = getelementptr ptr, ptr %528, i32 3
  %530 = load ptr, ptr %529, align 8
  %531 = alloca {}, align 8
  %532 = call ptr @behavior_wrapper(ptr %530, { ptr, ptr, ptr, i32 } %524, ptr %531)
  call void %532({ ptr, ptr, ptr, i32 } %524, { ptr, ptr, ptr, i32 } %524, ptr %525)
  %533 = alloca i32, align 4
  store i32 10, ptr %533, align 4
  %534 = alloca i64, align 8
  %535 = load i32, ptr %533, align 4
  %536 = sext i32 %535 to i64
  store i64 %536, ptr %534, align 4
  %537 = load i64, ptr %534, align 4
  %538 = alloca ptr, align 8
  %539 = mul i64 %537, ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
  %540 = call ptr @bump_malloc(i64 %539)
  store ptr %540, ptr %538, align 8
  %541 = alloca ptr, align 8
  %542 = getelementptr { ptr }, ptr %538, i32 0, i32 0
  %543 = load ptr, ptr %542, align 8
  store ptr %543, ptr %541, align 8
  %544 = alloca [9 x i8], align 1
  store [9 x i8] c"---------", ptr %544, align 1
  %545 = alloca i32, align 4
  store i32 0, ptr %545, align 4
  %546 = load ptr, ptr %541, align 8
  %547 = load i64, ptr %545, align 4
  %548 = mul i64 ptrtoint (ptr getelementptr ([9 x i8], ptr null, i32 1) to i64), %547
  %549 = getelementptr i8, ptr %546, i64 %548
  %550 = load <9 x i8>, ptr %544, align 1
  store <9 x i8> %550, ptr %549, align 1
  %551 = alloca i32, align 4
  store i32 9, ptr %551, align 4
  %552 = alloca i32, align 4
  store i32 9, ptr %552, align 4
  %553 = alloca i32, align 4
  store i32 10, ptr %553, align 4
  %554 = alloca [1 x ptr], align 8
  store ptr @String, ptr %554, align 8
  %555 = load ptr, ptr %554, align 8
  %556 = getelementptr ptr, ptr %555, i32 6
  %557 = load ptr, ptr %556, align 8
  %558 = call { i64, i64 } @size_wrapper(ptr %557, ptr %554)
  %559 = extractvalue { i64, i64 } %558, 0
  %560 = call ptr @bump_malloc(i64 %559)
  %561 = alloca i32, align 4
  %562 = alloca ptr, align 8
  %563 = alloca ptr, align 8
  %564 = alloca ptr, align 8
  store ptr @String, ptr %564, align 8
  store ptr %560, ptr %563, align 8
  store i32 10, ptr %561, align 4
  %565 = alloca i32, align 4
  store i32 9, ptr %565, align 4
  %566 = alloca i32, align 4
  store i32 9, ptr %566, align 4
  %567 = alloca i32, align 4
  store i32 10, ptr %567, align 4
  %568 = load ptr, ptr %541, align 8
  %569 = insertvalue { ptr } undef, ptr %568, 0
  %570 = load i32, ptr %565, align 4
  %571 = load i32, ptr %566, align 4
  %572 = load i32, ptr %567, align 4
  %573 = load ptr, ptr %564, align 8
  %574 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %573, 0
  %575 = load ptr, ptr %563, align 8
  %576 = insertvalue { ptr, ptr, ptr, i32 } %574, ptr %575, 1
  %577 = load ptr, ptr %562, align 8
  %578 = insertvalue { ptr, ptr, ptr, i32 } %576, ptr %577, 2
  %579 = load i32, ptr %561, align 4
  %580 = insertvalue { ptr, ptr, ptr, i32 } %578, i32 %579, 3
  %581 = alloca [4 x ptr], align 8
  %582 = getelementptr [4 x ptr], ptr %581, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %582, align 8
  %583 = getelementptr [4 x ptr], ptr %581, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %583, align 8
  %584 = getelementptr [4 x ptr], ptr %581, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %584, align 8
  %585 = getelementptr [4 x ptr], ptr %581, i32 0, i32 3
  store ptr @_parameterization_i32, ptr %585, align 8
  %586 = call ptr @llvm.invariant.start.p0(i64 16, ptr %581)
  %587 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %573)
  %588 = getelementptr ptr, ptr %573, i32 %579
  %589 = getelementptr ptr, ptr %588, i32 12
  %590 = load ptr, ptr %589, align 8
  %591 = alloca { ptr, ptr, ptr, ptr }, align 8
  %592 = getelementptr { ptr, ptr, ptr, ptr }, ptr %591, i32 0, i32 0
  store ptr @buffer_typ, ptr %592, align 8
  %593 = getelementptr { ptr, ptr, ptr, ptr }, ptr %591, i32 0, i32 1
  store ptr @i32_typ, ptr %593, align 8
  %594 = getelementptr { ptr, ptr, ptr, ptr }, ptr %591, i32 0, i32 2
  store ptr @i32_typ, ptr %594, align 8
  %595 = getelementptr { ptr, ptr, ptr, ptr }, ptr %591, i32 0, i32 3
  store ptr @i32_typ, ptr %595, align 8
  %596 = call ptr @behavior_wrapper(ptr %590, { ptr, ptr, ptr, i32 } %580, ptr %591)
  call void %596({ ptr, ptr, ptr, i32 } %580, { ptr, ptr, ptr, i32 } %580, ptr %581, { ptr } %569, i32 %570, i32 %571, i32 %572)
  %597 = load ptr, ptr %564, align 8
  %598 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %597, 0
  %599 = load ptr, ptr %563, align 8
  %600 = insertvalue { ptr, ptr, ptr, i32 } %598, ptr %599, 1
  %601 = load ptr, ptr %562, align 8
  %602 = insertvalue { ptr, ptr, ptr, i32 } %600, ptr %601, 2
  %603 = load i32, ptr %561, align 4
  %604 = insertvalue { ptr, ptr, ptr, i32 } %602, i32 %603, 3
  %605 = alloca [0 x ptr], align 8
  %606 = call ptr @llvm.invariant.start.p0(i64 0, ptr %605)
  %607 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %597)
  %608 = getelementptr ptr, ptr %597, i32 %603
  %609 = getelementptr ptr, ptr %608, i32 13
  %610 = load ptr, ptr %609, align 8
  %611 = alloca {}, align 8
  %612 = call ptr @behavior_wrapper(ptr %610, { ptr, ptr, ptr, i32 } %604, ptr %611)
  %613 = call { ptr } %612({ ptr, ptr, ptr, i32 } %604, { ptr, ptr, ptr, i32 } %604, ptr %605)
  %614 = alloca ptr, align 8
  store { ptr } %613, ptr %614, align 8
  %615 = load ptr, ptr %614, align 8
  %616 = call i32 (ptr, ...) @printf(ptr @string_string, ptr %615)
  ret void
}

define ptr @Exception_B_report_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 12, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [14 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define void @Exception_print_message_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @Exception)
  store i32 %18, ptr %5, align 4
  %19 = load ptr, ptr %7, align 8
  %20 = load ptr, ptr %6, align 8
  %21 = call ptr @llvm.invariant.start.p0(i64 112, ptr %20)
  %22 = load i32, ptr %5, align 4
  %23 = getelementptr ptr, ptr %20, i32 %22
  %24 = getelementptr ptr, ptr %23, i32 2
  %25 = load ptr, ptr %24, align 8
  %26 = getelementptr { ptr, ptr }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = call { ptr, ptr, ptr, i32 } %27(ptr %19) #1
  %29 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %28, ptr %29, align 8
  call void @assume_offset(ptr %29, ptr @String)
  %30 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %31, 0
  %33 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 1
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } %32, ptr %34, 1
  %36 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 2
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %37, 2
  %39 = getelementptr { ptr, ptr, ptr, i32 }, ptr %29, i32 0, i32 3
  %40 = load i32, ptr %39, align 4
  %41 = insertvalue { ptr, ptr, ptr, i32 } %38, i32 %40, 3
  %42 = alloca [0 x ptr], align 8
  %43 = call ptr @llvm.invariant.start.p0(i64 0, ptr %42)
  %44 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %31)
  %45 = getelementptr ptr, ptr %31, i32 %40
  %46 = getelementptr ptr, ptr %45, i32 13
  %47 = load ptr, ptr %46, align 8
  %48 = alloca {}, align 8
  %49 = call ptr @behavior_wrapper(ptr %47, { ptr, ptr, ptr, i32 } %41, ptr %48)
  %50 = call { ptr } %49({ ptr, ptr, ptr, i32 } %41, { ptr, ptr, ptr, i32 } %41, ptr %42)
  %51 = alloca ptr, align 8
  store { ptr } %50, ptr %51, align 8
  %52 = load ptr, ptr %51, align 8
  %53 = call i32 (ptr, ...) @printf(ptr @string_string, ptr %52)
  ret void
}

define ptr @Exception_B_print_message_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 13, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [14 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { i64, i64 } @_data_size_InvalidUTF8Error(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %10
  %12 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %5
  %13 = select i1 %12, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %5
  %14 = urem i64 %11, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %17
  %19 = add i64 %11, %18
  %20 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %13
  %21 = select i1 %20, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %13
  %22 = urem i64 %19, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %23 = icmp eq i64 %22, 0
  %24 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %22
  %25 = select i1 %23, i64 0, i64 %24
  %26 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %25
  %27 = add i64 %19, %26
  %28 = urem i64 %27, %21
  %29 = icmp eq i64 %28, 0
  %30 = sub i64 %21, %28
  %31 = select i1 %29, i64 0, i64 %30
  %32 = add i64 %27, %31
  %33 = insertvalue { i64, i64 } undef, i64 %32, 0
  %34 = insertvalue { i64, i64 } %33, i64 %21, 1
  ret { i64, i64 } %34
}

define i32 @InvalidUTF8Error_getter_line_number(ptr %0) {
  %2 = getelementptr i8, ptr %0, i64 0
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

define void @InvalidUTF8Error_setter_line_number(ptr %0, i32 %1) {
  %3 = getelementptr i8, ptr %0, i64 0
  %4 = alloca i32, align 4
  store i32 %1, ptr %4, align 4
  %5 = load i32, ptr %4, align 4
  store i32 %5, ptr %3, align 4
  ret void
}

define { ptr, ptr, ptr, i32 } @InvalidUTF8Error_getter_file_name(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %5
  %7 = getelementptr i8, ptr %0, i64 %6
  %8 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %9, 0
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  %13 = insertvalue { ptr, ptr, ptr, i32 } %10, ptr %12, 1
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 2
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } %13, ptr %15, 2
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  %19 = insertvalue { ptr, ptr, ptr, i32 } %16, i32 %18, 3
  ret { ptr, ptr, ptr, i32 } %19
}

define void @InvalidUTF8Error_setter_file_name(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %6
  %8 = getelementptr i8, ptr %0, i64 %7
  %9 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %9, align 8
  %10 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 0
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 0
  %12 = load ptr, ptr %10, align 8
  store ptr %12, ptr %11, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 1
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 1
  %15 = load ptr, ptr %13, align 8
  store ptr %15, ptr %14, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 2
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 2
  %18 = load ptr, ptr %16, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %9, i32 0, i32 3
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %8, i32 0, i32 3
  %21 = load i32, ptr %19, align 4
  store i32 %21, ptr %20, align 4
  ret void
}

define { ptr, ptr, ptr, i32 } @InvalidUTF8Error_getter_message(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %7, %11
  %13 = getelementptr i8, ptr %0, i64 %12
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %15, 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 1
  %18 = load ptr, ptr %17, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %18, 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 2
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %21, 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 3
  %24 = load i32, ptr %23, align 4
  %25 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %24, 3
  ret { ptr, ptr, ptr, i32 } %25
}

define void @InvalidUTF8Error_setter_message(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %8, %12
  %14 = getelementptr i8, ptr %0, i64 %13
  %15 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %15, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 0
  %18 = load ptr, ptr %16, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 1
  %21 = load ptr, ptr %19, align 8
  store ptr %21, ptr %20, align 8
  %22 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 2
  %24 = load ptr, ptr %22, align 8
  store ptr %24, ptr %23, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 3
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 3
  %27 = load i32, ptr %25, align 4
  store i32 %27, ptr %26, align 4
  ret void
}

define { ptr, ptr, ptr, i32 } @InvalidUTF8Error_getter_stacktrace(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %11
  %13 = add i64 %7, %12
  %14 = urem i64 %13, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 %13, %17
  %19 = getelementptr i8, ptr %0, i64 %18
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 0
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %21, 0
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 1
  %24 = load ptr, ptr %23, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %24, 1
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 2
  %27 = load ptr, ptr %26, align 8
  %28 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %27, 2
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 3
  %30 = load i32, ptr %29, align 4
  %31 = insertvalue { ptr, ptr, ptr, i32 } %28, i32 %30, 3
  ret { ptr, ptr, ptr, i32 } %31
}

define void @InvalidUTF8Error_setter_stacktrace(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %12
  %14 = add i64 %8, %13
  %15 = urem i64 %14, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %16 = icmp eq i64 %15, 0
  %17 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add i64 %14, %18
  %20 = getelementptr i8, ptr %0, i64 %19
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %21, align 8
  %22 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 0
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 0
  %24 = load ptr, ptr %22, align 8
  store ptr %24, ptr %23, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 1
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 1
  %27 = load ptr, ptr %25, align 8
  store ptr %27, ptr %26, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 2
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 2
  %30 = load ptr, ptr %28, align 8
  store ptr %30, ptr %29, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 3
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 3
  %33 = load i32, ptr %31, align 4
  store i32 %33, ptr %32, align 4
  ret void
}

define ptr @InvalidUTF8Error_B_init_messageString({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @String, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @String to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 9, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [28 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define void @InvalidUTF8Error_init_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @InvalidUTF8Error)
  store i32 %18, ptr %5, align 4
  %19 = alloca i32, align 4
  store i32 61, ptr %19, align 4
  %20 = alloca i64, align 8
  %21 = load i32, ptr %19, align 4
  %22 = sext i32 %21 to i64
  store i64 %22, ptr %20, align 4
  %23 = load i64, ptr %20, align 4
  %24 = alloca ptr, align 8
  %25 = mul i64 %23, ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
  %26 = call ptr @bump_malloc(i64 %25)
  store ptr %26, ptr %24, align 8
  %27 = alloca ptr, align 8
  %28 = getelementptr { ptr }, ptr %24, i32 0, i32 0
  %29 = load ptr, ptr %28, align 8
  store ptr %29, ptr %27, align 8
  %30 = alloca [60 x i8], align 1
  store [60 x i8] c"Invalid UTF-8 sequence encountered during string conversion.", ptr %30, align 1
  %31 = alloca i32, align 4
  store i32 0, ptr %31, align 4
  %32 = load ptr, ptr %27, align 8
  %33 = load i64, ptr %31, align 4
  %34 = mul i64 ptrtoint (ptr getelementptr ([60 x i8], ptr null, i32 1) to i64), %33
  %35 = getelementptr i8, ptr %32, i64 %34
  %36 = load <60 x i8>, ptr %30, align 1
  store <60 x i8> %36, ptr %35, align 1
  %37 = alloca i32, align 4
  store i32 60, ptr %37, align 4
  %38 = alloca i32, align 4
  store i32 60, ptr %38, align 4
  %39 = alloca i32, align 4
  store i32 61, ptr %39, align 4
  %40 = alloca [1 x ptr], align 8
  store ptr @String, ptr %40, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = getelementptr ptr, ptr %41, i32 6
  %43 = load ptr, ptr %42, align 8
  %44 = call { i64, i64 } @size_wrapper(ptr %43, ptr %40)
  %45 = extractvalue { i64, i64 } %44, 0
  %46 = call ptr @bump_malloc(i64 %45)
  %47 = alloca i32, align 4
  %48 = alloca ptr, align 8
  %49 = alloca ptr, align 8
  %50 = alloca ptr, align 8
  store ptr @String, ptr %50, align 8
  store ptr %46, ptr %49, align 8
  store i32 10, ptr %47, align 4
  %51 = alloca i32, align 4
  store i32 60, ptr %51, align 4
  %52 = alloca i32, align 4
  store i32 60, ptr %52, align 4
  %53 = alloca i32, align 4
  store i32 61, ptr %53, align 4
  %54 = load ptr, ptr %27, align 8
  %55 = insertvalue { ptr } undef, ptr %54, 0
  %56 = load i32, ptr %51, align 4
  %57 = load i32, ptr %52, align 4
  %58 = load i32, ptr %53, align 4
  %59 = load ptr, ptr %50, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %59, 0
  %61 = load ptr, ptr %49, align 8
  %62 = insertvalue { ptr, ptr, ptr, i32 } %60, ptr %61, 1
  %63 = load ptr, ptr %48, align 8
  %64 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %63, 2
  %65 = load i32, ptr %47, align 4
  %66 = insertvalue { ptr, ptr, ptr, i32 } %64, i32 %65, 3
  %67 = alloca [4 x ptr], align 8
  %68 = getelementptr [4 x ptr], ptr %67, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %68, align 8
  %69 = getelementptr [4 x ptr], ptr %67, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %69, align 8
  %70 = getelementptr [4 x ptr], ptr %67, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %70, align 8
  %71 = getelementptr [4 x ptr], ptr %67, i32 0, i32 3
  store ptr @_parameterization_i32, ptr %71, align 8
  %72 = call ptr @llvm.invariant.start.p0(i64 16, ptr %67)
  %73 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %59)
  %74 = getelementptr ptr, ptr %59, i32 %65
  %75 = getelementptr ptr, ptr %74, i32 12
  %76 = load ptr, ptr %75, align 8
  %77 = alloca { ptr, ptr, ptr, ptr }, align 8
  %78 = getelementptr { ptr, ptr, ptr, ptr }, ptr %77, i32 0, i32 0
  store ptr @buffer_typ, ptr %78, align 8
  %79 = getelementptr { ptr, ptr, ptr, ptr }, ptr %77, i32 0, i32 1
  store ptr @i32_typ, ptr %79, align 8
  %80 = getelementptr { ptr, ptr, ptr, ptr }, ptr %77, i32 0, i32 2
  store ptr @i32_typ, ptr %80, align 8
  %81 = getelementptr { ptr, ptr, ptr, ptr }, ptr %77, i32 0, i32 3
  store ptr @i32_typ, ptr %81, align 8
  %82 = call ptr @behavior_wrapper(ptr %76, { ptr, ptr, ptr, i32 } %66, ptr %77)
  call void %82({ ptr, ptr, ptr, i32 } %66, { ptr, ptr, ptr, i32 } %66, ptr %67, { ptr } %55, i32 %56, i32 %57, i32 %58)
  %83 = alloca i32, align 4
  %84 = alloca ptr, align 8
  %85 = alloca ptr, align 8
  %86 = alloca ptr, align 8
  %87 = load ptr, ptr %50, align 8
  store ptr %87, ptr %86, align 8
  %88 = load ptr, ptr %49, align 8
  store ptr %88, ptr %85, align 8
  %89 = load ptr, ptr %48, align 8
  store ptr %89, ptr %84, align 8
  %90 = load i32, ptr %47, align 4
  store i32 %90, ptr %83, align 4
  %91 = load ptr, ptr %86, align 8
  %92 = call i32 @get_offset(ptr %91, ptr @String)
  store i32 %92, ptr %83, align 4
  %93 = load ptr, ptr %7, align 8
  %94 = load ptr, ptr %6, align 8
  %95 = call ptr @llvm.invariant.start.p0(i64 224, ptr %94)
  %96 = load i32, ptr %5, align 4
  %97 = getelementptr ptr, ptr %94, i32 %96
  %98 = getelementptr ptr, ptr %97, i32 2
  %99 = load ptr, ptr %98, align 8
  %100 = getelementptr { ptr, ptr }, ptr %99, i32 0, i32 1
  %101 = load ptr, ptr %100, align 8
  %102 = load ptr, ptr %86, align 8
  %103 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %102, 0
  %104 = load ptr, ptr %85, align 8
  %105 = insertvalue { ptr, ptr, ptr, i32 } %103, ptr %104, 1
  %106 = load ptr, ptr %84, align 8
  %107 = insertvalue { ptr, ptr, ptr, i32 } %105, ptr %106, 2
  %108 = load i32, ptr %83, align 4
  %109 = insertvalue { ptr, ptr, ptr, i32 } %107, i32 %108, 3
  call void %101(ptr %93, { ptr, ptr, ptr, i32 } %109) #2
  %110 = alloca i32, align 4
  store i32 0, ptr %110, align 4
  %111 = load ptr, ptr %7, align 8
  %112 = load ptr, ptr %6, align 8
  %113 = call ptr @llvm.invariant.start.p0(i64 224, ptr %112)
  %114 = load i32, ptr %5, align 4
  %115 = getelementptr ptr, ptr %112, i32 %114
  %116 = load ptr, ptr %115, align 8
  %117 = getelementptr { ptr, ptr }, ptr %116, i32 0, i32 1
  %118 = load ptr, ptr %117, align 8
  %119 = load i32, ptr %110, align 4
  call void %118(ptr %111, i32 %119) #2
  %120 = alloca i32, align 4
  store i32 1, ptr %120, align 4
  %121 = alloca i64, align 8
  %122 = load i32, ptr %120, align 4
  %123 = sext i32 %122 to i64
  store i64 %123, ptr %121, align 4
  %124 = load i64, ptr %121, align 4
  %125 = alloca ptr, align 8
  %126 = mul i64 %124, ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
  %127 = call ptr @bump_malloc(i64 %126)
  store ptr %127, ptr %125, align 8
  %128 = alloca ptr, align 8
  %129 = getelementptr { ptr }, ptr %125, i32 0, i32 0
  %130 = load ptr, ptr %129, align 8
  store ptr %130, ptr %128, align 8
  %131 = alloca [0 x i8], align 1
  store [0 x i8] zeroinitializer, ptr %131, align 1
  %132 = alloca i32, align 4
  store i32 0, ptr %132, align 4
  %133 = alloca i32, align 4
  store i32 0, ptr %133, align 4
  %134 = alloca i32, align 4
  store i32 0, ptr %134, align 4
  %135 = alloca i32, align 4
  store i32 1, ptr %135, align 4
  %136 = alloca [1 x ptr], align 8
  store ptr @String, ptr %136, align 8
  %137 = load ptr, ptr %136, align 8
  %138 = getelementptr ptr, ptr %137, i32 6
  %139 = load ptr, ptr %138, align 8
  %140 = call { i64, i64 } @size_wrapper(ptr %139, ptr %136)
  %141 = extractvalue { i64, i64 } %140, 0
  %142 = call ptr @bump_malloc(i64 %141)
  %143 = alloca i32, align 4
  %144 = alloca ptr, align 8
  %145 = alloca ptr, align 8
  %146 = alloca ptr, align 8
  store ptr @String, ptr %146, align 8
  store ptr %142, ptr %145, align 8
  store i32 10, ptr %143, align 4
  %147 = alloca i32, align 4
  store i32 0, ptr %147, align 4
  %148 = alloca i32, align 4
  store i32 0, ptr %148, align 4
  %149 = alloca i32, align 4
  store i32 1, ptr %149, align 4
  %150 = load ptr, ptr %128, align 8
  %151 = insertvalue { ptr } undef, ptr %150, 0
  %152 = load i32, ptr %147, align 4
  %153 = load i32, ptr %148, align 4
  %154 = load i32, ptr %149, align 4
  %155 = load ptr, ptr %146, align 8
  %156 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %155, 0
  %157 = load ptr, ptr %145, align 8
  %158 = insertvalue { ptr, ptr, ptr, i32 } %156, ptr %157, 1
  %159 = load ptr, ptr %144, align 8
  %160 = insertvalue { ptr, ptr, ptr, i32 } %158, ptr %159, 2
  %161 = load i32, ptr %143, align 4
  %162 = insertvalue { ptr, ptr, ptr, i32 } %160, i32 %161, 3
  %163 = alloca [4 x ptr], align 8
  %164 = getelementptr [4 x ptr], ptr %163, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %164, align 8
  %165 = getelementptr [4 x ptr], ptr %163, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %165, align 8
  %166 = getelementptr [4 x ptr], ptr %163, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %166, align 8
  %167 = getelementptr [4 x ptr], ptr %163, i32 0, i32 3
  store ptr @_parameterization_i32, ptr %167, align 8
  %168 = call ptr @llvm.invariant.start.p0(i64 16, ptr %163)
  %169 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %155)
  %170 = getelementptr ptr, ptr %155, i32 %161
  %171 = getelementptr ptr, ptr %170, i32 12
  %172 = load ptr, ptr %171, align 8
  %173 = alloca { ptr, ptr, ptr, ptr }, align 8
  %174 = getelementptr { ptr, ptr, ptr, ptr }, ptr %173, i32 0, i32 0
  store ptr @buffer_typ, ptr %174, align 8
  %175 = getelementptr { ptr, ptr, ptr, ptr }, ptr %173, i32 0, i32 1
  store ptr @i32_typ, ptr %175, align 8
  %176 = getelementptr { ptr, ptr, ptr, ptr }, ptr %173, i32 0, i32 2
  store ptr @i32_typ, ptr %176, align 8
  %177 = getelementptr { ptr, ptr, ptr, ptr }, ptr %173, i32 0, i32 3
  store ptr @i32_typ, ptr %177, align 8
  %178 = call ptr @behavior_wrapper(ptr %172, { ptr, ptr, ptr, i32 } %162, ptr %173)
  call void %178({ ptr, ptr, ptr, i32 } %162, { ptr, ptr, ptr, i32 } %162, ptr %163, { ptr } %151, i32 %152, i32 %153, i32 %154)
  %179 = alloca i32, align 4
  %180 = alloca ptr, align 8
  %181 = alloca ptr, align 8
  %182 = alloca ptr, align 8
  %183 = load ptr, ptr %146, align 8
  store ptr %183, ptr %182, align 8
  %184 = load ptr, ptr %145, align 8
  store ptr %184, ptr %181, align 8
  %185 = load ptr, ptr %144, align 8
  store ptr %185, ptr %180, align 8
  %186 = load i32, ptr %143, align 4
  store i32 %186, ptr %179, align 4
  %187 = load ptr, ptr %182, align 8
  %188 = call i32 @get_offset(ptr %187, ptr @String)
  store i32 %188, ptr %179, align 4
  %189 = load ptr, ptr %7, align 8
  %190 = load ptr, ptr %6, align 8
  %191 = call ptr @llvm.invariant.start.p0(i64 224, ptr %190)
  %192 = load i32, ptr %5, align 4
  %193 = getelementptr ptr, ptr %190, i32 %192
  %194 = getelementptr ptr, ptr %193, i32 1
  %195 = load ptr, ptr %194, align 8
  %196 = getelementptr { ptr, ptr }, ptr %195, i32 0, i32 1
  %197 = load ptr, ptr %196, align 8
  %198 = load ptr, ptr %182, align 8
  %199 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %198, 0
  %200 = load ptr, ptr %181, align 8
  %201 = insertvalue { ptr, ptr, ptr, i32 } %199, ptr %200, 1
  %202 = load ptr, ptr %180, align 8
  %203 = insertvalue { ptr, ptr, ptr, i32 } %201, ptr %202, 2
  %204 = load i32, ptr %179, align 4
  %205 = insertvalue { ptr, ptr, ptr, i32 } %203, i32 %204, 3
  call void %197(ptr %189, { ptr, ptr, ptr, i32 } %205) #2
  %206 = alloca [1 x ptr], align 8
  store ptr @Stacktrace, ptr %206, align 8
  %207 = load ptr, ptr %206, align 8
  %208 = getelementptr ptr, ptr %207, i32 6
  %209 = load ptr, ptr %208, align 8
  %210 = call { i64, i64 } @size_wrapper(ptr %209, ptr %206)
  %211 = extractvalue { i64, i64 } %210, 0
  %212 = call ptr @bump_malloc(i64 %211)
  %213 = alloca i32, align 4
  %214 = alloca ptr, align 8
  %215 = alloca ptr, align 8
  %216 = alloca ptr, align 8
  store ptr @Stacktrace, ptr %216, align 8
  store ptr %212, ptr %215, align 8
  store i32 10, ptr %213, align 4
  %217 = load ptr, ptr %216, align 8
  %218 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %217, 0
  %219 = load ptr, ptr %215, align 8
  %220 = insertvalue { ptr, ptr, ptr, i32 } %218, ptr %219, 1
  %221 = load ptr, ptr %214, align 8
  %222 = insertvalue { ptr, ptr, ptr, i32 } %220, ptr %221, 2
  %223 = load i32, ptr %213, align 4
  %224 = insertvalue { ptr, ptr, ptr, i32 } %222, i32 %223, 3
  %225 = alloca [0 x ptr], align 8
  %226 = call ptr @llvm.invariant.start.p0(i64 0, ptr %225)
  %227 = call ptr @llvm.invariant.start.p0(i64 48, ptr %217)
  %228 = getelementptr ptr, ptr %217, i32 %223
  %229 = getelementptr ptr, ptr %228, i32 2
  %230 = load ptr, ptr %229, align 8
  %231 = alloca {}, align 8
  %232 = call ptr @behavior_wrapper(ptr %230, { ptr, ptr, ptr, i32 } %224, ptr %231)
  call void %232({ ptr, ptr, ptr, i32 } %224, { ptr, ptr, ptr, i32 } %224, ptr %225)
  %233 = alloca i32, align 4
  %234 = alloca ptr, align 8
  %235 = alloca ptr, align 8
  %236 = alloca ptr, align 8
  %237 = load ptr, ptr %216, align 8
  store ptr %237, ptr %236, align 8
  %238 = load ptr, ptr %215, align 8
  store ptr %238, ptr %235, align 8
  %239 = load ptr, ptr %214, align 8
  store ptr %239, ptr %234, align 8
  %240 = load i32, ptr %213, align 4
  store i32 %240, ptr %233, align 4
  %241 = load ptr, ptr %236, align 8
  %242 = call i32 @get_offset(ptr %241, ptr @Stacktrace)
  store i32 %242, ptr %233, align 4
  %243 = load ptr, ptr %7, align 8
  %244 = load ptr, ptr %6, align 8
  %245 = call ptr @llvm.invariant.start.p0(i64 224, ptr %244)
  %246 = load i32, ptr %5, align 4
  %247 = getelementptr ptr, ptr %244, i32 %246
  %248 = getelementptr ptr, ptr %247, i32 3
  %249 = load ptr, ptr %248, align 8
  %250 = getelementptr { ptr, ptr }, ptr %249, i32 0, i32 1
  %251 = load ptr, ptr %250, align 8
  %252 = load ptr, ptr %236, align 8
  %253 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %252, 0
  %254 = load ptr, ptr %235, align 8
  %255 = insertvalue { ptr, ptr, ptr, i32 } %253, ptr %254, 1
  %256 = load ptr, ptr %234, align 8
  %257 = insertvalue { ptr, ptr, ptr, i32 } %255, ptr %256, 2
  %258 = load i32, ptr %233, align 4
  %259 = insertvalue { ptr, ptr, ptr, i32 } %257, i32 %258, 3
  call void %251(ptr %243, { ptr, ptr, ptr, i32 } %259) #2
  ret void
}

define ptr @InvalidUTF8Error_B_init_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 10, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [28 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @InvalidUTF8Error_B_set_info_line_numberi32_file_nameString({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = ptrtoint ptr %7 to i64
  %9 = icmp eq i64 %8, ptrtoint (ptr @i32_typ to i64)
  %10 = zext i1 %9 to i8
  store i8 %10, ptr %4, align 1
  %11 = getelementptr ptr, ptr %1, i32 1
  %12 = load ptr, ptr %11, align 8
  %13 = getelementptr { [3 x i64], [3 x ptr] }, ptr %12, i32 0, i32 0, i32 1
  %14 = getelementptr { [3 x i64], [3 x ptr] }, ptr %12, i32 0, i32 0, i32 2
  %15 = getelementptr { [3 x i64], [3 x ptr] }, ptr %12, i32 0, i32 1, i32 0
  %16 = getelementptr { [3 x i64], [3 x ptr] }, ptr %12, i32 0, i32 1, i32 1
  %17 = load i64, ptr %13, align 4
  %18 = load i64, ptr %14, align 4
  %19 = load ptr, ptr %15, align 8
  %20 = load ptr, ptr %16, align 8
  %21 = load i64, ptr @String, align 4
  %22 = call i1 @subtype_test_wrapper(ptr %19, i64 %18, i64 %17, i64 %21, i64 ptrtoint (ptr @String to i64), ptr %20)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 11, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [28 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define ptr @InvalidUTF8Error_B_report_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 12, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [28 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @InvalidUTF8Error_B_print_message_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 13, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [28 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { i64, i64 } @_data_size_OutOfBounds(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, i160 } }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, i160 } }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr ({ ptr, i160 }, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr ({ ptr, i160 }, ptr null, i32 1) to i64), %10
  %12 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %5
  %13 = select i1 %12, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %5
  %14 = urem i64 %11, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %17
  %19 = add i64 %11, %18
  %20 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %13
  %21 = select i1 %20, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %13
  %22 = urem i64 %19, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %23 = icmp eq i64 %22, 0
  %24 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %22
  %25 = select i1 %23, i64 0, i64 %24
  %26 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %25
  %27 = add i64 %19, %26
  %28 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %21
  %29 = select i1 %28, i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), i64 %21
  %30 = urem i64 %27, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %31 = icmp eq i64 %30, 0
  %32 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %30
  %33 = select i1 %31, i64 0, i64 %32
  %34 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %33
  %35 = add i64 %27, %34
  %36 = urem i64 %35, %29
  %37 = icmp eq i64 %36, 0
  %38 = sub i64 %29, %36
  %39 = select i1 %37, i64 0, i64 %38
  %40 = add i64 %35, %39
  %41 = insertvalue { i64, i64 } undef, i64 %40, 0
  %42 = insertvalue { i64, i64 } %41, i64 %29, 1
  ret { i64, i64 } %42
}

define { ptr, i160 } @OutOfBounds_getter_details(ptr %0) {
  %2 = getelementptr i8, ptr %0, i64 0
  %3 = getelementptr { ptr, i160 }, ptr %2, i32 0, i32 0
  %4 = load ptr, ptr %3, align 8
  %5 = insertvalue { ptr, i160 } undef, ptr %4, 0
  %6 = getelementptr { ptr, i160 }, ptr %2, i32 0, i32 1
  %7 = load i160, ptr %6, align 4
  %8 = insertvalue { ptr, i160 } %5, i160 %7, 1
  ret { ptr, i160 } %8
}

define void @OutOfBounds_setter_details(ptr %0, { ptr, i160 } %1) {
  %3 = getelementptr i8, ptr %0, i64 0
  %4 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %1, ptr %4, align 8
  %5 = getelementptr { ptr, i160 }, ptr %4, i32 0, i32 0
  %6 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 0
  %7 = load ptr, ptr %5, align 8
  store ptr %7, ptr %6, align 8
  %8 = getelementptr { ptr, i160 }, ptr %4, i32 0, i32 1
  %9 = getelementptr { ptr, i160 }, ptr %3, i32 0, i32 1
  %10 = load i160, ptr %8, align 4
  store i160 %10, ptr %9, align 4
  ret void
}

define i32 @OutOfBounds_getter_line_number(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr ({ ptr, i160 }, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr ({ ptr, i160 }, ptr null, i32 1) to i64), %5
  %7 = getelementptr i8, ptr %0, i64 %6
  %8 = load i32, ptr %7, align 4
  ret i32 %8
}

define void @OutOfBounds_setter_line_number(ptr %0, i32 %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr ({ ptr, i160 }, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr ({ ptr, i160 }, ptr null, i32 1) to i64), %6
  %8 = getelementptr i8, ptr %0, i64 %7
  %9 = alloca i32, align 4
  store i32 %1, ptr %9, align 4
  %10 = load i32, ptr %9, align 4
  store i32 %10, ptr %8, align 4
  ret void
}

define { ptr, ptr, ptr, i32 } @OutOfBounds_getter_file_name(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr ({ ptr, i160 }, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr ({ ptr, i160 }, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 %7, %11
  %13 = getelementptr i8, ptr %0, i64 %12
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 0
  %15 = load ptr, ptr %14, align 8
  %16 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %15, 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 1
  %18 = load ptr, ptr %17, align 8
  %19 = insertvalue { ptr, ptr, ptr, i32 } %16, ptr %18, 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 2
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } %19, ptr %21, 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %13, i32 0, i32 3
  %24 = load i32, ptr %23, align 4
  %25 = insertvalue { ptr, ptr, ptr, i32 } %22, i32 %24, 3
  ret { ptr, ptr, ptr, i32 } %25
}

define void @OutOfBounds_setter_file_name(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr ({ ptr, i160 }, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr ({ ptr, i160 }, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 %8, %12
  %14 = getelementptr i8, ptr %0, i64 %13
  %15 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %15, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 0
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 0
  %18 = load ptr, ptr %16, align 8
  store ptr %18, ptr %17, align 8
  %19 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 1
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 1
  %21 = load ptr, ptr %19, align 8
  store ptr %21, ptr %20, align 8
  %22 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 2
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 2
  %24 = load ptr, ptr %22, align 8
  store ptr %24, ptr %23, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %15, i32 0, i32 3
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %14, i32 0, i32 3
  %27 = load i32, ptr %25, align 4
  store i32 %27, ptr %26, align 4
  ret void
}

define { ptr, ptr, ptr, i32 } @OutOfBounds_getter_message(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr ({ ptr, i160 }, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr ({ ptr, i160 }, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %11
  %13 = add i64 %7, %12
  %14 = urem i64 %13, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 %13, %17
  %19 = getelementptr i8, ptr %0, i64 %18
  %20 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 0
  %21 = load ptr, ptr %20, align 8
  %22 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %21, 0
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 1
  %24 = load ptr, ptr %23, align 8
  %25 = insertvalue { ptr, ptr, ptr, i32 } %22, ptr %24, 1
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 2
  %27 = load ptr, ptr %26, align 8
  %28 = insertvalue { ptr, ptr, ptr, i32 } %25, ptr %27, 2
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %19, i32 0, i32 3
  %30 = load i32, ptr %29, align 4
  %31 = insertvalue { ptr, ptr, ptr, i32 } %28, i32 %30, 3
  ret { ptr, ptr, ptr, i32 } %31
}

define void @OutOfBounds_setter_message(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr ({ ptr, i160 }, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr ({ ptr, i160 }, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %12
  %14 = add i64 %8, %13
  %15 = urem i64 %14, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %16 = icmp eq i64 %15, 0
  %17 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add i64 %14, %18
  %20 = getelementptr i8, ptr %0, i64 %19
  %21 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %21, align 8
  %22 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 0
  %23 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 0
  %24 = load ptr, ptr %22, align 8
  store ptr %24, ptr %23, align 8
  %25 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 1
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 1
  %27 = load ptr, ptr %25, align 8
  store ptr %27, ptr %26, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 2
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 2
  %30 = load ptr, ptr %28, align 8
  store ptr %30, ptr %29, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %21, i32 0, i32 3
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %20, i32 0, i32 3
  %33 = load i32, ptr %31, align 4
  store i32 %33, ptr %32, align 4
  ret void
}

define { ptr, ptr, ptr, i32 } @OutOfBounds_getter_stacktrace(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr ({ ptr, i160 }, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %5
  %7 = add i64 ptrtoint (ptr getelementptr ({ ptr, i160 }, ptr null, i32 1) to i64), %6
  %8 = urem i64 %7, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %9 = icmp eq i64 %8, 0
  %10 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %8
  %11 = select i1 %9, i64 0, i64 %10
  %12 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %11
  %13 = add i64 %7, %12
  %14 = urem i64 %13, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %15 = icmp eq i64 %14, 0
  %16 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %14
  %17 = select i1 %15, i64 0, i64 %16
  %18 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %17
  %19 = add i64 %13, %18
  %20 = urem i64 %19, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %21 = icmp eq i64 %20, 0
  %22 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %20
  %23 = select i1 %21, i64 0, i64 %22
  %24 = add i64 %19, %23
  %25 = getelementptr i8, ptr %0, i64 %24
  %26 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 0
  %27 = load ptr, ptr %26, align 8
  %28 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %27, 0
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 1
  %30 = load ptr, ptr %29, align 8
  %31 = insertvalue { ptr, ptr, ptr, i32 } %28, ptr %30, 1
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 2
  %33 = load ptr, ptr %32, align 8
  %34 = insertvalue { ptr, ptr, ptr, i32 } %31, ptr %33, 2
  %35 = getelementptr { ptr, ptr, ptr, i32 }, ptr %25, i32 0, i32 3
  %36 = load i32, ptr %35, align 4
  %37 = insertvalue { ptr, ptr, ptr, i32 } %34, i32 %36, 3
  ret { ptr, ptr, ptr, i32 } %37
}

define void @OutOfBounds_setter_stacktrace(ptr %0, { ptr, ptr, ptr, i32 } %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr ({ ptr, i160 }, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %6
  %8 = add i64 ptrtoint (ptr getelementptr ({ ptr, i160 }, ptr null, i32 1) to i64), %7
  %9 = urem i64 %8, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %10 = icmp eq i64 %9, 0
  %11 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %9
  %12 = select i1 %10, i64 0, i64 %11
  %13 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %12
  %14 = add i64 %8, %13
  %15 = urem i64 %14, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %16 = icmp eq i64 %15, 0
  %17 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %15
  %18 = select i1 %16, i64 0, i64 %17
  %19 = add i64 ptrtoint (ptr getelementptr ({ ptr, ptr, ptr, i32 }, ptr null, i32 1) to i64), %18
  %20 = add i64 %14, %19
  %21 = urem i64 %20, ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64)
  %22 = icmp eq i64 %21, 0
  %23 = sub i64 ptrtoint (ptr getelementptr ({ i8, { ptr, ptr, ptr, i32 } }, ptr null, i32 0, i32 1) to i64), %21
  %24 = select i1 %22, i64 0, i64 %23
  %25 = add i64 %20, %24
  %26 = getelementptr i8, ptr %0, i64 %25
  %27 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %1, ptr %27, align 8
  %28 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 0
  %29 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 0
  %30 = load ptr, ptr %28, align 8
  store ptr %30, ptr %29, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 1
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 1
  %33 = load ptr, ptr %31, align 8
  store ptr %33, ptr %32, align 8
  %34 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 2
  %35 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 2
  %36 = load ptr, ptr %34, align 8
  store ptr %36, ptr %35, align 8
  %37 = getelementptr { ptr, ptr, ptr, i32 }, ptr %27, i32 0, i32 3
  %38 = getelementptr { ptr, ptr, ptr, i32 }, ptr %26, i32 0, i32 3
  %39 = load i32, ptr %37, align 4
  store i32 %39, ptr %38, align 4
  ret void
}

define void @OutOfBounds_init_boundsi32_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, i32 %3, i32 %4) {
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %6, align 8
  %7 = alloca i32, align 4
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = alloca ptr, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %8, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 1
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %9, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 2
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %10, align 8
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  store i32 %18, ptr %7, align 4
  %19 = load ptr, ptr %8, align 8
  %20 = call i32 @get_offset(ptr %19, ptr @OutOfBounds)
  store i32 %20, ptr %7, align 4
  %21 = alloca i32, align 4
  store i32 %3, ptr %21, align 4
  %22 = alloca i32, align 4
  store i32 %4, ptr %22, align 4
  %23 = alloca [1 x ptr], align 8
  store ptr @OutOfBoundsDetails, ptr %23, align 8
  %24 = load ptr, ptr %23, align 8
  %25 = getelementptr ptr, ptr %24, i32 6
  %26 = load ptr, ptr %25, align 8
  %27 = call { i64, i64 } @size_wrapper(ptr %26, ptr %23)
  %28 = extractvalue { i64, i64 } %27, 0
  %29 = call ptr @bump_malloc(i64 %28)
  %30 = alloca { ptr, ptr, ptr, i32 }, align 8
  %31 = getelementptr { ptr, ptr, ptr, i32 }, ptr %30, i32 0, i32 1
  %32 = getelementptr { ptr, ptr, ptr, i32 }, ptr %30, i32 0, i32 3
  store ptr @OutOfBoundsDetails, ptr %30, align 8
  store ptr %29, ptr %31, align 8
  store i32 10, ptr %32, align 4
  %33 = load i32, ptr %21, align 4
  %34 = load i32, ptr %22, align 4
  %35 = getelementptr { ptr, ptr, ptr, i32 }, ptr %30, i32 0, i32 0
  %36 = load ptr, ptr %35, align 8
  %37 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %36, 0
  %38 = load ptr, ptr %31, align 8
  %39 = insertvalue { ptr, ptr, ptr, i32 } %37, ptr %38, 1
  %40 = getelementptr { ptr, ptr, ptr, i32 }, ptr %30, i32 0, i32 2
  %41 = load ptr, ptr %40, align 8
  %42 = insertvalue { ptr, ptr, ptr, i32 } %39, ptr %41, 2
  %43 = load i32, ptr %32, align 4
  %44 = insertvalue { ptr, ptr, ptr, i32 } %42, i32 %43, 3
  %45 = alloca [2 x ptr], align 8
  %46 = getelementptr [2 x ptr], ptr %45, i32 0, i32 0
  store ptr @_parameterization_i32, ptr %46, align 8
  %47 = getelementptr [2 x ptr], ptr %45, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %47, align 8
  %48 = call ptr @llvm.invariant.start.p0(i64 4, ptr %45)
  %49 = call ptr @llvm.invariant.start.p0(i64 48, ptr %36)
  %50 = getelementptr ptr, ptr %36, i32 %43
  %51 = getelementptr ptr, ptr %50, i32 2
  %52 = load ptr, ptr %51, align 8
  %53 = alloca { ptr, ptr }, align 8
  %54 = getelementptr { ptr, ptr }, ptr %53, i32 0, i32 0
  store ptr @i32_typ, ptr %54, align 8
  %55 = getelementptr { ptr, ptr }, ptr %53, i32 0, i32 1
  store ptr @i32_typ, ptr %55, align 8
  %56 = call ptr @behavior_wrapper(ptr %52, { ptr, ptr, ptr, i32 } %44, ptr %53)
  call void %56({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr %45, i32 %33, i32 %34)
  %57 = load ptr, ptr %9, align 8
  %58 = load ptr, ptr %8, align 8
  %59 = call ptr @llvm.invariant.start.p0(i64 248, ptr %58)
  %60 = load i32, ptr %7, align 4
  %61 = getelementptr ptr, ptr %58, i32 %60
  %62 = load ptr, ptr %61, align 8
  %63 = getelementptr { ptr, ptr }, ptr %62, i32 0, i32 1
  %64 = load ptr, ptr %63, align 8
  %65 = getelementptr { ptr, i160 }, ptr %30, i32 0, i32 0
  %66 = load ptr, ptr %65, align 8
  %67 = insertvalue { ptr, i160 } undef, ptr %66, 0
  %68 = getelementptr { ptr, i160 }, ptr %30, i32 0, i32 1
  %69 = load i160, ptr %68, align 4
  %70 = insertvalue { ptr, i160 } %67, i160 %69, 1
  call void %64(ptr %57, { ptr, i160 } %70) #2
  %71 = alloca i32, align 4
  store i32 0, ptr %71, align 4
  %72 = load ptr, ptr %9, align 8
  %73 = load ptr, ptr %8, align 8
  %74 = call ptr @llvm.invariant.start.p0(i64 248, ptr %73)
  %75 = load i32, ptr %7, align 4
  %76 = getelementptr ptr, ptr %73, i32 %75
  %77 = getelementptr ptr, ptr %76, i32 1
  %78 = load ptr, ptr %77, align 8
  %79 = getelementptr { ptr, ptr }, ptr %78, i32 0, i32 1
  %80 = load ptr, ptr %79, align 8
  %81 = load i32, ptr %71, align 4
  call void %80(ptr %72, i32 %81) #2
  %82 = alloca i32, align 4
  store i32 1, ptr %82, align 4
  %83 = alloca i64, align 8
  %84 = load i32, ptr %82, align 4
  %85 = sext i32 %84 to i64
  store i64 %85, ptr %83, align 4
  %86 = load i64, ptr %83, align 4
  %87 = alloca ptr, align 8
  %88 = mul i64 %86, ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
  %89 = call ptr @bump_malloc(i64 %88)
  store ptr %89, ptr %87, align 8
  %90 = alloca ptr, align 8
  %91 = getelementptr { ptr }, ptr %87, i32 0, i32 0
  %92 = load ptr, ptr %91, align 8
  store ptr %92, ptr %90, align 8
  %93 = alloca [0 x i8], align 1
  store [0 x i8] zeroinitializer, ptr %93, align 1
  %94 = alloca i32, align 4
  store i32 0, ptr %94, align 4
  %95 = alloca i32, align 4
  store i32 0, ptr %95, align 4
  %96 = alloca i32, align 4
  store i32 0, ptr %96, align 4
  %97 = alloca i32, align 4
  store i32 1, ptr %97, align 4
  %98 = alloca [1 x ptr], align 8
  store ptr @String, ptr %98, align 8
  %99 = load ptr, ptr %98, align 8
  %100 = getelementptr ptr, ptr %99, i32 6
  %101 = load ptr, ptr %100, align 8
  %102 = call { i64, i64 } @size_wrapper(ptr %101, ptr %98)
  %103 = extractvalue { i64, i64 } %102, 0
  %104 = call ptr @bump_malloc(i64 %103)
  %105 = alloca i32, align 4
  %106 = alloca ptr, align 8
  %107 = alloca ptr, align 8
  %108 = alloca ptr, align 8
  store ptr @String, ptr %108, align 8
  store ptr %104, ptr %107, align 8
  store i32 10, ptr %105, align 4
  %109 = alloca i32, align 4
  store i32 0, ptr %109, align 4
  %110 = alloca i32, align 4
  store i32 0, ptr %110, align 4
  %111 = alloca i32, align 4
  store i32 1, ptr %111, align 4
  %112 = load ptr, ptr %90, align 8
  %113 = insertvalue { ptr } undef, ptr %112, 0
  %114 = load i32, ptr %109, align 4
  %115 = load i32, ptr %110, align 4
  %116 = load i32, ptr %111, align 4
  %117 = load ptr, ptr %108, align 8
  %118 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %117, 0
  %119 = load ptr, ptr %107, align 8
  %120 = insertvalue { ptr, ptr, ptr, i32 } %118, ptr %119, 1
  %121 = load ptr, ptr %106, align 8
  %122 = insertvalue { ptr, ptr, ptr, i32 } %120, ptr %121, 2
  %123 = load i32, ptr %105, align 4
  %124 = insertvalue { ptr, ptr, ptr, i32 } %122, i32 %123, 3
  %125 = alloca [4 x ptr], align 8
  %126 = getelementptr [4 x ptr], ptr %125, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %126, align 8
  %127 = getelementptr [4 x ptr], ptr %125, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %127, align 8
  %128 = getelementptr [4 x ptr], ptr %125, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %128, align 8
  %129 = getelementptr [4 x ptr], ptr %125, i32 0, i32 3
  store ptr @_parameterization_i32, ptr %129, align 8
  %130 = call ptr @llvm.invariant.start.p0(i64 16, ptr %125)
  %131 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %117)
  %132 = getelementptr ptr, ptr %117, i32 %123
  %133 = getelementptr ptr, ptr %132, i32 12
  %134 = load ptr, ptr %133, align 8
  %135 = alloca { ptr, ptr, ptr, ptr }, align 8
  %136 = getelementptr { ptr, ptr, ptr, ptr }, ptr %135, i32 0, i32 0
  store ptr @buffer_typ, ptr %136, align 8
  %137 = getelementptr { ptr, ptr, ptr, ptr }, ptr %135, i32 0, i32 1
  store ptr @i32_typ, ptr %137, align 8
  %138 = getelementptr { ptr, ptr, ptr, ptr }, ptr %135, i32 0, i32 2
  store ptr @i32_typ, ptr %138, align 8
  %139 = getelementptr { ptr, ptr, ptr, ptr }, ptr %135, i32 0, i32 3
  store ptr @i32_typ, ptr %139, align 8
  %140 = call ptr @behavior_wrapper(ptr %134, { ptr, ptr, ptr, i32 } %124, ptr %135)
  call void %140({ ptr, ptr, ptr, i32 } %124, { ptr, ptr, ptr, i32 } %124, ptr %125, { ptr } %113, i32 %114, i32 %115, i32 %116)
  %141 = alloca i32, align 4
  %142 = alloca ptr, align 8
  %143 = alloca ptr, align 8
  %144 = alloca ptr, align 8
  %145 = load ptr, ptr %108, align 8
  store ptr %145, ptr %144, align 8
  %146 = load ptr, ptr %107, align 8
  store ptr %146, ptr %143, align 8
  %147 = load ptr, ptr %106, align 8
  store ptr %147, ptr %142, align 8
  %148 = load i32, ptr %105, align 4
  store i32 %148, ptr %141, align 4
  %149 = load ptr, ptr %144, align 8
  %150 = call i32 @get_offset(ptr %149, ptr @String)
  store i32 %150, ptr %141, align 4
  %151 = load ptr, ptr %9, align 8
  %152 = load ptr, ptr %8, align 8
  %153 = call ptr @llvm.invariant.start.p0(i64 248, ptr %152)
  %154 = load i32, ptr %7, align 4
  %155 = getelementptr ptr, ptr %152, i32 %154
  %156 = getelementptr ptr, ptr %155, i32 2
  %157 = load ptr, ptr %156, align 8
  %158 = getelementptr { ptr, ptr }, ptr %157, i32 0, i32 1
  %159 = load ptr, ptr %158, align 8
  %160 = load ptr, ptr %144, align 8
  %161 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %160, 0
  %162 = load ptr, ptr %143, align 8
  %163 = insertvalue { ptr, ptr, ptr, i32 } %161, ptr %162, 1
  %164 = load ptr, ptr %142, align 8
  %165 = insertvalue { ptr, ptr, ptr, i32 } %163, ptr %164, 2
  %166 = load i32, ptr %141, align 4
  %167 = insertvalue { ptr, ptr, ptr, i32 } %165, i32 %166, 3
  call void %159(ptr %151, { ptr, ptr, ptr, i32 } %167) #2
  %168 = alloca i32, align 4
  store i32 66, ptr %168, align 4
  %169 = alloca i64, align 8
  %170 = load i32, ptr %168, align 4
  %171 = sext i32 %170 to i64
  store i64 %171, ptr %169, align 4
  %172 = load i64, ptr %169, align 4
  %173 = alloca ptr, align 8
  %174 = mul i64 %172, ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
  %175 = call ptr @bump_malloc(i64 %174)
  store ptr %175, ptr %173, align 8
  %176 = alloca ptr, align 8
  %177 = getelementptr { ptr }, ptr %173, i32 0, i32 0
  %178 = load ptr, ptr %177, align 8
  store ptr %178, ptr %176, align 8
  %179 = alloca [65 x i8], align 1
  store [65 x i8] c"An out-of-bounds error occurred while indexing into a collection.", ptr %179, align 1
  %180 = alloca i32, align 4
  store i32 0, ptr %180, align 4
  %181 = load ptr, ptr %176, align 8
  %182 = load i64, ptr %180, align 4
  %183 = mul i64 ptrtoint (ptr getelementptr ([65 x i8], ptr null, i32 1) to i64), %182
  %184 = getelementptr i8, ptr %181, i64 %183
  %185 = load <65 x i8>, ptr %179, align 1
  store <65 x i8> %185, ptr %184, align 1
  %186 = alloca i32, align 4
  store i32 65, ptr %186, align 4
  %187 = alloca i32, align 4
  store i32 65, ptr %187, align 4
  %188 = alloca i32, align 4
  store i32 66, ptr %188, align 4
  %189 = alloca [1 x ptr], align 8
  store ptr @String, ptr %189, align 8
  %190 = load ptr, ptr %189, align 8
  %191 = getelementptr ptr, ptr %190, i32 6
  %192 = load ptr, ptr %191, align 8
  %193 = call { i64, i64 } @size_wrapper(ptr %192, ptr %189)
  %194 = extractvalue { i64, i64 } %193, 0
  %195 = call ptr @bump_malloc(i64 %194)
  %196 = alloca i32, align 4
  %197 = alloca ptr, align 8
  %198 = alloca ptr, align 8
  %199 = alloca ptr, align 8
  store ptr @String, ptr %199, align 8
  store ptr %195, ptr %198, align 8
  store i32 10, ptr %196, align 4
  %200 = alloca i32, align 4
  store i32 65, ptr %200, align 4
  %201 = alloca i32, align 4
  store i32 65, ptr %201, align 4
  %202 = alloca i32, align 4
  store i32 66, ptr %202, align 4
  %203 = load ptr, ptr %176, align 8
  %204 = insertvalue { ptr } undef, ptr %203, 0
  %205 = load i32, ptr %200, align 4
  %206 = load i32, ptr %201, align 4
  %207 = load i32, ptr %202, align 4
  %208 = load ptr, ptr %199, align 8
  %209 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %208, 0
  %210 = load ptr, ptr %198, align 8
  %211 = insertvalue { ptr, ptr, ptr, i32 } %209, ptr %210, 1
  %212 = load ptr, ptr %197, align 8
  %213 = insertvalue { ptr, ptr, ptr, i32 } %211, ptr %212, 2
  %214 = load i32, ptr %196, align 4
  %215 = insertvalue { ptr, ptr, ptr, i32 } %213, i32 %214, 3
  %216 = alloca [4 x ptr], align 8
  %217 = getelementptr [4 x ptr], ptr %216, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %217, align 8
  %218 = getelementptr [4 x ptr], ptr %216, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %218, align 8
  %219 = getelementptr [4 x ptr], ptr %216, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %219, align 8
  %220 = getelementptr [4 x ptr], ptr %216, i32 0, i32 3
  store ptr @_parameterization_i32, ptr %220, align 8
  %221 = call ptr @llvm.invariant.start.p0(i64 16, ptr %216)
  %222 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %208)
  %223 = getelementptr ptr, ptr %208, i32 %214
  %224 = getelementptr ptr, ptr %223, i32 12
  %225 = load ptr, ptr %224, align 8
  %226 = alloca { ptr, ptr, ptr, ptr }, align 8
  %227 = getelementptr { ptr, ptr, ptr, ptr }, ptr %226, i32 0, i32 0
  store ptr @buffer_typ, ptr %227, align 8
  %228 = getelementptr { ptr, ptr, ptr, ptr }, ptr %226, i32 0, i32 1
  store ptr @i32_typ, ptr %228, align 8
  %229 = getelementptr { ptr, ptr, ptr, ptr }, ptr %226, i32 0, i32 2
  store ptr @i32_typ, ptr %229, align 8
  %230 = getelementptr { ptr, ptr, ptr, ptr }, ptr %226, i32 0, i32 3
  store ptr @i32_typ, ptr %230, align 8
  %231 = call ptr @behavior_wrapper(ptr %225, { ptr, ptr, ptr, i32 } %215, ptr %226)
  call void %231({ ptr, ptr, ptr, i32 } %215, { ptr, ptr, ptr, i32 } %215, ptr %216, { ptr } %204, i32 %205, i32 %206, i32 %207)
  %232 = alloca i32, align 4
  %233 = alloca ptr, align 8
  %234 = alloca ptr, align 8
  %235 = alloca ptr, align 8
  %236 = load ptr, ptr %199, align 8
  store ptr %236, ptr %235, align 8
  %237 = load ptr, ptr %198, align 8
  store ptr %237, ptr %234, align 8
  %238 = load ptr, ptr %197, align 8
  store ptr %238, ptr %233, align 8
  %239 = load i32, ptr %196, align 4
  store i32 %239, ptr %232, align 4
  %240 = load ptr, ptr %235, align 8
  %241 = call i32 @get_offset(ptr %240, ptr @String)
  store i32 %241, ptr %232, align 4
  %242 = load ptr, ptr %9, align 8
  %243 = load ptr, ptr %8, align 8
  %244 = call ptr @llvm.invariant.start.p0(i64 248, ptr %243)
  %245 = load i32, ptr %7, align 4
  %246 = getelementptr ptr, ptr %243, i32 %245
  %247 = getelementptr ptr, ptr %246, i32 3
  %248 = load ptr, ptr %247, align 8
  %249 = getelementptr { ptr, ptr }, ptr %248, i32 0, i32 1
  %250 = load ptr, ptr %249, align 8
  %251 = load ptr, ptr %235, align 8
  %252 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %251, 0
  %253 = load ptr, ptr %234, align 8
  %254 = insertvalue { ptr, ptr, ptr, i32 } %252, ptr %253, 1
  %255 = load ptr, ptr %233, align 8
  %256 = insertvalue { ptr, ptr, ptr, i32 } %254, ptr %255, 2
  %257 = load i32, ptr %232, align 4
  %258 = insertvalue { ptr, ptr, ptr, i32 } %256, i32 %257, 3
  call void %250(ptr %242, { ptr, ptr, ptr, i32 } %258) #2
  %259 = alloca [1 x ptr], align 8
  store ptr @Stacktrace, ptr %259, align 8
  %260 = load ptr, ptr %259, align 8
  %261 = getelementptr ptr, ptr %260, i32 6
  %262 = load ptr, ptr %261, align 8
  %263 = call { i64, i64 } @size_wrapper(ptr %262, ptr %259)
  %264 = extractvalue { i64, i64 } %263, 0
  %265 = call ptr @bump_malloc(i64 %264)
  %266 = alloca i32, align 4
  %267 = alloca ptr, align 8
  %268 = alloca ptr, align 8
  %269 = alloca ptr, align 8
  store ptr @Stacktrace, ptr %269, align 8
  store ptr %265, ptr %268, align 8
  store i32 10, ptr %266, align 4
  %270 = load ptr, ptr %269, align 8
  %271 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %270, 0
  %272 = load ptr, ptr %268, align 8
  %273 = insertvalue { ptr, ptr, ptr, i32 } %271, ptr %272, 1
  %274 = load ptr, ptr %267, align 8
  %275 = insertvalue { ptr, ptr, ptr, i32 } %273, ptr %274, 2
  %276 = load i32, ptr %266, align 4
  %277 = insertvalue { ptr, ptr, ptr, i32 } %275, i32 %276, 3
  %278 = alloca [0 x ptr], align 8
  %279 = call ptr @llvm.invariant.start.p0(i64 0, ptr %278)
  %280 = call ptr @llvm.invariant.start.p0(i64 48, ptr %270)
  %281 = getelementptr ptr, ptr %270, i32 %276
  %282 = getelementptr ptr, ptr %281, i32 2
  %283 = load ptr, ptr %282, align 8
  %284 = alloca {}, align 8
  %285 = call ptr @behavior_wrapper(ptr %283, { ptr, ptr, ptr, i32 } %277, ptr %284)
  call void %285({ ptr, ptr, ptr, i32 } %277, { ptr, ptr, ptr, i32 } %277, ptr %278)
  %286 = alloca i32, align 4
  %287 = alloca ptr, align 8
  %288 = alloca ptr, align 8
  %289 = alloca ptr, align 8
  %290 = load ptr, ptr %269, align 8
  store ptr %290, ptr %289, align 8
  %291 = load ptr, ptr %268, align 8
  store ptr %291, ptr %288, align 8
  %292 = load ptr, ptr %267, align 8
  store ptr %292, ptr %287, align 8
  %293 = load i32, ptr %266, align 4
  store i32 %293, ptr %286, align 4
  %294 = load ptr, ptr %289, align 8
  %295 = call i32 @get_offset(ptr %294, ptr @Stacktrace)
  store i32 %295, ptr %286, align 4
  %296 = load ptr, ptr %9, align 8
  %297 = load ptr, ptr %8, align 8
  %298 = call ptr @llvm.invariant.start.p0(i64 248, ptr %297)
  %299 = load i32, ptr %7, align 4
  %300 = getelementptr ptr, ptr %297, i32 %299
  %301 = getelementptr ptr, ptr %300, i32 4
  %302 = load ptr, ptr %301, align 8
  %303 = getelementptr { ptr, ptr }, ptr %302, i32 0, i32 1
  %304 = load ptr, ptr %303, align 8
  %305 = load ptr, ptr %289, align 8
  %306 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %305, 0
  %307 = load ptr, ptr %288, align 8
  %308 = insertvalue { ptr, ptr, ptr, i32 } %306, ptr %307, 1
  %309 = load ptr, ptr %287, align 8
  %310 = insertvalue { ptr, ptr, ptr, i32 } %308, ptr %309, 2
  %311 = load i32, ptr %286, align 4
  %312 = insertvalue { ptr, ptr, ptr, i32 } %310, i32 %311, 3
  call void %304(ptr %296, { ptr, ptr, ptr, i32 } %312) #2
  ret void
}

define ptr @OutOfBounds_B_init_boundsi32_indexi32({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = ptrtoint ptr %7 to i64
  %9 = icmp eq i64 %8, ptrtoint (ptr @i32_typ to i64)
  %10 = zext i1 %9 to i8
  store i8 %10, ptr %4, align 1
  %11 = getelementptr ptr, ptr %1, i32 1
  %12 = load ptr, ptr %11, align 8
  %13 = ptrtoint ptr %12 to i64
  %14 = icmp eq i64 %13, ptrtoint (ptr @i32_typ to i64)
  %15 = zext i1 %14 to i8
  store i8 %15, ptr %3, align 1
  store i32 11, ptr %6, align 4
  %16 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %17 = load i32, ptr %6, align 4
  %18 = getelementptr [31 x ptr], ptr %16, i32 0, i32 %17
  %19 = getelementptr ptr, ptr %18, i32 10
  %20 = load ptr, ptr %19, align 8
  ret ptr %20
}

define ptr @OutOfBounds_B_init_messageString({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = call ptr @llvm.invariant.start.p0(i64 8, ptr %1)
  %5 = alloca ptr, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 1
  %8 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 0, i32 2
  %9 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 0
  %10 = getelementptr { [3 x i64], [3 x ptr] }, ptr %6, i32 0, i32 1, i32 1
  %11 = load i64, ptr %7, align 4
  %12 = load i64, ptr %8, align 4
  %13 = load ptr, ptr %9, align 8
  %14 = load ptr, ptr %10, align 8
  %15 = load i64, ptr @String, align 4
  %16 = call i1 @subtype_test_wrapper(ptr %13, i64 %12, i64 %11, i64 %15, i64 ptrtoint (ptr @String to i64), ptr %14)
  %17 = zext i1 %16 to i8
  store i8 %17, ptr %3, align 1
  store i32 12, ptr %5, align 4
  %18 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %19 = load i32, ptr %5, align 4
  %20 = getelementptr [31 x ptr], ptr %18, i32 0, i32 %19
  %21 = getelementptr ptr, ptr %20, i32 10
  %22 = load ptr, ptr %21, align 8
  ret ptr %22
}

define ptr @OutOfBounds_B_init_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 13, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [31 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define ptr @OutOfBounds_B_set_info_line_numberi32_file_nameString({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = ptrtoint ptr %7 to i64
  %9 = icmp eq i64 %8, ptrtoint (ptr @i32_typ to i64)
  %10 = zext i1 %9 to i8
  store i8 %10, ptr %4, align 1
  %11 = getelementptr ptr, ptr %1, i32 1
  %12 = load ptr, ptr %11, align 8
  %13 = getelementptr { [3 x i64], [3 x ptr] }, ptr %12, i32 0, i32 0, i32 1
  %14 = getelementptr { [3 x i64], [3 x ptr] }, ptr %12, i32 0, i32 0, i32 2
  %15 = getelementptr { [3 x i64], [3 x ptr] }, ptr %12, i32 0, i32 1, i32 0
  %16 = getelementptr { [3 x i64], [3 x ptr] }, ptr %12, i32 0, i32 1, i32 1
  %17 = load i64, ptr %13, align 4
  %18 = load i64, ptr %14, align 4
  %19 = load ptr, ptr %15, align 8
  %20 = load ptr, ptr %16, align 8
  %21 = load i64, ptr @String, align 4
  %22 = call i1 @subtype_test_wrapper(ptr %19, i64 %18, i64 %17, i64 %21, i64 ptrtoint (ptr @String to i64), ptr %20)
  %23 = zext i1 %22 to i8
  store i8 %23, ptr %3, align 1
  store i32 14, ptr %6, align 4
  %24 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %25 = load i32, ptr %6, align 4
  %26 = getelementptr [31 x ptr], ptr %24, i32 0, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 10
  %28 = load ptr, ptr %27, align 8
  ret ptr %28
}

define ptr @OutOfBounds_B_report_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 15, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [31 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define void @OutOfBounds_print_message_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  %5 = alloca [0 x ptr], align 8
  %6 = alloca {}, align 8
  %7 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %7, align 8
  %8 = alloca i32, align 4
  %9 = alloca ptr, align 8
  %10 = alloca ptr, align 8
  %11 = alloca ptr, align 8
  %12 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  store ptr %13, ptr %9, align 8
  %14 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 1
  %15 = load ptr, ptr %14, align 8
  store ptr %15, ptr %10, align 8
  %16 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 2
  %17 = load ptr, ptr %16, align 8
  store ptr %17, ptr %11, align 8
  %18 = getelementptr { ptr, ptr, ptr, i32 }, ptr %7, i32 0, i32 3
  %19 = load i32, ptr %18, align 4
  store i32 %19, ptr %8, align 4
  %20 = load ptr, ptr %9, align 8
  %21 = call i32 @get_offset(ptr %20, ptr @OutOfBounds)
  store i32 %21, ptr %8, align 4
  %22 = load ptr, ptr %10, align 8
  %23 = load ptr, ptr %9, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 248, ptr %23)
  %25 = load i32, ptr %8, align 4
  %26 = getelementptr ptr, ptr %23, i32 %25
  %27 = getelementptr ptr, ptr %26, i32 3
  %28 = load ptr, ptr %27, align 8
  %29 = getelementptr { ptr, ptr }, ptr %28, i32 0, i32 0
  %30 = load ptr, ptr %29, align 8
  %31 = call { ptr, ptr, ptr, i32 } %30(ptr %22) #1
  %32 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %31, ptr %32, align 8
  call void @assume_offset(ptr %32, ptr @String)
  %33 = getelementptr { ptr, ptr, ptr, i32 }, ptr %32, i32 0, i32 0
  %34 = load ptr, ptr %33, align 8
  %35 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %34, 0
  %36 = getelementptr { ptr, ptr, ptr, i32 }, ptr %32, i32 0, i32 1
  %37 = load ptr, ptr %36, align 8
  %38 = insertvalue { ptr, ptr, ptr, i32 } %35, ptr %37, 1
  %39 = getelementptr { ptr, ptr, ptr, i32 }, ptr %32, i32 0, i32 2
  %40 = load ptr, ptr %39, align 8
  %41 = insertvalue { ptr, ptr, ptr, i32 } %38, ptr %40, 2
  %42 = getelementptr { ptr, ptr, ptr, i32 }, ptr %32, i32 0, i32 3
  %43 = load i32, ptr %42, align 4
  %44 = insertvalue { ptr, ptr, ptr, i32 } %41, i32 %43, 3
  %45 = alloca [0 x ptr], align 8
  %46 = call ptr @llvm.invariant.start.p0(i64 0, ptr %45)
  %47 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %34)
  %48 = getelementptr ptr, ptr %34, i32 %43
  %49 = getelementptr ptr, ptr %48, i32 13
  %50 = load ptr, ptr %49, align 8
  %51 = alloca {}, align 8
  %52 = call ptr @behavior_wrapper(ptr %50, { ptr, ptr, ptr, i32 } %44, ptr %51)
  %53 = call { ptr } %52({ ptr, ptr, ptr, i32 } %44, { ptr, ptr, ptr, i32 } %44, ptr %45)
  %54 = alloca ptr, align 8
  store { ptr } %53, ptr %54, align 8
  %55 = load ptr, ptr %54, align 8
  %56 = call i32 (ptr, ...) @printf(ptr @string_string, ptr %55)
  %57 = load ptr, ptr %10, align 8
  %58 = load ptr, ptr %9, align 8
  %59 = call ptr @llvm.invariant.start.p0(i64 248, ptr %58)
  %60 = load i32, ptr %8, align 4
  %61 = getelementptr ptr, ptr %58, i32 %60
  %62 = load ptr, ptr %61, align 8
  %63 = getelementptr { ptr, ptr }, ptr %62, i32 0, i32 0
  %64 = load ptr, ptr %63, align 8
  %65 = call { ptr, i160 } %64(ptr %57) #1
  %66 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %65, ptr %66, align 8
  %67 = alloca i160, align 8
  %68 = alloca ptr, align 8
  %69 = getelementptr { ptr, i160 }, ptr %66, i32 0, i32 0
  %70 = load ptr, ptr %69, align 8
  store ptr %70, ptr %68, align 8
  %71 = getelementptr { ptr, i160 }, ptr %66, i32 0, i32 1
  %72 = load i160, ptr %71, align 4
  store i160 %72, ptr %67, align 4
  %73 = load ptr, ptr %68, align 8
  %74 = ptrtoint ptr %73 to i64
  %75 = icmp eq i64 %74, ptrtoint (ptr @nil_typ to i64)
  %76 = icmp eq i64 %74, 0
  %77 = or i1 %75, %76
  %78 = icmp eq i1 %77, false
  %79 = alloca i1, align 1
  %80 = zext i1 %78 to i8
  store i8 %80, ptr %79, align 1
  %81 = load i8, ptr %79, align 1
  %82 = trunc i8 %81 to i1
  br i1 %82, label %83, label %110

83:                                               ; preds = %3
  %84 = getelementptr { ptr, i160 }, ptr %4, i32 0, i32 0
  %85 = load ptr, ptr %68, align 8
  store ptr %85, ptr %84, align 8
  %86 = getelementptr { ptr, i160 }, ptr %4, i32 0, i32 1
  %87 = load i160, ptr %67, align 4
  store i160 %87, ptr %86, align 4
  %88 = load ptr, ptr %4, align 8
  %89 = call i32 @get_offset(ptr %88, ptr @OutOfBoundsDetails)
  %90 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  store i32 %89, ptr %90, align 4
  %91 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %92 = load ptr, ptr %91, align 8
  %93 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %92, 0
  %94 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %95 = load ptr, ptr %94, align 8
  %96 = insertvalue { ptr, ptr, ptr, i32 } %93, ptr %95, 1
  %97 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %98 = load ptr, ptr %97, align 8
  %99 = insertvalue { ptr, ptr, ptr, i32 } %96, ptr %98, 2
  %100 = load i32, ptr %90, align 4
  %101 = insertvalue { ptr, ptr, ptr, i32 } %99, i32 %100, 3
  %102 = call ptr @llvm.invariant.start.p0(i64 0, ptr %5)
  %103 = call ptr @llvm.invariant.start.p0(i64 48, ptr %92)
  %104 = getelementptr ptr, ptr %92, i32 %100
  %105 = getelementptr ptr, ptr %104, i32 3
  %106 = load ptr, ptr %105, align 8
  %107 = call ptr @behavior_wrapper(ptr %106, { ptr, ptr, ptr, i32 } %101, ptr %6)
  call void %107({ ptr, ptr, ptr, i32 } %101, { ptr, ptr, ptr, i32 } %101, ptr %5)
  %108 = load ptr, ptr %84, align 8
  store ptr %108, ptr %68, align 8
  %109 = load i160, ptr %86, align 4
  store i160 %109, ptr %67, align 4
  br label %110

110:                                              ; preds = %83, %3
  ret void
}

define ptr @OutOfBounds_B_print_message_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 16, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [31 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define { i64, i64 } @_data_size_OutOfBoundsDetails(ptr %0) {
  %2 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), 1
  %3 = select i1 %2, i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), i64 1
  %4 = icmp ugt i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %3
  %5 = select i1 %4, i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), i64 %3
  %6 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %7 = icmp eq i64 %6, 0
  %8 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %6
  %9 = select i1 %7, i64 0, i64 %8
  %10 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %9
  %11 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %10
  %12 = urem i64 %11, %5
  %13 = icmp eq i64 %12, 0
  %14 = sub i64 %5, %12
  %15 = select i1 %13, i64 0, i64 %14
  %16 = add i64 %11, %15
  %17 = insertvalue { i64, i64 } undef, i64 %16, 0
  %18 = insertvalue { i64, i64 } %17, i64 %5, 1
  ret { i64, i64 } %18
}

define i32 @OutOfBoundsDetails_getter_bounds(ptr %0) {
  %2 = getelementptr i8, ptr %0, i64 0
  %3 = load i32, ptr %2, align 4
  ret i32 %3
}

define void @OutOfBoundsDetails_setter_bounds(ptr %0, i32 %1) {
  %3 = getelementptr i8, ptr %0, i64 0
  %4 = alloca i32, align 4
  store i32 %1, ptr %4, align 4
  %5 = load i32, ptr %4, align 4
  store i32 %5, ptr %3, align 4
  ret void
}

define i32 @OutOfBoundsDetails_getter_index(ptr %0) {
  %2 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %3 = icmp eq i64 %2, 0
  %4 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %2
  %5 = select i1 %3, i64 0, i64 %4
  %6 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %5
  %7 = getelementptr i8, ptr %0, i64 %6
  %8 = load i32, ptr %7, align 4
  ret i32 %8
}

define void @OutOfBoundsDetails_setter_index(ptr %0, i32 %1) {
  %3 = urem i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64)
  %4 = icmp eq i64 %3, 0
  %5 = sub i64 ptrtoint (ptr getelementptr ({ i8, i32 }, ptr null, i32 0, i32 1) to i64), %3
  %6 = select i1 %4, i64 0, i64 %5
  %7 = add i64 ptrtoint (ptr getelementptr (i32, ptr null, i32 1) to i64), %6
  %8 = getelementptr i8, ptr %0, i64 %7
  %9 = alloca i32, align 4
  store i32 %1, ptr %9, align 4
  %10 = load i32, ptr %9, align 4
  store i32 %10, ptr %8, align 4
  ret void
}

define void @OutOfBoundsDetails_init_boundsi32_indexi32({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2, i32 %3, i32 %4) {
  %6 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %6, align 8
  %7 = alloca i32, align 4
  %8 = alloca ptr, align 8
  %9 = alloca ptr, align 8
  %10 = alloca ptr, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %8, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 1
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %9, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 2
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %10, align 8
  %17 = getelementptr { ptr, ptr, ptr, i32 }, ptr %6, i32 0, i32 3
  %18 = load i32, ptr %17, align 4
  store i32 %18, ptr %7, align 4
  %19 = load ptr, ptr %8, align 8
  %20 = call i32 @get_offset(ptr %19, ptr @OutOfBoundsDetails)
  store i32 %20, ptr %7, align 4
  %21 = alloca i32, align 4
  store i32 %3, ptr %21, align 4
  %22 = load ptr, ptr %9, align 8
  %23 = load ptr, ptr %8, align 8
  %24 = call ptr @llvm.invariant.start.p0(i64 48, ptr %23)
  %25 = load i32, ptr %7, align 4
  %26 = getelementptr ptr, ptr %23, i32 %25
  %27 = load ptr, ptr %26, align 8
  %28 = getelementptr { ptr, ptr }, ptr %27, i32 0, i32 1
  %29 = load ptr, ptr %28, align 8
  %30 = load i32, ptr %21, align 4
  call void %29(ptr %22, i32 %30) #2
  %31 = alloca i32, align 4
  store i32 %4, ptr %31, align 4
  %32 = load ptr, ptr %9, align 8
  %33 = load ptr, ptr %8, align 8
  %34 = call ptr @llvm.invariant.start.p0(i64 48, ptr %33)
  %35 = load i32, ptr %7, align 4
  %36 = getelementptr ptr, ptr %33, i32 %35
  %37 = getelementptr ptr, ptr %36, i32 1
  %38 = load ptr, ptr %37, align 8
  %39 = getelementptr { ptr, ptr }, ptr %38, i32 0, i32 1
  %40 = load ptr, ptr %39, align 8
  %41 = load i32, ptr %31, align 4
  call void %40(ptr %32, i32 %41) #2
  ret void
}

define ptr @OutOfBoundsDetails_B_init_boundsi32_indexi32({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = alloca i1, align 1
  %4 = alloca i1, align 1
  %5 = call ptr @llvm.invariant.start.p0(i64 16, ptr %1)
  %6 = alloca ptr, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = ptrtoint ptr %7 to i64
  %9 = icmp eq i64 %8, ptrtoint (ptr @i32_typ to i64)
  %10 = zext i1 %9 to i8
  store i8 %10, ptr %4, align 1
  %11 = getelementptr ptr, ptr %1, i32 1
  %12 = load ptr, ptr %11, align 8
  %13 = ptrtoint ptr %12 to i64
  %14 = icmp eq i64 %13, ptrtoint (ptr @i32_typ to i64)
  %15 = zext i1 %14 to i8
  store i8 %15, ptr %3, align 1
  store i32 4, ptr %6, align 4
  %16 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %17 = load i32, ptr %6, align 4
  %18 = getelementptr [6 x ptr], ptr %16, i32 0, i32 %17
  %19 = getelementptr ptr, ptr %18, i32 10
  %20 = load ptr, ptr %19, align 8
  ret ptr %20
}

define void @OutOfBoundsDetails_report_({ ptr, ptr, ptr, i32 } %0, { ptr, ptr, ptr, i32 } %1, ptr %2) {
  %4 = alloca { ptr, ptr, ptr, i32 }, align 8
  store { ptr, ptr, ptr, i32 } %0, ptr %4, align 8
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca ptr, align 8
  %9 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %6, align 8
  %11 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %7, align 8
  %13 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 2
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %8, align 8
  %15 = getelementptr { ptr, ptr, ptr, i32 }, ptr %4, i32 0, i32 3
  %16 = load i32, ptr %15, align 4
  store i32 %16, ptr %5, align 4
  %17 = load ptr, ptr %6, align 8
  %18 = call i32 @get_offset(ptr %17, ptr @OutOfBoundsDetails)
  store i32 %18, ptr %5, align 4
  %19 = alloca i32, align 4
  store i32 45, ptr %19, align 4
  %20 = alloca i64, align 8
  %21 = load i32, ptr %19, align 4
  %22 = sext i32 %21 to i64
  store i64 %22, ptr %20, align 4
  %23 = load i64, ptr %20, align 4
  %24 = alloca ptr, align 8
  %25 = mul i64 %23, ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
  %26 = call ptr @bump_malloc(i64 %25)
  store ptr %26, ptr %24, align 8
  %27 = alloca ptr, align 8
  %28 = getelementptr { ptr }, ptr %24, i32 0, i32 0
  %29 = load ptr, ptr %28, align 8
  store ptr %29, ptr %27, align 8
  %30 = alloca [44 x i8], align 1
  store [44 x i8] c"The size of the collection being indexed was", ptr %30, align 1
  %31 = alloca i32, align 4
  store i32 0, ptr %31, align 4
  %32 = load ptr, ptr %27, align 8
  %33 = load i64, ptr %31, align 4
  %34 = mul i64 ptrtoint (ptr getelementptr ([44 x i8], ptr null, i32 1) to i64), %33
  %35 = getelementptr i8, ptr %32, i64 %34
  %36 = load <44 x i8>, ptr %30, align 1
  store <44 x i8> %36, ptr %35, align 1
  %37 = alloca i32, align 4
  store i32 44, ptr %37, align 4
  %38 = alloca i32, align 4
  store i32 44, ptr %38, align 4
  %39 = alloca i32, align 4
  store i32 45, ptr %39, align 4
  %40 = alloca [1 x ptr], align 8
  store ptr @String, ptr %40, align 8
  %41 = load ptr, ptr %40, align 8
  %42 = getelementptr ptr, ptr %41, i32 6
  %43 = load ptr, ptr %42, align 8
  %44 = call { i64, i64 } @size_wrapper(ptr %43, ptr %40)
  %45 = extractvalue { i64, i64 } %44, 0
  %46 = call ptr @bump_malloc(i64 %45)
  %47 = alloca i32, align 4
  %48 = alloca ptr, align 8
  %49 = alloca ptr, align 8
  %50 = alloca ptr, align 8
  store ptr @String, ptr %50, align 8
  store ptr %46, ptr %49, align 8
  store i32 10, ptr %47, align 4
  %51 = alloca i32, align 4
  store i32 44, ptr %51, align 4
  %52 = alloca i32, align 4
  store i32 44, ptr %52, align 4
  %53 = alloca i32, align 4
  store i32 45, ptr %53, align 4
  %54 = load ptr, ptr %27, align 8
  %55 = insertvalue { ptr } undef, ptr %54, 0
  %56 = load i32, ptr %51, align 4
  %57 = load i32, ptr %52, align 4
  %58 = load i32, ptr %53, align 4
  %59 = load ptr, ptr %50, align 8
  %60 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %59, 0
  %61 = load ptr, ptr %49, align 8
  %62 = insertvalue { ptr, ptr, ptr, i32 } %60, ptr %61, 1
  %63 = load ptr, ptr %48, align 8
  %64 = insertvalue { ptr, ptr, ptr, i32 } %62, ptr %63, 2
  %65 = load i32, ptr %47, align 4
  %66 = insertvalue { ptr, ptr, ptr, i32 } %64, i32 %65, 3
  %67 = alloca [4 x ptr], align 8
  %68 = getelementptr [4 x ptr], ptr %67, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %68, align 8
  %69 = getelementptr [4 x ptr], ptr %67, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %69, align 8
  %70 = getelementptr [4 x ptr], ptr %67, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %70, align 8
  %71 = getelementptr [4 x ptr], ptr %67, i32 0, i32 3
  store ptr @_parameterization_i32, ptr %71, align 8
  %72 = call ptr @llvm.invariant.start.p0(i64 16, ptr %67)
  %73 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %59)
  %74 = getelementptr ptr, ptr %59, i32 %65
  %75 = getelementptr ptr, ptr %74, i32 12
  %76 = load ptr, ptr %75, align 8
  %77 = alloca { ptr, ptr, ptr, ptr }, align 8
  %78 = getelementptr { ptr, ptr, ptr, ptr }, ptr %77, i32 0, i32 0
  store ptr @buffer_typ, ptr %78, align 8
  %79 = getelementptr { ptr, ptr, ptr, ptr }, ptr %77, i32 0, i32 1
  store ptr @i32_typ, ptr %79, align 8
  %80 = getelementptr { ptr, ptr, ptr, ptr }, ptr %77, i32 0, i32 2
  store ptr @i32_typ, ptr %80, align 8
  %81 = getelementptr { ptr, ptr, ptr, ptr }, ptr %77, i32 0, i32 3
  store ptr @i32_typ, ptr %81, align 8
  %82 = call ptr @behavior_wrapper(ptr %76, { ptr, ptr, ptr, i32 } %66, ptr %77)
  call void %82({ ptr, ptr, ptr, i32 } %66, { ptr, ptr, ptr, i32 } %66, ptr %67, { ptr } %55, i32 %56, i32 %57, i32 %58)
  %83 = load ptr, ptr %50, align 8
  %84 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %83, 0
  %85 = load ptr, ptr %49, align 8
  %86 = insertvalue { ptr, ptr, ptr, i32 } %84, ptr %85, 1
  %87 = load ptr, ptr %48, align 8
  %88 = insertvalue { ptr, ptr, ptr, i32 } %86, ptr %87, 2
  %89 = load i32, ptr %47, align 4
  %90 = insertvalue { ptr, ptr, ptr, i32 } %88, i32 %89, 3
  %91 = alloca [0 x ptr], align 8
  %92 = call ptr @llvm.invariant.start.p0(i64 0, ptr %91)
  %93 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %83)
  %94 = getelementptr ptr, ptr %83, i32 %89
  %95 = getelementptr ptr, ptr %94, i32 13
  %96 = load ptr, ptr %95, align 8
  %97 = alloca {}, align 8
  %98 = call ptr @behavior_wrapper(ptr %96, { ptr, ptr, ptr, i32 } %90, ptr %97)
  %99 = call { ptr } %98({ ptr, ptr, ptr, i32 } %90, { ptr, ptr, ptr, i32 } %90, ptr %91)
  %100 = alloca ptr, align 8
  store { ptr } %99, ptr %100, align 8
  %101 = load ptr, ptr %100, align 8
  %102 = call i32 (ptr, ...) @printf(ptr @string_string, ptr %101)
  %103 = load ptr, ptr %7, align 8
  %104 = load ptr, ptr %6, align 8
  %105 = call ptr @llvm.invariant.start.p0(i64 48, ptr %104)
  %106 = load i32, ptr %5, align 4
  %107 = getelementptr ptr, ptr %104, i32 %106
  %108 = load ptr, ptr %107, align 8
  %109 = getelementptr { ptr, ptr }, ptr %108, i32 0, i32 0
  %110 = load ptr, ptr %109, align 8
  %111 = call i32 %110(ptr %103) #1
  %112 = alloca i32, align 4
  store i32 %111, ptr %112, align 4
  %113 = load i32, ptr %112, align 4
  %114 = call i32 (ptr, ...) @printf(ptr @i32_string, i32 %113)
  %115 = alloca i32, align 4
  store i32 26, ptr %115, align 4
  %116 = alloca i64, align 8
  %117 = load i32, ptr %115, align 4
  %118 = sext i32 %117 to i64
  store i64 %118, ptr %116, align 4
  %119 = load i64, ptr %116, align 4
  %120 = alloca ptr, align 8
  %121 = mul i64 %119, ptrtoint (ptr getelementptr (i8, ptr null, i32 1) to i64)
  %122 = call ptr @bump_malloc(i64 %121)
  store ptr %122, ptr %120, align 8
  %123 = alloca ptr, align 8
  %124 = getelementptr { ptr }, ptr %120, i32 0, i32 0
  %125 = load ptr, ptr %124, align 8
  store ptr %125, ptr %123, align 8
  %126 = alloca [25 x i8], align 1
  store [25 x i8] c"The indexing argument was", ptr %126, align 1
  %127 = alloca i32, align 4
  store i32 0, ptr %127, align 4
  %128 = load ptr, ptr %123, align 8
  %129 = load i64, ptr %127, align 4
  %130 = mul i64 ptrtoint (ptr getelementptr ([25 x i8], ptr null, i32 1) to i64), %129
  %131 = getelementptr i8, ptr %128, i64 %130
  %132 = load <25 x i8>, ptr %126, align 1
  store <25 x i8> %132, ptr %131, align 1
  %133 = alloca i32, align 4
  store i32 25, ptr %133, align 4
  %134 = alloca i32, align 4
  store i32 25, ptr %134, align 4
  %135 = alloca i32, align 4
  store i32 26, ptr %135, align 4
  %136 = alloca [1 x ptr], align 8
  store ptr @String, ptr %136, align 8
  %137 = load ptr, ptr %136, align 8
  %138 = getelementptr ptr, ptr %137, i32 6
  %139 = load ptr, ptr %138, align 8
  %140 = call { i64, i64 } @size_wrapper(ptr %139, ptr %136)
  %141 = extractvalue { i64, i64 } %140, 0
  %142 = call ptr @bump_malloc(i64 %141)
  %143 = alloca i32, align 4
  %144 = alloca ptr, align 8
  %145 = alloca ptr, align 8
  %146 = alloca ptr, align 8
  store ptr @String, ptr %146, align 8
  store ptr %142, ptr %145, align 8
  store i32 10, ptr %143, align 4
  %147 = alloca i32, align 4
  store i32 25, ptr %147, align 4
  %148 = alloca i32, align 4
  store i32 25, ptr %148, align 4
  %149 = alloca i32, align 4
  store i32 26, ptr %149, align 4
  %150 = load ptr, ptr %123, align 8
  %151 = insertvalue { ptr } undef, ptr %150, 0
  %152 = load i32, ptr %147, align 4
  %153 = load i32, ptr %148, align 4
  %154 = load i32, ptr %149, align 4
  %155 = load ptr, ptr %146, align 8
  %156 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %155, 0
  %157 = load ptr, ptr %145, align 8
  %158 = insertvalue { ptr, ptr, ptr, i32 } %156, ptr %157, 1
  %159 = load ptr, ptr %144, align 8
  %160 = insertvalue { ptr, ptr, ptr, i32 } %158, ptr %159, 2
  %161 = load i32, ptr %143, align 4
  %162 = insertvalue { ptr, ptr, ptr, i32 } %160, i32 %161, 3
  %163 = alloca [4 x ptr], align 8
  %164 = getelementptr [4 x ptr], ptr %163, i32 0, i32 0
  store ptr @_parameterization_Bufferi8, ptr %164, align 8
  %165 = getelementptr [4 x ptr], ptr %163, i32 0, i32 1
  store ptr @_parameterization_i32, ptr %165, align 8
  %166 = getelementptr [4 x ptr], ptr %163, i32 0, i32 2
  store ptr @_parameterization_i32, ptr %166, align 8
  %167 = getelementptr [4 x ptr], ptr %163, i32 0, i32 3
  store ptr @_parameterization_i32, ptr %167, align 8
  %168 = call ptr @llvm.invariant.start.p0(i64 16, ptr %163)
  %169 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %155)
  %170 = getelementptr ptr, ptr %155, i32 %161
  %171 = getelementptr ptr, ptr %170, i32 12
  %172 = load ptr, ptr %171, align 8
  %173 = alloca { ptr, ptr, ptr, ptr }, align 8
  %174 = getelementptr { ptr, ptr, ptr, ptr }, ptr %173, i32 0, i32 0
  store ptr @buffer_typ, ptr %174, align 8
  %175 = getelementptr { ptr, ptr, ptr, ptr }, ptr %173, i32 0, i32 1
  store ptr @i32_typ, ptr %175, align 8
  %176 = getelementptr { ptr, ptr, ptr, ptr }, ptr %173, i32 0, i32 2
  store ptr @i32_typ, ptr %176, align 8
  %177 = getelementptr { ptr, ptr, ptr, ptr }, ptr %173, i32 0, i32 3
  store ptr @i32_typ, ptr %177, align 8
  %178 = call ptr @behavior_wrapper(ptr %172, { ptr, ptr, ptr, i32 } %162, ptr %173)
  call void %178({ ptr, ptr, ptr, i32 } %162, { ptr, ptr, ptr, i32 } %162, ptr %163, { ptr } %151, i32 %152, i32 %153, i32 %154)
  %179 = load ptr, ptr %146, align 8
  %180 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %179, 0
  %181 = load ptr, ptr %145, align 8
  %182 = insertvalue { ptr, ptr, ptr, i32 } %180, ptr %181, 1
  %183 = load ptr, ptr %144, align 8
  %184 = insertvalue { ptr, ptr, ptr, i32 } %182, ptr %183, 2
  %185 = load i32, ptr %143, align 4
  %186 = insertvalue { ptr, ptr, ptr, i32 } %184, i32 %185, 3
  %187 = alloca [0 x ptr], align 8
  %188 = call ptr @llvm.invariant.start.p0(i64 0, ptr %187)
  %189 = call ptr @llvm.invariant.start.p0(i64 2512, ptr %179)
  %190 = getelementptr ptr, ptr %179, i32 %185
  %191 = getelementptr ptr, ptr %190, i32 13
  %192 = load ptr, ptr %191, align 8
  %193 = alloca {}, align 8
  %194 = call ptr @behavior_wrapper(ptr %192, { ptr, ptr, ptr, i32 } %186, ptr %193)
  %195 = call { ptr } %194({ ptr, ptr, ptr, i32 } %186, { ptr, ptr, ptr, i32 } %186, ptr %187)
  %196 = alloca ptr, align 8
  store { ptr } %195, ptr %196, align 8
  %197 = load ptr, ptr %196, align 8
  %198 = call i32 (ptr, ...) @printf(ptr @string_string, ptr %197)
  %199 = load ptr, ptr %7, align 8
  %200 = load ptr, ptr %6, align 8
  %201 = call ptr @llvm.invariant.start.p0(i64 48, ptr %200)
  %202 = load i32, ptr %5, align 4
  %203 = getelementptr ptr, ptr %200, i32 %202
  %204 = getelementptr ptr, ptr %203, i32 1
  %205 = load ptr, ptr %204, align 8
  %206 = getelementptr { ptr, ptr }, ptr %205, i32 0, i32 0
  %207 = load ptr, ptr %206, align 8
  %208 = call i32 %207(ptr %199) #1
  %209 = alloca i32, align 4
  store i32 %208, ptr %209, align 4
  %210 = load i32, ptr %209, align 4
  %211 = call i32 (ptr, ...) @printf(ptr @i32_string, i32 %210)
  ret void
}

define ptr @OutOfBoundsDetails_B_report_({ ptr, ptr, ptr, i32 } %0, ptr %1) {
  %3 = call ptr @llvm.invariant.start.p0(i64 0, ptr %1)
  %4 = alloca ptr, align 8
  store i32 5, ptr %4, align 4
  %5 = extractvalue { ptr, ptr, ptr, i32 } %0, 0
  %6 = load i32, ptr %4, align 4
  %7 = getelementptr [6 x ptr], ptr %5, i32 0, i32 %6
  %8 = getelementptr ptr, ptr %7, i32 10
  %9 = load ptr, ptr %8, align 8
  ret ptr %9
}

define void @report_exception({ ptr } %0) {
  %2 = alloca { ptr, ptr, ptr, i32 }, align 8
  %3 = alloca [0 x ptr], align 8
  %4 = alloca {}, align 8
  %5 = alloca ptr, align 8
  store { ptr } %0, ptr %5, align 8
  %6 = load ptr, ptr %5, align 8
  %7 = getelementptr { ptr, [3 x ptr], ptr, i1, { ptr, i160 } }, ptr %6, i32 0, i32 4
  %8 = getelementptr { ptr, i160 }, ptr %7, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = insertvalue { ptr, i160 } undef, ptr %9, 0
  %11 = getelementptr { ptr, i160 }, ptr %7, i32 0, i32 1
  %12 = load i160, ptr %11, align 4
  %13 = insertvalue { ptr, i160 } %10, i160 %12, 1
  %14 = alloca { ptr, i160 }, align 8
  store { ptr, i160 } %13, ptr %14, align 8
  %15 = load ptr, ptr %14, align 8
  %16 = getelementptr { [3 x i64], [3 x ptr] }, ptr %15, i32 0, i32 0, i32 1
  %17 = getelementptr { [3 x i64], [3 x ptr] }, ptr %15, i32 0, i32 0, i32 2
  %18 = getelementptr { [3 x i64], [3 x ptr] }, ptr %15, i32 0, i32 1, i32 0
  %19 = getelementptr { [3 x i64], [3 x ptr] }, ptr %15, i32 0, i32 1, i32 1
  %20 = load i64, ptr %16, align 4
  %21 = load i64, ptr %17, align 4
  %22 = load ptr, ptr %18, align 8
  %23 = load ptr, ptr %19, align 8
  %24 = load i64, ptr @Exception, align 4
  %25 = call i1 @subtype_test_wrapper(ptr %22, i64 %21, i64 %20, i64 %24, i64 ptrtoint (ptr @Exception to i64), ptr %23)
  %26 = alloca i1, align 1
  %27 = zext i1 %25 to i8
  store i8 %27, ptr %26, align 1
  %28 = load i8, ptr %26, align 1
  %29 = trunc i8 %28 to i1
  br i1 %29, label %30, label %59

30:                                               ; preds = %1
  %31 = getelementptr { ptr, i160 }, ptr %14, i32 0, i32 0
  %32 = getelementptr { ptr, i160 }, ptr %2, i32 0, i32 0
  %33 = load ptr, ptr %31, align 8
  store ptr %33, ptr %32, align 8
  %34 = getelementptr { ptr, i160 }, ptr %14, i32 0, i32 1
  %35 = getelementptr { ptr, i160 }, ptr %2, i32 0, i32 1
  %36 = load i160, ptr %34, align 4
  store i160 %36, ptr %35, align 4
  %37 = load ptr, ptr %2, align 8
  %38 = call i32 @get_offset(ptr %37, ptr @Exception)
  %39 = getelementptr { ptr, ptr, ptr, i32 }, ptr %2, i32 0, i32 3
  store i32 %38, ptr %39, align 4
  %40 = getelementptr { ptr, ptr, ptr, i32 }, ptr %2, i32 0, i32 0
  %41 = load ptr, ptr %40, align 8
  %42 = insertvalue { ptr, ptr, ptr, i32 } undef, ptr %41, 0
  %43 = getelementptr { ptr, ptr, ptr, i32 }, ptr %2, i32 0, i32 1
  %44 = load ptr, ptr %43, align 8
  %45 = insertvalue { ptr, ptr, ptr, i32 } %42, ptr %44, 1
  %46 = getelementptr { ptr, ptr, ptr, i32 }, ptr %2, i32 0, i32 2
  %47 = load ptr, ptr %46, align 8
  %48 = insertvalue { ptr, ptr, ptr, i32 } %45, ptr %47, 2
  %49 = load i32, ptr %39, align 4
  %50 = insertvalue { ptr, ptr, ptr, i32 } %48, i32 %49, 3
  %51 = call ptr @llvm.invariant.start.p0(i64 0, ptr %3)
  %52 = call ptr @llvm.invariant.start.p0(i64 112, ptr %41)
  %53 = getelementptr ptr, ptr %41, i32 %49
  %54 = getelementptr ptr, ptr %53, i32 7
  %55 = load ptr, ptr %54, align 8
  %56 = call ptr @behavior_wrapper(ptr %55, { ptr, ptr, ptr, i32 } %50, ptr %4)
  call void %56({ ptr, ptr, ptr, i32 } %50, { ptr, ptr, ptr, i32 } %50, ptr %3)
  %57 = load ptr, ptr %32, align 8
  store ptr %57, ptr %31, align 8
  %58 = load i160, ptr %35, align 4
  store i160 %58, ptr %34, align 4
  br label %59

59:                                               ; preds = %30, %1
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare ptr @llvm.invariant.start.p0(i64 immarg, ptr nocapture) #0

attributes #0 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #1 = { nounwind willreturn memory(argmem: read, inaccessiblemem: readwrite) }
attributes #2 = { nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0}

!0 = !{i32 2, !"Debug Info Version", i32 3}
// -----
; ModuleID = 'LLVMDialectModule'
source_filename = "LLVMDialectModule"

%bool_typ = type opaque
%i1_typ = type opaque
%i8_typ = type opaque
%i32_typ = type opaque
%i64_typ = type opaque
%i128_typ = type opaque
%f64_typ = type opaque
%nil_typ = type opaque
%any_typ = type opaque
%nothing_typ = type opaque
%coroutine_typ = type opaque
%function_typ = type opaque
%buffer_typ = type opaque
%tuple_typ = type opaque
%union_typ = type opaque
%Object = type opaque
%Pair = type opaque
%Iterator = type opaque
%Iterable = type opaque
%ConstantTimeIterator = type opaque
%CoroIterator = type opaque
%Enumerated = type opaque
%Enumerator = type opaque
%Mapped = type opaque
%Mapper = type opaque
%Filtered = type opaque
%Filterer = type opaque
%Chained = type opaque
%Chainer = type opaque
%Interleaved = type opaque
%Interleaver = type opaque
%Zipped = type opaque
%Zipper = type opaque
%Products = type opaque
%Productizer = type opaque
%Collection = type opaque
%EnumeratedCollection = type opaque
%MappedCollection = type opaque
%ChainedCollection = type opaque
%InterleavedCollection = type opaque
%ZippedCollection = type opaque
%ProductCollection = type opaque
%List = type opaque
%Indexable = type opaque
%IndexableCollection = type opaque
%Range = type opaque
%RangeIterator = type opaque
%Unicode = type opaque
%Representable = type opaque
%String = type opaque
%Character = type opaque
%StringIterator = type opaque
%Stacktrace = type opaque
%Exception = type opaque
%InvalidUTF8Error = type opaque
%OutOfBounds = type opaque
%OutOfBoundsDetails = type opaque

@i32_string = linkonce_odr constant [4 x i8] c"%d\0A\00"
@i64_string = linkonce_odr constant [6 x i8] c"%lld\0A\00"
@float_string = linkonce_odr constant [4 x i8] c"%f\0A\00"
@string_string = linkonce_odr constant [4 x i8] c"%s\0A\00"
@bool_typ = external constant %bool_typ
@i1_typ = external constant %i1_typ
@i8_typ = external constant %i8_typ
@i32_typ = external constant %i32_typ
@i64_typ = external constant %i64_typ
@i128_typ = external constant %i128_typ
@f64_typ = external constant %f64_typ
@nil_typ = external constant %nil_typ
@any_typ = external constant %any_typ
@nothing_typ = external constant %nothing_typ
@coroutine_typ = external constant %coroutine_typ
@function_typ = external constant %function_typ
@buffer_typ = external constant %buffer_typ
@tuple_typ = external constant %tuple_typ
@union_typ = external constant %union_typ
@Object = external constant %Object
@Pair = external constant %Pair
@Iterator = external constant %Iterator
@Iterable = external constant %Iterable
@ConstantTimeIterator = external constant %ConstantTimeIterator
@CoroIterator = external constant %CoroIterator
@Enumerated = external constant %Enumerated
@Enumerator = external constant %Enumerator
@Mapped = external constant %Mapped
@Mapper = external constant %Mapper
@Filtered = external constant %Filtered
@Filterer = external constant %Filterer
@Chained = external constant %Chained
@Chainer = external constant %Chainer
@Interleaved = external constant %Interleaved
@Interleaver = external constant %Interleaver
@Zipped = external constant %Zipped
@Zipper = external constant %Zipper
@Products = external constant %Products
@Productizer = external constant %Productizer
@Collection = external constant %Collection
@EnumeratedCollection = external constant %EnumeratedCollection
@MappedCollection = external constant %MappedCollection
@ChainedCollection = external constant %ChainedCollection
@InterleavedCollection = external constant %InterleavedCollection
@ZippedCollection = external constant %ZippedCollection
@ProductCollection = external constant %ProductCollection
@List = external constant %List
@Indexable = external constant %Indexable
@IndexableCollection = external constant %IndexableCollection
@Range = external constant %Range
@RangeIterator = external constant %RangeIterator
@Unicode = external constant %Unicode
@Representable = external constant %Representable
@String = external constant %String
@Character = external constant %Character
@StringIterator = external constant %StringIterator
@Stacktrace = external constant %Stacktrace
@Exception = external constant %Exception
@InvalidUTF8Error = external constant %InvalidUTF8Error
@OutOfBounds = external constant %OutOfBounds
@OutOfBoundsDetails = external constant %OutOfBoundsDetails

declare i32 @printf(ptr, ...)

declare ptr @bump_malloc(i64)

declare void @free(ptr)

declare void @setup_landing_pad()

declare void @anoint_trampoline(ptr)

declare ptr @adjust_trampoline(ptr)

declare ptr @coroutine_create(ptr, ptr)

declare void @arg_passer(ptr)

declare void @arg_buffer_filler(ptr)

declare void @coroutine_yield(ptr)

declare void @coroutine_yield_cold(ptr)

declare ptr @get_current_coroutine()

declare i32 @get_offset(ptr, ptr)

declare void @assume_offset(ptr, ptr)

declare { ptr, i160 } @_box_Default(ptr, ptr)

declare void @_unbox_Default({ ptr, i160 }, ptr, ptr)

declare { i64, i64 } @_size_Default(ptr)

declare void @_unbox_union_typ({ ptr, i160 }, ptr, ptr)

declare { i64, i64 } @_data_size_tuple_typ(ptr)

declare { i64, i64 } @_data_size_union_typ(ptr)

declare i1 @subtype_test(i64, i64, i64, i64, ptr)

declare i1 @subtype_test_wrapper(ptr, i64, i64, i64, i64, ptr)

declare { i64, i64 } @size_wrapper(ptr, ptr)

declare ptr @typegetter_wrapper(ptr, ptr)

declare { ptr, i160 } @box_wrapper(ptr, ptr, ptr)

declare void @unbox_wrapper(ptr, { ptr, i160 }, ptr, ptr)

declare ptr @behavior_wrapper(ptr, { ptr, ptr, ptr, i32 }, ptr)

declare ptr @class_behavior_wrapper(ptr, ptr)

declare void @coroutine_call(ptr)

declare i64 @capture_backtrace(i64, { ptr })

declare void @print_backtrace({ ptr }, i64)

declare void @report_exception({ ptr })

!llvm.module.flags = !{!0}

!0 = !{i32 2, !"Debug Info Version", i32 3}
